<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Catch Your Dream</title>
  
  
  <link href="https://hanielxx.com/atom.xml" rel="self"/>
  
  <link href="https://hanielxx.com/"/>
  <updated>2020-11-14T12:40:56.232Z</updated>
  <id>https://hanielxx.com/</id>
  
  <author>
    <name>Hanielxx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VIM常用操作整理</title>
    <link href="https://hanielxx.com/Linux/2020-08-27-vim-keybord-record"/>
    <id>https://hanielxx.com/Linux/2020-08-27-vim-keybord-record</id>
    <published>2020-08-27T10:35:48.000Z</published>
    <updated>2020-11-14T12:40:56.232Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从<a href="https://yianwillis.github.io/vimcdoc/doc/help.html" target="_blank" rel="external nofollow noopener noreferrer">Vim 8.2</a>的文档中 mark 了一些常用 VIM 操作，方便以后使用查阅</p></div><a id="more"></a><h2 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h2><h3 id="g"><a href="#g" class="headerlink" title="g"></a>g</h3><table><thead><tr><th>操作</th><th>N 可选计数</th><th>含义</th></tr></thead><tbody><tr><td>g0</td><td></td><td>至屏幕首个字符</td></tr><tr><td>g0</td><td>g0</td><td>至屏幕行首个字符 (行回绕时不同于 “0”)</td></tr><tr><td>g^</td><td>g^</td><td>至屏幕行首个非空白字符 (行回绕时不同于 “^”)</td></tr><tr><td>g$</td><td>N g$</td><td>至屏幕行末个字符 (行回绕时不同于 “$“)</td></tr><tr><td>gm</td><td>gm</td><td>至屏幕行中点</td></tr><tr><td>gM</td><td>gM</td><td>至本行中点</td></tr><tr><td>gk</td><td>N gk</td><td>上移 N 屏幕行 (回绕行时不同于 “k”)</td></tr><tr><td>gj</td><td>N gj</td><td>下移 N 屏幕行 (回绕行时不同于 “j”)</td></tr><tr><td>ge</td><td>N ge</td><td>向后至第 N 个单词词尾(w 是向前单词头，e 是向前单词尾，b 是向后单词头)</td></tr></tbody></table><h3 id="f-t"><a href="#f-t" class="headerlink" title="f t"></a>f t</h3><table><thead><tr><th>操作</th><th>N 可选计数</th><th>含义</th></tr></thead><tbody><tr><td>bar</td><td>N &#124;</td><td>至第 N 列 (缺省: 1)</td></tr><tr><td>f</td><td>N f{char}</td><td>至右边第 N 次出现 {char} 之处 (find)</td></tr><tr><td>F</td><td>N F{char}</td><td>至左边第 N 次出现 {char} 之处 (Find)</td></tr><tr><td>t</td><td>N t{char}</td><td>至右边第 N 次出现 {char} 之前 (till)</td></tr><tr><td>T</td><td>N T{char}</td><td>至左边第 N 次出现 {char} 之前 (Till)</td></tr></tbody></table><h3><a href="#" class="headerlink" title="; , - + _ %"></a>; , - + _ %</h3><table><thead><tr><th>操作</th><th>N 可选计数</th><th>含义</th></tr></thead><tbody><tr><td>;</td><td>N ;</td><td>重复前次 “f”、”F”、”t” 或 “T” 命令 N 次</td></tr><tr><td>,</td><td>N ,</td><td>以相反方向重复前次 “f”、”F”、”t” 或 “T” 命令 N 次</td></tr><tr><td>-</td><td>N -</td><td>上移 N 行，至首个非空白字符处</td></tr><tr><td>+</td><td>N +</td><td>下移 N 行，至首个非空白字符处 (亦: CTRL-M 和 <code>&lt;CR&gt;</code>)</td></tr><tr><td>_</td><td>N _</td><td>下移 N - 1 行，至首个非空白字符处</td></tr><tr><td>N%</td><td>N %</td><td>至全文件行数百分之 N 处；必须给出 N，否则是 % 命令</td></tr></tbody></table><h3 id="-1"><a href="#-1" class="headerlink" title="( ) [ ] { }"></a>( ) [ ] { }</h3><table><thead><tr><th>操作</th><th>N 可选计数</th><th>含义</th></tr></thead><tbody><tr><td>)</td><td>N )</td><td>向前 N 个句子</td></tr><tr><td>(</td><td>N (</td><td>向后 N 个句子</td></tr><tr><td>}</td><td>N }</td><td>向前 N 个段落</td></tr><tr><td>{</td><td>N {</td><td>向后 N 个段落</td></tr><tr><td>[(</td><td>N [(</td><td>向后至第 N 个未闭合的 ‘(‘</td></tr><tr><td>[{</td><td>N [{</td><td>向后至第 N 个未闭合的 ‘{‘</td></tr><tr><td>])</td><td>N ])</td><td>向前至第 N 个未闭合的 ‘)’</td></tr><tr><td>]}</td><td>N ]}</td><td>向前至第 N 个未闭合的 ‘}’</td></tr></tbody></table><h3 id="-2"><a href="#-2" class="headerlink" title="* #"></a>* #</h3><table><thead><tr><th>操作</th><th>N 可选计数</th><th>含义</th></tr></thead><tbody><tr><td>star</td><td>N *</td><td>向前查找光标下的标识符</td></tr><tr><td>#</td><td>N #</td><td>向后查找光标下的标识符</td></tr><tr><td>gstar</td><td>N g*</td><td>同 “*“，但也查找部分匹配</td></tr><tr><td>g#</td><td>N g#</td><td>同 “*“，但也查找部分匹配</td></tr><tr><td>gd</td><td>gd</td><td>至光标下标识符的局部声明 (goto declaration)</td></tr><tr><td>gD</td><td>gD</td><td>至光标下标识符的全局声明 (goto Declaration)</td></tr></tbody></table><h2 id="查找模式中的特殊字符"><a href="#查找模式中的特殊字符" class="headerlink" title="查找模式中的特殊字符"></a>查找模式中的特殊字符</h2><table><thead><tr><th>含义</th><th>magic</th><th>nomagic</th></tr></thead><tbody><tr><td>匹配任意单个字符</td><td>.</td><td>\.</td></tr><tr><td>匹配行首</td><td>^</td><td>^</td></tr><tr><td>匹配 <code>&lt;EOL&gt;</code></td><td>$</td><td>$</td></tr><tr><td>匹配单词开始</td><td><code>\&lt;</code></td><td><code>\&lt;</code></td></tr><tr><td>匹配单词结束</td><td><code>\&gt;</code></td><td><code>\&gt;</code></td></tr><tr><td>匹配单个标定范围中的字符</td><td>[a-z]</td><td>\[a-z]</td></tr><tr><td>匹配单个不在标定范围中的字符</td><td><code>[^a-z]</code></td><td>\[^a-z]</td></tr><tr><td>匹配一个标识符字符</td><td>\i</td><td>\i</td></tr><tr><td>同上但不包括数字</td><td>\I</td><td>\I</td></tr><tr><td>匹配一个关键字字符</td><td>\k</td><td>\k</td></tr><tr><td>同上但不包括数字</td><td>\K</td><td>\K</td></tr><tr><td>匹配一个文件名字符</td><td>\f</td><td>\f</td></tr><tr><td>同上但不包括数字</td><td>\F</td><td>\F</td></tr><tr><td>匹配一个可显示的字符</td><td>\p</td><td>\p</td></tr><tr><td>同上但不包括数字</td><td>\P</td><td>\P</td></tr><tr><td>匹配一个空白字符</td><td>\s</td><td>\s</td></tr><tr><td>匹配一个非空白字符</td><td>\S</td><td>\S</td></tr><tr><td>匹配 <code>&lt;Esc&gt;</code></td><td>\e</td><td>\e</td></tr><tr><td>匹配 <code>&lt;Tab&gt;</code></td><td>\t</td><td>\t</td></tr><tr><td>匹配 <code>&lt;CR&gt;</code></td><td>\r</td><td>\r</td></tr><tr><td>匹配 <code>&lt;BS&gt;</code></td><td>\b</td><td>\b</td></tr><tr><td>匹配 0 或多个前面的匹配原</td><td>*</td><td>\*</td></tr><tr><td>匹配 1 或多个前面的匹配原</td><td>\+</td><td>\+</td></tr><tr><td>匹配 0 或 1 个前面的匹配原</td><td>\=</td><td>\=</td></tr><tr><td>匹配 2 至 5 个前面的匹配原</td><td>\{2,5}</td><td>\{2,5}</td></tr><tr><td>隔开两种可替换的匹配</td><td>&amp;#124;</td><td>&amp;#124;</td></tr><tr><td>组合模式为单个匹配原</td><td>\(\)</td><td>\(\)</td></tr></tbody></table><h2 id="位置-mark-标记"><a href="#位置-mark-标记" class="headerlink" title="位置 mark 标记"></a>位置 mark 标记</h2><table><thead><tr><th>命令</th><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>m</td><td>m{a-zA-Z}</td><td>用标记 {a-zA-Z} 记录当前位置</td></tr><tr><td>`a</td><td>`{a-z}</td><td>至当前文件中的标记 {a-z}</td></tr><tr><td>`A</td><td>`{A-Z}</td><td>至任何文件中的标记 {A-Z}</td></tr><tr><td>`0</td><td>`{0-9}</td><td>至 Vim 前次退出的位置</td></tr><tr><td>``</td><td>``</td><td>至前次跳转之前的位置</td></tr><tr><td>`[</td><td>`[</td><td>至前次被操作或放置的文本的开始</td></tr><tr><td>`]</td><td>`]</td><td>至前次被操作或放置的文本的结尾</td></tr><tr><td>`&lt;</td><td>`&lt;</td><td>至 (前次) 可视区域的开始</td></tr><tr><td>`&gt;</td><td>`&gt;</td><td>至 (前次) 可视区域的结尾</td></tr><tr><td>`.</td><td>`.</td><td>至当前文件最后被改动的位置</td></tr><tr><td>‘</td><td>‘{a-zA-Z0-9[]’”&lt;&gt;.}</td><td>同 `，但同时移动至该行的首个非空白字符上</td></tr><tr><td>:marks</td><td>:marks</td><td>列出活动的标记</td></tr><tr><td>:ju</td><td>:ju[mps]</td><td>列出跳转表</td></tr><tr><td></td><td></td><td></td></tr><tr><td>H</td><td>N H</td><td>至窗口的第 N 行的首个非空白字符处 (Home)</td></tr><tr><td>M</td><td>M</td><td>至窗口的中间行的首个非空白字符处 (Middle)</td></tr><tr><td>L</td><td>N L</td><td>至窗口的从下方算第 N 行的首个非空白字符处 (Last)</td></tr></tbody></table><h2 id="tags-标签"><a href="#tags-标签" class="headerlink" title="tags 标签"></a>tags 标签</h2><p>使用 ctags 等插件生成标签文件</p><table><thead><tr><th>命令</th><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>:ta</td><td>:ta[g][!] {tag}</td><td>跳转到标签 {tag}</td></tr><tr><td>CTRL-]</td><td>CTRL-]</td><td>跳转到光标下的标签，除非文件被改动</td></tr><tr><td>CTRL-T</td><td>N CTRL-T</td><td>跳转到标签列表中第 N 个较早的标签</td></tr><tr><td>:ts</td><td>:ts[elect][!] [tag]</td><td>列出匹配的标签并选择其中一个跳转</td></tr><tr><td>:tjump</td><td>:tj[ump][!] [tag]</td><td>跳转到标签 [tag]，当有多个匹配时从列表中选择</td></tr><tr><td>:tags</td><td>:tags</td><td>显示标签列表</td></tr><tr><td>:tnext</td><td>:[count]tn[ext][!]</td><td>跳转到向后第 [count] 个匹配的标签</td></tr><tr><td>:tp</td><td>:[count]tp[revious][!]</td><td>跳转到向前第 [count] 个匹配的标签</td></tr><tr><td>:tl</td><td>:tl[ast][!]</td><td>跳转到前次匹配的标签</td></tr><tr><td>:tr</td><td>:[count]tr[ewind][!]</td><td>跳转到第 [count] 个匹配的标签</td></tr><tr><td></td><td></td><td></td></tr><tr><td>:ptag</td><td>:pt[ag] {tag}</td><td>打开预览窗口来显示 {tag} 标签</td></tr><tr><td>:pts</td><td>:pts[elect]</td><td>同 “:tselect” 但在预览窗口显示标签</td></tr><tr><td>:ptjump</td><td>:ptj[ump]</td><td>同 “:tjump” 但在预览窗口显示标签</td></tr><tr><td>:pclose</td><td>:pc[lose]</td><td>关闭标签预览窗口</td></tr></tbody></table><h2 id="屏幕滚动"><a href="#屏幕滚动" class="headerlink" title="屏幕滚动"></a>屏幕滚动</h2><table><thead><tr><th>命令</th><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>CTRL-E</td><td>N CTRL-E</td><td>窗口下滚 N 行 (缺省: 1) (Extra)</td></tr><tr><td>CTRL-D</td><td>N CTRL-D</td><td>窗口下滚 N 行 (缺省: 1/2 窗口) (Downwards)</td></tr><tr><td>CTRL-F</td><td>N CTRL-F</td><td>窗口下滚 N 页 (Forwards)</td></tr><tr><td>CTRL-Y</td><td>N CTRL-Y</td><td>窗口上滚 N 行 (缺省: 1)</td></tr><tr><td>CTRL-U</td><td>N CTRL-U</td><td>窗口上滚 N 行 (缺省: 1/2 窗口) (Upwards)</td></tr><tr><td>CTRL-B</td><td>N CTRL-B</td><td>窗口上滚 N 页 (Backwards)</td></tr><tr><td><code>z&lt;CR&gt;</code></td><td><code>z&lt;CR&gt;</code> 或 zt</td><td>重画，当前行置于窗口顶端</td></tr><tr><td>z.</td><td>z. 或 zz</td><td>重画，当前行置于窗口正中</td></tr><tr><td>z-</td><td>z- 或 zb</td><td>重画，当前行置于窗口底端</td></tr></tbody></table><h2 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h2><table><thead><tr><th>命令</th><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>A</td><td>N A</td><td>在行末添加文本 (N 次)</td></tr><tr><td>I</td><td>N I</td><td>在当前行首个非空白字符前插入文本 (N 次)</td></tr><tr><td>gI</td><td>N gI</td><td>在第一栏中插入文本 (N 次)</td></tr><tr><td>v_b_I</td><td>I</td><td>在所有选中的行之前插入相同的文本</td></tr><tr><td>v_b_A</td><td>A</td><td>在所有选中的行之后添加相同的文本</td></tr></tbody></table><h3 id="特殊插入"><a href="#特殊插入" class="headerlink" title="特殊插入"></a>特殊插入</h3><table><thead><tr><th>命令</th><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>i_CTRL-E</td><td>CTRL-E</td><td>插入光标下方的字符</td></tr><tr><td>i_CTRL-Y</td><td>CTRL-Y</td><td>插入光标上方的字符</td></tr><tr><td>i_CTRL-A</td><td>CTRL-A</td><td>插入前次插入的文本</td></tr><tr><td>:r</td><td>:r [file]</td><td>将文件 [file] 的内容插入到光标之下</td></tr><tr><td>:r!</td><td>:r! {command}</td><td>将命令 {command} 的标准输出插入到光标之下</td></tr></tbody></table><h2 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h2><table><thead><tr><th>命令</th><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>D</td><td>N D</td><td>删除至行尾 (及 N - 1 后续行)</td></tr><tr><td>J</td><td>N J</td><td>连接 N - 1 行 (删除 <code>&lt;EOL&gt;</code>)</td></tr><tr><td>v_J</td><td>{visual}J</td><td>连接高亮的行</td></tr><tr><td>gJ</td><td>N gJ</td><td>同 “J”，但不插入空格</td></tr><tr><td>v_gJ</td><td>{visual}gJ</td><td>同 “{visual}J”，但不插入空格</td></tr><tr><td>:d</td><td>:[range]d [x]</td><td>删除范围 [range] 覆盖的行 [存入寄存器 x]，如 :1,3d</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从&lt;a href=&quot;https://yianwillis.github.io/vimcdoc/doc/help.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Vim 8.2&lt;/a&gt;的文档中 mark 了一些常用 VIM 操作，方便以后使用查阅&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hanielxx.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hanielxx.com/tags/Linux/"/>
    
    <category term="Vim" scheme="https://hanielxx.com/tags/Vim/"/>
    
    <category term="Summary" scheme="https://hanielxx.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>CNN-DNN 预测siRNA沉默效率论文笔记及对AUC的理解与困惑</title>
    <link href="https://hanielxx.com/DeepLearning/2020-08-04-CNN-DNN-siRNA-AUC"/>
    <id>https://hanielxx.com/DeepLearning/2020-08-04-CNN-DNN-siRNA-AUC</id>
    <published>2020-08-04T01:55:11.000Z</published>
    <updated>2020-11-14T12:40:56.191Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>论文《SiRNA silencing efficacy prediction based on a deep architecture》笔记，以及对这篇论文的看法、理解和困惑。</p></div><a id="more"></a><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><table><thead><tr><th>论文名</th><th>SiRNA silencing efficacy prediction based on a deep architecture</th></tr></thead><tbody><tr><td>作者</td><td>Han, Ye, He, Fei,Chen, Yongbing, Liu, Yuanning, Yu, Helong</td></tr><tr><td>时间</td><td>2018</td></tr><tr><td>会议/期刊</td><td>Spinger BMC Genomics</td></tr><tr><td>领域</td><td>DL/Bioinformatics</td></tr><tr><td>原文</td><td><a href="https://link.springer.com/article/10.1186/s12864-018-5028-8" target="_blank" rel="external nofollow noopener noreferrer">链接</a></td></tr></tbody></table><h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>siRNA 通常是 19-29bp 长度的短 RNA 双链，在 RNA 干扰机制中有很重要的作用。但是人体的 RNA/DNA 并不像平时的语言一样具有可识别的语义，我们对这种序列的认知还比较少，同时，由于 siRNA 数据集比较小，大规模的有对应沉默效率的数据集难以获得，因此在预测 siRNA 沉默效率上具有一定的难度。</p><p>大部分的 siRNA 数据是没有对应的沉默效率的，最大的 Husken 数据集还是使用高通量技术在相同环境下实验得到。</p><p>现有的预测 siRNA 效率的方法不够好，很多已有的方法基于特征工程，可能导致偏差和特征的不完整。</p><p>数据集使用了 Huesken(2431) , Reynolds(248) , Vickers (80) , Haborth(44) , Takayuki(702) , Ui-Tei (62) and siRNAdb(500)</p><h2 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h2><p>本文主要使用深度学习中的 CNN 和 DNN 模型，结合 siRNA 的热力学参数，预测 RNA 干扰中的 siRNA 沉默效率。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>使用 CNN 作为特征提取器，DNN 用于回归</li><li>结合了热力学参数和序列特征，每个碱基使用 one-hot 编码，热力学参数的影响由<a href="https://academic.oup.com/nar/article/35/18/e123/2402822" target="_blank" rel="external nofollow noopener noreferrer">引文 21</a>和<a href="https://academic.oup.com/nar/article/32/3/936/2904484" target="_blank" rel="external nofollow noopener noreferrer">引文 25</a>证明，计算由<a href="https://www.researchgate.net/profile/John_Santalucia/publication/243786835_Parameters_for_an_expanded_nearest-neighbor_model_for_formation_of_RNA_duplexes_with_Watson-Crick_pairs/links/5ab420acaca272171003cb09/Parameters-for-an-expanded-nearest-neighbor-model-for-formation-of-RNA-duplexes-with-Watson-Crick-pairs.pdf" target="_blank" rel="external nofollow noopener noreferrer">引文 28</a>得到</li><li>结合了靶基因上下游的部分核苷酸，见<a href="https://www.sciencedirect.com/science/article/pii/S0888754313001468" target="_blank" rel="external nofollow noopener noreferrer">引文 27</a>，21+2*n 的长度</li><li>CNN 中实验了 $m \times 4 (2 \le m \le 20)$ 19 个卷积核的效果，挑出$PCC \ge 0.6$的作为子集</li><li>实验了上下游碱基数量</li><li>实验了 CNN 中和 DNN 中使用<code>Sigmoid</code>和<code>ReLU</code>的组合哪个最好</li><li>pooling 使用 avg pool 和 max pool</li><li>使用 PCC 和 AUC 度量模型</li></ol><p>模型结构图如下：</p><h2 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h2><ol><li><p>CNN 结合 DNN 在这个任务上 PCC 达到了 0.725，比她之前单纯的 CNN，PCC 为 0.717 的高，可能是增加的热力学参数起了作用，后面思路也可以往这个方向试试</p></li><li><p>对卷积和和上下游碱基数都做了实验还是值得参考的，后面的可以自己实验上下游到底是多长比较适合自己</p></li><li><p>数据集确实比单纯用 Husken 大了很多，后面还是得扩充自己数据集</p></li><li><p>论文里面使用了 PCC 度量模型可以理解，但是为什么使用了 AUC 这个指标，AUC 不是只能用于分类吗。后面再次去理解了下 AUC 和 ROC 曲线。感觉还是应该只能用于分类问题，不然正例负例怎么划分？</p></li></ol><h2 id="关于-ROC-曲线和-AUC"><a href="#关于-ROC-曲线和-AUC" class="headerlink" title="关于 ROC 曲线和 AUC"></a>关于 ROC 曲线和 AUC</h2><h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p>假设有两个类别 0 和 1，模型预测得到结果，其中：</p><ul><li>预测为 1 的为阳性(Positive)，预测为 0 的为阴性(Negative)</li><li>预测正确为真(True)，预测错误为假（False）</li></ul><p>这样就可以得到混淆矩阵如下：</p><h3 id="真阳率和假阳率"><a href="#真阳率和假阳率" class="headerlink" title="真阳率和假阳率"></a>真阳率和假阳率</h3><p>即 True Positive Rate 和 False Positive Rate</p><ul><li>$TPRate = {TP \over TP+FN}$，即：预测为 1 的里面，正例数占所有正样本的比例，也就是数据集中正例有多少预测对了</li><li>$FPRate = {FP \over FP+TN}$，即：预测为 1 的里面，负例数占所有负样本的比例，也就是数据集中负例有多少预测错了</li></ul><h3 id="ROC-曲线"><a href="#ROC-曲线" class="headerlink" title="ROC 曲线"></a>ROC 曲线</h3><ul><li><p>ROC 曲线的横轴就是<code>FPRate</code>，纵轴是<code>TPRate</code></p></li><li><p>绘制 ROC 曲线对每个混淆矩阵计算 TPRate 和 FPRate 得到（x,y），然后连接（0,0）和（x,y）和(1,1)</p></li><li><p>在预测的结果是概率的时候，把每个结果概率作为阈值，把结果分为正例和负例，计算每个 TPRate 和 FPRate，然后描点，连线。</p></li><li><p>期望结果是<code>y&gt;x</code>，总是想正例预测正确的比例大</p></li><li><p>二者相等就<code>y=x</code>时，分类器不起作用，和抛硬币一样随机</p></li><li><p><code>y&lt;x</code>时即总是把正例预测为负例，负例预测为正例。可以把预测的类别反一下就可以得到<code>y&gt;x</code></p></li></ul><h3 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h3><p>AUC 是 ROC 曲线下面的面积，越大越好。是能够度量分类器的分类能力的。</p><p>AUC 同时考虑了分类器对于正例和负例的分类能力，在样本不平衡的情况下，依然能够对分类器作出合理的评价。如在异常检测和欺诈场景之类。</p><h2 id="关于其他性能度量标准"><a href="#关于其他性能度量标准" class="headerlink" title="关于其他性能度量标准"></a>关于其他性能度量标准</h2><ul><li>准确率：${TP+TN} \over {TP+TN+FP+FN}$，即预测正确的结果占总样本的百分比</li><li>精准率（Precision/查准率）：$TP \over {TP+FP}$，即在所有被预测为正的样本中，实际为正的样本占被预测为正的样本的比例</li><li>召回率（Reacll/查全率/真阳率）：$TP \over {TP+FN}$</li><li>P-R(查准率-查全率)曲线，横轴是查全率，纵轴是查准率</li><li>F1 分数：$2 \times 查准率 \times 查全率 \over {查准率+查全率}$，是 P-R（查准率-查全率）的平衡点</li><li>灵敏度（Sensitivity）：真阳率，$TP \over {TP+FN}$</li><li>特异度（Specificity）：1-假阳率，$TN \over {FP+TN}$</li></ul><p><strong>条件概率表示，假设 X 为预测值，Y 为真实值：</strong></p><ul><li>精准率=P(Y=1|X=1)</li><li>召回率=灵敏度=查全率=真阳率=P(X=1|Y=1)</li><li>特异度=P(X=0|Y=0)</li></ul><h2 id="其他参考文献"><a href="#其他参考文献" class="headerlink" title="其他参考文献"></a>其他参考文献</h2><p>数据集来源：</p><table><thead><tr><th>Dataset</th><th>Title</th></tr></thead><tbody><tr><td><a href="https://www.researchgate.net/profile/Fred_Asselbergs/publication/7719918_Design_of_a_genome-wide_siRNA_library_using_an_artificial_neural_network/links/02bfe5100040c1a916000000.pdf" target="_blank" rel="external nofollow noopener noreferrer">Huesken(2431)</a></td><td>Design of a genome-wide siRNA library using an artificial neural network</td></tr><tr><td><a href="https://sci-hub.tw/10.1038/nbt936" target="_blank" rel="external nofollow noopener noreferrer">Reynolds(248)</a></td><td>Rational siRNA design for RNA interference</td></tr><tr><td><a href="https://sci-hub.tw/10.1074/jbc.m210326200" target="_blank" rel="external nofollow noopener noreferrer">Vickers(80)</a></td><td>Efficient reduction of target RNAs by small interfering RNA and RNase H-dependent antisense agents</td></tr><tr><td><a href="https://sci-hub.tw/10.1089/108729003321629638" target="_blank" rel="external nofollow noopener noreferrer">Haborth(44)</a></td><td>Sequence, chemical, and structural variation of small interfering RNAs and short hairpin RNAs and the effect on mammalian gene silencing</td></tr><tr><td><a href="https://sci-hub.st/10.1093/nar/gkl1120" target="_blank" rel="external nofollow noopener noreferrer">Takayuki(702)</a></td><td>Specific residues at every third position of siRNA shape its efficient RNAi activity</td></tr><tr><td><a href="https://sci-hub.tw/10.1093/nar/gkh247" target="_blank" rel="external nofollow noopener noreferrer">Ui-Tei(62)</a></td><td>Guidelines for the selection of highly effective siRNA sequences for mammalian and chick RNA interference</td></tr><tr><td><a href="https://sci-hub.st/10.1093/nar/gki294" target="_blank" rel="external nofollow noopener noreferrer">siRNAdb(500)</a></td><td>siRNAdb: a database of siRNA sequences</td></tr></tbody></table><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;论文《SiRNA silencing efficacy prediction based on a deep architecture》笔记，以及对这篇论文的看法、理解和困惑。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="DeepLearning" scheme="https://hanielxx.com/categories/DeepLearning/"/>
    
    
    <category term="DeepLearning" scheme="https://hanielxx.com/tags/DeepLearning/"/>
    
    <category term="Paper" scheme="https://hanielxx.com/tags/Paper/"/>
    
    <category term="Note" scheme="https://hanielxx.com/tags/Note/"/>
    
    <category term="AUC" scheme="https://hanielxx.com/tags/AUC/"/>
    
    <category term="ROC" scheme="https://hanielxx.com/tags/ROC/"/>
    
    <category term="siRNA" scheme="https://hanielxx.com/tags/siRNA/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro下Mendeley无法输入中文</title>
    <link href="https://hanielxx.com/Linux/2020-07-30-manjaro-mendeley-fcitx"/>
    <id>https://hanielxx.com/Linux/2020-07-30-manjaro-mendeley-fcitx</id>
    <published>2020-07-30T08:12:40.000Z</published>
    <updated>2020-11-14T12:40:56.237Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mendeley是一款论文管理软件，可以跨平台同步使用。</p><p>在Manjaro上发现Mendeley无法输入中文，进行批注。<br>查找原因是Mendeley使用了自己的QT库，没有对fcitx的支持。</p></div><a id="more"></a><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>网上查到了基本上都是添加<code>/opt/mendeleydesktop/lib/mendeleydesktop/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so</code></p><p>方法大同小异，可以参考<a href="https://www.findhao.net/easycoding/2287" target="_blank" rel="external nofollow noopener noreferrer">这个博客</a>有的是从github上自己下载放里面，有的是用<code>locate libfcitxplatforminputcontextplugin.so</code>后进行本地的软链接。但是这些方法在我这都失效了。</p><p>后续发现<a href="https://www.zhihu.com/question/25517900/answer/236861798" target="_blank" rel="external nofollow noopener noreferrer">一个帖子</a>，说是Mendeley版本升级后，对Qt的依赖版本也升级了，要下载对应的版本。Mendeley 1.18-1.191使用了Qt5.10.1的库，但是进行操作后还是无法输入中文。。</p><p>最后在AUR中搜到了一个<a href="https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=mendeleydesktop-bundled-fcitx" target="_blank" rel="external nofollow noopener noreferrer">AUR : mendeleydesktop-bundled-fcitx.git</a>，尝试了下，ok了。</p><p>查看了它的PKGBUILD，发现安装的不止上面方面说的那个库，还包括了<code>/opt/mendeleydesktop/lib/qt/libFcitxQt5DBusAddons.so.1.0</code>这个包，可以从<a href="https://github.com/yinflying/BlogSource/raw/master/lib-fcitx-plugin/arch-qt5.10.1/libFcitxQt5DBusAddons.so.1.0" target="_blank" rel="external nofollow noopener noreferrer">github</a>上下载。</p><h2 id="PKGBUILD"><a href="#PKGBUILD" class="headerlink" title="PKGBUILD"></a>PKGBUILD</h2><p>具体的PKGBUILD如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># This is an example PKGBUILD file. Use this as a start to creating your own,</span><br><span class="line"># and remove these comments. For more information, see &#39;man PKGBUILD&#39;.</span><br><span class="line"># NOTE: Please fill out the license field for your package! If it is unknown,</span><br><span class="line"># then please put &#39;unknown&#39;.</span><br><span class="line"></span><br><span class="line"># The following guidelines are specific to BZR, GIT, HG and SVN packages.</span><br><span class="line"># Other VCS sources are not natively supported by makepkg yet.</span><br><span class="line"></span><br><span class="line"># Maintainer: yinflying &lt;yinflying@foxmail.com&gt;</span><br><span class="line">pkgname&#x3D;mendeleydesktop-bundled-fcitx</span><br><span class="line">pkgver&#x3D;1.19.4</span><br><span class="line">pkgrel&#x3D;1</span><br><span class="line">pkgdesc&#x3D;&quot;mendeleydesktop fcitx input method support&quot;</span><br><span class="line">arch&#x3D;(&#39;x86_64&#39;)</span><br><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;yinflying.top&#x2F;2017&#x2F;09&#x2F;727&quot;</span><br><span class="line">license&#x3D;(&#39;GPL&#39;)</span><br><span class="line">depends&#x3D;(&#39;mendeleydesktop-bundled&#39;)</span><br><span class="line">makedepends&#x3D;(&#39;git&#39;)  # &#39;bzr&#39;, &#39;git&#39;, &#39;mercurial&#39; or &#39;subversion&#39;</span><br><span class="line">provides&#x3D;(&quot;$&#123;pkgname&#125;&quot;)</span><br><span class="line">conflicts&#x3D;(&quot;$&#123;pkgname&#125;&quot;)</span><br><span class="line">replaces&#x3D;()</span><br><span class="line">backup&#x3D;()</span><br><span class="line">options&#x3D;()</span><br><span class="line">install&#x3D;</span><br><span class="line">source&#x3D;(&quot;https:&#x2F;&#x2F;github.com&#x2F;yinflying&#x2F;BlogSource&#x2F;raw&#x2F;master&#x2F;lib-fcitx-plugin&#x2F;arch-qt5.10.1&#x2F;libFcitxQt5DBusAddons.so.1.0&quot;</span><br><span class="line">        &quot;https:&#x2F;&#x2F;github.com&#x2F;yinflying&#x2F;BlogSource&#x2F;raw&#x2F;master&#x2F;lib-fcitx-plugin&#x2F;arch-qt5.10.1&#x2F;libfcitxplatforminputcontextplugin.so&quot;)</span><br><span class="line">noextract&#x3D;()</span><br><span class="line">md5sums&#x3D;(&#39;SKIP&#39; &#39;SKIP&#39;)</span><br><span class="line"></span><br><span class="line">package() &#123;</span><br><span class="line">    install -Dm755 &quot;$srcdir&#x2F;libfcitxplatforminputcontextplugin.so&quot; &quot;$pkgdir&#x2F;opt&#x2F;mendeleydesktop&#x2F;lib&#x2F;mendeleydesktop&#x2F;plugins&#x2F;platforminputcontexts&#x2F;libfcitxplatforminputcontextplugin.so&quot;</span><br><span class="line">    install -Dm755 &quot;$srcdir&#x2F;libFcitxQt5DBusAddons.so.1.0&quot; &quot;$pkgdir&#x2F;opt&#x2F;mendeleydesktop&#x2F;lib&#x2F;qt&#x2F;libFcitxQt5DBusAddons.so.1.0&quot;</span><br><span class="line">    cd &quot;$pkgdir&#x2F;opt&#x2F;mendeleydesktop&#x2F;lib&#x2F;qt&quot;</span><br><span class="line">    ln -s libFcitxQt5DBusAddons.so.1.0 libFcitxQt5DBusAddons.so.1</span><br><span class="line">    ln -s libFcitxQt5DBusAddons.so.1 libFcitxQt5DBusAddons.so</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Mendeley是一款论文管理软件，可以跨平台同步使用。&lt;/p&gt;&lt;p&gt;在Manjaro上发现Mendeley无法输入中文，进行批注。&lt;br&gt;查找原因是Mendeley使用了自己的QT库，没有对fcitx的支持。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hanielxx.com/categories/Linux/"/>
    
    
    <category term="Arch" scheme="https://hanielxx.com/tags/Arch/"/>
    
    <category term="Linux" scheme="https://hanielxx.com/tags/Linux/"/>
    
    <category term="Manjaro" scheme="https://hanielxx.com/tags/Manjaro/"/>
    
    <category term="Mendeley" scheme="https://hanielxx.com/tags/Mendeley/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-039-Combination Sum</title>
    <link href="https://hanielxx.com/LeetCode/2019-11-18-LeetCode-039-Combination-Sum"/>
    <id>https://hanielxx.com/LeetCode/2019-11-18-LeetCode-039-Combination-Sum</id>
    <published>2019-11-18T07:57:44.000Z</published>
    <updated>2020-11-14T12:40:56.195Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="external nofollow noopener noreferrer">Problem</a></h2><p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p><p>The same repeated number may be chosen from candidates unlimited number of times.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>candidates = [2,3,6,7], target = 7<br>candidates = [2,3,5], target = 8</p></blockquote><p><strong>Output:</strong></p><blockquote><p>[ [7], [2,2,3] ]<br>[ [2,2,2,2], [2,3,3], [3,5] ]</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>刚开始还以为是完全背包问题，后来想想好像不太对，只是有点像背包问题</li><li>然后就想到可以直接递归做，应该也可以用DP，但是递归加剪枝加回溯就可以了</li><li>先从不大于target的candidates开始找，然后将这个candidate记下，递归找到所有target-candidate的组合，最后回溯，将之前记下的candidate和所有的组合拼接起来，得到结果，具体看代码</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        sort(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归边界</span></span><br><span class="line">        <span class="keyword">if</span>(candidates[<span class="number">0</span>]&gt;target || target==<span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=candidates.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 大于target，无法组合，剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(candidates[i]&gt;target)<span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前数加入pre数组</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">            pre.push_back(candidates[i]);</span><br><span class="line">            <span class="keyword">if</span>(target-candidates[i]==<span class="number">0</span>) &#123;</span><br><span class="line">                res.push_back(pre);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归找到target-candidates[i]的组合</span></span><br><span class="line">            <span class="comment">// 使用tmpCandidates防止结果重复</span></span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmpCandidates</span><span class="params">(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">begin</span>()+i+<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; last=combinationSum(tmpCandidates,target-candidates[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯，拼接pre和last[..]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;last.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">                tmp.insert(tmp.<span class="built_in">end</span>(),pre.<span class="built_in">begin</span>(),pre.<span class="built_in">end</span>());</span><br><span class="line">                tmp.insert(tmp.<span class="built_in">end</span>(),last[j].<span class="built_in">begin</span>(),last[j].<span class="built_in">end</span>());</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用递归和回溯，尽量进行一些剪枝操作，防止复杂度太高</li><li>递归问题要注意返回条件，这里是<code>candidates[0]&gt;target || target==0</code>，这样就返回<code>{}</code></li><li><code>vector</code>的拼接操作使用<code>insert</code>比较方便</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;/p&gt;&lt;p&gt;The same repeated number may be chosen from candidates unlimited number of times.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;candidates = [2,3,6,7], target = 7&lt;br&gt;candidates = [2,3,5], target = 8&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;[ [7], [2,2,3] ]&lt;br&gt;[ [2,2,2,2], [2,3,3], [3,5] ]&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
    <category term="Recursive" scheme="https://hanielxx.com/tags/Recursive/"/>
    
    <category term="Backtracking" scheme="https://hanielxx.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-038-Count and Say</title>
    <link href="https://hanielxx.com/LeetCode/2019-11-18-LeetCode-038-Count-and-Say"/>
    <id>https://hanielxx.com/LeetCode/2019-11-18-LeetCode-038-Count-and-Say</id>
    <published>2019-11-18T07:51:19.000Z</published>
    <updated>2020-11-14T12:40:56.195Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="external nofollow noopener noreferrer">Problem</a></h2><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p><p>Given an integer n where 1 ≤ n ≤ 30, generate thenthterm of the count-and-say sequence.</p><p>Note: Each term of the sequence of integers will be represented as a string.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>1<br>4</p></blockquote><p><strong>Output:</strong></p><blockquote><p>“1”<br>“1211”</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>直接对上一次的结果进行从左往右的遍历，暴力求解</li><li>要注意的就是里面的细节和边界</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>, pre = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span> (; cnt &lt; n; cnt++) &#123;</span><br><span class="line">            <span class="keyword">int</span> numCnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> numPre = pre[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[i] == numPre)</span><br><span class="line">                numCnt++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += to_string(numCnt) + numPre;</span><br><span class="line">                numPre = pre[i];</span><br><span class="line">                numCnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += to_string(numCnt) + numPre;</span><br><span class="line">            pre = res;</span><br><span class="line">            res = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;pre&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/count-and-say/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The count-and-say sequence is the sequence of integers with the first five terms as following:&lt;/p&gt;&lt;p&gt;&lt;code&gt;1&lt;/code&gt; is read off as &lt;code&gt;&amp;quot;one 1&amp;quot;&lt;/code&gt; or &lt;code&gt;11&lt;/code&gt;.&lt;br&gt;&lt;code&gt;11&lt;/code&gt; is read off as &lt;code&gt;&amp;quot;two 1s&amp;quot;&lt;/code&gt; or &lt;code&gt;21&lt;/code&gt;.&lt;br&gt;&lt;code&gt;21&lt;/code&gt; is read off as &lt;code&gt;&amp;quot;one 2&lt;/code&gt;, then &lt;code&gt;one 1&amp;quot;&lt;/code&gt; or &lt;code&gt;1211&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Given an integer n where 1 ≤ n ≤ 30, generate thenthterm of the count-and-say sequence.&lt;/p&gt;&lt;p&gt;Note: Each term of the sequence of integers will be represented as a string.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;1&lt;br&gt;4&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“1”&lt;br&gt;“1211”&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
    <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
    <category term="BruteForce" scheme="https://hanielxx.com/tags/BruteForce/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-036-Valid Sudoku</title>
    <link href="https://hanielxx.com/LeetCode/2019-11-15-LeetCode-036-Valid-Sudoku"/>
    <id>https://hanielxx.com/LeetCode/2019-11-15-LeetCode-036-Valid-Sudoku</id>
    <published>2019-11-15T03:34:14.000Z</published>
    <updated>2020-11-14T12:40:56.199Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href>Problem</a></h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p><ul><li>Each row must contain the digits 1-9 without repetition.</li><li>Each column must contain the digits 1-9 without repetition.</li><li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition</li></ul><center></center><p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>[<br>[ 5 , 3 ,”.”,”.”, 7 ,”.”,”.”,”.”,”.”],<br>[ 6 ,”.”,”.”, 1 , 9 , 5 ,”.”,”.”,”.”],<br>[“.”, 9 , 8 ,”.”,”.”,”.”,”.”, 6 ,”.”],<br>[ 8 ,”.”,”.”,”.”, 6 ,”.”,”.”,”.”, 3 ],<br>[ 4 ,”.”,”.”, 8 ,”.”, 3 ,”.”,”.”, 1 ],<br>[ 7 ,”.”,”.”,”.”, 2 ,”.”,”.”,”.”, 6 ],<br>[“.”, 6 ,”.”,”.”,”.”,”.”, 2 , 8 ,”.”],<br>[“.”,”.”,”.”, 4 , 1 , 9 ,”.”,”.”, 5 ],<br>[“.”,”.”,”.”,”.”, 8 ,”.”,”.”, 7 , 9 ]<br>]</p></blockquote><p><strong>Output:</strong></p><blockquote><p>true</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>简单的方法就是三次遍历，暴力求解</li><li>优化就是一次遍历，然后使用<code>map</code>来记录，确保：<ul><li>行中没有重复的数字。</li><li>列中没有重复的数字。</li><li>3 x 3 子数独内没有重复的数字。</li></ul></li><li>难点是，如何确定子数独里方块的位置，需要进行坐标变换，参考：<ul><li>外层循环行i：0-8,内层循环列j：0-8</li><li>子数独的行号是：<code>i/3*3+j/3</code></li><li>子数独的列号是：<code>i%3*3+j%3</code></li></ul></li><li>使用到的技巧就是，坐标变换</li></ul><center></center><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">bool</span>&gt; rowMap, colMap, subMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">            <span class="comment">// 判断行</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]!=<span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rowMap[board[i][j]]==<span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                rowMap[board[i][j]]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断列</span></span><br><span class="line">            <span class="keyword">if</span>(board[j][i]!=<span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(colMap[board[j][i]]==<span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                colMap[board[j][i]]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过坐标变换，判断子数独</span></span><br><span class="line">            <span class="keyword">if</span>(board[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][i%<span class="number">3</span>*<span class="number">3</span>+j%<span class="number">3</span>] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(subMap[board[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][i%<span class="number">3</span>*<span class="number">3</span>+j%<span class="number">3</span>]] == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                subMap[board[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][i%<span class="number">3</span>*<span class="number">3</span>+j%<span class="number">3</span>]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在矩阵中的多次迭代遍历，可以想办法通过坐标变换映射到需要的上面。可以自己画个图，把坐标列出来找规律</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Each row must contain the digits 1-9 without repetition.&lt;/li&gt;&lt;li&gt;Each column must contain the digits 1-9 without repetition.&lt;/li&gt;&lt;li&gt;Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition&lt;/li&gt;&lt;/ul&gt;&lt;center&gt;&lt;/center&gt;&lt;p&gt;The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;[&lt;br&gt;[ 5 , 3 ,”.”,”.”, 7 ,”.”,”.”,”.”,”.”],&lt;br&gt;[ 6 ,”.”,”.”, 1 , 9 , 5 ,”.”,”.”,”.”],&lt;br&gt;[“.”, 9 , 8 ,”.”,”.”,”.”,”.”, 6 ,”.”],&lt;br&gt;[ 8 ,”.”,”.”,”.”, 6 ,”.”,”.”,”.”, 3 ],&lt;br&gt;[ 4 ,”.”,”.”, 8 ,”.”, 3 ,”.”,”.”, 1 ],&lt;br&gt;[ 7 ,”.”,”.”,”.”, 2 ,”.”,”.”,”.”, 6 ],&lt;br&gt;[“.”, 6 ,”.”,”.”,”.”,”.”, 2 , 8 ,”.”],&lt;br&gt;[“.”,”.”,”.”, 4 , 1 , 9 ,”.”,”.”, 5 ],&lt;br&gt;[“.”,”.”,”.”,”.”, 8 ,”.”,”.”, 7 , 9 ]&lt;br&gt;]&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;true&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Arch安装YCM</title>
    <link href="https://hanielxx.com/Linux/2019-11-10-arch-install-ycm"/>
    <id>https://hanielxx.com/Linux/2019-11-10-arch-install-ycm</id>
    <published>2019-11-10T03:26:57.000Z</published>
    <updated>2020-11-14T12:40:56.236Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安装几次YCM都有问题，记录下安装过程。其实挺简单的。</p></div><a id="more"></a><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>安装clang，boost，llvm。我用的是Arch，其他系统自己装llvm，clang，libclang，libboost，cmake</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S clang boost llvm-libs cmake</span><br></pre></td></tr></table></figure><h2 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a>正式安装</h2><h3 id="安装YCM"><a href="#安装YCM" class="headerlink" title="安装YCM"></a>安装YCM</h3><p>看你用的是vundle还是什么。因为我是用的SpaceVim，所以直接在配置文件中enable这个选项就可以了，然后添加一些配置。再次打开vim后会自动安装至<code>~/.cache/vimfiles/repos/github.com/Valloric/YouCompleteMe</code>。</p><p>或者可以通过git安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;ycm-core&#x2F;YouCompleteMe.git</span><br><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>需要编译一下，直接使用<code>install.py</code>或者<code>install.sh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;.cache&#x2F;vimfiles&#x2F;repos&#x2F;github.com&#x2F;Valloric&#x2F;YouCompleteMe</span><br><span class="line">$ .&#x2F;install.sh --clang-completer --java-completer</span><br></pre></td></tr></table></figure><h3 id="构建ycm-core库"><a href="#构建ycm-core库" class="headerlink" title="构建ycm_core库"></a>构建ycm_core库</h3><p>这一步需要cmake和python3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~&#x2F;tmp&#x2F;ycm_build</span><br><span class="line">$ cd ~&#x2F;tmp&#x2F;ycm_build</span><br><span class="line">$ cmake -G &quot;Unix Makefiles&quot; -DUSE_SYSTEM_BOOST&#x3D;ON -DUSE_SYSTEM_LIBCLANG&#x3D;ON . &#x2F;home&#x2F;hanielxx&#x2F;.cache&#x2F;vimfiles&#x2F;repos&#x2F;github.com&#x2F;Valloric&#x2F;YouCompleteMe&#x2F;third_party&#x2F;ycmd&#x2F;cpp</span><br><span class="line">$ cmake --build . --target ycm_core --config Releas</span><br></pre></td></tr></table></figure><p>上面步骤自己检查输出是否正常，如果出现<code>NOT using libclang, nosemantic completion for C/C++/ObjC will be avaiable</code>之类的输出，那么还是有问题的，没有C家族语言的支持。</p><h3 id="配置ycm-extra-conf-py"><a href="#配置ycm-extra-conf-py" class="headerlink" title="配置ycm_extra_conf.py"></a>配置ycm_extra_conf.py</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;.SpaceVim.d</span><br><span class="line">$ cp &#x2F;home&#x2F;hanielxx&#x2F;.cache&#x2F;vimfiles&#x2F;repos&#x2F;github.com&#x2F;Valloric&#x2F;YouCompleteMe&#x2F;third_party&#x2F;ycmd&#x2F;examples&#x2F;.ycm_extra_conf.py .&#x2F;</span><br></pre></td></tr></table></figure><h3 id="配置YCM"><a href="#配置YCM" class="headerlink" title="配置YCM"></a>配置YCM</h3><p>还要去修改下<code>~/.SpaceVim.d/init.vim</code>，配置YCM。下面是YCM部分的配置，注意第一行，需要加上python2的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let g:ycm_server_python_interpreter&#x3D;&#39;&#x2F;usr&#x2F;bin&#x2F;python2&#39;</span><br><span class="line">let g:spacevim_enable_ycm &#x3D; 1</span><br><span class="line">let g:ycm_complete_in_comments &#x3D; 1</span><br><span class="line">let g:ycm_confirm_extra_conf &#x3D; 0</span><br><span class="line">let g:ycm_seed_identifiers_with_syntax &#x3D; 0</span><br><span class="line">let g:ycm_error_symbol &#x3D; &#39;✗&#39;</span><br><span class="line">let g:ycm_warning_symbol &#x3D; &#39;!&#39;</span><br><span class="line">let g:ycm_global_ycm_extra_conf &#x3D; &#39;~&#x2F;.SpaceVim.d&#x2F;.ycm_extra_conf.py&#39;</span><br><span class="line">let g:ycm_semantic_triggers &#x3D;  &#123;</span><br><span class="line">  \   &#39;c&#39; : [&#39;-&gt;&#39;, &#39;.&#39;],</span><br><span class="line">  \   &#39;cpp,objcpp&#39; : [&#39;-&gt;&#39;, &#39;.&#39;, &#39;::&#39;],</span><br><span class="line">  \   &#39;php&#39; : [&#39;-&gt;&#39;, &#39;::&#39;],</span><br><span class="line">  \   &#39;cs,java,javascript,typescript,d,python,perl6,scala,vb,elixir,go&#39; : [&#39;.&#39;],</span><br><span class="line">  \   &#39;ruby&#39; : [&#39;.&#39;, &#39;::&#39;],</span><br><span class="line">  \   &#39;lua&#39; : [&#39;.&#39;, &#39;:&#39;],</span><br><span class="line">  \ &#125;</span><br><span class="line">let g:ycm_filetype_blacklist &#x3D; &#123; &#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;安装几次YCM都有问题，记录下安装过程。其实挺简单的。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hanielxx.com/categories/Linux/"/>
    
    
    <category term="Arch" scheme="https://hanielxx.com/tags/Arch/"/>
    
    <category term="Linux" scheme="https://hanielxx.com/tags/Linux/"/>
    
    <category term="Vim" scheme="https://hanielxx.com/tags/Vim/"/>
    
    <category term="YCM" scheme="https://hanielxx.com/tags/YCM/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-035-Search Insert Position</title>
    <link href="https://hanielxx.com/LeetCode/2019-11-07-LeetCode-035-Search-Insert-Position"/>
    <id>https://hanielxx.com/LeetCode/2019-11-07-LeetCode-035-Search-Insert-Position</id>
    <published>2019-11-07T03:22:45.000Z</published>
    <updated>2020-11-14T12:40:56.197Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/search-insert-position/submissions/" target="_blank" rel="external nofollow noopener noreferrer">Problem</a></h2><p>target is found. If not, return the index where it would be if it were inserted in order.<br>You may assume no duplicates in the array.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>[1,3,5,6], 5<br>[1,3,5,6], 2<br>[1,3,5,6], 7<br>[1,3,5,6], 0</p></blockquote><p><strong>Output:</strong></p><blockquote><p>2<br>1<br>4<br>0</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>简单的二分查找，然后找不到的话，就返回r+1。因为while的条件是(l&gt;=r)，所以，出了while循环就是l&gt;r了，因此返回r+_1就可以了</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> l=<span class="number">0</span>, r=nums.<span class="built_in">size</span>()<span class="number">-1</span>, mid;</span><br><span class="line">      <span class="comment">// 条件是l&lt;=r</span></span><br><span class="line">      <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(target&gt;nums[mid])&#123;</span><br><span class="line">          l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 到这里代表没找到，l&gt;r, 返回r+1</span></span><br><span class="line">      <span class="keyword">return</span> r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-insert-position/submissions/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;target is found. If not, return the index where it would be if it were inserted in order.&lt;br&gt;You may assume no duplicates in the array.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;[1,3,5,6], 5&lt;br&gt;[1,3,5,6], 2&lt;br&gt;[1,3,5,6], 7&lt;br&gt;[1,3,5,6], 0&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;2&lt;br&gt;1&lt;br&gt;4&lt;br&gt;0&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
    <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
    <category term="BinarySearch" scheme="https://hanielxx.com/tags/BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-034-Find First and Last Position of Element in Sorted Array</title>
    <link href="https://hanielxx.com/LeetCode/2019-11-06-LeetCode-034-Find%20First%20and%20Last%20Position%20of%20Element%20in%20Sorted%20Array"/>
    <id>https://hanielxx.com/LeetCode/2019-11-06-LeetCode-034-Find%20First%20and%20Last%20Position%20of%20Element%20in%20Sorted%20Array</id>
    <published>2019-11-06T04:10:35.000Z</published>
    <updated>2020-11-14T12:40:56.196Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="external nofollow noopener noreferrer">Problem</a></h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><p>If the target is not found in the array, return [-1, -1].</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>nums = [5,7,7,8,8,10], target = 8<br>nums = [5,7,7,8,8,10], target = 6</p></blockquote><p><strong>Output:</strong></p><blockquote><p>[3,4]<br>[-1,-1]</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>题目要求$$ O(log n) $$ 级别的时间复杂度，又是查找，所以肯定是二分查找比较快</li><li>这里要求的是找到最左边的target和最右边的target</li><li>两种思路<ul><li>直接按照原始二分，找到一个之后，向左右遍历</li><li>直接找左边界和右边界，两次查找</li></ul></li><li>下面采用的是第一种思路，第二种思路见题解：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="external nofollow noopener noreferrer">二分查找算法细节详解</a></li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>找到一个target之后往左右遍历，8ms，10.2MB</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> mid;</span><br><span class="line">      <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]) l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> l,r;</span><br><span class="line">      <span class="keyword">int</span> pos = binarySearch(nums,target);</span><br><span class="line">      <span class="keyword">if</span>(pos==<span class="number">-1</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        l = r = pos;</span><br><span class="line">        <span class="keyword">while</span>(r+<span class="number">1</span>&lt;nums.<span class="built_in">size</span>() &amp;&amp; nums[r+<span class="number">1</span>]==target) r++;</span><br><span class="line">        <span class="keyword">while</span>(l<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; nums[l<span class="number">-1</span>]==target) l--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.&lt;/p&gt;&lt;p&gt;Your algorithm’s runtime complexity must be in the order of O(log n).&lt;/p&gt;&lt;p&gt;If the target is not found in the array, return [-1, -1].&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;nums = [5,7,7,8,8,10], target = 8&lt;br&gt;nums = [5,7,7,8,8,10], target = 6&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;[3,4]&lt;br&gt;[-1,-1]&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
    <category term="List" scheme="https://hanielxx.com/tags/List/"/>
    
    <category term="Search" scheme="https://hanielxx.com/tags/Search/"/>
    
    <category term="BinarySearch" scheme="https://hanielxx.com/tags/BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-033-Search in Rotated Sorted Array</title>
    <link href="https://hanielxx.com/LeetCode/2019-11-05-LeetCode-033-Search-in-Rotated-Sorted-Array"/>
    <id>https://hanielxx.com/LeetCode/2019-11-05-LeetCode-033-Search-in-Rotated-Sorted-Array</id>
    <published>2019-11-05T04:25:45.000Z</published>
    <updated>2020-11-14T12:40:56.193Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/submissions/" target="_blank" rel="external nofollow noopener noreferrer">Problem</a></h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>nums = [4,5,6,7,0,1,2], target = 0<br>nums = [4,5,6,7,0,1,2], target = 3</p></blockquote><p><strong>Output:</strong></p><blockquote><p>4<br>-1</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>题目要求时间复杂度要在$$ O(log n) $$，所以很自然要想到二分搜索</li><li>基础版本的二分搜索很明显不适用，因为有一个分隔点，要在此基础上修改</li><li>思路是：判断分隔点在前半部分还是在后半部分，以mid为分界。找到有序的部分，在这部分上应用二叉搜索查找target。如果target不在有序的部分内，则转移到无序的部分，然后继续这样找有序的部分。具体看代码注释</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    mid = (l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果nums[mid]==target，就返回</span></span><br><span class="line">    <span class="keyword">if</span>(target==nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前半部分有序，即切割点在后半部分</span></span><br><span class="line">    <span class="comment">// 注意这里是大于等于，将mid=l的情况分为前半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&gt;=nums[l])&#123;</span><br><span class="line">      <span class="comment">// 如果target在有序部分，则二分</span></span><br><span class="line">      <span class="keyword">if</span>(target&gt;=nums[l] &amp;&amp; target&lt;nums[mid])&#123;</span><br><span class="line">        r=mid<span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        l=mid+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 如果后半部分有序，即切割点在前半部分</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(target&gt;nums[mid] &amp;&amp; target&lt;=nums[r])&#123;</span><br><span class="line">        l=mid+<span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        r=mid<span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums=&#123;<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;search(nums, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_rotate_index</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                pivot = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[pivot] &gt; nums[pivot + <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> pivot + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> nums[pivot] &lt; nums[left]:</span><br><span class="line">                        right = pivot - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = pivot + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            Binary search</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                pivot = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[pivot] == target:</span><br><span class="line">                    <span class="keyword">return</span> pivot</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; nums[pivot]:</span><br><span class="line">                        right = pivot - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = pivot + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> nums[<span class="number">0</span>] == target <span class="keyword">else</span> <span class="number">-1</span> </span><br><span class="line">        </span><br><span class="line">        rotate_index = find_rotate_index(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># if target is the smallest element</span></span><br><span class="line">        <span class="keyword">if</span> nums[rotate_index] == target:</span><br><span class="line">            <span class="keyword">return</span> rotate_index</span><br><span class="line">        <span class="comment"># if array is not rotated, search in the entire array</span></span><br><span class="line">        <span class="keyword">if</span> rotate_index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> search(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> target &lt; nums[<span class="number">0</span>]:</span><br><span class="line">            <span class="comment"># search on the right side</span></span><br><span class="line">            <span class="keyword">return</span> search(rotate_index, n - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># search on the left side</span></span><br><span class="line">        <span class="keyword">return</span> search(<span class="number">0</span>, rotate_index)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>这样的题目，还是从基础算法着手，然后将基础算法和具体题目结合起来。这题关键就是找到有序的部分，然后应用二分搜索。</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array/submissions/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;/p&gt;&lt;p&gt;(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).&lt;/p&gt;&lt;p&gt;You are given a target value to search. If found in the array return its index, otherwise return -1.&lt;/p&gt;&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;&lt;p&gt;Your algorithm’s runtime complexity must be in the order of O(log n).&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;nums = [4,5,6,7,0,1,2], target = 0&lt;br&gt;nums = [4,5,6,7,0,1,2], target = 3&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;4&lt;br&gt;-1&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
    <category term="List" scheme="https://hanielxx.com/tags/List/"/>
    
    <category term="Search" scheme="https://hanielxx.com/tags/Search/"/>
    
    <category term="BinarySearch" scheme="https://hanielxx.com/tags/BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>EM算法</title>
    <link href="https://hanielxx.com/Notes/2019-11-04-EM-Notes"/>
    <id>https://hanielxx.com/Notes/2019-11-04-EM-Notes</id>
    <published>2019-11-04T05:42:24.000Z</published>
    <updated>2020-11-14T12:40:56.231Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>主要介绍EM的整个推导过程。</p></div><a id="more"></a><h2 id="1-Jensen不等式"><a href="#1-Jensen不等式" class="headerlink" title="1. Jensen不等式"></a>1. Jensen不等式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>回顾优化理论中的一些概念:</p><ul><li>设f是定义域为实数的函数</li><li>如果对于所有的实数x，$$ f’’(x) \ge 0 $$，那么f是凸函数。</li><li>当x是向量时，如果其hessian矩阵H是半正定的（$$ H \ge 0 $$），那么f是凸函数。</li><li>如果$$ f’’(x) \gt 0 $$或者$$ H \gt 0 $$，那么称f是严格凸函数。</li></ul><h3 id="Jensen的表述"><a href="#Jensen的表述" class="headerlink" title="Jensen的表述"></a>Jensen的表述</h3><div class="note"><p>如果f是凸函数，X是随机变量，那么$$ E[f(X)] \ge f(EX) $$<br>特别地，如果f是严格凸函数，那么$$ E[f(X)] = f(EX)$$, 当且仅当$$ p(x=E[x]=1) $$，也就是说X是常量。</p><p>这里我们将$$ f(E[x]) $$简写为$$ f(EX) $$。</p></div><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>如果用图表示会很清晰：</p><center></center><p>图中，实线f是凸函数，X是随机变量，有0.5的概率是a，有0.5的概率是b。（就像掷硬币一样）。<br>X的期望值就是a和b的中值了，图中可以看到$$ E[f(X)] \ge f(EX)$$成立。</p><p>当$$ f $$是（严格）凹函数即当且仅当$$ -f $$是（严格）凸函数。</p><p>Jensen不等式应用于凹函数时，不等号方向反向，也就是$$ E[f(X)] \le f(EX) $$。</p><h2 id="2-EM算法"><a href="#2-EM算法" class="headerlink" title="2. EM算法"></a>2. EM算法</h2><h3 id="隐藏变量"><a href="#隐藏变量" class="headerlink" title="隐藏变量"></a>隐藏变量</h3><p>给定的训练样本是$$ { x^{(1)},…,x^{(m)}} $$，样例间独立，我们想找到每个样例隐含的类别z，能使得$$p(x,z)$$最大。$$ p(x,z) $$的最大似然估计如下：</p><p>$$<br>\begin{equation}\begin{split}<br>{\ell}(\theta) &amp;= \sum_{i=1}^m log p (x;\theta) \<br>&amp;= \sum_{i=1}^m log \sum_z p(x,z;\theta)<br>\end{split}\end{equation}<br>$$</p><ul><li>第一步是对极大似然取对数</li><li>第二步是对每个样例的每个可能类别z求联合分布概率和</li><li>直接求$$ \theta $$一般比较困难，因为有隐藏变量z存在，但是一般确定了z后，求解就容易了。</li></ul><h3 id="建立、优化下界"><a href="#建立、优化下界" class="headerlink" title="建立、优化下界"></a>建立、优化下界</h3><p>EM是一种解决存在隐含变量优化问题的有效方法。既然不能直接最大化$$ \ell(\theta) $$，我们可以不断地建立$$ \ell $$的下界（E步），然后优化下界（M步）。</p><p>这句话比较抽象，看下面的。</p><ul><li>对于每一个样例i，让$$ Q_i $$表示该样例隐含变量z的某种分布，$$ Q(i) $$满足的条件是$$ \sum_z Q_i(z)=1, Q_i(z) \ge 0 $$。</li><li>如果z是连续性的，那么$$ Q_i $$是概率密度函数，需要将求和符号换做积分符号。</li><li>比如要将班上学生聚类，假设隐藏变量z是身高，那么就是连续的高斯分布。如果按照隐藏变量是男女，那么就是伯努利分布了。</li></ul><p>可以由前面阐述的内容得到下面的公式：</p><p>\begin{equation}\begin{split}<br>\sum_i logp(x^{(i)}; \theta) &amp;= \sum_i log \sum_{z^{(i)}} p(x^{(i)},z^{(i)}; \theta) \<br>&amp;= \sum_i log \sum_{z^{(i)}} Q_i(z^{(i)}) {p(x^{(i)}, z^{(i)}; \theta) \over Q_i(z^{(i)})} \<br>&amp; \ge \sum_i \sum_{z^{(i)}} Q_i(z^{(i)}) log {p(x^{(i)},z^{(i)}; \theta) \over Q_i(z^{(i)})}<br>\end{split}\end{equation}</p><ul><li>（1）到（2）比较直接，就是分子分母同乘以一个相等的函数。</li><li>（2）到（3）利用了Jensen不等式，考虑到$$ log(x) $$是凹函数（二阶导数小于0），而且$$ \sum_{z^{(i)}} Q_i(z^{(i)})[{ p(x^{(i)}), z^{(i)}; \theta] \over Q_i(z^{(i)}) }] $$就是$$ [{ {p(x^{(i)}, z^{(i)}; \theta)} \over Q_i(z^{(i)}) }]$$的期望（回想期望公式中的Lazy Statistician规则）</li></ul><p>设Y是随机变量X的函数$$Y=g(X) $$（g是连续函数），那么</p><ul><li>（1） X是离散型随机变量，它的分布律为$$ P(X=x_k)=p_k, k=1,2,.. $$。若$$ \sum_{k=1}^{\infty}g(x_k)p_k $$绝对收敛，则有<br>$$ E(Y) = E[g(X)] = \sum_{k=1}^{\infty}g(x_k)p_k $$</li><li>（2） X是连续型随机变量，它的概率密度为$$ f(x) $$，若$${\int}<em>{-\infty}^{\infty}g(x)f(x)dx $$绝对收敛，则有<br>$$ E(Y)=E[g(X)]={\int}</em>{-\infty}^{\infty}g(x)f(x)d(x) $$</li></ul><p>对应于上述问题，Y是$$ [{ p(x^{(i)}, z^{(i)}; \theta) \over Q_i(z^{(i)}) }] $$，X是$$ z^{(i)} $$，$$ Q_i(z^{(i)}) $$是$$ p_k $$，$$ g $$是$$ z^{(i)} $$到$$ [ { { p(x^{(i)}, z^{(i)}; \theta) } \over Q_i(z^{(i)}) }] $$的映射。这样解释了式子（2）中的期望，再根据凹函数时的Jensen不等式：<br>$$ f(E_{z^{(i)}{\sim}Q_i}[{ {p(x^{(i)}, z^{(i)}; \theta)} \over Q_i(z^{(i)}) }]) \ge E_{z^{(i)}{\sim}Q_i}[{ f({ p(x^{(i)},z^{(i)};\theta) } \over Q_i(z^{(i)})) }] $$</p><p>可以得到（3）。</p><p>这个过程可以看作是对 $${\ell} $$求了下界。对于$$ Q_i $$的选择，有多种可能，那种更好的？假设$$ \theta $$已经给定，那么$$ {\ell}(\theta) $$的值就决定于$$ Q_i(z^{(i)}) $$和$$ p(x^{(i)},z^{(i)}) $$了。我们可以通过调整这两个概率使下界不断上升，以逼近$$ {\ell} $$的真实值，那么什么时候算是调整好了呢？当不等式变成等式时，说明我们调整后的概率能够等价于$$ {\ell} $$了。按照这个思路，我们要找到等式成立的条件。</p><p>根据Jensen不等式，要想让等式成立，需要让随机变量变成常数值，这里得到：<br>$$ { p(x^{(i)},z^{(i)}; \theta) \over Q_i(z^{(i)})} =c $$</p><p>c为常数，不依赖于$$ z^{(i)} $$。对此式子做进一步推导，我们知道$$ \sum_z Q(z^{(i)})=q $$，那么也就有$$ \sum_z p(x^{(i)},z^{(i)};\theta) =c $$，（多个等式分子分母相加不变，这个认为每个样例的两个概率比值都是c），那么有下式：</p><p>$$<br>\begin{equation}\begin{split}<br>Q_i(Z^{(i)}) &amp;= {p(x^{(i)},z^{(i)};\theta) \over \sum_z p(x^{(i)},z;\theta)} \<br>&amp;= {p(x^{(i)},z^{(i)};\theta) \over p(x^{(i)};\theta) }\<br>&amp;= p(z^{(i)}|x^{(i)};\theta)<br>\end{split}\end{equation}<br>$$</p><p>至此，我们推出了在固定其他参数$$ \theta $$后，$$ Q_i(z^{(i)}) $$的计算公式就是后验概率，解决$$Q_i(z^{(i)}) $$如何选择的问题。这一步就是E步，建立$$ {\ell}(\theta) $$的下界。接下来的M步，就是在给定i$$ Q_i(z^{(i)}) $$后，调整$$ \theta $$，去极大化$$ {\ell}(\theta) $$的下界（在固定$$ Q_i(z^{(i)}) $$后，下界还可以调整的更大）。</p><h3 id="EM算法步骤"><a href="#EM算法步骤" class="headerlink" title="EM算法步骤"></a>EM算法步骤</h3><p><strong>一般的EM算法的步骤如下：</strong></p><p>循环重复直到收敛</p><ol><li><p>（E步）对于每一个i，计算：<br>$$ Q_i(z^{(i)}) := p(z^{(i)}|x^{(i)};\theta) $$</p></li><li><p>（M步）计算：<br>$$ \theta := arg max_\theta \sum_i \sum_{z^{(i)}} Q_i(z^{(i)})log{p(z^{(i)},z^{(i)};\theta) \over Q_i(z^{(i)}) } $$</p></li></ol><h3 id="EM算法收敛"><a href="#EM算法收敛" class="headerlink" title="EM算法收敛"></a>EM算法收敛</h3><p>那么究竟怎么确保EM收敛？</p><ul><li>假定$$ \theta^{(t)} 和 \theta^{(t+1)} $$是EM第t次和t+1次迭代后的结果。</li><li>如果我们证明了$$ {\ell}(\theta^{(t)}) \le {\ell}(\theta^{(t+1)}) $$，也就是说极大似然估计单调增加，那么最终我们会到达最大似然估计的最大值。</li></ul><p>下面来证明，选定$$ \theta^{(t)} $$后，我们得到E步<br>$$ Q_i^{(t)} := p(z^{(i)} | x^{(i)} ; \theta^{(t)} ) $$</p><p>这一步保证了在给定$$ \theta^{(t)} $$时，Jensen不等式中的等式成立，也就是<br>$$ {\ell}(\theta^{(t)}) = \sum_i \sum_{z^{(i)}} Q_i^{(t)}(z^{(i)}) log{ p(x^{(i)},z^{(i)};\theta^{(t)}) \over Q_i^{(i)}(z^{(i)})} $$</p><p>然后进行M步，固定$$ Q_i^{(t)} $$，并将$$ \theta^{(t)} $$视作变量，对上面的$$ {\ell}(\theta^{(t)}) $$求导后，得到$$ \theta^{(t+1)} $$，这样经过一些推导会有以下式子成立：<br>$$<br>\begin{equation}\begin{split}<br>{\ell}(\theta^{(t+1)}) &amp;\ge \sum_i \sum_{z^{(i)}} Q_i^{(t)}(z^{(i)})log{ p(x^{(i)},z^{(i)});\theta^{(t+1)} \over Q_i^{(t)}(z^{(i)})} \<br>&amp;\ge \sum_i \sum_{z^{(i)}} Q_i^{(i)}(z^{(i)})log{ p(x^{(i)},z^{(i)};\theta^{(t)}) \over Q_i^{(t)(z^{(i)})}} \<br>&amp;= {\ell}(\theta^{(t)})<br>\end{split}\end{equation}<br>$$</p><p>解释第（4）步，得到$$ \theta^{(t+1)} $$，只是最大化$$ {\ell}(\theta^{(t)}) $$，也就是$$ {\ell}(\theta^{(t+1)}) $$的下界，而没有使等式成立，等式成立只有是在固定$$ \theta $$，并按E步得到$$ Q_i $$时才能成立。</p><p>况且根据我们前面得到的下式，对于所有的$$ Q_i 和 \theta $$都成立<br>$$ {\ell} \ge \sum_i \sum_{z^{(i)}} Q_i(z^{(i)})log{ p(x^{(i)},z^{(i)};\theta) \over Q_i(z^{(i)})} $$</p><p>第（5）步利用了M步的定义，M步就是将$$ \theta^{(t)} $$调整到$$ |the^{(t+1)} $$，使得下界最大化。因此（5）成立，（6）是之前的等式结果。</p><p>这样就证明了$$ {\ell}(\theta) $$会单调增加。一种收敛方法是$$ {\ell}(\theta) $$不再变化，还有一种就是变化幅度很小。</p><p>再次解释一下（4）、（5）、（6）。首先（4）对所有的参数都满足，而其等式成立条件只是在固定$$ \theta $$，并调整好Q时成立，而第（4）步只是固定Q，调整$$ \theta $$，不能保证等式一定成立。（4）到（5）就是M步的定义，（5）到（6）是前面E步所保证等式成立条件。也就是说E步会将下界拉到与$$ {\ell}(\theta) $$一个特定值（这里$$ \theta^{(t)} $$）一样的高度，而此时发现下界仍然可以上升，因此经过M步后，下界又被拉升，但达不到与$$ {\ell}(\theta) $$另外一个特定值一样的高度，之后E步又将下界拉到与这个特定值一样的高度，重复下去，直到最大值。</p><p>如果我们定义:</p><p>$$ J(Q,\theta) = \sum_i \sum_{z^{(i)}} Q_i(z^{(i)})log{ p(x^{(i)},z^{(i)};\theta) \over Q_i(z^{(i)})} $$</p><p>从前面的推导中我们知道$$ {\ell}(\theta) \ge J(Q,\theta) $$，EM可以看作是J的坐标上升法，E步固定$$ \theta $$，优化$$ Q $$，M步固定$$ Q $$优化$$ \theta $$。</p><h2 id="高斯混合模型"><a href="#高斯混合模型" class="headerlink" title="高斯混合模型"></a>高斯混合模型</h2><p>我们已经知道了EM的精髓和推导过程，再次审视一下混合高斯模型。之前提到的混合高斯模型的参数$$ \phi , \mu 和 \sum $$计算公式都是根据很多假定得出的，有些没有说明来由。为了简单，这里在M步只给出$$ \phi 和 \mu $$的推导方法。</p><h3 id="E步"><a href="#E步" class="headerlink" title="E步"></a>E步</h3><p>E步很简单，按照一般EM公式得到：</p><p>$$ \omega_j^{(i)} = Q_i(z^{(i)}=j) = P(z^{(i)}=j|x^{(i)}; \phi,\mu,\sum) $$</p><p>简单解释就是每个样例i的隐含类别$$ z^{(i)} $$为j的概率可以通过后验概率计算得到。</p><h3 id="M步"><a href="#M步" class="headerlink" title="M步"></a>M步</h3><p>在M步中，我们需要在固定$$ Q_i(z^{(i)}) $$后最大化最大似然估计，也就是</p><p>$$<br>\begin{equation}\begin{split}<br>\sum_{i=1}^m \sum_{z^{(i)}} &amp; Q_i(z^{(i)})log{ p(x^{(i)},z^{(i)};\phi, \mu, \sum) \over Q_i(z^{(i)})} \<br>&amp;= \sum_{i=1}^m \sum_{j=1}^k Q_i(z^{(i)}=j)log{ p(x^{(i)}| z^{(i)}=j;\mu,\sum)p(z^{(i)}=j;\phi) \over Q_i(z^{(i)}=j)} \<br>&amp;= \sum_{i=1}^m \sum_{j=1}^k \omega_j^{(i)} log { {1 \over (2\pi)^{n/2}|\sum_j|^{1/2} } exp(-{1 \over 2}(x^{(i)}-\mu_j)^T \sum_j^{-1}(x^{(i)}-\mu_j)) \cdot \phi_j \over \omega_j^{(i)} }<br>\end{split}\end{equation}<br>$$</p><p>这是将$$ z^{(i)} $$的k种情况展开后的样子，未知参数$$ \phi_j , \mu_j 和 \sum_j$$。</p><p>固定$$ \phi_j和\sum_j $$对$$ \mu_j $$求导得</p><center></center><p>等于0时，得到<br>$$ \mu_l := {\sum_{i=1}^m \omega_l^{(i)}x^{(i)} \over \sum_{i=1}^m \omega_l^{(i)}} $$</p><p>这就是我们之前模型中的$$ \mu $$的更新公式。</p><p>然后推导$$ \phi_j $$的更新公式。看之前得到的</p><p>$$ \sum_{i=1}^m \sum_{j=1}^k \omega_j^{(i)} log { {1 \over (2\pi)^{n/2}|\sum_j|^{1/2}} exp(-{1 \over 2}(x^{(i)}-\mu_j)^T \sum_j^{-1}(x^{(i)}-\mu_j)) \cdot \phi_j \over \omega_j^{(i)}} $$</p><p>在$$ \phi和\mu $$确定后，分子上面的一串都是常数了，实际上需要优化的公式是：</p><p>$$ \sum_{i=1}^m \sum_{j=1}^k \omega_j^{(i)} log \phi_j $$</p><p>需要知道的是，$$ \phi_j $$还需要满足一定的约束条件就是$$ \sum_{j=1}^k \phi_j =1 $$。</p><h3 id="构造拉格郎日乘子优化"><a href="#构造拉格郎日乘子优化" class="headerlink" title="构造拉格郎日乘子优化"></a>构造拉格郎日乘子优化</h3><p>这个优化问题我们很熟悉了，直接构造拉格朗日乘子。<br>$$ L(\phi) = \sum_{i=1}^m \sum_{j=1}^k \omega_j^{(i)} log \phi_j + \beta(\sum_{j=1}^k \phi_j-1)$$</p><p>还有一点就是$$ \phi_j \ge 0 $$，但这一点会在得到的公式里自动满足。</p><p>求导得：<br>$$ {\partial \over \partial \phi_j} L( \phi ) = \sum_{i=1}^m {\omega_j^{(i)} \over \phi_j}+\beta $$</p><p>等于0时，得到:</p><p>$$ \phi_j = {\sum_{i=1}^m \omega_j^{(i)} \over -\beta} $$</p><p>也就是说$$ \phi_j \propto \sum_{i=1}^m \omega_j^{(i)} $$。再次使用$$ \sum_{j=1}^k \phi_j = 1 $$，得到</p><p>$$ -\beta = \sum_{i=1}^m \sum_{j=1}^k \omega_j^{(i)} = \sum_{i=1}^m 1 = m $$</p><p>这样就神奇地得到了$$ \beta $$。</p><p>那么就顺势得到M步中$$ \phi_j $$的更新公式：</p><p>$$ \phi_j := {1 \over m} \sum_{i=1}^m \omega_j^{(i)} $$</p><p>$$\sum$$的推导也类似，不过稍微复杂一些，毕竟是矩阵。结果在之前的混合高斯模型中已经给出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果将样本看作观察值，潜在类别看作是隐藏变量，那么聚类问题也就是参数估计问题。</p><p>只不过聚类问题中参数分为隐含类别变量和其他参数，这犹如在x-y坐标系中找一个曲线的极值，然而曲线函数不能直接求导，因此什么梯度下降方法就不适用了。<br>但固定一个变量后，另外一个可以通过求导得到，因此可以使用坐标上升法，一次固定一个变量，对另外的求极值，最后逐步逼近极值。</p><p>对应到EM上，E步估计隐含变量，M步估计其他参数，交替将极值推向最大。EM中还有&ldquo;硬&rdquo;指定和&ldquo;软&rdquo;指定的概念，&ldquo;软&rdquo;指定看似更为合理，但计算量要大，&ldquo;硬&rdquo;指定在某些场合如K-means中更为实用（要是保持一个样本点到其他所有中心的概率，就会很麻烦）。</p><p>另外，EM的收敛性证明方法确实很牛，能够利用log的凹函数性质，还能够想到利用创造下界，拉平函数下界，优化下界的方法来逐步逼近极大值。而且每一步迭代都能保证是单调的。</p><p>最重要的是证明的数学公式非常精妙，硬是分子分母都乘以z的概率变成期望来套上Jensen不等式。</p><p>有一个EM应用的例子，明白地说就是将班上学生的身高都放在一起，要求聚成两个类。<br>这些身高可以看作是男生身高的高斯分布和女生身高的高斯分布组成。因此变成了如何估计每个样例是男生还是女生，然后在确定男女生情况下，如何估计均值和方差，里面也给出了公式，有兴趣可以参考。</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;主要介绍EM的整个推导过程。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://hanielxx.com/categories/Notes/"/>
    
    
    <category term="MachineLearning" scheme="https://hanielxx.com/tags/MachineLearning/"/>
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="Notes" scheme="https://hanielxx.com/tags/Notes/"/>
    
    <category term="EM" scheme="https://hanielxx.com/tags/EM/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-031-Next Permutation</title>
    <link href="https://hanielxx.com/LeetCode/2019-11-04-LeetCode-031-Next-Permutation"/>
    <id>https://hanielxx.com/LeetCode/2019-11-04-LeetCode-031-Next-Permutation</id>
    <published>2019-11-04T01:46:18.000Z</published>
    <updated>2020-11-14T12:40:56.199Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="external nofollow noopener noreferrer">Problem</a></h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be in-place and use only constant extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ol><li>暴力方法</li></ol><ul><li>直接求出所有可能的排列，然后找下一个比当前序列更大的</li><li>很明显不太现实，因为时间复杂度$O(n!)$</li></ul><ol><li>正确姿势</li></ol><ul><li>首先了解到一个规律：如果序列递减排列，那就已经是最大的了，没有更大的</li><li>因为要找字典序更大的，所以应该尽量修改后面部分的数字</li><li>如果后面部分的数字，都是递减的，那么只能继续往前找数字</li><li>因此：从后往前找到比后一个数字小的数字i，那么就可以通过改变这个数字i，及它后面所有数字的排列找到结果</li><li>我们在后面递减的序列中找最接近数字i的数字j，交换两个数字，固定数字i，这时候i后面的数字还是全部递减的，所以，将它们逆序，得到最小的。再加上i就是字典序的下一个排列</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>这次用了英文注释，后面慢慢的都用英文写注释了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Find target i, which is smaller than i+1</span></span><br><span class="line">        <span class="keyword">int</span> target=nums.<span class="built_in">size</span>()<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(target&gt;=<span class="number">0</span> &amp;&amp; nums[target]&gt;=nums[target+<span class="number">1</span>])</span><br><span class="line">            target--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If nums is descending</span></span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span> reverse(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Find the bigger number</span></span><br><span class="line">        <span class="comment">//Pay attention to the boundary </span></span><br><span class="line">        <span class="keyword">int</span> bigger=target+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(bigger&lt;nums.<span class="built_in">size</span>() &amp;&amp; nums[bigger]&gt;nums[target])&#123; </span><br><span class="line">            bigger++;</span><br><span class="line">        &#125;</span><br><span class="line">        bigger--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//swap the bigger number and target</span></span><br><span class="line">        <span class="keyword">int</span> tmp = nums[target];</span><br><span class="line">        nums[target] = nums[bigger];</span><br><span class="line">        nums[bigger]=tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//reverse nums[target+1:N-1]</span></span><br><span class="line">        reverse(nums.<span class="built_in">begin</span>()+target+<span class="number">1</span>,nums.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        firstIndex = <span class="number">-1</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(nums, i, j)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                nums[i],nums[j] = nums[j], nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                firstIndex = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#print(firstIndex)</span></span><br><span class="line">        <span class="keyword">if</span> firstIndex == <span class="number">-1</span>:</span><br><span class="line">            reverse(nums, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        secondIndex = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, firstIndex, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[firstIndex]:</span><br><span class="line">                secondIndex = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[firstIndex],nums[secondIndex] = nums[secondIndex], nums[firstIndex]</span><br><span class="line">        reverse(nums, firstIndex+<span class="number">1</span>, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>字典序问题，不应该从前往后比较，应该从后往前，越低位的越小</li><li>通过极端情况，如从整个序列降序和升序的情况，来找思路</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.&lt;/p&gt;&lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).&lt;/p&gt;&lt;p&gt;The replacement must be in-place and use only constant extra memory.&lt;/p&gt;&lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;1,2,3 → 1,3,2&lt;br&gt;3,2,1 → 1,2,3&lt;br&gt;1,1,5 → 1,5,1&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
    <category term="List" scheme="https://hanielxx.com/tags/List/"/>
    
    <category term="Permutation" scheme="https://hanielxx.com/tags/Permutation/"/>
    
    <category term="In-Place" scheme="https://hanielxx.com/tags/In-Place/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-029-Divide Two Integers</title>
    <link href="https://hanielxx.com/LeetCode/2019-10-31-leetcode-028-divide-two-integers"/>
    <id>https://hanielxx.com/LeetCode/2019-10-31-leetcode-028-divide-two-integers</id>
    <published>2019-10-31T03:54:20.000Z</published>
    <updated>2020-11-14T12:40:56.197Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/divide-two-integers/submissions/" target="_blank" rel="external nofollow noopener noreferrer">Problem</a></h2><p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.</p><p>Return the quotient after dividing dividend by divisor.</p><p>The integer division should truncate toward zero.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>dividend = 10, divisor = 3<br>dividend = 7, divisor = -3</p></blockquote><p><strong>Output:</strong></p><blockquote><p>3<br>-2</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>刚开始就是想到用减法，把被除数和除数都变成正数，然后一个个减。这样虽然能做，但是复杂度太高，总超时</li><li>题解中都用到了左移和右移这样的方法，看了之后按照自己的理解，将除数的倍数存在向量中，一直到最接近被除数。比如被除数是23，除数是5，，那么向量中就存放<code>5&lt;&lt;0=5，5&lt;&lt;1=10，10&lt;&lt;1=20</code>。分别对应的是<code>1&lt;&lt;0=1，1&lt;&lt;1=2 和 1&lt;&lt;2=4</code>。最后的结果计算是，<code>23&gt;20，res+4，23-20=3, 3&lt;10, 3&lt;5</code>，都不加，结果就是<code>4</code></li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">0</span> || (dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>)) <span class="keyword">return</span> INT_MAX; </span><br><span class="line">        <span class="keyword">if</span>(dividend == divisor) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisor == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> symbolFlag= (dividend&lt;<span class="number">0</span>)==(divisor&lt;<span class="number">0</span>);    <span class="comment">//符号，同号为1</span></span><br><span class="line">        <span class="keyword">int</span> minFlag = dividend==INT_MIN;    <span class="comment">//被除数为INT_MIN标识</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果负数为2147483648，就先加上一个除数绝对值</span></span><br><span class="line">        <span class="keyword">if</span>(dividend==INT_MIN) dividend+=<span class="built_in">abs</span>(divisor); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//全部变成正数</span></span><br><span class="line">        divisor=<span class="built_in">abs</span>(divisor);</span><br><span class="line">        dividend=<span class="built_in">abs</span>(dividend);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>, tmp=divisor;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//直到divisor大于dividend</span></span><br><span class="line">        <span class="keyword">while</span>(tmp&lt;=dividend)&#123;</span><br><span class="line">            nums.push_back(tmp);</span><br><span class="line">            <span class="keyword">if</span>(INT_MAX-tmp&lt;tmp) <span class="keyword">break</span>;  <span class="comment">//如果右移溢出，那肯定也大于divideng</span></span><br><span class="line">            tmp&lt;&lt;=<span class="number">1</span>;    <span class="comment">//除数乘以2</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从后往前减</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dividend&gt;=nums[i])&#123;</span><br><span class="line">                result += <span class="number">1</span>&lt;&lt;i;     <span class="comment">//result加上对应的数量</span></span><br><span class="line">                dividend -= nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理结果</span></span><br><span class="line">        <span class="keyword">if</span>(minFlag)&#123;    <span class="comment">//绝对值需加上1</span></span><br><span class="line">            <span class="keyword">if</span>(symbolFlag)&#123; <span class="comment">//同号</span></span><br><span class="line">                result = result==INT_MAX? result : result+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123; <span class="comment">//异号</span></span><br><span class="line">                result = -result<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            result = symbolFlag?result:-result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>题解：<a href="https://leetcode-cn.com/problems/divide-two-integers/solution/xiao-xue-sheng-du-hui-de-lie-shu-shi-suan-chu-fa-b/" target="_blank" rel="external nofollow noopener noreferrer">小学生都会的列竖式算除法</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line">    sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)</span><br><span class="line">    dividend = abs(dividend)</span><br><span class="line">    divisor = abs(divisor)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="comment">#把除数不断左移，直到它大于被除数</span></span><br><span class="line">    <span class="keyword">while</span> dividend &gt;= divisor:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        divisor &lt;&lt;= <span class="number">1</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        divisor &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> divisor &lt;= dividend:</span><br><span class="line">            result += <span class="number">1</span> &lt;&lt; count <span class="comment">#这里的移位运算是把二进制（第count+1位上的1）转换为十进制</span></span><br><span class="line">            dividend -= divisor</span><br><span class="line">    <span class="keyword">if</span> sign: result = -result</span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">if</span> -(<span class="number">1</span>&lt;&lt;<span class="number">31</span>) &lt;= result &lt;= (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span> <span class="keyword">else</span> (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="大整数进制转换"><a href="#大整数进制转换" class="headerlink" title="大整数进制转换"></a>大整数进制转换</h2><p>附上自己做的思维导图截图</p><h2 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h2><p>附上自己做的思维导图截图</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>大整数运算，时间复杂度太高的，可以想想移位运算和二进制模拟。甚至是字符串。</li><li>联想到大整数乘除法。</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/divide-two-integers/submissions/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.&lt;/p&gt;&lt;p&gt;Return the quotient after dividing dividend by divisor.&lt;/p&gt;&lt;p&gt;The integer division should truncate toward zero.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;dividend = 10, divisor = 3&lt;br&gt;dividend = 7, divisor = -3&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;3&lt;br&gt;-2&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
    <category term="Math" scheme="https://hanielxx.com/tags/Math/"/>
    
    <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
    <category term="BigNumber" scheme="https://hanielxx.com/tags/BigNumber/"/>
    
    <category term="ShiftOperation" scheme="https://hanielxx.com/tags/ShiftOperation/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="https://hanielxx.com/Notes/2019-10-30-kmp-algorithm"/>
    <id>https://hanielxx.com/Notes/2019-10-30-kmp-algorithm</id>
    <published>2019-10-30T04:35:59.000Z</published>
    <updated>2020-11-14T12:40:56.215Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>KMP算法又复习了一遍，写个总结，贴下自己的代码。</p></div><a id="more"></a><h2 id="KMP算法介绍和原理"><a href="#KMP算法介绍和原理" class="headerlink" title="KMP算法介绍和原理"></a>KMP算法介绍和原理</h2><p>简单说就是字符串匹配，在主串中匹配模式串，返回匹配到的下标。</p><p>具体的可以看<a href="https://www.cnblogs.com/yjiyjige/p/3263858.html" target="_blank" rel="external nofollow noopener noreferrer">详解KMP算法</a>这篇博客，讲的挺好的，也有图解。<br>这里只放几张截图，不做详细介绍了。</p><h2 id="KMP算法实现"><a href="#KMP算法实现" class="headerlink" title="KMP算法实现"></a>KMP算法实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">i<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用next作为变量名会报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> SIZE = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> myNext[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// myNext[j] = k，表示当T[i] !=</span></span><br><span class="line">  <span class="comment">// P[j]时，j指针的下一个位置，myNext[0]=-1表示主串后移 </span></span><br><span class="line">  <span class="built_in">memset</span>(myNext, <span class="number">-1</span>, <span class="keyword">sizeof</span>(myNext));</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (j &lt; p.length() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//如果两个字符相等或者k==-1</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) &#123;</span><br><span class="line">      <span class="comment">//当后两个字符相等时，跳转到k就没必要了，因为p[j]==p[k]，所以应该跳转到myNext[k]</span></span><br><span class="line">      <span class="comment">//因此要设置为myNext[k]</span></span><br><span class="line">      <span class="keyword">if</span> (p[++j] == p[++k]) &#123;</span><br><span class="line">        myNext[j] = myNext[k];</span><br><span class="line">        <span class="comment">//不等就正常跳转</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        myNext[j] = k;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//不等就k=myNext[k]，往前找匹配的</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      k = myNext[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts主串，ps模式串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> ts, <span class="built_in">string</span> ps)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//主串位置</span></span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">//模式串位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> tsLen = ts.length(), psLen = ps.length();</span><br><span class="line">  <span class="keyword">if</span> (tsLen == <span class="number">0</span> &amp;&amp; psLen == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (tsLen == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (psLen == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  getNext(ps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里如果直接写 i&lt;ts.length() &amp;&amp;</span></span><br><span class="line">  <span class="comment">// j&lt;ps.length()会出错，只进行一次循环就跳出了，很奇怪</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; tsLen &amp;&amp; j &lt; psLen) &#123;</span><br><span class="line">    <span class="comment">//当j为-1时，要移动的是i，当然j也要自增归0</span></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">-1</span> || ts[i] == ps[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// i不需要回溯了，i=i-j+1，j回到指定位置</span></span><br><span class="line">      j = myNext[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//全部匹配，返回主串匹配的下标，否则返回-1</span></span><br><span class="line">  <span class="keyword">if</span> (j == ps.length()) &#123;</span><br><span class="line">    <span class="keyword">return</span> i - j;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> t = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="built_in">string</span> p = <span class="string">"ll"</span>;</span><br><span class="line">  <span class="comment">// 输出2</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; KMP(t, p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;KMP算法又复习了一遍，写个总结，贴下自己的代码。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://hanielxx.com/categories/Notes/"/>
    
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="String" scheme="https://hanielxx.com/tags/String/"/>
    
    <category term="Match" scheme="https://hanielxx.com/tags/Match/"/>
    
    <category term="KMP" scheme="https://hanielxx.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-028-Implement strStr()</title>
    <link href="https://hanielxx.com/LeetCode/2019-10-30-LeetCode-028-Implement-strStr"/>
    <id>https://hanielxx.com/LeetCode/2019-10-30-LeetCode-028-Implement-strStr</id>
    <published>2019-10-30T04:30:27.000Z</published>
    <updated>2020-11-14T12:40:56.198Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="external nofollow noopener noreferrer">Problem</a></h2><p>Implement strStr().</p><p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>haystack = “hello”, needle = “ll”</p></blockquote><p><strong>Output:</strong></p><blockquote><p>2</p></blockquote><p><strong>Input:</strong></p><blockquote><p>haystack = “aaaaa”, needle = “bba”</p></blockquote><p><strong>Output:</strong></p><blockquote><p>-1</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>很明显是一个字符串匹配的问题，自然想到用KMP算法</li><li>难的是会不会KMP…</li><li>KMP本身难点在getNext()函数，具体见代码和注释</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//如果使用next作为变量名会报错</span></span><br><span class="line">    <span class="keyword">int</span> myNext[<span class="number">1000000</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = KMP(haystack,needle);</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">      <span class="comment">// myNext[j] = k，表示当T[i] != P[j]时，j指针的下一个位置，myNext[0]=-1表示主串后移</span></span><br><span class="line">      <span class="built_in">memset</span>(myNext,<span class="number">-1</span>,<span class="keyword">sizeof</span>(myNext));</span><br><span class="line">      <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> k=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(j&lt;p.length()<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//如果两个字符相等或者k==-1</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">-1</span> || p[j]==p[k])&#123;</span><br><span class="line">          <span class="comment">//当后两个字符相等时，跳转到k就没必要了，因为p[j]==p[k]，所以应该跳转到myNext[k]</span></span><br><span class="line">          <span class="comment">//因此要设置为myNext[k]</span></span><br><span class="line">          <span class="keyword">if</span>(p[++j] == p[++k])&#123;</span><br><span class="line">            myNext[j]=myNext[k];</span><br><span class="line">          <span class="comment">//不等就正常跳转</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            myNext[j]=k;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//不等就k=myNext[k]，往前找匹配的</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          k=myNext[k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ts主串，ps模式串</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> ts, <span class="built_in">string</span> ps)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;  <span class="comment">//主串位置</span></span><br><span class="line">      <span class="keyword">int</span> j=<span class="number">0</span>;  <span class="comment">//模式串位置</span></span><br><span class="line">        </span><br><span class="line">      <span class="keyword">int</span> tsLen = ts.length(), psLen = ps.length();</span><br><span class="line">      <span class="keyword">if</span>(tsLen==<span class="number">0</span> &amp;&amp; psLen==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(tsLen==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span>(psLen==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">      getNext(ps);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 这里如果直接写 i&lt;ts.length() &amp;&amp; j&lt;ps.length()会出错，只进行一次循环就跳出了，很奇怪</span></span><br><span class="line">      <span class="keyword">while</span>(i&lt;tsLen &amp;&amp; j&lt;psLen)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"Before: i: "&lt;&lt;i&lt;&lt;" j: "&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//当j为-1时，要移动的是i，当然j也要自增归0</span></span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span> || ts[i]==ps[j])&#123;</span><br><span class="line">          i++;</span><br><span class="line">          j++;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">// i不需要回溯了，i=i-j+1，j回到指定位置</span></span><br><span class="line">          j=myNext[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"Before: i: "&lt;&lt;i&lt;&lt;" j: "&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//全部匹配，返回主串匹配的下标，否则返回-1</span></span><br><span class="line">      <span class="keyword">if</span>(j==ps.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>理解KMP很重要，每一步要理解为什么</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-strstr/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Implement strStr().&lt;/p&gt;&lt;p&gt;Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;haystack = “hello”, needle = “ll”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;2&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;haystack = “aaaaa”, needle = “bba”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;-1&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
    <category term="KMP" scheme="https://hanielxx.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-027-Remove-Element</title>
    <link href="https://hanielxx.com/LeetCode/2019-10-24-LeetCode-027-Remove-Element"/>
    <id>https://hanielxx.com/LeetCode/2019-10-24-LeetCode-027-Remove-Element</id>
    <published>2019-10-24T01:27:06.000Z</published>
    <updated>2020-11-14T12:40:56.192Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="external nofollow noopener noreferrer">Problem</a></h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>Given nums = [3,2,2,3], val = 3,</p></blockquote><p><strong>Output:</strong></p><blockquote><p>Your function should return length = 2, with the first two elements of nums being 2.</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>题目要求就地，不使用额外空间，所以只能在原数组修改</li><li>双指针，以前的题目中用了很多。如果后一个指针内容和前一个不相等，就赋值，然后全部自增。否则就只有后指针自增。</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val) nums[pos++]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-element/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given an array nums and a value val, remove all instances of that value in-place and return the new length.&lt;/p&gt;&lt;p&gt;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&lt;/p&gt;&lt;p&gt;The order of elements can be changed. It doesn’t matter what you leave beyond the new length.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Given nums = [3,2,2,3], val = 3,&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 2.&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
    <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
    <category term="Vector" scheme="https://hanielxx.com/tags/Vector/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-026-Remove Duplicates from Sorted Array</title>
    <link href="https://hanielxx.com/LeetCode/2019-10-24-Remove-Duplicates-from-Sorted-Array"/>
    <id>https://hanielxx.com/LeetCode/2019-10-24-Remove-Duplicates-from-Sorted-Array</id>
    <published>2019-10-24T01:19:10.000Z</published>
    <updated>2020-11-14T12:40:56.199Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/" target="_blank" rel="external nofollow noopener noreferrer">Problem</a></h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>Given nums = [1,1,2]</p></blockquote><p><strong>Output:</strong></p><blockquote><p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>和前一个元素比较，直接对vector进行元素删除</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                nums.erase(nums.<span class="built_in">begin</span>()+i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.&lt;/p&gt;&lt;p&gt;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Given nums = [1,1,2]&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
    <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
    <category term="Vector" scheme="https://hanielxx.com/tags/Vector/"/>
    
  </entry>
  
  <entry>
    <title>凸函数、Jensen不等式、凸集和凸优化</title>
    <link href="https://hanielxx.com/MachineLearning/2019-10-20-convex-function-set-optimization"/>
    <id>https://hanielxx.com/MachineLearning/2019-10-20-convex-function-set-optimization</id>
    <published>2019-10-20T13:38:40.000Z</published>
    <updated>2020-11-14T12:40:56.202Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>记录凸函数、凸集和凸优化的一些问题。<br>在一些算法优化中要用到。</p></div><a id="more"></a><h2 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>用简单的一元函数$$ f(x) $$来说，如果对于任意$$ t \in [0,1] $$均满足：$$ f(tx_1+(1−t)x_2) \le tf(x_1)+(1−t)f(x_2)$$ ，则称f(x)为凸函数(convex function)</p><p>如果对于任意tϵ(0,1)均满足：$$ f(tx_1+(1−t)x_2) \lt tf(x_1)+(1−t)f(x_2)，则称f(x)为严格凸函数(convex function) $$</p><p>直观上理解，凸函数的隔线在曲线下方。</p><p>上述可以推广到多元函数。</p><p>如果优化函数是凸函数，那么，局部最小就是全局最小，不会陷入局部最优里。<br>SVM的目标函数$$ ||\omega||^2 $$就是一个凸函数</p><h3 id="判断凸函数"><a href="#判断凸函数" class="headerlink" title="判断凸函数"></a>判断凸函数</h3><ul><li>一元函数：求二阶导数的符号来判断，如果非负，就是凸函数</li><li>多元函数：通过Hessian矩阵的正定性判断，如果Hessian矩阵是半正定矩阵，那就是凸函数</li></ul><h3 id="性质：Jensen不等式"><a href="#性质：Jensen不等式" class="headerlink" title="性质：Jensen不等式"></a>性质：Jensen不等式</h3><p>凸函数满足Jensen不等式：</p><p>一元情况：对于任意$$ t \in [0,1] $$均满足：$$ f(tx_1+(1−t)x_2) \le tf(x_1)+(1−t)f(x_2)$$</p><p>推广：</p><p>如果 f 是凸函数，X是随机变量，那么$$ \theta_1,…,\theta_k \ge 0，\theta_1 + … + \theta_k = 1$$,$$ f(\theta_1x_1+ … + \theta_kx_k) \le \theta_1f(x_1)+ … + \theta_kf(x_k)$$</p><p>如果把$$ \theta $$看成是$$ x_k $$的概率，那么就可以理解成下面的一般式子：<br>$$f(E(X)) \le E(f(X))$$</p><p>如果是凹函数，那么很容易想到，应该把不等号反过来，原理相同。</p><p>在EM算法中，收敛性证明部分就是用到的凹函数Jensen不等式，而不是凸函数。</p><div class="note info"><p>简言之：</p><ul><li><strong>凸函数：函数的期望，大于等于，期望的函数</strong></li><li><strong>凹函数：函数的期望，小于等于，期望的函数</strong></li></ul></div><h2 id="凸集"><a href="#凸集" class="headerlink" title="凸集"></a>凸集</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>如果集合 C 为凸集，那么对于任意的 $$ x1,x2 in C 与0 \le \theta \le 1都有 \theta x_1+(1−\theta)x_2 in C $$，与仿射集的区别在于仿射集并没有$$ \theta \ge 0 $$的要求，例如一条线段是凸集，而一条直线是仿射集。</p><p>扩展到多维的情况，如果有 $$ \theta_1 + \theta_2 +…+ \theta_k = 1, \theta_i \gt 0 $$，则称具有$$ \theta_1x_1 + \theta_2x_2 +…+ \theta_kx_k $$形式的点为 $$ x_1,x_2….x_k $$的凸组合。</p><p>称由集合$$ C \subset R^n $$中点的所有凸组合所组成的集合为C的凸包：<br>$$ conv C = { \theta_1x_1 +…+ \theta_kx_k | x_1,..,x_k in C, \theta_1+\theta_2+…+\theta_k=1, \theta_i \ge 0}$$</p><p>与仿射包同样，凸包也是包含 C 的最小的凸集，在一般情况下，设$$ C \subset R^n $$ 是凸集，x 是随机变量，并且$$ x in C $$的概率为1，那么 $$ E x \in C $$</p><h3 id="重要的凸集"><a href="#重要的凸集" class="headerlink" title="重要的凸集"></a>重要的凸集</h3><p>任意的仿射集和子空间都是凸集，一些比较简单的例如空集 $$ \emptyset $$ ，单点集{x0}，全空间$$ R^n $$ ，直线/射线/线段都是凸的。</p><p>还有一些比较重要的凸集如下：</p><ol><li>超平面$$ {x|a^Tx = b} $$和半空间$$ {x|a^Tx \le b}$$</li><li>Euclid球 $$B(x_c,r)={x| ||x−x_c||_2 \le r}$$</li><li>椭球$$ \xi ={x|(x−x_c)^T P^(−1) (x−x_c) \le 1}</li><li>范数球 $${x| ||x−x_c|| \le r}，其中 ||⋅|| 是$$ R^n $$中的范数</li><li>范数锥 $$C={(x,t)| ||x|| \le t} \subset R^(n+1)$$</li><li>多面体 $$P={x|a^T_j \le b_j, j=1,…,m, c^T_j x = d_j,j=1,…,p}$$，即为有限个半空间和超平面的交集，单纯形也为凸集，是一种特殊的多面体半正定锥 $$S^n_+={X \subset R^{n∗n}|X=X^T,X \ge 0}$$，即为半正定对称矩阵的集合_</li></ol><h2 id="凸优化问题"><a href="#凸优化问题" class="headerlink" title="凸优化问题"></a>凸优化问题</h2><p>在优化问题中，凸优化问题由于具有优良的性质（局部最优解即是全局最优解），受到广泛研究。<br>主要作用是，将有约束条件的转换成无约束条件的。</p><p>对于一个含约束的优化问题：<br>$$<br>\left{<br>\begin{array}{c}<br>min_x f(x) \<br>s.t. x in C<br>\end{array}<br>\right.<br>$$<br>其中，f(x) 为一个凸函数，变量x 的可行域C 是一个凸集，那么这个优化问题称为一个凸优化问题。<br>将上面的约束条件的形式更加明确一点，一个凸优化问题可以写成：</p><p>$$<br>\left{<br>\begin{array}{c}<br>min_x f(x) \<br>s.t. &amp; g_i(x) \le 0 \<br>&amp; h_i(x) = 0<br>\end{array}<br>\right.<br>$$</p><p>其中，f(x) 当然仍然为一个凸函数，但对约束条件有一定要求：$$ g_i(x) $$ 是凸函数；$$ h_i(x) $$为仿射函数。这样的要求当然是为了保证可行域是一个凸集。</p><p>不等式约束中$$ g_i(x) $$为凸函数，而凸函数的水平截集$${x|g_i(x) \le \alpha}是一个凸集(凸函数的性质)，这就使得不等式约束保证了可行域为凸集；<br>对于等式约束$$ h_i(x)=0 $$可以写成：<br>$$<br>\left{<br>\begin{array}{c}<br>h_i(x) \le 0 \<br>h_i(x) \ge 0<br>\end{array}<br>\right.<br>$$</p><p>要使得满足条件的x 组成的集合为凸集，就要求$$ h_i(x) $$ 既是一个凸函数，又是一个凹函数，这样hi(x)便只能是仿射函数了。</p><p>以上便是凸优化问题的一般形式。常见的线性规划、二次规划、二次约束二次规划等优化问题都是凸优化问题。</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;记录凸函数、凸集和凸优化的一些问题。&lt;br&gt;在一些算法优化中要用到。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="MachineLearning" scheme="https://hanielxx.com/categories/MachineLearning/"/>
    
    
    <category term="凸函数" scheme="https://hanielxx.com/tags/%E5%87%B8%E5%87%BD%E6%95%B0/"/>
    
    <category term="凸集" scheme="https://hanielxx.com/tags/%E5%87%B8%E9%9B%86/"/>
    
    <category term="凸优化" scheme="https://hanielxx.com/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"/>
    
    <category term="SVM" scheme="https://hanielxx.com/tags/SVM/"/>
    
  </entry>
  
  <entry>
    <title>超平面、函数间隔和几何间隔</title>
    <link href="https://hanielxx.com/MachineLearning/2019-10-20-hyperplane-functionalmargin-geometricmargin"/>
    <id>https://hanielxx.com/MachineLearning/2019-10-20-hyperplane-functionalmargin-geometricmargin</id>
    <published>2019-10-20T12:24:35.000Z</published>
    <updated>2020-11-14T12:40:56.211Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>关于超平面、函数间隔以及几何间隔的理解。<br>这些在SVM中要用到。</p></div><a id="more"></a><h2 id="超平面"><a href="#超平面" class="headerlink" title="超平面"></a>超平面</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>超平面是指n维线性空间中维度为n-1的子空间。它可以把线性空间分割成不相交的两部分。比如二维空间中，一条直线是一维的，它把平面分成了两块；三维空间中，一个平面是二维的，它把空间分成了两块。</li><li>法向量是指垂直于超平面的向量</li></ol><h3 id="法向量和超平面公式"><a href="#法向量和超平面公式" class="headerlink" title="法向量和超平面公式"></a>法向量和超平面公式</h3><p>假设在$$R^3$$空间内，那么法向量和平面总是垂直的。如下图：</p><p>$$ x(x_1’, x_2, x_3) $$<br>$$ x(x_1, x_2, x_3)，x’(x_1’, x_2’, x_3’)，w(w_1, w_2, w_3) $$</p><p>不难看出，$$x - x’$$和法向量垂直，于是：<br>$$(x-x’)w = 0$$<br>$$(x_1-x_1’, x_2-x_2’, x_3-x_3’) · (w_1, w_2, w_3) = 0$$<br>化简后得：<br>$$x_1w_1 + x_2w_2 + x_3w_3 = w_1x_1’ + w_2x_2’ + w_3x_3’$$<br>由于其为常数项，所以令：<br>$$b = -w^Tx’$$<br>于是超平面公式可以写成:<br>$$w^Tx+b = 0$$<br>同样可以推导到$$R^n$$空间</p><h3 id="点到超平面距离"><a href="#点到超平面距离" class="headerlink" title="点到超平面距离"></a>点到超平面距离</h3><p>x是平面外一点，距离平面是d，即红色线。<br>通过三角函数得到：<br>$$ cos{\theta}=\dfrac{d}{||x-x’||} $$<br>又因为d和法向量平行，所以可以通过向量相乘等于模乘模乘cos得到：<br>$$ |(x-x’)\omega|=||x-x’||\cdot||\omega||\cdot\cos{\theta} $$<br>联立得到：<br>$$ d = \dfrac{|(x-x’)\omega|}{||\omega||}=\dfrac{|\omega x-\omega x’|}{||\omega||} $$<br>因为$$ x’ $$在超平面内，$$ \omega x’=-b $$，于是最后得到的任意点到超平面的距离公式：<br>$$ d=\dfrac{|\omega x+b|}{||\omega||} $$</p><p>其实高中学过一点$$ x_i, y_i $$到直线$$ ax+by+c=0 $$的距离公式：<br>$$ d(x_i, y_i) = {|ax_i+by_i+c| \over \sqrt{a^2+b^2}}$$<br>这个和上面通用的公式可以对应</p><h2 id="函数间隔"><a href="#函数间隔" class="headerlink" title="函数间隔"></a>函数间隔</h2><p>在超平面确定的情况下，点到平面距离公式中，分母不变，所以分子$$|\omega·x + b|$$可以近似表示点到超平面的距离。</p><p>如果$$ \omega · x + b &gt; 0 $$，则被认为是正类，否则为负类<br>如果都正确分类，那么$$ y(\omega ·x +b) &gt; 0 $$，如果分类错误，那么小于0.<br>同时，$$ y(\omega ·x +b) &gt; 0 $$的绝对值越大，则确信度越大</p><p>因此用这个来表示函数间隔。对于一个训练样本(x(i),y(i))我们定义它到超平面(w,b)的函数间隔为:<br>$$\hatγ = y^{(i)}(w^Tx^{(i)}+b)$$</p><p>函数间隔越大越好，并且如果$$ \hatγ &gt; 0 $$，则样本正确分类<br>对于整个训练集，定义函数间隔为所有样本中最小的那个函数间隔:<br>$$ \hatγ = min_i \hatγ^{(i)}$$</p><h2 id="几何间隔"><a href="#几何间隔" class="headerlink" title="几何间隔"></a>几何间隔</h2><p>对于函数间隔，有个问题就是，可以在不改变超平面的情况下，让函数间隔任意大。<br>如果$$ \omega $$和$$ b $$倍增，函数间隔改变，但是超平面不变。</p><p>因此我们对函数间隔加上一个限制：<br>$$ ||\omega|| = 1 $$</p><p>这样是为了，让$$ \omega和b $$倍增的时候，分母也会倍增，所以几何间隔就不会改变。<br>当$$ ||\omega||=1 $$的时候，几何间隔就是函数间隔</p><p>所以几何间隔的公式就是：<br>$$ γ^{(i)} = y^{(i)}({w^T \over ∥w∥}x^{(i)}+{b \over ∥w∥}) $$</p><p>训练集的集合间隔是所有样本中最小的那个：<br>$$ γ = min_iγ^{(i)}$$</p><p>有没有发现，几何间隔其实就是<strong>点到平面的距离</strong></p><p>函数间隔和几何间隔的关系：<br>$$ γ^{(i)}={\hatγ^{(i)} \over ∥w∥ }$$</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;关于超平面、函数间隔以及几何间隔的理解。&lt;br&gt;这些在SVM中要用到。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="MachineLearning" scheme="https://hanielxx.com/categories/MachineLearning/"/>
    
    
    <category term="SVM" scheme="https://hanielxx.com/tags/SVM/"/>
    
    <category term="超平面" scheme="https://hanielxx.com/tags/%E8%B6%85%E5%B9%B3%E9%9D%A2/"/>
    
    <category term="函数间隔" scheme="https://hanielxx.com/tags/%E5%87%BD%E6%95%B0%E9%97%B4%E9%9A%94/"/>
    
    <category term="几何间隔" scheme="https://hanielxx.com/tags/%E5%87%A0%E4%BD%95%E9%97%B4%E9%9A%94/"/>
    
  </entry>
  
  <entry>
    <title>论文笔记 | 基于机器学习的siRNA沉默效率预测方法研究</title>
    <link href="https://hanielxx.com/MachineLearning/2019-10-17-Paper-note-Research-on-prediction-method-of-siRNA-silencing-efficiency-based-on-machine-learning"/>
    <id>https://hanielxx.com/MachineLearning/2019-10-17-Paper-note-Research-on-prediction-method-of-siRNA-silencing-efficiency-based-on-machine-learning</id>
    <published>2019-10-17T02:56:51.000Z</published>
    <updated>2020-11-14T12:40:56.211Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>最近在看<a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&dbname=CDFDLAST2017&filename=1017152231.nh" target="_blank" rel="external nofollow noopener noreferrer">基于机器学习的siRNA沉默效率预测方法研究</a>这篇论文，论文一共98页，实在太长，不得不单独一篇笔记用于记录要点。</p><p>这篇论文在使用机器学习方法研究siRNA沉默效率这方面讲的还是很清楚的，用以入门。</p></div><a id="more"></a><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="研究意义"><a href="#研究意义" class="headerlink" title="研究意义"></a>研究意义</h2><p>这里主要讲述了RNAi的起源、作用机制和应用，可以参考上一篇文章<a href="https://hanielxx.com/Notes/2019-10-01-basic-knowledge-of-RNAi.html">RNAi和siRNA设计基础</a>，这里就不记录了。</p><h2 id="国内外研究动态"><a href="#国内外研究动态" class="headerlink" title="国内外研究动态"></a>国内外研究动态</h2><h3 id="基于规则的第一代-siRNA-沉默效率预测方法"><a href="#基于规则的第一代-siRNA-沉默效率预测方法" class="headerlink" title="基于规则的第一代 siRNA 沉默效率预测方法"></a>基于规则的第一代 siRNA 沉默效率预测方法</h3><p>早期主要是用统计学方法寻找siRNA不同沉默效率的规则，因此沉默效率不能量化，只能分高效和低效siRNA</p><p>主要是在siRNA不同位置上的规则约束，这部分可以用一张表总结。</p><p>其次需要考虑siRNA热力学稳定性，主要是下面两种规则：</p><p><strong>缺点是：</strong></p><ol><li>样本量太少</li><li>规则不够具体</li><li>没有设置权重区分规则重要性</li><li>具有数据偏向性<h3 id="基于机器学习的第二代-siRNA-沉默效率预测方法"><a href="#基于机器学习的第二代-siRNA-沉默效率预测方法" class="headerlink" title="基于机器学习的第二代 siRNA 沉默效率预测方法"></a>基于机器学习的第二代 siRNA 沉默效率预测方法</h3></li></ol><h4 id="数据集方面"><a href="#数据集方面" class="headerlink" title="数据集方面"></a>数据集方面</h4><p>主要是使用Huesken数据集，Huesken 数据集到目前为止同样实验条件下提出的数量最多的数据集。</p><p>其他一些包括化学修饰的数据集可以有需要再去论文中查看。</p><h3 id="特征方面"><a href="#特征方面" class="headerlink" title="特征方面"></a>特征方面</h3><ol><li><p>碱基组成</p></li><li><p>1-3mer的motif频率和位置特征</p></li><li><p>热力学参数，包括siRNA 双链的G ，siRNA 反义链的内部分子结构稳定性，局部靶标的 mRNA 稳定性以及 siRNA 双链中每相邻两个碱基对的稳定性等等</p></li><li><p>反义链的二级结构</p></li><li><p>与mRNA有区别的结构特征</p></li><li><p>靶mRNA的二级结构</p></li><li><p>靶mRNA内多个反义链结合位点的能量</p></li><li><p>siRNA的3n+1位碱基组成，也意味着siRNA的绑定蛋白和效率有关</p></li><li><p>siRNA上下游碱基，可能是上下游特定的motif可能影响效率</p></li></ol><h4 id="算法方面"><a href="#算法方面" class="headerlink" title="算法方面"></a>算法方面</h4><p>统计如下：</p><ol><li>GP算法</li><li>GSK和SVM</li><li>神经网络</li><li>线性回归</li><li>决策树</li><li>随机森林&gt;SVM</li><li>后缀树</li><li>规则矩阵，利用已知规则设置权重，结合半监督的回归算法</li></ol><h1 id="机器学习在siRNA沉默效率预测中的应用"><a href="#机器学习在siRNA沉默效率预测中的应用" class="headerlink" title="机器学习在siRNA沉默效率预测中的应用"></a>机器学习在siRNA沉默效率预测中的应用</h1><h2 id="siRNA样本收集"><a href="#siRNA样本收集" class="headerlink" title="siRNA样本收集"></a>siRNA样本收集</h2><p>此需要选择具有代表性、数量充足的样本集合。生物信息学使用的数据还需要注意数据是否存在冗余</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;最近在看&lt;a href=&quot;https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2017&amp;filename=1017152231.nh&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;基于机器学习的siRNA沉默效率预测方法研究&lt;/a&gt;这篇论文，论文一共98页，实在太长，不得不单独一篇笔记用于记录要点。&lt;/p&gt;&lt;p&gt;这篇论文在使用机器学习方法研究siRNA沉默效率这方面讲的还是很清楚的，用以入门。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="MachineLearning" scheme="https://hanielxx.com/categories/MachineLearning/"/>
    
    
    <category term="MachineLearning" scheme="https://hanielxx.com/tags/MachineLearning/"/>
    
    <category term="Paper" scheme="https://hanielxx.com/tags/Paper/"/>
    
    <category term="siRNA" scheme="https://hanielxx.com/tags/siRNA/"/>
    
    <category term="Notes" scheme="https://hanielxx.com/tags/Notes/"/>
    
  </entry>
  
</feed>
