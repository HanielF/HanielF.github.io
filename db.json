{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/Staticfile","path":"Staticfile","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":1,"renderable":0},{"_id":"source/uploads/Screenshot from 2019-03-19 21-26-16.png","path":"uploads/Screenshot from 2019-03-19 21-26-16.png","modified":1,"renderable":0},{"_id":"themes/next-geek/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next-geek/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next-geek/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"source/uploads/Screenshot from 2019-03-19 20-57-25.png","path":"uploads/Screenshot from 2019-03-19 20-57-25.png","modified":1,"renderable":0},{"_id":"themes/next-geek/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/js/src/lang-select.js","path":"js/src/lang-select.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next-geek/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1556705680819},{"_id":"source/favicon.ico","hash":"1d3b2e8527e2e02d155b444bcfb5893f5e721e73","modified":1552809095767},{"_id":"source/robots.txt","hash":"0e10b41dbc46bca7db46efb761d8532a6bc07927","modified":1564075542328},{"_id":"source/CNAME","hash":"0c722a462f71155a4be367d560b37b5f3e4e85dc","modified":1563711523241},{"_id":"themes/next-geek/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1553160728116},{"_id":"themes/next-geek/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1553160728116},{"_id":"themes/next-geek/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1553160728116},{"_id":"themes/next-geek/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1553160728116},{"_id":"themes/next-geek/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1553160728116},{"_id":"themes/next-geek/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1553160728116},{"_id":"themes/next-geek/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1553160728116},{"_id":"themes/next-geek/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1553160728116},{"_id":"themes/next-geek/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1553160728116},{"_id":"themes/next-geek/.travis.yml","hash":"1a69a0b3ae010b10080069332829205573c64371","modified":1553160728116},{"_id":"themes/next-geek/README.md","hash":"c5d5e78772a0e231f8d316ca8a6c0bec35da52c0","modified":1553160728116},{"_id":"themes/next-geek/README.en.md","hash":"e73c7c434962584359248279fb44e7276b7929e7","modified":1553160728116},{"_id":"themes/next-geek/bower.json","hash":"7d7938f9da896fe710aa0e9120140e528bf058df","modified":1553160728116},{"_id":"themes/next-geek/package.json","hash":"193dad6f59a588908fac082cc46fe067dac1b84d","modified":1553160728116},{"_id":"themes/next-geek/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1553160728116},{"_id":"themes/next-geek/_config.yml","hash":"d12c1ada279bd8b2add05a94281459f42833b352","modified":1571575959850},{"_id":"source/_posts/Archlinux的灵魂──PKGBUILD、AUR-和-ABS.md","hash":"df544fa8589e9416e8d006daf9fcbadf1977686b","modified":1564138826187},{"_id":"source/_posts/ACM-2017WF-F-Posterize.md","hash":"0c091c1d16d7f175d8dc5d2c6e5b905c5a4ba502","modified":1564076332440},{"_id":"source/_posts/ArchLinux-Gnome下触摸板设置.md","hash":"fd3c6f662439d55508d8e8e3d0d960ef4a4a50c4","modified":1569997681250},{"_id":"source/LeetCode/index.md","hash":"f7f90292d373d39cd868db78a56474f150e72415","modified":1571277146119},{"_id":"source/_posts/Fedora26编译内核.md","hash":"06cc509c69b4f81415b3f9738e88d7617ca18f06","modified":1564076642350},{"_id":"source/_posts/CentOS搭建LNMP环境.md","hash":"3ceb410517408516d85a738ec05555f6adb69e4d","modified":1564076606046},{"_id":"source/_posts/Fedora搭建LNMP环境.md","hash":"c84d9b196a14227e9da3f27c2fbbe3e21291768d","modified":1564076999333},{"_id":"source/_posts/Linux将deb包转为ArchLinux软件包.md","hash":"abd01bc9b09e9c181fc51f3fceaab7c33f76db42","modified":1564079471139},{"_id":"source/_posts/C-优先级队列.md","hash":"859f667f146b6566f6147285862e05b5a8789a92","modified":1564076531910},{"_id":"source/_posts/Canvas中像素级别ImageData缩放.md","hash":"72c845865c12d2492f1399965c00d11541f79599","modified":1564076607446},{"_id":"source/_posts/Markdown学习笔记.md","hash":"2b6c6b9131f0d526792a3477da7cf2d03d222d8c","modified":1564079479752},{"_id":"source/_posts/Tornado中的异步.md","hash":"5a3631239be6cbca419c65a15cf8f7c154dc966a","modified":1564079652896},{"_id":"source/_posts/Python中的异步.md","hash":"34e7d9b1add7f035b6040cd9f33dc8b418a4dd29","modified":1564079599546},{"_id":"source/_posts/arch安装和gnome配置教程.md","hash":"de16db7a474335697e3c0f1a52fe776c3c64637d","modified":1564079086936},{"_id":"source/_posts/cannot-start-gnome-tweaks.md","hash":"67c8d0ced34b805953e93e9e91d5c358d4afc2a1","modified":1564079084859},{"_id":"source/_posts/numpy-dot-函数.md","hash":"d545b0a15ce5e679123282d881477661b9f8f64d","modified":1564079585699},{"_id":"source/_posts/Python复习.md","hash":"9f76f79d895a5a46a4863bde283f10ae87013fa6","modified":1568292926551},{"_id":"source/_posts/SpaceVim中自定义Markdown相关快捷键.md","hash":"7f644481d9ed3aa11fcbe4b025637180ecb3a2b5","modified":1564079636003},{"_id":"source/_posts/hello-world.md","hash":"c551106b4c2a4c9d6c5aea8548af2ed1743542b3","modified":1564076997919},{"_id":"source/_posts/动态规划套路详解.md","hash":"6b8406f22f48f01c4b317f870aafe22882c6d6ba","modified":1564079670506},{"_id":"source/_data/next.yml","hash":"7252fd7af39049912ec7c2df6c81fda1d6383332","modified":1571280061183},{"_id":"source/_posts/记2019南大计算机本科生开放日.md","hash":"951cc744659c791d625342272787be87d6c235f7","modified":1570038370633},{"_id":"source/about/index.md","hash":"98f3d3b4add040d8054fc52b03def44fe7f84e5c","modified":1564091798711},{"_id":"source/archives/index.md","hash":"c5890c8b58f02aea692752520ae46e08fe1ec656","modified":1552809095767},{"_id":"source/_posts/每个人都需要一个引路人.md","hash":"bbfa6a75a9d9bb775801ce5d5eafc77ed6c897ff","modified":1571572489141},{"_id":"source/categories/index.md","hash":"5175da55811467d18b592019ec955b5829c79510","modified":1564091725600},{"_id":"source/tags/index.md","hash":"179ab8afa8b9a08adfc77a72a21d8e85b292e0cf","modified":1564091776054},{"_id":"source/uploads/avatar.jpg","hash":"1d3b2e8527e2e02d155b444bcfb5893f5e721e73","modified":1552809095771},{"_id":"themes/next-geek/languages/en.yml","hash":"5389a2745011b7b5e41b476e4b100c35e1c9b57d","modified":1571279924196},{"_id":"themes/next-geek/languages/de.yml","hash":"98aa551443b2a61a74b6f2a218635da6d2f6cf57","modified":1553160728116},{"_id":"themes/next-geek/languages/default.yml","hash":"c0b90d66772e79585cd26a81694ad69c16312d6b","modified":1553160728116},{"_id":"themes/next-geek/languages/ja.yml","hash":"0c99ba4ba7d36c43d002342611d2c656ef498582","modified":1553160728116},{"_id":"themes/next-geek/languages/id.yml","hash":"f8b57daac2e50ace9a6d5051b17208af8139c2ae","modified":1553160728116},{"_id":"themes/next-geek/languages/ko.yml","hash":"043951e82997131dd8be40ff2093ef36849ba725","modified":1553160728116},{"_id":"themes/next-geek/languages/fr-FR.yml","hash":"a14d051bbec26cfcae358bdcf1acf62a35fb1a45","modified":1553160728116},{"_id":"themes/next-geek/languages/pt-BR.yml","hash":"91584764104ef29293117375fc010b1bdbe9aff6","modified":1553160728116},{"_id":"themes/next-geek/languages/pt.yml","hash":"dfd0b8574177346b78cab29db055fbc44ac309dc","modified":1553160728116},{"_id":"themes/next-geek/languages/zh-hk.yml","hash":"e8072846fd43beadbae394e30a49aa5c92a0a53b","modified":1553160728116},{"_id":"themes/next-geek/languages/ru.yml","hash":"98dd9b6ddd88400a7b02cd7e8adb41e7b842bf57","modified":1553160728116},{"_id":"themes/next-geek/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1553160728120},{"_id":"themes/next-geek/scripts/helpers.js","hash":"f5eceb27ca7e9e7416ca18ef99a3c4609f6b7cfd","modified":1553160728120},{"_id":"themes/next-geek/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1553160728120},{"_id":"themes/next-geek/languages/zh-Hans.yml","hash":"a539dee5d70f484bd599de804ee78063e51cb760","modified":1553160728116},{"_id":"themes/next-geek/languages/zh-tw.yml","hash":"562141bfe450432131af012baa262a3de79a50bc","modified":1553160728116},{"_id":"themes/next-geek/.github/ISSUE_TEMPLATE.md","hash":"f4d1e85250d3d82f3dac23b747dff132490b6e91","modified":1553160728116},{"_id":"themes/next-geek/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1553160728116},{"_id":"themes/next-geek/.github/PULL_REQUEST_TEMPLATE.md","hash":"e9169b65a7e3392c27562f9e11061a3ab76bb600","modified":1553160728116},{"_id":"themes/next-geek/layout/_layout.swig","hash":"cd44562cc75436d8f905a6f0b85f6d4538523f3d","modified":1553160728116},{"_id":"themes/next-geek/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1553160728116},{"_id":"themes/next-geek/layout/archive.swig","hash":"383f64deab105724fd5512371963bd9e9aafbffd","modified":1553160728120},{"_id":"themes/next-geek/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1553160728120},{"_id":"themes/next-geek/layout/page.swig","hash":"37c874cd720acf0eda8d26e063278f2b6ae8d3a6","modified":1553160728120},{"_id":"themes/next-geek/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1553160728120},{"_id":"themes/next-geek/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1553160728120},{"_id":"themes/next-geek/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1553160728120},{"_id":"themes/next-geek/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1553160728120},{"_id":"source/uploads/Screenshot from 2019-03-19 21-26-16.png","hash":"92ec8d5807175f6f3bfdef909ba07c6a0c42a7be","modified":1553001979687},{"_id":"themes/next-geek/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1553160728130},{"_id":"themes/next-geek/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1553160728130},{"_id":"themes/next-geek/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1553160728130},{"_id":"source/_posts/MachineLearning/MNIST入门-手写数字识别问题集锦.md","hash":"7a67ac457527389ad4bd49e8a2b553d166be0ae6","modified":1564079558343},{"_id":"source/_posts/MachineLearning/机器学习概念整理.md","hash":"67748d1ad60b24f20751659f7e22a526cb5c930c","modified":1564079852350},{"_id":"source/_posts/MachineLearning/聚类和K-Means算法.md","hash":"35eb3aac34141fb034818b872bd9344091378477","modified":1564079868380},{"_id":"source/_posts/MachineLearning/MNIST入门-手写数字识别.md","hash":"7d2ba51c82c14ef0f3b7a563ba32a021f56d5029","modified":1564079533366},{"_id":"source/_posts/MachineLearning/凸函数、凸集和凸优化.md","hash":"3053b29b3872f0ac8335d4e6864ca9e84290e54e","modified":1571582417377},{"_id":"source/_posts/MachineLearning/超平面、函数间隔和几何间隔.md","hash":"18f68ef6422a5b2c87a9dbef9fe0d91467c22006","modified":1571578778401},{"_id":"source/_posts/LeetCode/LeetCode-001-Two-Sum.md","hash":"204193e6405b57cc6c3f0aedbc7cf332e54256e4","modified":1564077084258},{"_id":"source/_posts/LeetCode/LeetCode-002-Add-Two-Numbers.md","hash":"8bac641af9da9cfb75599a4b477c06d76d95396c","modified":1564077116951},{"_id":"source/_posts/LeetCode/LeetCode-006-ZigZag-Conversion.md","hash":"b51f8d9fdd8b137bd35faee5d54afb04857efdaf","modified":1564077304737},{"_id":"source/_posts/LeetCode/LeetCode-007-Reverse-Integer.md","hash":"124130b3b0df278b2306fa29db14f53cc567efe3","modified":1564077326461},{"_id":"source/_posts/LeetCode/LeetCode-004-Median-of-Two-Sorted-Arrays.md","hash":"fe0c83c2baaef592954e66421549097b91afc398","modified":1564077207089},{"_id":"source/_posts/LeetCode/LeetCode-008-String-to-Integer-atoi.md","hash":"b3c6a7abe3d03194c77798ae71189dd6f3097f52","modified":1564077348274},{"_id":"source/_posts/LeetCode/LeetCode-010-Regular-Expression-Matching.md","hash":"7f865d803807501a75a6cef5773aa08e3dfac6ab","modified":1564077392595},{"_id":"source/_posts/LeetCode/LeetCode-003-Longest-Substring-Without-Repeating-Characters.md","hash":"1870c6d786b826901616677f05b3f4e1f23d88e4","modified":1564077170672},{"_id":"source/_posts/LeetCode/LeetCode-011-Container-With-Most-Water.md","hash":"fe11b0bd351a9760eeef9845404b9de670ad4ae3","modified":1564077412015},{"_id":"source/_posts/LeetCode/LeetCode-012-Integer-to-Roman.md","hash":"ca69c4958a4c1a197fea91600315197c056831ab","modified":1564077427982},{"_id":"source/_posts/LeetCode/LeetCode-005-Longest-Palindromic-Substring.md","hash":"c16139184a227ec821718c2833acf76191d0d8ac","modified":1564077265307},{"_id":"source/_posts/LeetCode/LeetCode-013-Roman-to-Integer.md","hash":"fd665cdf80c457f0a4467e9e28c466079912cdda","modified":1564077449365},{"_id":"source/_posts/LeetCode/LeetCode-014-Longest-Common-Prefix.md","hash":"da5e592c0789a96e29b5056e9117a042966cb838","modified":1564077464585},{"_id":"source/_posts/LeetCode/LeetCode-016-3Sum-Closest.md","hash":"9e048013c94f724f8e202789002a8e55675831e3","modified":1564077498736},{"_id":"source/_posts/LeetCode/LeetCode-015-3Sum.md","hash":"1c7688ba8f67beee2e5187095e7906f1d727a0c8","modified":1564077480299},{"_id":"source/_posts/LeetCode/LeetCode-009-Palindrome-Number.md","hash":"fbb067867bc17065d4a3367173a2a6ff41a0b887","modified":1564077372324},{"_id":"source/_posts/LeetCode/LeetCode-017-Letter-Combinations-of-a-Phone-Number.md","hash":"e7f743aa3fb8f671927594914a4af304944e5ea7","modified":1564077521552},{"_id":"source/_posts/LeetCode/LeetCode-019-Remove-Nth-Node-From-End-of-List.md","hash":"cb1950b576b169467d5a00456721235dbb598692","modified":1564077561026},{"_id":"source/_posts/LeetCode/LeetCode-018-4Sum.md","hash":"dcef992b4f5fde4f51da7da9ac50892d1b7b7995","modified":1564077532523},{"_id":"source/_posts/LeetCode/LeetCode-024-Swap-Nodes-in-Pairs.md","hash":"8f4a684e42859ab7cd736da87ed0a7021dc153a6","modified":1564079253469},{"_id":"source/_posts/LeetCode/LeetCode-020-Valid-Parentheses.md","hash":"5fc8d1e806f948278232cecb432cbcbd097ec4d7","modified":1564079082259},{"_id":"source/_posts/LeetCode/LeetCode-022-Generate-Parentheses.md","hash":"46ab9124988b852137e45623efbc420eb21c8c6e","modified":1564079187056},{"_id":"source/_posts/LeetCode/LeetCode-026-Remove-Duplicates-from-Sorted-Array.md","hash":"09686712c6301227d770999921507f903e2cdcfa","modified":1571880349715},{"_id":"source/_posts/LeetCode/LeetCode-088-Merge-Sorted-Array.md","hash":"9c118ef98cfbe2df99c1c032ebb32653f444c28d","modified":1564079333859},{"_id":"source/_posts/LeetCode/LeetCode-027-Remove-Element.md","hash":"586e6e3d63fb5328de2366adb6f6296190e88395","modified":1571882278133},{"_id":"source/_posts/LeetCode/LeetCode-021-Merge-Two-Sorted-Lists.md","hash":"0d15e121416fc5977d41d244b9434d8b189ff3d7","modified":1564079165373},{"_id":"source/_posts/LeetCode/LeetCode-125-Valid-Palindrome.md","hash":"776ec2d0873a2abdba388331243a50fda0488eb3","modified":1564079376169},{"_id":"source/_posts/LeetCode/LeetCode-136-Single-Number.md","hash":"9c925cea1d0335c1fe98fe8efb9b912ae8e59f65","modified":1564079390839},{"_id":"source/_posts/LeetCode/LeetCode-025-Reverse-Nodes-in-k-Group.md","hash":"798a61bf277cf1900c68bd07e697e6b062aa4aa2","modified":1568727820703},{"_id":"source/_posts/LeetCode/LeetCode-169-Majority-Element.md","hash":"f1b43b2796efc4a73aee6788586f9e5e5ce03748","modified":1564079411532},{"_id":"source/_posts/LeetCode/LeetCode-023-Merge-k-Sorted-Lists.md","hash":"8aefd09bc2b271f66658bb87ce79e2f6edac1b09","modified":1564079227719},{"_id":"source/_posts/LeetCode/LeetCode-240-Search-a-2D-Matrix-II.md","hash":"8777992f0ef11c679348438022c7ac055061b395","modified":1564079434109},{"_id":"source/_posts/LeetCode/LeetCode-124-Binary-Tree-Maximum-Path-Sum.md","hash":"fcdd2b821310901fc5645c1a3b5bc837d8b6daa3","modified":1564079357632},{"_id":"source/_posts/NowCoder/NowCoder-IWannaGoHome.md","hash":"ea51e96d27c35b67bd0f16f6a5dc6fbe5bc9ddd9","modified":1569132188736},{"_id":"source/_posts/NowCoder/NowCoder-10进制和2进制.md","hash":"4f370a2785654d0950ee32465eda38735480fee3","modified":1569129251867},{"_id":"source/_posts/NowCoder/NowCoder-二叉树遍历.md","hash":"b7f00388ae5c6aa7f7200cb536f010a8a66c6d1a","modified":1569050973183},{"_id":"source/_posts/NowCoder/NowCoder-代理服务器.md","hash":"f99f93b16fcd11ff14a98aaa8b9a1015094e1edf","modified":1568292812113},{"_id":"source/_posts/NowCoder/NowCoder-剩下的树.md","hash":"6301033bc731a80ea14276e8e3035fe6b6f37746","modified":1569128116661},{"_id":"source/_posts/NowCoder/NowCoder-完数和盈数.md","hash":"090800e171f0b6dac5f816e3994f6bf5b56ba279","modified":1569077272144},{"_id":"source/_posts/NowCoder/NowCoder-成绩排序.md","hash":"4e707eca9b69c4fcb72399bbb0d0b0c2814a4ac1","modified":1567180894118},{"_id":"source/_posts/NowCoder/NowCoder-今年第几天.md","hash":"2833ccb4075ff35e7f2c2f748463b1ab96fa50dc","modified":1569076882931},{"_id":"source/_posts/NowCoder/NowCoder-手机键盘.md","hash":"8f4ffb9595e10004b2cb5b2738fc6b8782e91f3f","modified":1568686705130},{"_id":"source/_posts/NowCoder/NowCoder-最小花费.md","hash":"31b05730cb5c61a4bfd723bafcb44443e5716e12","modified":1569080811197},{"_id":"source/_posts/NowCoder/NowCoder-整数拆分.md","hash":"c914b6e67af19e4cd37008d5a16cbd0f3e93c7d7","modified":1568687733238},{"_id":"source/_posts/NowCoder/NowCoder-最小邮票数.md","hash":"a988ad115e3570f11fe4bdfdad21e0850a742c20","modified":1569051605465},{"_id":"source/_posts/NowCoder/NowCoder-特殊乘法.md","hash":"90e3365c776a1348472a00016457ca446117973f","modified":1569052179082},{"_id":"source/_posts/NowCoder/NowCoder-玛雅人的密码.md","hash":"3ad018227d649e0cdb736f8b047aafab2de6529e","modified":1569051001173},{"_id":"source/_posts/NowCoder/NowCoder-球的半径和体积.md","hash":"beb4ef7a56dfbfdb95f3f4f4d328dbd8c11b8520","modified":1568688353705},{"_id":"source/_posts/NowCoder/NowCoder-大数阶乘.md","hash":"792c0c4d5433c8216cc1e1558033c73ba644880f","modified":1569083139809},{"_id":"source/_posts/NowCoder/NowCoder-约数个数.md","hash":"c0771636d0969788a052cc3cd797d7b61d85eca7","modified":1568286912602},{"_id":"source/_posts/NowCoder/NowCoder-最大序列和.md","hash":"f44667a61609f418c0c5a6f2a16558b0033af175","modified":1569079616788},{"_id":"source/_posts/NowCoder/NowCoder-递推数列.md","hash":"814898e3bbc17717d1bd4f2fb6b50bf119e3cfc7","modified":1569078836419},{"_id":"source/_posts/NowCoder/NowCoder-质因数个数.md","hash":"f7d54b9b93f4a866c5e9f7afc78003b4d654e782","modified":1568687267413},{"_id":"source/_posts/siRNA/siRNA设计基础.md","hash":"d155524fd4bc71bfa13853055b5e536db2805bbe","modified":1570628871374},{"_id":"source/_posts/siRNA/论文笔记-基于机器学习的siRNA沉默效率预测方法研究.md","hash":"8ec998dee473280de35ebd0fa130738f9ae3091d","modified":1571381760428},{"_id":"source/_posts/NowCoder/NowCoder-查找学生信息.md","hash":"a2688b246402f0945bf35fbfae05a360da968c88","modified":1569129527556},{"_id":"themes/next-geek/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553160728123},{"_id":"source/_posts/NowCoder/NowCoder-谁是你的潜在朋友.md","hash":"dd306d589932bce3f91c4985963d811c9c44f2ec","modified":1569133912637},{"_id":"themes/next-geek/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1553160728120},{"_id":"themes/next-geek/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1553160728120},{"_id":"themes/next-geek/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1553160728120},{"_id":"themes/next-geek/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1553160728120},{"_id":"themes/next-geek/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1553160728120},{"_id":"themes/next-geek/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1553160728120},{"_id":"themes/next-geek/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1553160728120},{"_id":"themes/next-geek/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1553160728120},{"_id":"themes/next-geek/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1553160728120},{"_id":"themes/next-geek/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1553160728116},{"_id":"themes/next-geek/layout/_macro/reward.swig","hash":"5d5f70deb6074cb4dd0438463e14ccf89213c282","modified":1553160728116},{"_id":"themes/next-geek/layout/_macro/post.swig","hash":"890644e5834a1e5594b3c2f9cf0a973033aa5f44","modified":1553160728116},{"_id":"themes/next-geek/layout/_macro/post-copyright.swig","hash":"53d4f83b2b7fb4387dfc9fe81519abd56fbce4ae","modified":1553160728116},{"_id":"themes/next-geek/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1553160728116},{"_id":"themes/next-geek/layout/_custom/lang-switch.swig","hash":"307ac34362ce8dd4f40dce035afa0163c5923518","modified":1553160728116},{"_id":"themes/next-geek/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1553160728116},{"_id":"themes/next-geek/layout/_partials/head.swig","hash":"1f14d3f494b2dbbcee802fd6f6d1abd5b7e2304c","modified":1553160728116},{"_id":"themes/next-geek/layout/_partials/header.swig","hash":"bd03d6b9cbf10fb85cb1feb88081ec3ee729da18","modified":1554137816349},{"_id":"themes/next-geek/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1553160728120},{"_id":"themes/next-geek/layout/_macro/sidebar.swig","hash":"67ea578bb8c2270b0e8d1776bac329e6caa5145c","modified":1564167872590},{"_id":"themes/next-geek/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1553160728120},{"_id":"themes/next-geek/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1553160728120},{"_id":"themes/next-geek/layout/_partials/comments.swig","hash":"010ef8c42d2e1a95abc60caf757293ca8eb4a68b","modified":1564091086502},{"_id":"themes/next-geek/layout/_partials/footer.swig","hash":"6af2557481906a6cafb95e46ba30275b1121c860","modified":1564094675946},{"_id":"themes/next-geek/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1553160728120},{"_id":"themes/next-geek/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1553160728120},{"_id":"themes/next-geek/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1553160728120},{"_id":"themes/next-geek/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1553160728120},{"_id":"themes/next-geek/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1553160728123},{"_id":"themes/next-geek/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1553160728123},{"_id":"themes/next-geek/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1553160728123},{"_id":"themes/next-geek/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1553160728123},{"_id":"themes/next-geek/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1553160728123},{"_id":"themes/next-geek/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1553160728123},{"_id":"themes/next-geek/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1553160728123},{"_id":"themes/next-geek/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1553160728123},{"_id":"themes/next-geek/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1553160728123},{"_id":"themes/next-geek/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1553160728123},{"_id":"themes/next-geek/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1553160728123},{"_id":"themes/next-geek/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1553160728123},{"_id":"themes/next-geek/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1553160728123},{"_id":"themes/next-geek/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1553160728123},{"_id":"themes/next-geek/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1553160728123},{"_id":"themes/next-geek/layout/_scripts/schemes/mala.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553160728120},{"_id":"themes/next-geek/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553160728120},{"_id":"themes/next-geek/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553160728120},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法.md","hash":"e5a878fcca1de290a778bb5bdcd0c4607603aba3","modified":1564079764679},{"_id":"source/_posts/MachineLearning/超平面、函数间隔和几何间隔/faxiangliang.png","hash":"a636c92b320b4a478051aa0e432374a0cf9cad9e","modified":1571575123242},{"_id":"source/_posts/MachineLearning/超平面、函数间隔和几何间隔/distance.png","hash":"ee26e54733ec78aa0ca914c6fc2fff0f9d81c363","modified":1571576592924},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Types-of-Learning.md","hash":"2c23dde4c18845648957a0a652c2731ce43e15f1","modified":1564079777700},{"_id":"themes/next-geek/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553160728123},{"_id":"themes/next-geek/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553160728123},{"_id":"themes/next-geek/source/css/_mixins/Mala.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553160728123},{"_id":"themes/next-geek/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553160728123},{"_id":"themes/next-geek/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553160728123},{"_id":"themes/next-geek/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553160728123},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning.md","hash":"9db974c7a64b9e5ee9cf1a8084d081bce2cec822","modified":1564079753226},{"_id":"source/_posts/LeetCode/LeetCode-011-Container-With-Most-Water/011.png","hash":"ec6e543d9e59f947068ea78c925d2212ec3bb62f","modified":1564076304149},{"_id":"source/uploads/Screenshot from 2019-03-19 20-57-25.png","hash":"b1208ea8f5a1d3d9a9440c9d5d84e5b443b81d2b","modified":1553000250299},{"_id":"themes/next-geek/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1553160728120},{"_id":"themes/next-geek/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1553160728120},{"_id":"themes/next-geek/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1553160728120},{"_id":"themes/next-geek/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1553160728120},{"_id":"themes/next-geek/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1553160728120},{"_id":"themes/next-geek/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1553160728120},{"_id":"themes/next-geek/layout/_partials/share/jiathis.swig","hash":"fd65b0d38d4a8b8306de815c48caad20b84ba4cb","modified":1553160728120},{"_id":"themes/next-geek/layout/_partials/suprise/assist.swig","hash":"6b8a25353dbfe9f92e0d48388a6f46996e03b7cb","modified":1553160728120},{"_id":"themes/next-geek/layout/_partials/suprise/donate.swig","hash":"25f196afc193a7b192a49cb7d84db7d727a9e8c2","modified":1553160728120},{"_id":"themes/next-geek/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1553160728116},{"_id":"themes/next-geek/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1553160728120},{"_id":"themes/next-geek/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1553160728120},{"_id":"themes/next-geek/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1553160728120},{"_id":"themes/next-geek/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/comments/index.swig","hash":"576e716893153a855eaf6d136fad7cb6d4065e09","modified":1564091076835},{"_id":"themes/next-geek/layout/_third-party/comments/valine.swig","hash":"9f4ed36c73e890909b8ebbe601fb60e13d048288","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1553160728120},{"_id":"source/_posts/siRNA/论文笔记-基于机器学习的siRNA沉默效率预测方法研究/1-1.png","hash":"aeaf6ccb0df6f3e8fd36ee5c4ed2a9911a840863","modified":1571282172232},{"_id":"themes/next-geek/source/css/_custom/custom.styl","hash":"bd301290ba397c7f52fe60a054f8e1501c226ca1","modified":1554616593873},{"_id":"themes/next-geek/source/css/_variables/Mala.styl","hash":"87662c094aa68b7df36288c4ed9d62144e3d4340","modified":1553160728123},{"_id":"themes/next-geek/source/css/_variables/Gemini.styl","hash":"49b5210fa62d6cbc6a98f57d89d5067a06ab3561","modified":1553160728123},{"_id":"themes/next-geek/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1553160728123},{"_id":"themes/next-geek/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1553160728123},{"_id":"themes/next-geek/source/css/_variables/Pisces.styl","hash":"cfee25d790e4f9b7d57f0dc7e2ea9c1649f08f11","modified":1553160728123},{"_id":"themes/next-geek/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1553160728123},{"_id":"themes/next-geek/source/css/_variables/base.styl","hash":"d477196c5699c8261b08e993a77ef67054d86166","modified":1553160728123},{"_id":"themes/next-geek/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1553160728123},{"_id":"themes/next-geek/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1553160728123},{"_id":"themes/next-geek/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1553160728123},{"_id":"themes/next-geek/source/js/src/bootstrap.js","hash":"6117f97b4984b8e33f21c726132da64ba678e4ed","modified":1553160728123},{"_id":"themes/next-geek/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1553160728123},{"_id":"themes/next-geek/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1553160728123},{"_id":"themes/next-geek/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1553160728123},{"_id":"themes/next-geek/source/js/src/lang-select.js","hash":"8bb0cd0b464357f8e2b794e64b89e4dbe2a836e3","modified":1553160728123},{"_id":"themes/next-geek/source/js/src/motion.js","hash":"28f977030d95c3a2d58789a3376811ee9fa1bf6e","modified":1553160728123},{"_id":"themes/next-geek/source/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1553160728123},{"_id":"themes/next-geek/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1553160728123},{"_id":"themes/next-geek/source/js/src/utils.js","hash":"3b9f28f8d5a097254eddedf4406bc01e57781be8","modified":1553160728123},{"_id":"themes/next-geek/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1553160728123},{"_id":"source/_posts/MachineLearning/超平面、函数间隔和几何间隔/tuhanshu.png","hash":"f91a1bbbdb5e7ea13efa9a7299eb2cc91f5b7fb4","modified":1571579317552},{"_id":"themes/next-geek/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1553160728123},{"_id":"themes/next-geek/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1553160728126},{"_id":"themes/next-geek/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1553160728126},{"_id":"themes/next-geek/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1553160728126},{"_id":"themes/next-geek/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1553160728126},{"_id":"themes/next-geek/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1553160728126},{"_id":"themes/next-geek/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1553160728126},{"_id":"themes/next-geek/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1553160728126},{"_id":"themes/next-geek/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1553160728126},{"_id":"themes/next-geek/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1553160728126},{"_id":"themes/next-geek/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1553160728126},{"_id":"themes/next-geek/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1553160728126},{"_id":"themes/next-geek/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1553160728126},{"_id":"themes/next-geek/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1553160728126},{"_id":"themes/next-geek/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1553160728126},{"_id":"themes/next-geek/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1553160728126},{"_id":"themes/next-geek/source/lib/three/canvas_lines.min.js","hash":"a063db69fac7985b34b3174f835234ac8ef776ac","modified":1553160728126},{"_id":"themes/next-geek/source/lib/three/canvas_sphere.min.js","hash":"973e8c9904de841be8aac8530c1e56b7feb4e217","modified":1553160728126},{"_id":"themes/next-geek/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1553160728126},{"_id":"themes/next-geek/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1553160728130},{"_id":"themes/next-geek/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1553160728130},{"_id":"themes/next-geek/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1553160728130},{"_id":"themes/next-geek/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1553160728130},{"_id":"themes/next-geek/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1553160728130},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla3.png","hash":"36c87c8685e3ed57fb4af8dc4cf7fd52b84eb674","modified":1564076304123},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla4.png","hash":"e5608d78b5e27c51e53ba40666d7881d7c35e31d","modified":1564076304123},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla5.png","hash":"1df535a61c883749e0527303324e82be1562546b","modified":1564076304123},{"_id":"source/_posts/动态规划套路详解/4.png","hash":"555e84ea20382a764aef800d31b39b38b8d38313","modified":1564076304136},{"_id":"themes/next-geek/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1553160728126},{"_id":"themes/next-geek/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1553160728120},{"_id":"themes/next-geek/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1553160728120},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning/fol5.png","hash":"d733e073826e6adec2d009de5564b66b97e51b35","modified":1564076304146},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla1.png","hash":"1426508d18ae0303f315052c2f28d421608b5b0e","modified":1564076304123},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla6.png","hash":"408f80ee7f54152c7e40281c34cfe1e85bd8c8bc","modified":1564076304123},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla2.png","hash":"c8ea48a64cd32418b39f042373af6e6b0f11e9ee","modified":1564076304123},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla7.png","hash":"d533605a8e68fc0d39894576e9386ae85f987c3a","modified":1564076304123},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Types-of-Learning/tol3.png","hash":"45d97a574ae611634e30166ad5681b67f5f9bb82","modified":1564076304149},{"_id":"themes/next-geek/source/css/_common/components/back-to-top-sidebar.styl","hash":"d026c8489f66ab6c12ad04bd37f1d5b6f2f3f0d1","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/scaffolding/base.styl","hash":"a9c6355d6516af2e13254ec89e33e5b7dcf8ceb4","modified":1553160728123},{"_id":"themes/next-geek/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1553160728123},{"_id":"themes/next-geek/source/css/_common/outline/outline.styl","hash":"f2030fa436c47791d1a42358cc0ef6f9809f212c","modified":1553160728123},{"_id":"themes/next-geek/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1553160728123},{"_id":"themes/next-geek/source/css/_common/scaffolding/mobile.styl","hash":"86b6fd7f1b1be3ae98f8af6b23a6b1299c670ce9","modified":1553160728123},{"_id":"source/_posts/siRNA/论文笔记-基于机器学习的siRNA沉默效率预测方法研究/1-2.png","hash":"90bc2cda80317d102acecda7dee29080f5f2c174","modified":1571283401639},{"_id":"themes/next-geek/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1553160728123},{"_id":"source/_posts/siRNA/siRNA设计基础/1.png","hash":"5b6bf71dc6f2168d360e7c2b7412e1a5c7fc6244","modified":1570614374482},{"_id":"source/_posts/siRNA/siRNA设计基础/2.png","hash":"41cae14ca7c752768cda05f11bcf1f6b35bc3f52","modified":1570626695687},{"_id":"source/_posts/MachineLearning/MNIST入门-手写数字识别/sof1.png","hash":"d55fb0ab3d0770d04eba7dba3612e7e46267c080","modified":1564076304126},{"_id":"themes/next-geek/source/css/_common/scaffolding/normalize.styl","hash":"02fe53286d071637534d5aa2c57c76c168c0d521","modified":1568831487268},{"_id":"themes/next-geek/source/css/_schemes/Mala/_base.styl","hash":"03a30d72db15e61576d9cb12be2d3b91f1e52171","modified":1568830836679},{"_id":"themes/next-geek/source/css/_schemes/Mala/_footer.styl","hash":"46b7fbc74062166e718399bb2836e03d6e7a2d10","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/_header.styl","hash":"3b49f83af20fb435a6d519f7fd97a7a1b28355b3","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/_menu.styl","hash":"972b44bca7c402bcea2fb8fe855b84bb727a6729","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/_posts-callapsed.styl","hash":"eb14b58d2fb5c90f7cfbb7dd4d8fc357da653801","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/_posts-expanded.styl","hash":"7eb83b2585379e17c90839ffc746413d90e46e83","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/_posts-footer.styl","hash":"cfcd4a10834f1635e99e7e0924eba026f19513ed","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/_posts-copyright.styl","hash":"ab2a44eaac41942493ef3bece32f57bcaa715986","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/_suprise.styl","hash":"043aaeea87564f9c17ac295d33cbaff69e5472e2","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/index.styl","hash":"4091b4aecad70f9853643e232c0d16937b87e6d2","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Gemini/index.styl","hash":"bc8c388553bbcf95897459a466ba35bffd5ec5f0","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1553160728123},{"_id":"themes/next-geek/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1553160728126},{"_id":"themes/next-geek/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1553160728123},{"_id":"themes/next-geek/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1553160728126},{"_id":"themes/next-geek/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Pisces/_layout.styl","hash":"0af5a9322156c4c21d3c7d38f5ee48de5286f523","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Pisces/_sidebar.styl","hash":"f00d0a9ff02f6814011e0b613a2d9020911b5c58","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1553160728123},{"_id":"themes/next-geek/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1553160728126},{"_id":"themes/next-geek/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1553160728126},{"_id":"themes/next-geek/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1553160728126},{"_id":"themes/next-geek/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1553160728126},{"_id":"themes/next-geek/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1553160728130},{"_id":"themes/next-geek/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1553160728123},{"_id":"themes/next-geek/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1553160728130},{"_id":"themes/next-geek/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1553160728123},{"_id":"themes/next-geek/layout/_partials/suprise/ball.swig","hash":"53a4d6d81c07e36d83f156238d17ba363cc36ccf","modified":1553160728120},{"_id":"themes/next-geek/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1553160728123},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning/fol4.png","hash":"118915e165cc067c5f191b2a7c6e2f49c40d9612","modified":1564076304146},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning/fol3.png","hash":"33369d899a827575c512ba5adccac152e2e15677","modified":1564076304146},{"_id":"source/_posts/动态规划套路详解/1.png","hash":"3121f0aa272c31f28a5c8d467a5615ae305e5b78","modified":1564076304133},{"_id":"source/_posts/动态规划套路详解/3.png","hash":"7ea702841eaeb5d7ba2b40f11bd0921b0031dd46","modified":1564076304143},{"_id":"source/_posts/动态规划套路详解/7.png","hash":"be465399af8136ddfb14d9ce19c46076b2282322","modified":1564076304133},{"_id":"themes/next-geek/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1553160728123},{"_id":"themes/next-geek/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1553160728126},{"_id":"themes/next-geek/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1553160728126},{"_id":"themes/next-geek/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1553160728130},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning/fol2.png","hash":"a7603ac08c8ab02a82897fd0eb6009ef744856e7","modified":1564076304146},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning/fol1.png","hash":"33d442e848eb64229ef3814eb848f9f382b9148d","modified":1564076304146},{"_id":"themes/next-geek/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-reward.styl","hash":"ee554b1031ef0070a5916477939021800e3c9d27","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1553160728120},{"_id":"source/_posts/动态规划套路详解/5.png","hash":"f2393eaccbf66ad5db32cec53b322def6ae29df0","modified":1564076304139},{"_id":"themes/next-geek/source/css/_common/components/post/post.styl","hash":"e6680feea343cecbdde8d643c777d689742abc28","modified":1554616589677},{"_id":"themes/next-geek/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1553160728120},{"_id":"source/_posts/动态规划套路详解/6.png","hash":"69c97e1ef82c380ea3d299303ad96b8508b600cc","modified":1564076304139},{"_id":"themes/next-geek/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"65a64d5662637b66e2f039a5f58217afe7a6e800","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/sidebar/sidebar.styl","hash":"57d2c8a060f5e4e1a0aef9aae11a0016cf7ac5ba","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1553160728120},{"_id":"themes/next-geek/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1553160728123},{"_id":"themes/next-geek/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/tags/note-modern.styl","hash":"45df0cf4c97b47e05573bcd41028ee50f3fdf432","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1553160728120},{"_id":"themes/next-geek/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1553160728123},{"_id":"themes/next-geek/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/comments/_hypercomments.styl","hash":"86d8af5a3b629741aa888a85357a9eb406d7e8fd","modified":1553160728123},{"_id":"themes/next-geek/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1553160728126},{"_id":"themes/next-geek/source/css/_common/components/third-party/third-party.styl","hash":"aeff0e6e23725e8baea27c890ccbbf466024f767","modified":1564091134579},{"_id":"themes/next-geek/source/css/_schemes/Mala/sidebar/sidebar-author-links.styl","hash":"59a981584dc87ebd5320680ed069083481145407","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/sidebar/sidebar-author.styl","hash":"88563638954bc2c0aac9a0eda4672d5509633d82","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mala/sidebar/sidebar-blogroll.styl","hash":"2947d7e612db21211b6b478f7adb133eebec2f66","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1553160728123},{"_id":"themes/next-geek/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1553160728123},{"_id":"themes/next-geek/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1553160728123},{"_id":"themes/next-geek/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1553160728123},{"_id":"themes/next-geek/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1553160728123},{"_id":"themes/next-geek/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1553160728126},{"_id":"themes/next-geek/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1553160728126},{"_id":"themes/next-geek/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1553160728126},{"_id":"themes/next-geek/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1553160728126},{"_id":"themes/next-geek/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1553160728123},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Types-of-Learning/tol1.png","hash":"5cfe8e4b80a44a2ad346824270636da79425e982","modified":1564076304149},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Types-of-Learning/tol2.png","hash":"3048a9c77da8beefc4d0d3516c9574a47baecb99","modified":1564076304149},{"_id":"source/_posts/动态规划套路详解/2.png","hash":"bfdb94b8d7ad3d7331e82eaeb7968a82dc88d0fd","modified":1564076304136},{"_id":"themes/next-geek/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1553160728126},{"_id":"themes/next-geek/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1553160728130},{"_id":"themes/next-geek/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1553160728126}],"Category":[{"name":"Daily","_id":"ck2424lk00003lksb55xyudi0"},{"name":"Notes","_id":"ck2424lk90008lksbvvtywjo5"},{"name":"Linux","_id":"ck2424lki000dlksbuwhzzz0q"},{"name":"MachineLearning","_id":"ck2424lly0030lksbimc7hwlc"},{"name":"LeetCode","_id":"ck2424lt3005alksbp4rhykr0"},{"name":"NowCoder","_id":"ck2424lui0082lksbzeorbnli"},{"name":"机器学习基石","parent":"ck2424lly0030lksbimc7hwlc","_id":"ck2424m3s00o2lksbv571a9wy"}],"Data":[{"_id":"next","data":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}],"Page":[{"title":"LeetCode","date":"2019-10-17T01:47:45.000Z","type":"LeetCode","comments":0,"_content":"","source":"LeetCode/index.md","raw":"---\ntitle: LeetCode\ndate: 2019-10-17 09:47:45\ntype: \"LeetCode\"\ncomments: false\n---\n","updated":"2019-10-17T01:52:26.119Z","path":"LeetCode/index.html","layout":"page","_id":"ck2424ljx0001lksb472bfq6u","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"","more":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><!-- rebuild by neat -->"},{"title":"about","date":"2018-09-07T13:18:25.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-09-07 21:18:25\n---\n","updated":"2019-07-25T21:56:38.711Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck2424llq002olksbcijrx5yr","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"","more":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><!-- rebuild by neat -->"},{"title":"archives","date":"2018-09-07T13:18:42.000Z","type":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2018-09-07 21:18:42\ntype: \"archives\"\n---\n","updated":"2019-03-17T07:51:35.767Z","path":"archives/index.html","comments":1,"layout":"page","_id":"ck2424lls002qlksbillgy1n0","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"","more":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><!-- rebuild by neat -->"},{"title":"categories","date":"2018-09-07T13:18:15.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-09-07 21:18:15\ntype: \"categories\"\ncomments: false\n---\n","updated":"2019-07-25T21:55:25.600Z","path":"categories/index.html","layout":"page","_id":"ck2424lqj004rlksbmpi19hbf","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"","more":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><!-- rebuild by neat -->"},{"title":"tags","date":"2018-09-07T13:17:15.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-09-07 21:17:15\ntype: \"tags\"\ncomments: false\n---\n","updated":"2019-07-25T21:56:16.054Z","path":"tags/index.html","layout":"page","_id":"ck2424lql004slksb2cxe9478","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"","more":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><!-- rebuild by neat -->"}],"Post":[{"title":"Archlinux的灵魂──PKGBUILD、AUR 和 ABS","comments":1,"mathjax":false,"date":"2019-07-26T09:57:00.000Z","urlname":"archlinux-pkgbuild-aur-and-abs","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n转自[Archlinux 的灵魂──PKGBUILD、AUR 和 ABS](https://blog.csdn.net/taiyang1987912/article/details/41457333)\n\n觉得看完对深入理解Arch很有帮助.\n{% endnote %}\n<!--more-->\n\n## 第一部分:PKGBUILD 和 makepkg\n其实，我使用 Archlinux 的时间并不是很长。可是，就是在这半年的时间内，我感觉我学到了很多的东西，对 GNU/Linux 有了更多的了解，也在这个过程中深深地爱上了 Archlinux 这个发行版。\n\n首先声明一下，我不是一个程序员，从来没有写过真正的 Code，顶多是写一点 scripts，或者做一些简单的网页什么的。和很多人一样，我对计算机的接触是从 DOS/Windows 开始的。\n\nWindows 的图形界面很容易学。可是时间长了，Windows 就会运行的越来越慢，我的硬盘上也就会有很多我根本不知道是什么的东西。而且，在 Windows 上很多东西都是设定好的，改变起来非常不容易。不要跟我提注册表，那个东西实在是让我一头雾水。\n\n还有，大部分 Windows 上的软件都不是自由软件。这意味着人们很难了解这些软件内部的情況，你可能在毫无察觉的情况下就中了病毒或木马。\n\n所以，为了能够完全了解和控制我每天工作生活要用的计算机，我开始学着使用 GNU/Linux。我一开始是用 Mandriva（那个时候还叫 Mandrake Linux）。后来是 Ubuntu（也包括其他一些 Debian 为基础的发行版）。\n\nWow！我一用上 Ubuntu 就有了完全不同的感觉。特别是非常好用的 apt-get，加上庞大的自由软件库，让我大开眼界。可是在使用 Ubuntu 一段时间以后，我发现这个平台实在和 Windows 非常相似。\n\nGnome 和 KDE 的界面都是在模仿 Windows。更糟糕的是，Ubuntu 会在一开始安装一些乱七八糟的东西，大大影响了我的电脑的运行速度。\n\n我需要一点一点把我不用的东西去掉，这个过程真的很不爽。我开始问自己为什么要放弃 Windows 呢？\n\nUbuntu 有一个很大很好的用户社区，很多问题都可以在讨论区得到解决。然而，Ubuntu 的用户完全要依赖 Maintainer。我就有过这样的经历，在发现一个 Bug 后得到很多其他人的确定，可是 Maintainer 迟迟不作修改。还有，也许有很多人都很想用一个比较新的软件，但是大家都要等到有人能够而且愿意作 Maintainer 之后，这个软件才会在 Repository 里出现。\n\n我或许能够在调试后自己从源代码编译，可是我要如何和别人分享我的成果呢？\n\n其实，各种 Linux 发行版在本质上没有什么不一样。大家使用的软件都是要从源代码编译生成可以运行的二进制码。如果没有 rpm、apt-get 或者 pacman，我们也是可以快乐生活的。只不过，我们的生活会变得麻烦一些。如果要从源码安装一个软件，我们通常是要做如下的步骤：wget http://somewhere.org/source/package.tar.gz（下载源代码）tar xvzf package.tar.gz （解压缩）cd package （进入源代码目录）./configure （设定）make （编译）make install （安装）\n\n如果我们要像这样安装一个两个软件是没有什么问题的。但是如果我们要对付成百上千的软件／类库的话，这样的土办法是行不通的。于是出现了不同的 Linux 发行版，他们之间的区别只是在于如何管理成百上千的软件，特别是不同软件／类库之间互相依存的关系，也就是 dependency 的问题。\n\n大多数 Linux 发行版都是以二进制包为基础的，这其中又分 Redhat（还有 SUSE、Fedora 等）、Debian（还有 Ubuntu、PCLinux 等）和 Slackware 阵营。为了解决管理大量软件包的问题，这些发行版采取了这样一个办法。他们找了一群大牛程序员来作 Maintainer，这些 Maintainer 负责把源代码编译成二进制码，加上一些控制信息（比如如何安装、dependency 等），然后一起打包放在服务器上。所以，最终用户根本不用接触源代码。如果你有兴趣的话，你可以抓一个 Debian 的 DEB 文件下来研究一下：wget http://somewhare.org/package.debar vx package.deb\n\n你会发现你多了三个文件：debian-binarycontrol.tar.gzdata.tar.gz\n\n然后再用 tar tzvf 命令看一看 control.tar.gz 和 data.tar.gz 里面有什么东东，你就明白神奇的 dpkg/apt-get 是怎么一回事情了。\n\n二进制包固然是很方便，但是这种办法有一个很大的问题。\n那就是最终用户受到 Maintainer 很大的控制。比如说，我们并不知道 Maintainer 在编译的过程中是如何设定的（./configure）。\n如果我们要用不同的设定，就要自己从源代码从头开始。另外，如果某一个 Maintainer 心术不正，在二进制包里面加了木马程序，我们这些最终用户是很难查觉的。\n还有，设想一下如果某一个 Maintainer 外出休假了，那么你的软件也就不能及时更新了。\n\n所以，也有一些发行版采取了完全不同的办法，这些发行版是以源代码为基础的。\nGentoo 就是其中的代表。如果你用过 Gentoo 你就会知道 ebuild 文件。\n你如果有兴趣，可以从 http://gentoo-package.com 抓一个 ebuild 文件研究一下。你会明白 Gentoo 的用户其实从 Gentoo 得到的只有这些 ebuild 文件，在每一个 ebuild 文件里包含了安装使用一个软件需要的所有信息（从哪里下载源代码、如何编译、如何安装还有 Dependency 的问题等）。\n之后，Gentoo 的用户用 emerge 命令按照 ebuild 文件的指示编译、安装一个软件。这样做的好处是，Gentoo 的用户可以一目了然地了解每一个软件的编译、安装的过程。如果需要的话，Gentoo 的用户可以修改 ebuild，按照自己的需要编译一个软件。\n\n我也用过 Gentoo。不过对于我这样的初学者，Gentoo 实在是太复杂了，有太多的参数要设定，ebuild 的编写也不是那么简单。还有，Gentoo 几乎不提供任何二进制包，所以绝大部分的软件都要从源代码编译，这是一个非常慢的过程。\n\n其实在大部分情况下，用户对一些软件的设定都是差不多的，没有必要让每一个 Gentoo 的用户都从头编译。所以，我需要找到一个发行版，既有 Debian 的易用性，又有 Gentoo 的灵活性。\n\n我因此找到了 Archlinux。那么 Archlinux 又是如何解决从源代码到二进制码的问题呢？\nArchlinux 使用了 makepkg 这样一个工具。makepkg 会按照 PKGBUILD 文件生成一个二进制包。有些时候，makepkg 还需要 install 文件（主要用来显示提示信息、备份用户设置等）和其他的配置文件。\n\n那么 PKGBUILD 是什么呢？\nPKGBUILD 和 Gentoo 的 ebuild 一样，包含了安装使用一个软件需要的所有信息。下面是 dwm（一个非常非常简捷、高效的窗口管理器）的 PKGBUILD 文件：\n\n```\npkgname=dwm 软件名称\npkgver=4.7\n\npkgrel=1 版本信息\npkgdesc=\"A dynamic window manager for X\"\n\nurl=\"http://www.suckless.org/wiki/dwm\" 软件说明和网站\narch=('i686' 'x86_64') 适用平台\nlicense=('MIT') 版权\ndepends=('libx11') Dependency\n\ninstall=dwm.install install 文件\nsource=(http://www.suckless.org/download/$pkgname-$pkgver.tar.gz \\\n    config.h) 要下载的源文件\nmd5sums=('827b128514a3edb87e208e84fee0eb3f'\n         '395e9a25f65605c4891e74c644b91530') md5 验证码\n\nbuild() { cd $startdir/src/$pkgname-$pkgver\n\ncp ../config.h .\n\nmake X11INC=/usr/include/X11 X11LIB=/usr/lib/X11 || return 1 make PREFIX=/usr DESTDIR=$startdir/pkg install || return 1\n\ninstall -m644 -D LICENSE $startdir/pkg/usr/share/licenses/$pkgname/LICENSE && \\ install -m644 -D README $startdir/pkg/usr/share/doc/$pkgname/README } 编译的过程 \n```\n\n我们可以注意到在“编译的过程”这个部分，很多代码都和我们在 shell 里编译的命令一样。对！Archlinux 不要求用户学习太多新的东西，PKGBUILD 很容易理解，因为里面都是基本的 shell 命令。\n\n好，我们把 PKGBUILD，dwm.install 和 config.h（dwm 比较特殊，config.h 包含所有的配置信息，所以要在编译之前提供。其他的软件大多依靠外部的配置文件，像是 .bashrc 等）放在一个新的目录里之后。我们执行：\n\n```\n$ makepkg\n```\n\n之后，你会发现这个目录里出现了一些新的东西，包括：dwm-4.7-1-x86_64.pkg.tar.gz dwm-4.7.tar.gz 两个文件，还有两个目录srcpkg\n\n通过比较这些文件、目录里的内容和 PKGBUILD，你就会明白 makepkg 到底做了些什么：\n\n1. 根据 source 里的内容下载了源代码文件 dwm-4.7.tar.gz；\n1. 通过 md5 验证码确定下载的源代码文件和 PKGBUILD 的作者使用的是一致的；\n1. 把源代码文件解压缩到 ./src/$pkgname-$pkgver （也就是 ./src/dwm-4.7）；\n1. 按照 build() 里的内容编译源代码，并把编译好的内容放在 ./pkg 里；\n1. 在 ./pkg 里加上其他的一些信息，包括 .PKGINFO 和 .INSTALL，也就是 dwm.install 的拷贝；\n1. 把 ./pkg 里面的内容打包形成 dwm-4.7-1-x86_64.pkg.tar.gz。\n\n那么，我们有了一个 .pkg.tar.gz 这样一个二进制包之后，我们要如何安装呢？我们要使用这样一个命令：\n\n```\n$ pacman -U dwm-4.7-1-x86_64.pkg.tar.gz\n```\n\n这个命令又完成了那些事情呢？\n\n1. 首先，二进制包被解压缩；\n1. 按照 .INSTALL 的内容执行一定的命令；\n1. 二进制包里面的内容会被拷贝到相应的目录（你注意到二进制包内的目录结构了吗？）；\n1. 在 /var/lib/pacman/local 这个目录中建立 dwm-4.7-1 这样一个目录；\n1. 这个目录里包含了四个文件 depends、desc、files 和 install;\n1. depends 记录了 dependency，desc 是软件说明，files 记录了每一个安装到系统上的文件的路径，install 就是 .INSTALL 的拷贝。\n\n从这以后，pacman 正是通过检查 /var/lib/pacman/local 里的内容来管理软件包的。比如说，在执行 pacman -R dwm 的过程中，pacman 首先在 /var/lib/pacman/local 找到了 dwm-4.7-1 这个目录，然后根据 files 的内容删除已安装的内容。Dependency 也是通过 depends 计算的。\n\nOK！我已经解释了 PKGBUILD 的基本结构和 makepkg 的过程。\n\n基本上是两步：从 PKGBUILD 到 .pkg.tar.gz 包，再从二进制包安装到系统。这样一种办法有很多好处。首先，PKGBUILD 非常方便用户交流。我的一个 PKGBUILD 如果编译成功了，就可以给别人用。PKGBUILD 的内容一目了然，不但有助于学习，也再不用担心木马的问题了。\n\n另外，我通过一个小例子展现 Archlinux 的灵活性在哪里。比如，我要对 dwm 有自己的设置，也就是自己的 config.h，那我应该怎么做呢？我会做如下的事情：\n1. 编辑 config.h，另存为 myconfig.h；\n1. 编辑 PKGBUILD，把所有的 config.h 替换为 myconfig.h；\n1. 把 pkgrel 变成 2。\n\n之后通过 makepkg，我会得到一个文件 dwm-4.7-2-x8664.pkg.tar.gz，这个和原来的 dwm-4.7-1-x8664.pkg.tar.gz 可以区别开。我可以安装 dwm-4.7-2-x8664.pkg.tar.gz，如果有问题我还可以通过 pacman -U dwm-4.7-1-x8664.pkg.tar.gz 来安装原来的二进制包。我还可以用同样的办法生成一系列的 .pkg.tar.gz 包，这在软件的安装调试过程中非常有用。\n\n好了，今天就讲到这里。有些人也许变得更疑惑了，因为在 TOY 的“打造完美的 Linux 桌面 — Arch Linux 2007.08-2”系列中并没有提到 PKGBUILD 的问题，所有的软件都是通过 pacman -S 来安装的。\n\n没关系，如果你理解了 makepkg 和 PKBGUILD，那么在我下一次谈到 AUR 和 ABS 之后，你就能完全明白了。\n\n实例:\n\n```\n# Maintainer: Sven-Hendrik Haase <sh@lutzhaase.com>\n# Contributor: jepaan <jepaan at hotmail dot com>\n\npkgname=client\npkgver=1.0\npkgrel=1\npkgdesc=\"tools\"\narch=('i686' 'x86_64')\nlicense=('MIT')\ndepends=('qt4' )\nmakedepends=('qt4')\ninstall=${pkgname}.install\nurl=('')\nsource=(\"./${pkgname}-${pkgver}.tar.gz\")\nmd5sums=('SKIP')\n\nbuild() {\n    cd ${srcdir}/${pkgname}-${pkgver}\n    qmake-qt4\n    make\n}\n\npackage()  {\n    cd ${srcdir}/${pkgname}-${pkgver}\n    #make PREFIX=/usr DESTDIR=$pkgdir install\n    mkdir -p ${DESTDIR}${PREFIX}/bin\n    mkdir -p ${pkgdir}/usr/share/icons\n    mkdir -p ${pkgdir}/usr/share/applications\n    install -Dm755 client ${pkgdir}/usr/bin/client\n    install -Dm755 ${srcdir}/client_logo.png  ${pkgdir}/usr/share/icons/\n    install -Dm644 ${srcdir}/client.desktop ${pkgdir}/usr/share/applications/client.desktop\n}\n\npre_remove() {\n  pid=`ps -ef | grep client | grep -v grep | grep -v pacman | awk '{print $2}'`\n  if [ -n \"$pid\" ]; then\n    kill -9 \"$pid\"\n  fi\n}\n```\n\n```\n$ makepkg -p PKGBUILD_client  或 makepkg -f -p PKGBUILD_client\n```\n\n## 第二部分：AUR 和 ABS\n我非常高兴看到我关于 PKGBUILD 和 Makepkg 的文章在 LinuxTOY 受到了欢迎。我想先针对一些读者的回复谈一点题外话。\n\n我先声明我一点也没有要诋毁 Debian 或 Gentoo 的意思，他们都是非常伟大的发行版，都有自己的特色。其实大多数的发行版都可以自己去定制，从而达到类似的目的。比如说，有的人提到 Gentoo 也有二进制包，比如像 Openoffice 这样的怪物。\n\n然而，我个人以为比较不同的发行版关键是要看它最核心的设计思想。比如说，Gentoo 根本就不是为了使用二进制包设计的。你要是都想用二进制包，就别费劲用 Gentoo 了。关于 Debian 阵营的发行版，我也想讲几句。正如一些朋友的回复所讲，DEB/apt-get 是非常好的管理工具，软件库也非常的大。\n\n我的笔记本现在还在用 elive，也是 Debian 的分支。我不喜欢 Debian 系列的发行版的原因不是它不能定制，而是他们非常依靠 Maintainer。我们可以自己做 DEB 包，然后呢？你的 DEB 包什么时候才能进入软件库呢？还有，只有你自己知道你的 DEB 是怎么做的，别人不能了解你编译打包的过程。Debian 本身打包的过程没有 Archlinux 的 PKGBUILD 来的简单明了。只要比较 Debian 的 Maintainer 手册和 Archlinux 的 Wiki 就可以看出这一点。\n\n选择什么样的发行版完全是要看个人需要。\n我选择 Archlinux，是因为它当初设计的时候就是要满足“KISS Rule”，也就是“Keep It Simple, Stupid”。或者说像爱因斯坦讲得：“Everything should be made as simple as possible, but no simpler”。Archlinux 的所有配置基本都是非常相似的脚本，加上简单灵活的 PKGBUILD 和 pacman，其实关于 Archlinux 本身真的没有太多新的东西要学习。大家有兴趣可以看看“Arch Compared To Other Distros”。\n\nArchlinux 实际上是强迫用户从零开始自己定制自己的系统，在这个过程中也就真正了解了 Linux 本身。\n\n好了，现在言归正传谈一谈 AUR 和 ABS。\n\nAUR 是指 Archlinux User-community Repository，也就是 Archlinux 用户社区的软件库。我们现在回忆一下在 Archlinux 中我们把源代码变成可以运行的二进制码需要哪些文件。我们需要：PKGBUILD，可能还有 .install 文件，加上一些补丁和必要的配置文件（像 dwm 的 config.h）。这样就足够了！当你成功使用 PKGBUILD 编译安装了一个新软件之后就可以通过 AUR 和其他的人分享你的成果了。具体的步骤是：\n1. tar -zcvf package.tar.gz package-dir 把 package-dir 中所有所需的文件打包（包括 PKGBUILD，.install，patch 和其他的 config 等）\n1. 前往 [http://aur.archlinux.org](http://aur.archlinux.org) 选择\"Submit”（参照下图），并把你的 package.tar.gz 上传\n\nAUR 会自动根据你的 PKGBUILD 内容把你的 Package 加到 AUR 里来。就是这么简单！那么有人会问：“别的用户要如何使用 AUR 呢？”\n\n这个就更简单了，我们还是用一张截图来解释：\n1. 首先下载“Tarball”（红色的圈圈），这个 Tarball 和你上传的内容是一样的，无非是 PKGBUILD 什么的；\n1. tar xvzf package.tar.gz 然后解压缩；\n1. 然后的步骤你应该知道了，那就是 makepkg 还有 pacman -U。\n\n之后又要如何使用 ABS 呢？ABS 所作的事情无非是把所有 Repo 里的软件的 PKGBUILD 下载到你本地的硬盘中。这些 PKGBUILD 都放在了 /var/abs 中。你能通过 pacman 直接安装的二进制包其实也都是按照 ABS 的内容编译的。下面我还是用 dwm 的例子解释 ABS 的使用：\n```\nsu\n$ cd /var/abs 你可以看到这个目录里有 core，extra，community 三个子目录，正如 abs.conf 中的设定；\n$ mkdir local 建立一个 local 目录，用来放你自己需要的软件的 PKGBUILD\n$ chown username:usergroup ./local makepkg 要以非 root 身份进行\n$ exit 退出 su\n$ cd local\n$ cp -r ../community/x11/dwm ./ 从 ABS 中拷贝 dwm 的内容\n$ cd dwm\n```\n\n下面不用我说了，你在这个目录里可以看到三个文件 PKGBUILD、dwm.install、config.h。你于是可以用 makepkg 和 pacman -U 来按照自己喜欢的方式安装 dwm。\n\nOK，你实际已经清楚了解了 ABS 和 pacman 的关系，那么 AUR 又和 ABS 还有 pacman 有什么联系呢？说的直白一点，你上传到 AUR 的 PKGBUILD 要足够“有品”才能直接通过 pacman 使用。\n\n对于“有品”，我是这样定义的。\n你的 PKGBUILD 要有很多人用（很多人投票），没有恶意代码，没有太多的 Bug……而判定你的 PKGBUILD 够不够“有品”的人是一些叫作 TU（Trusted User）的人。这些人的工作是检查 AUR，关注那些特别受欢迎的 PKGBUILD。之后，他会仔细检查，确定这些 PKGBUILD 是不是安全。\n然后，他们会给这些 PKGBUILD 打上安全的标签，并且把这些 PKGBUILD 从 unsupported（我们上传的 PKGBUILD 一开始都是在 unsupported 中）移到 community 的 Repo 中。\n\n在 community repo 里面的 PKGBUILD 会提前编译好，如果你在 /etc/pacman.conf 中开了 community repo，你就可以直接使用这些软件的二进制包了。\n也许有一天，你当初上传的 PKGBUILD 变得特别重要，这个软件可能被移到 testing，extra 或者 core 的 repo 中。补充一点，testing repo 里面一般是需要测试，又准备放到 core 或者 extra 中的软件。\n\nArchlinux 就是这样，非常灵活。既有 pacman 这样好的二进制包管理工具，又有 ABS 和 AUR 这样方便的源代码服务。通过 ABS，你可以完全控制你自己的系统到底是如何建立的。\n如果在 pacman -Ss 的时候找不到一个软件，你可以到 AUR 去找，如果还是找不到，为什么不自己试着从源代码开始，写一个 PKGBUILD 然后放到 AUR 中和别人分享呢？\n\n说到这里，我希望我已经把 Archlinux 最核心的东西讲明白了。\n有些人说我的文章写得比 wiki 里的文章清楚。其实，我写的东西只是在順序上不一样。我是从 PKGBUILD 开始讲到 AUR 和 ABS，再到 pacman。\n这个順序和 Archlinux 实际的开发过程是一致的，所以逻辑上容易理解很多。如果你从 pacman 入手反过来读，你可能就完全错过了理解 Archlinux 核心概念的机会。\n\nTOY 会很快再写一篇关于 yaourt 的文章，yaourt 是一个把 pacman 和 AUR 结合起来的很好用的工具。\n有了 yaourt，你不需要去 AUR 网站也能在 shell 下直接取得 AUR 的 package，还方便了投票的过程。\n\n如果大家对某些问题感兴趣，可以留言告诉我，我会尽量把我了解的用这样比较容易理解的文章与大家交流。\n\n## 第三部分：Yaourt\n在这一部分中，我们将简单介绍 Yaourt 的安装和使用。此部分上接 PKGBUILD 和 makepkg、AUR 和 ABS。\n\n就一般情况而言，当 Archlinux 用户需要使用 AUR 中的包时，往往会执行到[AUR 官方网站](http://aur.archlinux.org/packages.php)查找所需的包、下载该包的 Tarball 文件、在命令行下对 Tarball 文件解压、通过 makepkg 编译打包、最后使用 pacman 安装这样一个过程。\n\n仔细打量这个过程，你是否觉得稍微有些繁琐呢？有解决的方案吗？回答是肯定的。这就是我们今天将要介绍的主角──[Yaourt](http://archlinux.fr/yaourt-en)。\n\n### Yaourt 简介\nYaourt 是一个由 Julien Mischkowitz 所编写的 Bash 脚本，它是将 Pacman 与 AUR 这两者相结合的绝佳工具。\n通过 Yaourt 安装 AUR 中的包十分方便，它不仅简化了上述繁琐的过程，而且把这一过程半自动化，使用者只需在它的交互模式中简单的回答几个问题即可。此外，Yaourt 支持将结果以鲜亮的颜色输出，非常抢眼。\n\n### 安装 Yaourt\n除了在 Archlinux 的 AUR 中可以找到 Yaourt 外，archlinuxfr 这个源中也包含 Yaourt。我们采用后者来安装 Yaourt。首先，将下列内容添加到 /etc/pacman.conf 文件：[archlinuxfr]Server = http://repo.archlinux.fr/i686\n\n如果你的系统是 64 位，那么可以使用：[archlinuxfr]Server = http://repo.archlinux.fr/x86_64\n\n接着，我们可以执行下面的命令来安装 Yaourt：\n\n```\n$ pacman -Sy yaourt\n```\n\n另外，我们将 aurvote 和 customizepkg 这两个包也装上，前者用于对喜欢的包投票，而后者是定制 PKGBUILD 所需的：\n\n```\npacman -S aurvote customizepkg\n```\n同时，你需要为 aurvote 建立一个配置文件 .aurvote (位于 ~/ 目录下)：user=你的 AUR 帐号pass=该帐号的密码\n\n如果你没有 AUR 帐号，可到 [http://aur.archlinux.org/account.php](http://aur.archlinux.org/account.php)注册一个。\n\n### Yaourt 实战\n为了说明 Yaourt 的使用，我们以一个实例来进行。譬如，我对 Phatch 这个批量图片处理程序非常喜欢，我希望在 Archlinux 中安装它。首先，我们来看一下，在 Archlinux 中是否存在 Phatch：\n\n```\n$ yaourt phatch\nYaourt 在搜索后返回如下结果：1 aur/phatch 0.1.bzr435-1 Phatch is a simple to use cross-platform GUI Photo Batch Processor.==> Enter n° (separated by blanks, or a range) of packages to be installed Example: '1 6 7 8 9' or '1 6-9'==> ----------------------------------------------\n```\n\n从该结果我们可以断定，Phatch 在 Archlinux 的 AUR 中。现在，我们只需按 1 就可以安装它了。\n\n在显示一些输出信息后，Yaourt 会让你作出第一个选择：\n\n```\n是否编辑 PKGBUILD 文件。\n按 Y 回答并输入你喜欢的文本编辑器后，你可以针对 PKGBUILD 的内容进行修改。\n==> Edit the PKGBUILD (recommended) ? [Y/n] (\"A\" to abort)\n==> ----------------------------------------------\n```\n\n然后，Yaourt 会询问是否继续编译。我们的回答当然是 Y。\n\n```\n==> Continue the building of 'phatch'? [Y/n]\n==> ----------------------------------------------\n```\n\n接着，Yaourt 询问是否安装已编译好的包，同样回答 Y 即可。\n\n```\n==> Continue installing 'phatch'? [Y/n]\n==> [v]iew package contents [c]heck package with namcap\n==> ----------------------------------------------\n```\n\n最后，Yaourt 将检查投票情况，并问你是否要投票，按 Y 选择投票，按 n 表示不投票。\n\n```\n==> Checking for phatch's vote statusYou have already voted for phatch inclusion/keeping in [community]\n```\n\n综观 Yaourt 的命令行选项，与 Pacman 非常相似。关于 Yaourt 的更加详细的用法，通过 man yaourt 可以获得参考。其实，除了从 AUR 安装包外，Yaourt 也可以从 Archlinux 的源安装包，此不赘述。\n\n### 参考：\nPKGUILD：[https://wiki.archlinux.org/index.php/PKGBUILD_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29](https://wiki.archlinux.org/index.php/PKGBUILD_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29)\n\nABS：[https://wiki.archlinux.org/index.php/Arch_Build_System_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29](https://wiki.archlinux.org/index.php/Arch_Build_System_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29)\n\nArchlinux：[https://linuxtoy.org/archives/archlinux-pkgbuild-aur-and-abs.html](https://linuxtoy.org/archives/archlinux-pkgbuild-aur-and-abs.html)\n\npkg.tar.xz包:[http://ftp.isoft.zhcn.cc/](http://ftp.isoft.zhcn.cc/)\n\n","source":"_posts/Archlinux的灵魂──PKGBUILD、AUR-和-ABS.md","raw":"---\ntitle: Archlinux的灵魂──PKGBUILD、AUR 和 ABS\ntags:\n  - ArchLinux\n  - PKGBUILD\n  - AUR\n  - ABS\ncategories:\n  - Daily\ncomments: true\nmathjax: false\ndate: 2019-07-26 17:57:00\nurlname: archlinux-pkgbuild-aur-and-abs\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n转自[Archlinux 的灵魂──PKGBUILD、AUR 和 ABS](https://blog.csdn.net/taiyang1987912/article/details/41457333)\n\n觉得看完对深入理解Arch很有帮助.\n{% endnote %}\n<!--more-->\n\n## 第一部分:PKGBUILD 和 makepkg\n其实，我使用 Archlinux 的时间并不是很长。可是，就是在这半年的时间内，我感觉我学到了很多的东西，对 GNU/Linux 有了更多的了解，也在这个过程中深深地爱上了 Archlinux 这个发行版。\n\n首先声明一下，我不是一个程序员，从来没有写过真正的 Code，顶多是写一点 scripts，或者做一些简单的网页什么的。和很多人一样，我对计算机的接触是从 DOS/Windows 开始的。\n\nWindows 的图形界面很容易学。可是时间长了，Windows 就会运行的越来越慢，我的硬盘上也就会有很多我根本不知道是什么的东西。而且，在 Windows 上很多东西都是设定好的，改变起来非常不容易。不要跟我提注册表，那个东西实在是让我一头雾水。\n\n还有，大部分 Windows 上的软件都不是自由软件。这意味着人们很难了解这些软件内部的情況，你可能在毫无察觉的情况下就中了病毒或木马。\n\n所以，为了能够完全了解和控制我每天工作生活要用的计算机，我开始学着使用 GNU/Linux。我一开始是用 Mandriva（那个时候还叫 Mandrake Linux）。后来是 Ubuntu（也包括其他一些 Debian 为基础的发行版）。\n\nWow！我一用上 Ubuntu 就有了完全不同的感觉。特别是非常好用的 apt-get，加上庞大的自由软件库，让我大开眼界。可是在使用 Ubuntu 一段时间以后，我发现这个平台实在和 Windows 非常相似。\n\nGnome 和 KDE 的界面都是在模仿 Windows。更糟糕的是，Ubuntu 会在一开始安装一些乱七八糟的东西，大大影响了我的电脑的运行速度。\n\n我需要一点一点把我不用的东西去掉，这个过程真的很不爽。我开始问自己为什么要放弃 Windows 呢？\n\nUbuntu 有一个很大很好的用户社区，很多问题都可以在讨论区得到解决。然而，Ubuntu 的用户完全要依赖 Maintainer。我就有过这样的经历，在发现一个 Bug 后得到很多其他人的确定，可是 Maintainer 迟迟不作修改。还有，也许有很多人都很想用一个比较新的软件，但是大家都要等到有人能够而且愿意作 Maintainer 之后，这个软件才会在 Repository 里出现。\n\n我或许能够在调试后自己从源代码编译，可是我要如何和别人分享我的成果呢？\n\n其实，各种 Linux 发行版在本质上没有什么不一样。大家使用的软件都是要从源代码编译生成可以运行的二进制码。如果没有 rpm、apt-get 或者 pacman，我们也是可以快乐生活的。只不过，我们的生活会变得麻烦一些。如果要从源码安装一个软件，我们通常是要做如下的步骤：wget http://somewhere.org/source/package.tar.gz（下载源代码）tar xvzf package.tar.gz （解压缩）cd package （进入源代码目录）./configure （设定）make （编译）make install （安装）\n\n如果我们要像这样安装一个两个软件是没有什么问题的。但是如果我们要对付成百上千的软件／类库的话，这样的土办法是行不通的。于是出现了不同的 Linux 发行版，他们之间的区别只是在于如何管理成百上千的软件，特别是不同软件／类库之间互相依存的关系，也就是 dependency 的问题。\n\n大多数 Linux 发行版都是以二进制包为基础的，这其中又分 Redhat（还有 SUSE、Fedora 等）、Debian（还有 Ubuntu、PCLinux 等）和 Slackware 阵营。为了解决管理大量软件包的问题，这些发行版采取了这样一个办法。他们找了一群大牛程序员来作 Maintainer，这些 Maintainer 负责把源代码编译成二进制码，加上一些控制信息（比如如何安装、dependency 等），然后一起打包放在服务器上。所以，最终用户根本不用接触源代码。如果你有兴趣的话，你可以抓一个 Debian 的 DEB 文件下来研究一下：wget http://somewhare.org/package.debar vx package.deb\n\n你会发现你多了三个文件：debian-binarycontrol.tar.gzdata.tar.gz\n\n然后再用 tar tzvf 命令看一看 control.tar.gz 和 data.tar.gz 里面有什么东东，你就明白神奇的 dpkg/apt-get 是怎么一回事情了。\n\n二进制包固然是很方便，但是这种办法有一个很大的问题。\n那就是最终用户受到 Maintainer 很大的控制。比如说，我们并不知道 Maintainer 在编译的过程中是如何设定的（./configure）。\n如果我们要用不同的设定，就要自己从源代码从头开始。另外，如果某一个 Maintainer 心术不正，在二进制包里面加了木马程序，我们这些最终用户是很难查觉的。\n还有，设想一下如果某一个 Maintainer 外出休假了，那么你的软件也就不能及时更新了。\n\n所以，也有一些发行版采取了完全不同的办法，这些发行版是以源代码为基础的。\nGentoo 就是其中的代表。如果你用过 Gentoo 你就会知道 ebuild 文件。\n你如果有兴趣，可以从 http://gentoo-package.com 抓一个 ebuild 文件研究一下。你会明白 Gentoo 的用户其实从 Gentoo 得到的只有这些 ebuild 文件，在每一个 ebuild 文件里包含了安装使用一个软件需要的所有信息（从哪里下载源代码、如何编译、如何安装还有 Dependency 的问题等）。\n之后，Gentoo 的用户用 emerge 命令按照 ebuild 文件的指示编译、安装一个软件。这样做的好处是，Gentoo 的用户可以一目了然地了解每一个软件的编译、安装的过程。如果需要的话，Gentoo 的用户可以修改 ebuild，按照自己的需要编译一个软件。\n\n我也用过 Gentoo。不过对于我这样的初学者，Gentoo 实在是太复杂了，有太多的参数要设定，ebuild 的编写也不是那么简单。还有，Gentoo 几乎不提供任何二进制包，所以绝大部分的软件都要从源代码编译，这是一个非常慢的过程。\n\n其实在大部分情况下，用户对一些软件的设定都是差不多的，没有必要让每一个 Gentoo 的用户都从头编译。所以，我需要找到一个发行版，既有 Debian 的易用性，又有 Gentoo 的灵活性。\n\n我因此找到了 Archlinux。那么 Archlinux 又是如何解决从源代码到二进制码的问题呢？\nArchlinux 使用了 makepkg 这样一个工具。makepkg 会按照 PKGBUILD 文件生成一个二进制包。有些时候，makepkg 还需要 install 文件（主要用来显示提示信息、备份用户设置等）和其他的配置文件。\n\n那么 PKGBUILD 是什么呢？\nPKGBUILD 和 Gentoo 的 ebuild 一样，包含了安装使用一个软件需要的所有信息。下面是 dwm（一个非常非常简捷、高效的窗口管理器）的 PKGBUILD 文件：\n\n```\npkgname=dwm 软件名称\npkgver=4.7\n\npkgrel=1 版本信息\npkgdesc=\"A dynamic window manager for X\"\n\nurl=\"http://www.suckless.org/wiki/dwm\" 软件说明和网站\narch=('i686' 'x86_64') 适用平台\nlicense=('MIT') 版权\ndepends=('libx11') Dependency\n\ninstall=dwm.install install 文件\nsource=(http://www.suckless.org/download/$pkgname-$pkgver.tar.gz \\\n    config.h) 要下载的源文件\nmd5sums=('827b128514a3edb87e208e84fee0eb3f'\n         '395e9a25f65605c4891e74c644b91530') md5 验证码\n\nbuild() { cd $startdir/src/$pkgname-$pkgver\n\ncp ../config.h .\n\nmake X11INC=/usr/include/X11 X11LIB=/usr/lib/X11 || return 1 make PREFIX=/usr DESTDIR=$startdir/pkg install || return 1\n\ninstall -m644 -D LICENSE $startdir/pkg/usr/share/licenses/$pkgname/LICENSE && \\ install -m644 -D README $startdir/pkg/usr/share/doc/$pkgname/README } 编译的过程 \n```\n\n我们可以注意到在“编译的过程”这个部分，很多代码都和我们在 shell 里编译的命令一样。对！Archlinux 不要求用户学习太多新的东西，PKGBUILD 很容易理解，因为里面都是基本的 shell 命令。\n\n好，我们把 PKGBUILD，dwm.install 和 config.h（dwm 比较特殊，config.h 包含所有的配置信息，所以要在编译之前提供。其他的软件大多依靠外部的配置文件，像是 .bashrc 等）放在一个新的目录里之后。我们执行：\n\n```\n$ makepkg\n```\n\n之后，你会发现这个目录里出现了一些新的东西，包括：dwm-4.7-1-x86_64.pkg.tar.gz dwm-4.7.tar.gz 两个文件，还有两个目录srcpkg\n\n通过比较这些文件、目录里的内容和 PKGBUILD，你就会明白 makepkg 到底做了些什么：\n\n1. 根据 source 里的内容下载了源代码文件 dwm-4.7.tar.gz；\n1. 通过 md5 验证码确定下载的源代码文件和 PKGBUILD 的作者使用的是一致的；\n1. 把源代码文件解压缩到 ./src/$pkgname-$pkgver （也就是 ./src/dwm-4.7）；\n1. 按照 build() 里的内容编译源代码，并把编译好的内容放在 ./pkg 里；\n1. 在 ./pkg 里加上其他的一些信息，包括 .PKGINFO 和 .INSTALL，也就是 dwm.install 的拷贝；\n1. 把 ./pkg 里面的内容打包形成 dwm-4.7-1-x86_64.pkg.tar.gz。\n\n那么，我们有了一个 .pkg.tar.gz 这样一个二进制包之后，我们要如何安装呢？我们要使用这样一个命令：\n\n```\n$ pacman -U dwm-4.7-1-x86_64.pkg.tar.gz\n```\n\n这个命令又完成了那些事情呢？\n\n1. 首先，二进制包被解压缩；\n1. 按照 .INSTALL 的内容执行一定的命令；\n1. 二进制包里面的内容会被拷贝到相应的目录（你注意到二进制包内的目录结构了吗？）；\n1. 在 /var/lib/pacman/local 这个目录中建立 dwm-4.7-1 这样一个目录；\n1. 这个目录里包含了四个文件 depends、desc、files 和 install;\n1. depends 记录了 dependency，desc 是软件说明，files 记录了每一个安装到系统上的文件的路径，install 就是 .INSTALL 的拷贝。\n\n从这以后，pacman 正是通过检查 /var/lib/pacman/local 里的内容来管理软件包的。比如说，在执行 pacman -R dwm 的过程中，pacman 首先在 /var/lib/pacman/local 找到了 dwm-4.7-1 这个目录，然后根据 files 的内容删除已安装的内容。Dependency 也是通过 depends 计算的。\n\nOK！我已经解释了 PKGBUILD 的基本结构和 makepkg 的过程。\n\n基本上是两步：从 PKGBUILD 到 .pkg.tar.gz 包，再从二进制包安装到系统。这样一种办法有很多好处。首先，PKGBUILD 非常方便用户交流。我的一个 PKGBUILD 如果编译成功了，就可以给别人用。PKGBUILD 的内容一目了然，不但有助于学习，也再不用担心木马的问题了。\n\n另外，我通过一个小例子展现 Archlinux 的灵活性在哪里。比如，我要对 dwm 有自己的设置，也就是自己的 config.h，那我应该怎么做呢？我会做如下的事情：\n1. 编辑 config.h，另存为 myconfig.h；\n1. 编辑 PKGBUILD，把所有的 config.h 替换为 myconfig.h；\n1. 把 pkgrel 变成 2。\n\n之后通过 makepkg，我会得到一个文件 dwm-4.7-2-x8664.pkg.tar.gz，这个和原来的 dwm-4.7-1-x8664.pkg.tar.gz 可以区别开。我可以安装 dwm-4.7-2-x8664.pkg.tar.gz，如果有问题我还可以通过 pacman -U dwm-4.7-1-x8664.pkg.tar.gz 来安装原来的二进制包。我还可以用同样的办法生成一系列的 .pkg.tar.gz 包，这在软件的安装调试过程中非常有用。\n\n好了，今天就讲到这里。有些人也许变得更疑惑了，因为在 TOY 的“打造完美的 Linux 桌面 — Arch Linux 2007.08-2”系列中并没有提到 PKGBUILD 的问题，所有的软件都是通过 pacman -S 来安装的。\n\n没关系，如果你理解了 makepkg 和 PKBGUILD，那么在我下一次谈到 AUR 和 ABS 之后，你就能完全明白了。\n\n实例:\n\n```\n# Maintainer: Sven-Hendrik Haase <sh@lutzhaase.com>\n# Contributor: jepaan <jepaan at hotmail dot com>\n\npkgname=client\npkgver=1.0\npkgrel=1\npkgdesc=\"tools\"\narch=('i686' 'x86_64')\nlicense=('MIT')\ndepends=('qt4' )\nmakedepends=('qt4')\ninstall=${pkgname}.install\nurl=('')\nsource=(\"./${pkgname}-${pkgver}.tar.gz\")\nmd5sums=('SKIP')\n\nbuild() {\n    cd ${srcdir}/${pkgname}-${pkgver}\n    qmake-qt4\n    make\n}\n\npackage()  {\n    cd ${srcdir}/${pkgname}-${pkgver}\n    #make PREFIX=/usr DESTDIR=$pkgdir install\n    mkdir -p ${DESTDIR}${PREFIX}/bin\n    mkdir -p ${pkgdir}/usr/share/icons\n    mkdir -p ${pkgdir}/usr/share/applications\n    install -Dm755 client ${pkgdir}/usr/bin/client\n    install -Dm755 ${srcdir}/client_logo.png  ${pkgdir}/usr/share/icons/\n    install -Dm644 ${srcdir}/client.desktop ${pkgdir}/usr/share/applications/client.desktop\n}\n\npre_remove() {\n  pid=`ps -ef | grep client | grep -v grep | grep -v pacman | awk '{print $2}'`\n  if [ -n \"$pid\" ]; then\n    kill -9 \"$pid\"\n  fi\n}\n```\n\n```\n$ makepkg -p PKGBUILD_client  或 makepkg -f -p PKGBUILD_client\n```\n\n## 第二部分：AUR 和 ABS\n我非常高兴看到我关于 PKGBUILD 和 Makepkg 的文章在 LinuxTOY 受到了欢迎。我想先针对一些读者的回复谈一点题外话。\n\n我先声明我一点也没有要诋毁 Debian 或 Gentoo 的意思，他们都是非常伟大的发行版，都有自己的特色。其实大多数的发行版都可以自己去定制，从而达到类似的目的。比如说，有的人提到 Gentoo 也有二进制包，比如像 Openoffice 这样的怪物。\n\n然而，我个人以为比较不同的发行版关键是要看它最核心的设计思想。比如说，Gentoo 根本就不是为了使用二进制包设计的。你要是都想用二进制包，就别费劲用 Gentoo 了。关于 Debian 阵营的发行版，我也想讲几句。正如一些朋友的回复所讲，DEB/apt-get 是非常好的管理工具，软件库也非常的大。\n\n我的笔记本现在还在用 elive，也是 Debian 的分支。我不喜欢 Debian 系列的发行版的原因不是它不能定制，而是他们非常依靠 Maintainer。我们可以自己做 DEB 包，然后呢？你的 DEB 包什么时候才能进入软件库呢？还有，只有你自己知道你的 DEB 是怎么做的，别人不能了解你编译打包的过程。Debian 本身打包的过程没有 Archlinux 的 PKGBUILD 来的简单明了。只要比较 Debian 的 Maintainer 手册和 Archlinux 的 Wiki 就可以看出这一点。\n\n选择什么样的发行版完全是要看个人需要。\n我选择 Archlinux，是因为它当初设计的时候就是要满足“KISS Rule”，也就是“Keep It Simple, Stupid”。或者说像爱因斯坦讲得：“Everything should be made as simple as possible, but no simpler”。Archlinux 的所有配置基本都是非常相似的脚本，加上简单灵活的 PKGBUILD 和 pacman，其实关于 Archlinux 本身真的没有太多新的东西要学习。大家有兴趣可以看看“Arch Compared To Other Distros”。\n\nArchlinux 实际上是强迫用户从零开始自己定制自己的系统，在这个过程中也就真正了解了 Linux 本身。\n\n好了，现在言归正传谈一谈 AUR 和 ABS。\n\nAUR 是指 Archlinux User-community Repository，也就是 Archlinux 用户社区的软件库。我们现在回忆一下在 Archlinux 中我们把源代码变成可以运行的二进制码需要哪些文件。我们需要：PKGBUILD，可能还有 .install 文件，加上一些补丁和必要的配置文件（像 dwm 的 config.h）。这样就足够了！当你成功使用 PKGBUILD 编译安装了一个新软件之后就可以通过 AUR 和其他的人分享你的成果了。具体的步骤是：\n1. tar -zcvf package.tar.gz package-dir 把 package-dir 中所有所需的文件打包（包括 PKGBUILD，.install，patch 和其他的 config 等）\n1. 前往 [http://aur.archlinux.org](http://aur.archlinux.org) 选择\"Submit”（参照下图），并把你的 package.tar.gz 上传\n\nAUR 会自动根据你的 PKGBUILD 内容把你的 Package 加到 AUR 里来。就是这么简单！那么有人会问：“别的用户要如何使用 AUR 呢？”\n\n这个就更简单了，我们还是用一张截图来解释：\n1. 首先下载“Tarball”（红色的圈圈），这个 Tarball 和你上传的内容是一样的，无非是 PKGBUILD 什么的；\n1. tar xvzf package.tar.gz 然后解压缩；\n1. 然后的步骤你应该知道了，那就是 makepkg 还有 pacman -U。\n\n之后又要如何使用 ABS 呢？ABS 所作的事情无非是把所有 Repo 里的软件的 PKGBUILD 下载到你本地的硬盘中。这些 PKGBUILD 都放在了 /var/abs 中。你能通过 pacman 直接安装的二进制包其实也都是按照 ABS 的内容编译的。下面我还是用 dwm 的例子解释 ABS 的使用：\n```\nsu\n$ cd /var/abs 你可以看到这个目录里有 core，extra，community 三个子目录，正如 abs.conf 中的设定；\n$ mkdir local 建立一个 local 目录，用来放你自己需要的软件的 PKGBUILD\n$ chown username:usergroup ./local makepkg 要以非 root 身份进行\n$ exit 退出 su\n$ cd local\n$ cp -r ../community/x11/dwm ./ 从 ABS 中拷贝 dwm 的内容\n$ cd dwm\n```\n\n下面不用我说了，你在这个目录里可以看到三个文件 PKGBUILD、dwm.install、config.h。你于是可以用 makepkg 和 pacman -U 来按照自己喜欢的方式安装 dwm。\n\nOK，你实际已经清楚了解了 ABS 和 pacman 的关系，那么 AUR 又和 ABS 还有 pacman 有什么联系呢？说的直白一点，你上传到 AUR 的 PKGBUILD 要足够“有品”才能直接通过 pacman 使用。\n\n对于“有品”，我是这样定义的。\n你的 PKGBUILD 要有很多人用（很多人投票），没有恶意代码，没有太多的 Bug……而判定你的 PKGBUILD 够不够“有品”的人是一些叫作 TU（Trusted User）的人。这些人的工作是检查 AUR，关注那些特别受欢迎的 PKGBUILD。之后，他会仔细检查，确定这些 PKGBUILD 是不是安全。\n然后，他们会给这些 PKGBUILD 打上安全的标签，并且把这些 PKGBUILD 从 unsupported（我们上传的 PKGBUILD 一开始都是在 unsupported 中）移到 community 的 Repo 中。\n\n在 community repo 里面的 PKGBUILD 会提前编译好，如果你在 /etc/pacman.conf 中开了 community repo，你就可以直接使用这些软件的二进制包了。\n也许有一天，你当初上传的 PKGBUILD 变得特别重要，这个软件可能被移到 testing，extra 或者 core 的 repo 中。补充一点，testing repo 里面一般是需要测试，又准备放到 core 或者 extra 中的软件。\n\nArchlinux 就是这样，非常灵活。既有 pacman 这样好的二进制包管理工具，又有 ABS 和 AUR 这样方便的源代码服务。通过 ABS，你可以完全控制你自己的系统到底是如何建立的。\n如果在 pacman -Ss 的时候找不到一个软件，你可以到 AUR 去找，如果还是找不到，为什么不自己试着从源代码开始，写一个 PKGBUILD 然后放到 AUR 中和别人分享呢？\n\n说到这里，我希望我已经把 Archlinux 最核心的东西讲明白了。\n有些人说我的文章写得比 wiki 里的文章清楚。其实，我写的东西只是在順序上不一样。我是从 PKGBUILD 开始讲到 AUR 和 ABS，再到 pacman。\n这个順序和 Archlinux 实际的开发过程是一致的，所以逻辑上容易理解很多。如果你从 pacman 入手反过来读，你可能就完全错过了理解 Archlinux 核心概念的机会。\n\nTOY 会很快再写一篇关于 yaourt 的文章，yaourt 是一个把 pacman 和 AUR 结合起来的很好用的工具。\n有了 yaourt，你不需要去 AUR 网站也能在 shell 下直接取得 AUR 的 package，还方便了投票的过程。\n\n如果大家对某些问题感兴趣，可以留言告诉我，我会尽量把我了解的用这样比较容易理解的文章与大家交流。\n\n## 第三部分：Yaourt\n在这一部分中，我们将简单介绍 Yaourt 的安装和使用。此部分上接 PKGBUILD 和 makepkg、AUR 和 ABS。\n\n就一般情况而言，当 Archlinux 用户需要使用 AUR 中的包时，往往会执行到[AUR 官方网站](http://aur.archlinux.org/packages.php)查找所需的包、下载该包的 Tarball 文件、在命令行下对 Tarball 文件解压、通过 makepkg 编译打包、最后使用 pacman 安装这样一个过程。\n\n仔细打量这个过程，你是否觉得稍微有些繁琐呢？有解决的方案吗？回答是肯定的。这就是我们今天将要介绍的主角──[Yaourt](http://archlinux.fr/yaourt-en)。\n\n### Yaourt 简介\nYaourt 是一个由 Julien Mischkowitz 所编写的 Bash 脚本，它是将 Pacman 与 AUR 这两者相结合的绝佳工具。\n通过 Yaourt 安装 AUR 中的包十分方便，它不仅简化了上述繁琐的过程，而且把这一过程半自动化，使用者只需在它的交互模式中简单的回答几个问题即可。此外，Yaourt 支持将结果以鲜亮的颜色输出，非常抢眼。\n\n### 安装 Yaourt\n除了在 Archlinux 的 AUR 中可以找到 Yaourt 外，archlinuxfr 这个源中也包含 Yaourt。我们采用后者来安装 Yaourt。首先，将下列内容添加到 /etc/pacman.conf 文件：[archlinuxfr]Server = http://repo.archlinux.fr/i686\n\n如果你的系统是 64 位，那么可以使用：[archlinuxfr]Server = http://repo.archlinux.fr/x86_64\n\n接着，我们可以执行下面的命令来安装 Yaourt：\n\n```\n$ pacman -Sy yaourt\n```\n\n另外，我们将 aurvote 和 customizepkg 这两个包也装上，前者用于对喜欢的包投票，而后者是定制 PKGBUILD 所需的：\n\n```\npacman -S aurvote customizepkg\n```\n同时，你需要为 aurvote 建立一个配置文件 .aurvote (位于 ~/ 目录下)：user=你的 AUR 帐号pass=该帐号的密码\n\n如果你没有 AUR 帐号，可到 [http://aur.archlinux.org/account.php](http://aur.archlinux.org/account.php)注册一个。\n\n### Yaourt 实战\n为了说明 Yaourt 的使用，我们以一个实例来进行。譬如，我对 Phatch 这个批量图片处理程序非常喜欢，我希望在 Archlinux 中安装它。首先，我们来看一下，在 Archlinux 中是否存在 Phatch：\n\n```\n$ yaourt phatch\nYaourt 在搜索后返回如下结果：1 aur/phatch 0.1.bzr435-1 Phatch is a simple to use cross-platform GUI Photo Batch Processor.==> Enter n° (separated by blanks, or a range) of packages to be installed Example: '1 6 7 8 9' or '1 6-9'==> ----------------------------------------------\n```\n\n从该结果我们可以断定，Phatch 在 Archlinux 的 AUR 中。现在，我们只需按 1 就可以安装它了。\n\n在显示一些输出信息后，Yaourt 会让你作出第一个选择：\n\n```\n是否编辑 PKGBUILD 文件。\n按 Y 回答并输入你喜欢的文本编辑器后，你可以针对 PKGBUILD 的内容进行修改。\n==> Edit the PKGBUILD (recommended) ? [Y/n] (\"A\" to abort)\n==> ----------------------------------------------\n```\n\n然后，Yaourt 会询问是否继续编译。我们的回答当然是 Y。\n\n```\n==> Continue the building of 'phatch'? [Y/n]\n==> ----------------------------------------------\n```\n\n接着，Yaourt 询问是否安装已编译好的包，同样回答 Y 即可。\n\n```\n==> Continue installing 'phatch'? [Y/n]\n==> [v]iew package contents [c]heck package with namcap\n==> ----------------------------------------------\n```\n\n最后，Yaourt 将检查投票情况，并问你是否要投票，按 Y 选择投票，按 n 表示不投票。\n\n```\n==> Checking for phatch's vote statusYou have already voted for phatch inclusion/keeping in [community]\n```\n\n综观 Yaourt 的命令行选项，与 Pacman 非常相似。关于 Yaourt 的更加详细的用法，通过 man yaourt 可以获得参考。其实，除了从 AUR 安装包外，Yaourt 也可以从 Archlinux 的源安装包，此不赘述。\n\n### 参考：\nPKGUILD：[https://wiki.archlinux.org/index.php/PKGBUILD_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29](https://wiki.archlinux.org/index.php/PKGBUILD_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29)\n\nABS：[https://wiki.archlinux.org/index.php/Arch_Build_System_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29](https://wiki.archlinux.org/index.php/Arch_Build_System_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29)\n\nArchlinux：[https://linuxtoy.org/archives/archlinux-pkgbuild-aur-and-abs.html](https://linuxtoy.org/archives/archlinux-pkgbuild-aur-and-abs.html)\n\npkg.tar.xz包:[http://ftp.isoft.zhcn.cc/](http://ftp.isoft.zhcn.cc/)\n\n","slug":"Archlinux的灵魂──PKGBUILD、AUR-和-ABS","published":1,"updated":"2019-07-26T11:00:26.187Z","layout":"post","photos":[],"link":"","_id":"ck2424ljs0000lksbk89s2vct","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>转自<a href=\"https://blog.csdn.net/taiyang1987912/article/details/41457333\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Archlinux 的灵魂──PKGBUILD、AUR 和 ABS</a></p><p>觉得看完对深入理解Arch很有帮助.</p></div><a id=\"more\"></a><h2 id=\"第一部分-PKGBUILD-和-makepkg\"><a href=\"#第一部分-PKGBUILD-和-makepkg\" class=\"headerlink\" title=\"第一部分:PKGBUILD 和 makepkg\"></a>第一部分:PKGBUILD 和 makepkg</h2><p>其实，我使用 Archlinux 的时间并不是很长。可是，就是在这半年的时间内，我感觉我学到了很多的东西，对 GNU/Linux 有了更多的了解，也在这个过程中深深地爱上了 Archlinux 这个发行版。</p><p>首先声明一下，我不是一个程序员，从来没有写过真正的 Code，顶多是写一点 scripts，或者做一些简单的网页什么的。和很多人一样，我对计算机的接触是从 DOS/Windows 开始的。</p><p>Windows 的图形界面很容易学。可是时间长了，Windows 就会运行的越来越慢，我的硬盘上也就会有很多我根本不知道是什么的东西。而且，在 Windows 上很多东西都是设定好的，改变起来非常不容易。不要跟我提注册表，那个东西实在是让我一头雾水。</p><p>还有，大部分 Windows 上的软件都不是自由软件。这意味着人们很难了解这些软件内部的情況，你可能在毫无察觉的情况下就中了病毒或木马。</p><p>所以，为了能够完全了解和控制我每天工作生活要用的计算机，我开始学着使用 GNU/Linux。我一开始是用 Mandriva（那个时候还叫 Mandrake Linux）。后来是 Ubuntu（也包括其他一些 Debian 为基础的发行版）。</p><p>Wow！我一用上 Ubuntu 就有了完全不同的感觉。特别是非常好用的 apt-get，加上庞大的自由软件库，让我大开眼界。可是在使用 Ubuntu 一段时间以后，我发现这个平台实在和 Windows 非常相似。</p><p>Gnome 和 KDE 的界面都是在模仿 Windows。更糟糕的是，Ubuntu 会在一开始安装一些乱七八糟的东西，大大影响了我的电脑的运行速度。</p><p>我需要一点一点把我不用的东西去掉，这个过程真的很不爽。我开始问自己为什么要放弃 Windows 呢？</p><p>Ubuntu 有一个很大很好的用户社区，很多问题都可以在讨论区得到解决。然而，Ubuntu 的用户完全要依赖 Maintainer。我就有过这样的经历，在发现一个 Bug 后得到很多其他人的确定，可是 Maintainer 迟迟不作修改。还有，也许有很多人都很想用一个比较新的软件，但是大家都要等到有人能够而且愿意作 Maintainer 之后，这个软件才会在 Repository 里出现。</p><p>我或许能够在调试后自己从源代码编译，可是我要如何和别人分享我的成果呢？</p><p>其实，各种 Linux 发行版在本质上没有什么不一样。大家使用的软件都是要从源代码编译生成可以运行的二进制码。如果没有 rpm、apt-get 或者 pacman，我们也是可以快乐生活的。只不过，我们的生活会变得麻烦一些。如果要从源码安装一个软件，我们通常是要做如下的步骤：wget <a href=\"http://somewhere.org/source/package.tar.gz（下载源代码）tar\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://somewhere.org/source/package.tar.gz（下载源代码）tar</a> xvzf package.tar.gz （解压缩）cd package （进入源代码目录）./configure （设定）make （编译）make install （安装）</p><p>如果我们要像这样安装一个两个软件是没有什么问题的。但是如果我们要对付成百上千的软件／类库的话，这样的土办法是行不通的。于是出现了不同的 Linux 发行版，他们之间的区别只是在于如何管理成百上千的软件，特别是不同软件／类库之间互相依存的关系，也就是 dependency 的问题。</p><p>大多数 Linux 发行版都是以二进制包为基础的，这其中又分 Redhat（还有 SUSE、Fedora 等）、Debian（还有 Ubuntu、PCLinux 等）和 Slackware 阵营。为了解决管理大量软件包的问题，这些发行版采取了这样一个办法。他们找了一群大牛程序员来作 Maintainer，这些 Maintainer 负责把源代码编译成二进制码，加上一些控制信息（比如如何安装、dependency 等），然后一起打包放在服务器上。所以，最终用户根本不用接触源代码。如果你有兴趣的话，你可以抓一个 Debian 的 DEB 文件下来研究一下：wget <a href=\"http://somewhare.org/package.debar\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://somewhare.org/package.debar</a> vx package.deb</p><p>你会发现你多了三个文件：debian-binarycontrol.tar.gzdata.tar.gz</p><p>然后再用 tar tzvf 命令看一看 control.tar.gz 和 data.tar.gz 里面有什么东东，你就明白神奇的 dpkg/apt-get 是怎么一回事情了。</p><p>二进制包固然是很方便，但是这种办法有一个很大的问题。<br>那就是最终用户受到 Maintainer 很大的控制。比如说，我们并不知道 Maintainer 在编译的过程中是如何设定的（./configure）。<br>如果我们要用不同的设定，就要自己从源代码从头开始。另外，如果某一个 Maintainer 心术不正，在二进制包里面加了木马程序，我们这些最终用户是很难查觉的。<br>还有，设想一下如果某一个 Maintainer 外出休假了，那么你的软件也就不能及时更新了。</p><p>所以，也有一些发行版采取了完全不同的办法，这些发行版是以源代码为基础的。<br>Gentoo 就是其中的代表。如果你用过 Gentoo 你就会知道 ebuild 文件。<br>你如果有兴趣，可以从 <a href=\"http://gentoo-package.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://gentoo-package.com</a> 抓一个 ebuild 文件研究一下。你会明白 Gentoo 的用户其实从 Gentoo 得到的只有这些 ebuild 文件，在每一个 ebuild 文件里包含了安装使用一个软件需要的所有信息（从哪里下载源代码、如何编译、如何安装还有 Dependency 的问题等）。<br>之后，Gentoo 的用户用 emerge 命令按照 ebuild 文件的指示编译、安装一个软件。这样做的好处是，Gentoo 的用户可以一目了然地了解每一个软件的编译、安装的过程。如果需要的话，Gentoo 的用户可以修改 ebuild，按照自己的需要编译一个软件。</p><p>我也用过 Gentoo。不过对于我这样的初学者，Gentoo 实在是太复杂了，有太多的参数要设定，ebuild 的编写也不是那么简单。还有，Gentoo 几乎不提供任何二进制包，所以绝大部分的软件都要从源代码编译，这是一个非常慢的过程。</p><p>其实在大部分情况下，用户对一些软件的设定都是差不多的，没有必要让每一个 Gentoo 的用户都从头编译。所以，我需要找到一个发行版，既有 Debian 的易用性，又有 Gentoo 的灵活性。</p><p>我因此找到了 Archlinux。那么 Archlinux 又是如何解决从源代码到二进制码的问题呢？<br>Archlinux 使用了 makepkg 这样一个工具。makepkg 会按照 PKGBUILD 文件生成一个二进制包。有些时候，makepkg 还需要 install 文件（主要用来显示提示信息、备份用户设置等）和其他的配置文件。</p><p>那么 PKGBUILD 是什么呢？<br>PKGBUILD 和 Gentoo 的 ebuild 一样，包含了安装使用一个软件需要的所有信息。下面是 dwm（一个非常非常简捷、高效的窗口管理器）的 PKGBUILD 文件：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pkgname=dwm 软件名称</span><br><span class=\"line\">pkgver=4.7</span><br><span class=\"line\"></span><br><span class=\"line\">pkgrel=1 版本信息</span><br><span class=\"line\">pkgdesc=&quot;A dynamic window manager for X&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">url=&quot;http://www.suckless.org/wiki/dwm&quot; 软件说明和网站</span><br><span class=\"line\">arch=(&apos;i686&apos; &apos;x86_64&apos;) 适用平台</span><br><span class=\"line\">license=(&apos;MIT&apos;) 版权</span><br><span class=\"line\">depends=(&apos;libx11&apos;) Dependency</span><br><span class=\"line\"></span><br><span class=\"line\">install=dwm.install install 文件</span><br><span class=\"line\">source=(http://www.suckless.org/download/$pkgname-$pkgver.tar.gz \\</span><br><span class=\"line\">    config.h) 要下载的源文件</span><br><span class=\"line\">md5sums=(&apos;827b128514a3edb87e208e84fee0eb3f&apos;</span><br><span class=\"line\">         &apos;395e9a25f65605c4891e74c644b91530&apos;) md5 验证码</span><br><span class=\"line\"></span><br><span class=\"line\">build() &#123; cd $startdir/src/$pkgname-$pkgver</span><br><span class=\"line\"></span><br><span class=\"line\">cp ../config.h .</span><br><span class=\"line\"></span><br><span class=\"line\">make X11INC=/usr/include/X11 X11LIB=/usr/lib/X11 || return 1 make PREFIX=/usr DESTDIR=$startdir/pkg install || return 1</span><br><span class=\"line\"></span><br><span class=\"line\">install -m644 -D LICENSE $startdir/pkg/usr/share/licenses/$pkgname/LICENSE &amp;&amp; \\ install -m644 -D README $startdir/pkg/usr/share/doc/$pkgname/README &#125; 编译的过程</span><br></pre></td></tr></table></figure><p>我们可以注意到在“编译的过程”这个部分，很多代码都和我们在 shell 里编译的命令一样。对！Archlinux 不要求用户学习太多新的东西，PKGBUILD 很容易理解，因为里面都是基本的 shell 命令。</p><p>好，我们把 PKGBUILD，dwm.install 和 config.h（dwm 比较特殊，config.h 包含所有的配置信息，所以要在编译之前提供。其他的软件大多依靠外部的配置文件，像是 .bashrc 等）放在一个新的目录里之后。我们执行：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ makepkg</span><br></pre></td></tr></table></figure><p>之后，你会发现这个目录里出现了一些新的东西，包括：dwm-4.7-1-x86_64.pkg.tar.gz dwm-4.7.tar.gz 两个文件，还有两个目录srcpkg</p><p>通过比较这些文件、目录里的内容和 PKGBUILD，你就会明白 makepkg 到底做了些什么：</p><ol><li>根据 source 里的内容下载了源代码文件 dwm-4.7.tar.gz；</li><li>通过 md5 验证码确定下载的源代码文件和 PKGBUILD 的作者使用的是一致的；</li><li>把源代码文件解压缩到 ./src/$pkgname-$pkgver （也就是 ./src/dwm-4.7）；</li><li>按照 build() 里的内容编译源代码，并把编译好的内容放在 ./pkg 里；</li><li>在 ./pkg 里加上其他的一些信息，包括 .PKGINFO 和 .INSTALL，也就是 dwm.install 的拷贝；</li><li>把 ./pkg 里面的内容打包形成 dwm-4.7-1-x86_64.pkg.tar.gz。</li></ol><p>那么，我们有了一个 .pkg.tar.gz 这样一个二进制包之后，我们要如何安装呢？我们要使用这样一个命令：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pacman -U dwm-4.7-1-x86_64.pkg.tar.gz</span><br></pre></td></tr></table></figure><p>这个命令又完成了那些事情呢？</p><ol><li>首先，二进制包被解压缩；</li><li>按照 .INSTALL 的内容执行一定的命令；</li><li>二进制包里面的内容会被拷贝到相应的目录（你注意到二进制包内的目录结构了吗？）；</li><li>在 /var/lib/pacman/local 这个目录中建立 dwm-4.7-1 这样一个目录；</li><li>这个目录里包含了四个文件 depends、desc、files 和 install;</li><li>depends 记录了 dependency，desc 是软件说明，files 记录了每一个安装到系统上的文件的路径，install 就是 .INSTALL 的拷贝。</li></ol><p>从这以后，pacman 正是通过检查 /var/lib/pacman/local 里的内容来管理软件包的。比如说，在执行 pacman -R dwm 的过程中，pacman 首先在 /var/lib/pacman/local 找到了 dwm-4.7-1 这个目录，然后根据 files 的内容删除已安装的内容。Dependency 也是通过 depends 计算的。</p><p>OK！我已经解释了 PKGBUILD 的基本结构和 makepkg 的过程。</p><p>基本上是两步：从 PKGBUILD 到 .pkg.tar.gz 包，再从二进制包安装到系统。这样一种办法有很多好处。首先，PKGBUILD 非常方便用户交流。我的一个 PKGBUILD 如果编译成功了，就可以给别人用。PKGBUILD 的内容一目了然，不但有助于学习，也再不用担心木马的问题了。</p><p>另外，我通过一个小例子展现 Archlinux 的灵活性在哪里。比如，我要对 dwm 有自己的设置，也就是自己的 config.h，那我应该怎么做呢？我会做如下的事情：</p><ol><li>编辑 config.h，另存为 myconfig.h；</li><li>编辑 PKGBUILD，把所有的 config.h 替换为 myconfig.h；</li><li>把 pkgrel 变成 2。</li></ol><p>之后通过 makepkg，我会得到一个文件 dwm-4.7-2-x8664.pkg.tar.gz，这个和原来的 dwm-4.7-1-x8664.pkg.tar.gz 可以区别开。我可以安装 dwm-4.7-2-x8664.pkg.tar.gz，如果有问题我还可以通过 pacman -U dwm-4.7-1-x8664.pkg.tar.gz 来安装原来的二进制包。我还可以用同样的办法生成一系列的 .pkg.tar.gz 包，这在软件的安装调试过程中非常有用。</p><p>好了，今天就讲到这里。有些人也许变得更疑惑了，因为在 TOY 的“打造完美的 Linux 桌面 — Arch Linux 2007.08-2”系列中并没有提到 PKGBUILD 的问题，所有的软件都是通过 pacman -S 来安装的。</p><p>没关系，如果你理解了 makepkg 和 PKBGUILD，那么在我下一次谈到 AUR 和 ABS 之后，你就能完全明白了。</p><p>实例:</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Maintainer: Sven-Hendrik Haase &lt;sh@lutzhaase.com&gt;</span><br><span class=\"line\"># Contributor: jepaan &lt;jepaan at hotmail dot com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">pkgname=client</span><br><span class=\"line\">pkgver=1.0</span><br><span class=\"line\">pkgrel=1</span><br><span class=\"line\">pkgdesc=&quot;tools&quot;</span><br><span class=\"line\">arch=(&apos;i686&apos; &apos;x86_64&apos;)</span><br><span class=\"line\">license=(&apos;MIT&apos;)</span><br><span class=\"line\">depends=(&apos;qt4&apos; )</span><br><span class=\"line\">makedepends=(&apos;qt4&apos;)</span><br><span class=\"line\">install=$&#123;pkgname&#125;.install</span><br><span class=\"line\">url=(&apos;&apos;)</span><br><span class=\"line\">source=(&quot;./$&#123;pkgname&#125;-$&#123;pkgver&#125;.tar.gz&quot;)</span><br><span class=\"line\">md5sums=(&apos;SKIP&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">build() &#123;</span><br><span class=\"line\">    cd $&#123;srcdir&#125;/$&#123;pkgname&#125;-$&#123;pkgver&#125;</span><br><span class=\"line\">    qmake-qt4</span><br><span class=\"line\">    make</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">package()  &#123;</span><br><span class=\"line\">    cd $&#123;srcdir&#125;/$&#123;pkgname&#125;-$&#123;pkgver&#125;</span><br><span class=\"line\">    #make PREFIX=/usr DESTDIR=$pkgdir install</span><br><span class=\"line\">    mkdir -p $&#123;DESTDIR&#125;$&#123;PREFIX&#125;/bin</span><br><span class=\"line\">    mkdir -p $&#123;pkgdir&#125;/usr/share/icons</span><br><span class=\"line\">    mkdir -p $&#123;pkgdir&#125;/usr/share/applications</span><br><span class=\"line\">    install -Dm755 client $&#123;pkgdir&#125;/usr/bin/client</span><br><span class=\"line\">    install -Dm755 $&#123;srcdir&#125;/client_logo.png  $&#123;pkgdir&#125;/usr/share/icons/</span><br><span class=\"line\">    install -Dm644 $&#123;srcdir&#125;/client.desktop $&#123;pkgdir&#125;/usr/share/applications/client.desktop</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">pre_remove() &#123;</span><br><span class=\"line\">  pid=`ps -ef | grep client | grep -v grep | grep -v pacman | awk &apos;&#123;print $2&#125;&apos;`</span><br><span class=\"line\">  if [ -n &quot;$pid&quot; ]; then</span><br><span class=\"line\">    kill -9 &quot;$pid&quot;</span><br><span class=\"line\">  fi</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ makepkg -p PKGBUILD_client  或 makepkg -f -p PKGBUILD_client</span><br></pre></td></tr></table></figure><h2 id=\"第二部分：AUR-和-ABS\"><a href=\"#第二部分：AUR-和-ABS\" class=\"headerlink\" title=\"第二部分：AUR 和 ABS\"></a>第二部分：AUR 和 ABS</h2><p>我非常高兴看到我关于 PKGBUILD 和 Makepkg 的文章在 LinuxTOY 受到了欢迎。我想先针对一些读者的回复谈一点题外话。</p><p>我先声明我一点也没有要诋毁 Debian 或 Gentoo 的意思，他们都是非常伟大的发行版，都有自己的特色。其实大多数的发行版都可以自己去定制，从而达到类似的目的。比如说，有的人提到 Gentoo 也有二进制包，比如像 Openoffice 这样的怪物。</p><p>然而，我个人以为比较不同的发行版关键是要看它最核心的设计思想。比如说，Gentoo 根本就不是为了使用二进制包设计的。你要是都想用二进制包，就别费劲用 Gentoo 了。关于 Debian 阵营的发行版，我也想讲几句。正如一些朋友的回复所讲，DEB/apt-get 是非常好的管理工具，软件库也非常的大。</p><p>我的笔记本现在还在用 elive，也是 Debian 的分支。我不喜欢 Debian 系列的发行版的原因不是它不能定制，而是他们非常依靠 Maintainer。我们可以自己做 DEB 包，然后呢？你的 DEB 包什么时候才能进入软件库呢？还有，只有你自己知道你的 DEB 是怎么做的，别人不能了解你编译打包的过程。Debian 本身打包的过程没有 Archlinux 的 PKGBUILD 来的简单明了。只要比较 Debian 的 Maintainer 手册和 Archlinux 的 Wiki 就可以看出这一点。</p><p>选择什么样的发行版完全是要看个人需要。<br>我选择 Archlinux，是因为它当初设计的时候就是要满足“KISS Rule”，也就是“Keep It Simple, Stupid”。或者说像爱因斯坦讲得：“Everything should be made as simple as possible, but no simpler”。Archlinux 的所有配置基本都是非常相似的脚本，加上简单灵活的 PKGBUILD 和 pacman，其实关于 Archlinux 本身真的没有太多新的东西要学习。大家有兴趣可以看看“Arch Compared To Other Distros”。</p><p>Archlinux 实际上是强迫用户从零开始自己定制自己的系统，在这个过程中也就真正了解了 Linux 本身。</p><p>好了，现在言归正传谈一谈 AUR 和 ABS。</p><p>AUR 是指 Archlinux User-community Repository，也就是 Archlinux 用户社区的软件库。我们现在回忆一下在 Archlinux 中我们把源代码变成可以运行的二进制码需要哪些文件。我们需要：PKGBUILD，可能还有 .install 文件，加上一些补丁和必要的配置文件（像 dwm 的 config.h）。这样就足够了！当你成功使用 PKGBUILD 编译安装了一个新软件之后就可以通过 AUR 和其他的人分享你的成果了。具体的步骤是：</p><ol><li>tar -zcvf package.tar.gz package-dir 把 package-dir 中所有所需的文件打包（包括 PKGBUILD，.install，patch 和其他的 config 等）</li><li>前往 <a href=\"http://aur.archlinux.org\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://aur.archlinux.org</a> 选择”Submit”（参照下图），并把你的 package.tar.gz 上传</li></ol><p>AUR 会自动根据你的 PKGBUILD 内容把你的 Package 加到 AUR 里来。就是这么简单！那么有人会问：“别的用户要如何使用 AUR 呢？”</p><p>这个就更简单了，我们还是用一张截图来解释：</p><ol><li>首先下载“Tarball”（红色的圈圈），这个 Tarball 和你上传的内容是一样的，无非是 PKGBUILD 什么的；</li><li>tar xvzf package.tar.gz 然后解压缩；</li><li>然后的步骤你应该知道了，那就是 makepkg 还有 pacman -U。</li></ol><p>之后又要如何使用 ABS 呢？ABS 所作的事情无非是把所有 Repo 里的软件的 PKGBUILD 下载到你本地的硬盘中。这些 PKGBUILD 都放在了 /var/abs 中。你能通过 pacman 直接安装的二进制包其实也都是按照 ABS 的内容编译的。下面我还是用 dwm 的例子解释 ABS 的使用：<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su</span><br><span class=\"line\">$ cd /var/abs 你可以看到这个目录里有 core，extra，community 三个子目录，正如 abs.conf 中的设定；</span><br><span class=\"line\">$ mkdir local 建立一个 local 目录，用来放你自己需要的软件的 PKGBUILD</span><br><span class=\"line\">$ chown username:usergroup ./local makepkg 要以非 root 身份进行</span><br><span class=\"line\">$ exit 退出 su</span><br><span class=\"line\">$ cd local</span><br><span class=\"line\">$ cp -r ../community/x11/dwm ./ 从 ABS 中拷贝 dwm 的内容</span><br><span class=\"line\">$ cd dwm</span><br></pre></td></tr></table></figure><p></p><p>下面不用我说了，你在这个目录里可以看到三个文件 PKGBUILD、dwm.install、config.h。你于是可以用 makepkg 和 pacman -U 来按照自己喜欢的方式安装 dwm。</p><p>OK，你实际已经清楚了解了 ABS 和 pacman 的关系，那么 AUR 又和 ABS 还有 pacman 有什么联系呢？说的直白一点，你上传到 AUR 的 PKGBUILD 要足够“有品”才能直接通过 pacman 使用。</p><p>对于“有品”，我是这样定义的。<br>你的 PKGBUILD 要有很多人用（很多人投票），没有恶意代码，没有太多的 Bug……而判定你的 PKGBUILD 够不够“有品”的人是一些叫作 TU（Trusted User）的人。这些人的工作是检查 AUR，关注那些特别受欢迎的 PKGBUILD。之后，他会仔细检查，确定这些 PKGBUILD 是不是安全。<br>然后，他们会给这些 PKGBUILD 打上安全的标签，并且把这些 PKGBUILD 从 unsupported（我们上传的 PKGBUILD 一开始都是在 unsupported 中）移到 community 的 Repo 中。</p><p>在 community repo 里面的 PKGBUILD 会提前编译好，如果你在 /etc/pacman.conf 中开了 community repo，你就可以直接使用这些软件的二进制包了。<br>也许有一天，你当初上传的 PKGBUILD 变得特别重要，这个软件可能被移到 testing，extra 或者 core 的 repo 中。补充一点，testing repo 里面一般是需要测试，又准备放到 core 或者 extra 中的软件。</p><p>Archlinux 就是这样，非常灵活。既有 pacman 这样好的二进制包管理工具，又有 ABS 和 AUR 这样方便的源代码服务。通过 ABS，你可以完全控制你自己的系统到底是如何建立的。<br>如果在 pacman -Ss 的时候找不到一个软件，你可以到 AUR 去找，如果还是找不到，为什么不自己试着从源代码开始，写一个 PKGBUILD 然后放到 AUR 中和别人分享呢？</p><p>说到这里，我希望我已经把 Archlinux 最核心的东西讲明白了。<br>有些人说我的文章写得比 wiki 里的文章清楚。其实，我写的东西只是在順序上不一样。我是从 PKGBUILD 开始讲到 AUR 和 ABS，再到 pacman。<br>这个順序和 Archlinux 实际的开发过程是一致的，所以逻辑上容易理解很多。如果你从 pacman 入手反过来读，你可能就完全错过了理解 Archlinux 核心概念的机会。</p><p>TOY 会很快再写一篇关于 yaourt 的文章，yaourt 是一个把 pacman 和 AUR 结合起来的很好用的工具。<br>有了 yaourt，你不需要去 AUR 网站也能在 shell 下直接取得 AUR 的 package，还方便了投票的过程。</p><p>如果大家对某些问题感兴趣，可以留言告诉我，我会尽量把我了解的用这样比较容易理解的文章与大家交流。</p><h2 id=\"第三部分：Yaourt\"><a href=\"#第三部分：Yaourt\" class=\"headerlink\" title=\"第三部分：Yaourt\"></a>第三部分：Yaourt</h2><p>在这一部分中，我们将简单介绍 Yaourt 的安装和使用。此部分上接 PKGBUILD 和 makepkg、AUR 和 ABS。</p><p>就一般情况而言，当 Archlinux 用户需要使用 AUR 中的包时，往往会执行到<a href=\"http://aur.archlinux.org/packages.php\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">AUR 官方网站</a>查找所需的包、下载该包的 Tarball 文件、在命令行下对 Tarball 文件解压、通过 makepkg 编译打包、最后使用 pacman 安装这样一个过程。</p><p>仔细打量这个过程，你是否觉得稍微有些繁琐呢？有解决的方案吗？回答是肯定的。这就是我们今天将要介绍的主角──<a href=\"http://archlinux.fr/yaourt-en\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Yaourt</a>。</p><h3 id=\"Yaourt-简介\"><a href=\"#Yaourt-简介\" class=\"headerlink\" title=\"Yaourt 简介\"></a>Yaourt 简介</h3><p>Yaourt 是一个由 Julien Mischkowitz 所编写的 Bash 脚本，它是将 Pacman 与 AUR 这两者相结合的绝佳工具。<br>通过 Yaourt 安装 AUR 中的包十分方便，它不仅简化了上述繁琐的过程，而且把这一过程半自动化，使用者只需在它的交互模式中简单的回答几个问题即可。此外，Yaourt 支持将结果以鲜亮的颜色输出，非常抢眼。</p><h3 id=\"安装-Yaourt\"><a href=\"#安装-Yaourt\" class=\"headerlink\" title=\"安装 Yaourt\"></a>安装 Yaourt</h3><p>除了在 Archlinux 的 AUR 中可以找到 Yaourt 外，archlinuxfr 这个源中也包含 Yaourt。我们采用后者来安装 Yaourt。首先，将下列内容添加到 /etc/pacman.conf 文件：[archlinuxfr]Server = <a href=\"http://repo.archlinux.fr/i686\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://repo.archlinux.fr/i686</a></p><p>如果你的系统是 64 位，那么可以使用：[archlinuxfr]Server = <a href=\"http://repo.archlinux.fr/x86_64\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://repo.archlinux.fr/x86_64</a></p><p>接着，我们可以执行下面的命令来安装 Yaourt：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pacman -Sy yaourt</span><br></pre></td></tr></table></figure><p>另外，我们将 aurvote 和 customizepkg 这两个包也装上，前者用于对喜欢的包投票，而后者是定制 PKGBUILD 所需的：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pacman -S aurvote customizepkg</span><br></pre></td></tr></table></figure><p>同时，你需要为 aurvote 建立一个配置文件 .aurvote (位于 ~/ 目录下)：user=你的 AUR 帐号pass=该帐号的密码</p><p>如果你没有 AUR 帐号，可到 <a href=\"http://aur.archlinux.org/account.php\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://aur.archlinux.org/account.php</a>注册一个。</p><h3 id=\"Yaourt-实战\"><a href=\"#Yaourt-实战\" class=\"headerlink\" title=\"Yaourt 实战\"></a>Yaourt 实战</h3><p>为了说明 Yaourt 的使用，我们以一个实例来进行。譬如，我对 Phatch 这个批量图片处理程序非常喜欢，我希望在 Archlinux 中安装它。首先，我们来看一下，在 Archlinux 中是否存在 Phatch：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yaourt phatch</span><br><span class=\"line\">Yaourt 在搜索后返回如下结果：1 aur/phatch 0.1.bzr435-1 Phatch is a simple to use cross-platform GUI Photo Batch Processor.==&gt; Enter n° (separated by blanks, or a range) of packages to be installed Example: &apos;1 6 7 8 9&apos; or &apos;1 6-9&apos;==&gt; ----------------------------------------------</span><br></pre></td></tr></table></figure><p>从该结果我们可以断定，Phatch 在 Archlinux 的 AUR 中。现在，我们只需按 1 就可以安装它了。</p><p>在显示一些输出信息后，Yaourt 会让你作出第一个选择：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是否编辑 PKGBUILD 文件。</span><br><span class=\"line\">按 Y 回答并输入你喜欢的文本编辑器后，你可以针对 PKGBUILD 的内容进行修改。</span><br><span class=\"line\">==&gt; Edit the PKGBUILD (recommended) ? [Y/n] (&quot;A&quot; to abort)</span><br><span class=\"line\">==&gt; ----------------------------------------------</span><br></pre></td></tr></table></figure><p>然后，Yaourt 会询问是否继续编译。我们的回答当然是 Y。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt; Continue the building of &apos;phatch&apos;? [Y/n]</span><br><span class=\"line\">==&gt; ----------------------------------------------</span><br></pre></td></tr></table></figure><p>接着，Yaourt 询问是否安装已编译好的包，同样回答 Y 即可。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt; Continue installing &apos;phatch&apos;? [Y/n]</span><br><span class=\"line\">==&gt; [v]iew package contents [c]heck package with namcap</span><br><span class=\"line\">==&gt; ----------------------------------------------</span><br></pre></td></tr></table></figure><p>最后，Yaourt 将检查投票情况，并问你是否要投票，按 Y 选择投票，按 n 表示不投票。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt; Checking for phatch&apos;s vote statusYou have already voted for phatch inclusion/keeping in [community]</span><br></pre></td></tr></table></figure><p>综观 Yaourt 的命令行选项，与 Pacman 非常相似。关于 Yaourt 的更加详细的用法，通过 man yaourt 可以获得参考。其实，除了从 AUR 安装包外，Yaourt 也可以从 Archlinux 的源安装包，此不赘述。</p><h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p>PKGUILD：<a href=\"https://wiki.archlinux.org/index.php/PKGBUILD_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://wiki.archlinux.org/index.php/PKGBUILD_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29</a></p><p>ABS：<a href=\"https://wiki.archlinux.org/index.php/Arch_Build_System_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://wiki.archlinux.org/index.php/Arch_Build_System_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29</a></p><p>Archlinux：<a href=\"https://linuxtoy.org/archives/archlinux-pkgbuild-aur-and-abs.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://linuxtoy.org/archives/archlinux-pkgbuild-aur-and-abs.html</a></p><p>pkg.tar.xz包:<a href=\"http://ftp.isoft.zhcn.cc/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://ftp.isoft.zhcn.cc/</a></p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>转自<a href=\"https://blog.csdn.net/taiyang1987912/article/details/41457333\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Archlinux 的灵魂──PKGBUILD、AUR 和 ABS</a></p><p>觉得看完对深入理解Arch很有帮助.</p></div>","more":"<h2 id=\"第一部分-PKGBUILD-和-makepkg\"><a href=\"#第一部分-PKGBUILD-和-makepkg\" class=\"headerlink\" title=\"第一部分:PKGBUILD 和 makepkg\"></a>第一部分:PKGBUILD 和 makepkg</h2><p>其实，我使用 Archlinux 的时间并不是很长。可是，就是在这半年的时间内，我感觉我学到了很多的东西，对 GNU/Linux 有了更多的了解，也在这个过程中深深地爱上了 Archlinux 这个发行版。</p><p>首先声明一下，我不是一个程序员，从来没有写过真正的 Code，顶多是写一点 scripts，或者做一些简单的网页什么的。和很多人一样，我对计算机的接触是从 DOS/Windows 开始的。</p><p>Windows 的图形界面很容易学。可是时间长了，Windows 就会运行的越来越慢，我的硬盘上也就会有很多我根本不知道是什么的东西。而且，在 Windows 上很多东西都是设定好的，改变起来非常不容易。不要跟我提注册表，那个东西实在是让我一头雾水。</p><p>还有，大部分 Windows 上的软件都不是自由软件。这意味着人们很难了解这些软件内部的情況，你可能在毫无察觉的情况下就中了病毒或木马。</p><p>所以，为了能够完全了解和控制我每天工作生活要用的计算机，我开始学着使用 GNU/Linux。我一开始是用 Mandriva（那个时候还叫 Mandrake Linux）。后来是 Ubuntu（也包括其他一些 Debian 为基础的发行版）。</p><p>Wow！我一用上 Ubuntu 就有了完全不同的感觉。特别是非常好用的 apt-get，加上庞大的自由软件库，让我大开眼界。可是在使用 Ubuntu 一段时间以后，我发现这个平台实在和 Windows 非常相似。</p><p>Gnome 和 KDE 的界面都是在模仿 Windows。更糟糕的是，Ubuntu 会在一开始安装一些乱七八糟的东西，大大影响了我的电脑的运行速度。</p><p>我需要一点一点把我不用的东西去掉，这个过程真的很不爽。我开始问自己为什么要放弃 Windows 呢？</p><p>Ubuntu 有一个很大很好的用户社区，很多问题都可以在讨论区得到解决。然而，Ubuntu 的用户完全要依赖 Maintainer。我就有过这样的经历，在发现一个 Bug 后得到很多其他人的确定，可是 Maintainer 迟迟不作修改。还有，也许有很多人都很想用一个比较新的软件，但是大家都要等到有人能够而且愿意作 Maintainer 之后，这个软件才会在 Repository 里出现。</p><p>我或许能够在调试后自己从源代码编译，可是我要如何和别人分享我的成果呢？</p><p>其实，各种 Linux 发行版在本质上没有什么不一样。大家使用的软件都是要从源代码编译生成可以运行的二进制码。如果没有 rpm、apt-get 或者 pacman，我们也是可以快乐生活的。只不过，我们的生活会变得麻烦一些。如果要从源码安装一个软件，我们通常是要做如下的步骤：wget <a href=\"http://somewhere.org/source/package.tar.gz（下载源代码）tar\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://somewhere.org/source/package.tar.gz（下载源代码）tar</a> xvzf package.tar.gz （解压缩）cd package （进入源代码目录）./configure （设定）make （编译）make install （安装）</p><p>如果我们要像这样安装一个两个软件是没有什么问题的。但是如果我们要对付成百上千的软件／类库的话，这样的土办法是行不通的。于是出现了不同的 Linux 发行版，他们之间的区别只是在于如何管理成百上千的软件，特别是不同软件／类库之间互相依存的关系，也就是 dependency 的问题。</p><p>大多数 Linux 发行版都是以二进制包为基础的，这其中又分 Redhat（还有 SUSE、Fedora 等）、Debian（还有 Ubuntu、PCLinux 等）和 Slackware 阵营。为了解决管理大量软件包的问题，这些发行版采取了这样一个办法。他们找了一群大牛程序员来作 Maintainer，这些 Maintainer 负责把源代码编译成二进制码，加上一些控制信息（比如如何安装、dependency 等），然后一起打包放在服务器上。所以，最终用户根本不用接触源代码。如果你有兴趣的话，你可以抓一个 Debian 的 DEB 文件下来研究一下：wget <a href=\"http://somewhare.org/package.debar\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://somewhare.org/package.debar</a> vx package.deb</p><p>你会发现你多了三个文件：debian-binarycontrol.tar.gzdata.tar.gz</p><p>然后再用 tar tzvf 命令看一看 control.tar.gz 和 data.tar.gz 里面有什么东东，你就明白神奇的 dpkg/apt-get 是怎么一回事情了。</p><p>二进制包固然是很方便，但是这种办法有一个很大的问题。<br>那就是最终用户受到 Maintainer 很大的控制。比如说，我们并不知道 Maintainer 在编译的过程中是如何设定的（./configure）。<br>如果我们要用不同的设定，就要自己从源代码从头开始。另外，如果某一个 Maintainer 心术不正，在二进制包里面加了木马程序，我们这些最终用户是很难查觉的。<br>还有，设想一下如果某一个 Maintainer 外出休假了，那么你的软件也就不能及时更新了。</p><p>所以，也有一些发行版采取了完全不同的办法，这些发行版是以源代码为基础的。<br>Gentoo 就是其中的代表。如果你用过 Gentoo 你就会知道 ebuild 文件。<br>你如果有兴趣，可以从 <a href=\"http://gentoo-package.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://gentoo-package.com</a> 抓一个 ebuild 文件研究一下。你会明白 Gentoo 的用户其实从 Gentoo 得到的只有这些 ebuild 文件，在每一个 ebuild 文件里包含了安装使用一个软件需要的所有信息（从哪里下载源代码、如何编译、如何安装还有 Dependency 的问题等）。<br>之后，Gentoo 的用户用 emerge 命令按照 ebuild 文件的指示编译、安装一个软件。这样做的好处是，Gentoo 的用户可以一目了然地了解每一个软件的编译、安装的过程。如果需要的话，Gentoo 的用户可以修改 ebuild，按照自己的需要编译一个软件。</p><p>我也用过 Gentoo。不过对于我这样的初学者，Gentoo 实在是太复杂了，有太多的参数要设定，ebuild 的编写也不是那么简单。还有，Gentoo 几乎不提供任何二进制包，所以绝大部分的软件都要从源代码编译，这是一个非常慢的过程。</p><p>其实在大部分情况下，用户对一些软件的设定都是差不多的，没有必要让每一个 Gentoo 的用户都从头编译。所以，我需要找到一个发行版，既有 Debian 的易用性，又有 Gentoo 的灵活性。</p><p>我因此找到了 Archlinux。那么 Archlinux 又是如何解决从源代码到二进制码的问题呢？<br>Archlinux 使用了 makepkg 这样一个工具。makepkg 会按照 PKGBUILD 文件生成一个二进制包。有些时候，makepkg 还需要 install 文件（主要用来显示提示信息、备份用户设置等）和其他的配置文件。</p><p>那么 PKGBUILD 是什么呢？<br>PKGBUILD 和 Gentoo 的 ebuild 一样，包含了安装使用一个软件需要的所有信息。下面是 dwm（一个非常非常简捷、高效的窗口管理器）的 PKGBUILD 文件：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pkgname=dwm 软件名称</span><br><span class=\"line\">pkgver=4.7</span><br><span class=\"line\"></span><br><span class=\"line\">pkgrel=1 版本信息</span><br><span class=\"line\">pkgdesc=&quot;A dynamic window manager for X&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">url=&quot;http://www.suckless.org/wiki/dwm&quot; 软件说明和网站</span><br><span class=\"line\">arch=(&apos;i686&apos; &apos;x86_64&apos;) 适用平台</span><br><span class=\"line\">license=(&apos;MIT&apos;) 版权</span><br><span class=\"line\">depends=(&apos;libx11&apos;) Dependency</span><br><span class=\"line\"></span><br><span class=\"line\">install=dwm.install install 文件</span><br><span class=\"line\">source=(http://www.suckless.org/download/$pkgname-$pkgver.tar.gz \\</span><br><span class=\"line\">    config.h) 要下载的源文件</span><br><span class=\"line\">md5sums=(&apos;827b128514a3edb87e208e84fee0eb3f&apos;</span><br><span class=\"line\">         &apos;395e9a25f65605c4891e74c644b91530&apos;) md5 验证码</span><br><span class=\"line\"></span><br><span class=\"line\">build() &#123; cd $startdir/src/$pkgname-$pkgver</span><br><span class=\"line\"></span><br><span class=\"line\">cp ../config.h .</span><br><span class=\"line\"></span><br><span class=\"line\">make X11INC=/usr/include/X11 X11LIB=/usr/lib/X11 || return 1 make PREFIX=/usr DESTDIR=$startdir/pkg install || return 1</span><br><span class=\"line\"></span><br><span class=\"line\">install -m644 -D LICENSE $startdir/pkg/usr/share/licenses/$pkgname/LICENSE &amp;&amp; \\ install -m644 -D README $startdir/pkg/usr/share/doc/$pkgname/README &#125; 编译的过程</span><br></pre></td></tr></table></figure><p>我们可以注意到在“编译的过程”这个部分，很多代码都和我们在 shell 里编译的命令一样。对！Archlinux 不要求用户学习太多新的东西，PKGBUILD 很容易理解，因为里面都是基本的 shell 命令。</p><p>好，我们把 PKGBUILD，dwm.install 和 config.h（dwm 比较特殊，config.h 包含所有的配置信息，所以要在编译之前提供。其他的软件大多依靠外部的配置文件，像是 .bashrc 等）放在一个新的目录里之后。我们执行：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ makepkg</span><br></pre></td></tr></table></figure><p>之后，你会发现这个目录里出现了一些新的东西，包括：dwm-4.7-1-x86_64.pkg.tar.gz dwm-4.7.tar.gz 两个文件，还有两个目录srcpkg</p><p>通过比较这些文件、目录里的内容和 PKGBUILD，你就会明白 makepkg 到底做了些什么：</p><ol><li>根据 source 里的内容下载了源代码文件 dwm-4.7.tar.gz；</li><li>通过 md5 验证码确定下载的源代码文件和 PKGBUILD 的作者使用的是一致的；</li><li>把源代码文件解压缩到 ./src/$pkgname-$pkgver （也就是 ./src/dwm-4.7）；</li><li>按照 build() 里的内容编译源代码，并把编译好的内容放在 ./pkg 里；</li><li>在 ./pkg 里加上其他的一些信息，包括 .PKGINFO 和 .INSTALL，也就是 dwm.install 的拷贝；</li><li>把 ./pkg 里面的内容打包形成 dwm-4.7-1-x86_64.pkg.tar.gz。</li></ol><p>那么，我们有了一个 .pkg.tar.gz 这样一个二进制包之后，我们要如何安装呢？我们要使用这样一个命令：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pacman -U dwm-4.7-1-x86_64.pkg.tar.gz</span><br></pre></td></tr></table></figure><p>这个命令又完成了那些事情呢？</p><ol><li>首先，二进制包被解压缩；</li><li>按照 .INSTALL 的内容执行一定的命令；</li><li>二进制包里面的内容会被拷贝到相应的目录（你注意到二进制包内的目录结构了吗？）；</li><li>在 /var/lib/pacman/local 这个目录中建立 dwm-4.7-1 这样一个目录；</li><li>这个目录里包含了四个文件 depends、desc、files 和 install;</li><li>depends 记录了 dependency，desc 是软件说明，files 记录了每一个安装到系统上的文件的路径，install 就是 .INSTALL 的拷贝。</li></ol><p>从这以后，pacman 正是通过检查 /var/lib/pacman/local 里的内容来管理软件包的。比如说，在执行 pacman -R dwm 的过程中，pacman 首先在 /var/lib/pacman/local 找到了 dwm-4.7-1 这个目录，然后根据 files 的内容删除已安装的内容。Dependency 也是通过 depends 计算的。</p><p>OK！我已经解释了 PKGBUILD 的基本结构和 makepkg 的过程。</p><p>基本上是两步：从 PKGBUILD 到 .pkg.tar.gz 包，再从二进制包安装到系统。这样一种办法有很多好处。首先，PKGBUILD 非常方便用户交流。我的一个 PKGBUILD 如果编译成功了，就可以给别人用。PKGBUILD 的内容一目了然，不但有助于学习，也再不用担心木马的问题了。</p><p>另外，我通过一个小例子展现 Archlinux 的灵活性在哪里。比如，我要对 dwm 有自己的设置，也就是自己的 config.h，那我应该怎么做呢？我会做如下的事情：</p><ol><li>编辑 config.h，另存为 myconfig.h；</li><li>编辑 PKGBUILD，把所有的 config.h 替换为 myconfig.h；</li><li>把 pkgrel 变成 2。</li></ol><p>之后通过 makepkg，我会得到一个文件 dwm-4.7-2-x8664.pkg.tar.gz，这个和原来的 dwm-4.7-1-x8664.pkg.tar.gz 可以区别开。我可以安装 dwm-4.7-2-x8664.pkg.tar.gz，如果有问题我还可以通过 pacman -U dwm-4.7-1-x8664.pkg.tar.gz 来安装原来的二进制包。我还可以用同样的办法生成一系列的 .pkg.tar.gz 包，这在软件的安装调试过程中非常有用。</p><p>好了，今天就讲到这里。有些人也许变得更疑惑了，因为在 TOY 的“打造完美的 Linux 桌面 — Arch Linux 2007.08-2”系列中并没有提到 PKGBUILD 的问题，所有的软件都是通过 pacman -S 来安装的。</p><p>没关系，如果你理解了 makepkg 和 PKBGUILD，那么在我下一次谈到 AUR 和 ABS 之后，你就能完全明白了。</p><p>实例:</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Maintainer: Sven-Hendrik Haase &lt;sh@lutzhaase.com&gt;</span><br><span class=\"line\"># Contributor: jepaan &lt;jepaan at hotmail dot com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">pkgname=client</span><br><span class=\"line\">pkgver=1.0</span><br><span class=\"line\">pkgrel=1</span><br><span class=\"line\">pkgdesc=&quot;tools&quot;</span><br><span class=\"line\">arch=(&apos;i686&apos; &apos;x86_64&apos;)</span><br><span class=\"line\">license=(&apos;MIT&apos;)</span><br><span class=\"line\">depends=(&apos;qt4&apos; )</span><br><span class=\"line\">makedepends=(&apos;qt4&apos;)</span><br><span class=\"line\">install=$&#123;pkgname&#125;.install</span><br><span class=\"line\">url=(&apos;&apos;)</span><br><span class=\"line\">source=(&quot;./$&#123;pkgname&#125;-$&#123;pkgver&#125;.tar.gz&quot;)</span><br><span class=\"line\">md5sums=(&apos;SKIP&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">build() &#123;</span><br><span class=\"line\">    cd $&#123;srcdir&#125;/$&#123;pkgname&#125;-$&#123;pkgver&#125;</span><br><span class=\"line\">    qmake-qt4</span><br><span class=\"line\">    make</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">package()  &#123;</span><br><span class=\"line\">    cd $&#123;srcdir&#125;/$&#123;pkgname&#125;-$&#123;pkgver&#125;</span><br><span class=\"line\">    #make PREFIX=/usr DESTDIR=$pkgdir install</span><br><span class=\"line\">    mkdir -p $&#123;DESTDIR&#125;$&#123;PREFIX&#125;/bin</span><br><span class=\"line\">    mkdir -p $&#123;pkgdir&#125;/usr/share/icons</span><br><span class=\"line\">    mkdir -p $&#123;pkgdir&#125;/usr/share/applications</span><br><span class=\"line\">    install -Dm755 client $&#123;pkgdir&#125;/usr/bin/client</span><br><span class=\"line\">    install -Dm755 $&#123;srcdir&#125;/client_logo.png  $&#123;pkgdir&#125;/usr/share/icons/</span><br><span class=\"line\">    install -Dm644 $&#123;srcdir&#125;/client.desktop $&#123;pkgdir&#125;/usr/share/applications/client.desktop</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">pre_remove() &#123;</span><br><span class=\"line\">  pid=`ps -ef | grep client | grep -v grep | grep -v pacman | awk &apos;&#123;print $2&#125;&apos;`</span><br><span class=\"line\">  if [ -n &quot;$pid&quot; ]; then</span><br><span class=\"line\">    kill -9 &quot;$pid&quot;</span><br><span class=\"line\">  fi</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ makepkg -p PKGBUILD_client  或 makepkg -f -p PKGBUILD_client</span><br></pre></td></tr></table></figure><h2 id=\"第二部分：AUR-和-ABS\"><a href=\"#第二部分：AUR-和-ABS\" class=\"headerlink\" title=\"第二部分：AUR 和 ABS\"></a>第二部分：AUR 和 ABS</h2><p>我非常高兴看到我关于 PKGBUILD 和 Makepkg 的文章在 LinuxTOY 受到了欢迎。我想先针对一些读者的回复谈一点题外话。</p><p>我先声明我一点也没有要诋毁 Debian 或 Gentoo 的意思，他们都是非常伟大的发行版，都有自己的特色。其实大多数的发行版都可以自己去定制，从而达到类似的目的。比如说，有的人提到 Gentoo 也有二进制包，比如像 Openoffice 这样的怪物。</p><p>然而，我个人以为比较不同的发行版关键是要看它最核心的设计思想。比如说，Gentoo 根本就不是为了使用二进制包设计的。你要是都想用二进制包，就别费劲用 Gentoo 了。关于 Debian 阵营的发行版，我也想讲几句。正如一些朋友的回复所讲，DEB/apt-get 是非常好的管理工具，软件库也非常的大。</p><p>我的笔记本现在还在用 elive，也是 Debian 的分支。我不喜欢 Debian 系列的发行版的原因不是它不能定制，而是他们非常依靠 Maintainer。我们可以自己做 DEB 包，然后呢？你的 DEB 包什么时候才能进入软件库呢？还有，只有你自己知道你的 DEB 是怎么做的，别人不能了解你编译打包的过程。Debian 本身打包的过程没有 Archlinux 的 PKGBUILD 来的简单明了。只要比较 Debian 的 Maintainer 手册和 Archlinux 的 Wiki 就可以看出这一点。</p><p>选择什么样的发行版完全是要看个人需要。<br>我选择 Archlinux，是因为它当初设计的时候就是要满足“KISS Rule”，也就是“Keep It Simple, Stupid”。或者说像爱因斯坦讲得：“Everything should be made as simple as possible, but no simpler”。Archlinux 的所有配置基本都是非常相似的脚本，加上简单灵活的 PKGBUILD 和 pacman，其实关于 Archlinux 本身真的没有太多新的东西要学习。大家有兴趣可以看看“Arch Compared To Other Distros”。</p><p>Archlinux 实际上是强迫用户从零开始自己定制自己的系统，在这个过程中也就真正了解了 Linux 本身。</p><p>好了，现在言归正传谈一谈 AUR 和 ABS。</p><p>AUR 是指 Archlinux User-community Repository，也就是 Archlinux 用户社区的软件库。我们现在回忆一下在 Archlinux 中我们把源代码变成可以运行的二进制码需要哪些文件。我们需要：PKGBUILD，可能还有 .install 文件，加上一些补丁和必要的配置文件（像 dwm 的 config.h）。这样就足够了！当你成功使用 PKGBUILD 编译安装了一个新软件之后就可以通过 AUR 和其他的人分享你的成果了。具体的步骤是：</p><ol><li>tar -zcvf package.tar.gz package-dir 把 package-dir 中所有所需的文件打包（包括 PKGBUILD，.install，patch 和其他的 config 等）</li><li>前往 <a href=\"http://aur.archlinux.org\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://aur.archlinux.org</a> 选择”Submit”（参照下图），并把你的 package.tar.gz 上传</li></ol><p>AUR 会自动根据你的 PKGBUILD 内容把你的 Package 加到 AUR 里来。就是这么简单！那么有人会问：“别的用户要如何使用 AUR 呢？”</p><p>这个就更简单了，我们还是用一张截图来解释：</p><ol><li>首先下载“Tarball”（红色的圈圈），这个 Tarball 和你上传的内容是一样的，无非是 PKGBUILD 什么的；</li><li>tar xvzf package.tar.gz 然后解压缩；</li><li>然后的步骤你应该知道了，那就是 makepkg 还有 pacman -U。</li></ol><p>之后又要如何使用 ABS 呢？ABS 所作的事情无非是把所有 Repo 里的软件的 PKGBUILD 下载到你本地的硬盘中。这些 PKGBUILD 都放在了 /var/abs 中。你能通过 pacman 直接安装的二进制包其实也都是按照 ABS 的内容编译的。下面我还是用 dwm 的例子解释 ABS 的使用：<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su</span><br><span class=\"line\">$ cd /var/abs 你可以看到这个目录里有 core，extra，community 三个子目录，正如 abs.conf 中的设定；</span><br><span class=\"line\">$ mkdir local 建立一个 local 目录，用来放你自己需要的软件的 PKGBUILD</span><br><span class=\"line\">$ chown username:usergroup ./local makepkg 要以非 root 身份进行</span><br><span class=\"line\">$ exit 退出 su</span><br><span class=\"line\">$ cd local</span><br><span class=\"line\">$ cp -r ../community/x11/dwm ./ 从 ABS 中拷贝 dwm 的内容</span><br><span class=\"line\">$ cd dwm</span><br></pre></td></tr></table></figure><p></p><p>下面不用我说了，你在这个目录里可以看到三个文件 PKGBUILD、dwm.install、config.h。你于是可以用 makepkg 和 pacman -U 来按照自己喜欢的方式安装 dwm。</p><p>OK，你实际已经清楚了解了 ABS 和 pacman 的关系，那么 AUR 又和 ABS 还有 pacman 有什么联系呢？说的直白一点，你上传到 AUR 的 PKGBUILD 要足够“有品”才能直接通过 pacman 使用。</p><p>对于“有品”，我是这样定义的。<br>你的 PKGBUILD 要有很多人用（很多人投票），没有恶意代码，没有太多的 Bug……而判定你的 PKGBUILD 够不够“有品”的人是一些叫作 TU（Trusted User）的人。这些人的工作是检查 AUR，关注那些特别受欢迎的 PKGBUILD。之后，他会仔细检查，确定这些 PKGBUILD 是不是安全。<br>然后，他们会给这些 PKGBUILD 打上安全的标签，并且把这些 PKGBUILD 从 unsupported（我们上传的 PKGBUILD 一开始都是在 unsupported 中）移到 community 的 Repo 中。</p><p>在 community repo 里面的 PKGBUILD 会提前编译好，如果你在 /etc/pacman.conf 中开了 community repo，你就可以直接使用这些软件的二进制包了。<br>也许有一天，你当初上传的 PKGBUILD 变得特别重要，这个软件可能被移到 testing，extra 或者 core 的 repo 中。补充一点，testing repo 里面一般是需要测试，又准备放到 core 或者 extra 中的软件。</p><p>Archlinux 就是这样，非常灵活。既有 pacman 这样好的二进制包管理工具，又有 ABS 和 AUR 这样方便的源代码服务。通过 ABS，你可以完全控制你自己的系统到底是如何建立的。<br>如果在 pacman -Ss 的时候找不到一个软件，你可以到 AUR 去找，如果还是找不到，为什么不自己试着从源代码开始，写一个 PKGBUILD 然后放到 AUR 中和别人分享呢？</p><p>说到这里，我希望我已经把 Archlinux 最核心的东西讲明白了。<br>有些人说我的文章写得比 wiki 里的文章清楚。其实，我写的东西只是在順序上不一样。我是从 PKGBUILD 开始讲到 AUR 和 ABS，再到 pacman。<br>这个順序和 Archlinux 实际的开发过程是一致的，所以逻辑上容易理解很多。如果你从 pacman 入手反过来读，你可能就完全错过了理解 Archlinux 核心概念的机会。</p><p>TOY 会很快再写一篇关于 yaourt 的文章，yaourt 是一个把 pacman 和 AUR 结合起来的很好用的工具。<br>有了 yaourt，你不需要去 AUR 网站也能在 shell 下直接取得 AUR 的 package，还方便了投票的过程。</p><p>如果大家对某些问题感兴趣，可以留言告诉我，我会尽量把我了解的用这样比较容易理解的文章与大家交流。</p><h2 id=\"第三部分：Yaourt\"><a href=\"#第三部分：Yaourt\" class=\"headerlink\" title=\"第三部分：Yaourt\"></a>第三部分：Yaourt</h2><p>在这一部分中，我们将简单介绍 Yaourt 的安装和使用。此部分上接 PKGBUILD 和 makepkg、AUR 和 ABS。</p><p>就一般情况而言，当 Archlinux 用户需要使用 AUR 中的包时，往往会执行到<a href=\"http://aur.archlinux.org/packages.php\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">AUR 官方网站</a>查找所需的包、下载该包的 Tarball 文件、在命令行下对 Tarball 文件解压、通过 makepkg 编译打包、最后使用 pacman 安装这样一个过程。</p><p>仔细打量这个过程，你是否觉得稍微有些繁琐呢？有解决的方案吗？回答是肯定的。这就是我们今天将要介绍的主角──<a href=\"http://archlinux.fr/yaourt-en\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Yaourt</a>。</p><h3 id=\"Yaourt-简介\"><a href=\"#Yaourt-简介\" class=\"headerlink\" title=\"Yaourt 简介\"></a>Yaourt 简介</h3><p>Yaourt 是一个由 Julien Mischkowitz 所编写的 Bash 脚本，它是将 Pacman 与 AUR 这两者相结合的绝佳工具。<br>通过 Yaourt 安装 AUR 中的包十分方便，它不仅简化了上述繁琐的过程，而且把这一过程半自动化，使用者只需在它的交互模式中简单的回答几个问题即可。此外，Yaourt 支持将结果以鲜亮的颜色输出，非常抢眼。</p><h3 id=\"安装-Yaourt\"><a href=\"#安装-Yaourt\" class=\"headerlink\" title=\"安装 Yaourt\"></a>安装 Yaourt</h3><p>除了在 Archlinux 的 AUR 中可以找到 Yaourt 外，archlinuxfr 这个源中也包含 Yaourt。我们采用后者来安装 Yaourt。首先，将下列内容添加到 /etc/pacman.conf 文件：[archlinuxfr]Server = <a href=\"http://repo.archlinux.fr/i686\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://repo.archlinux.fr/i686</a></p><p>如果你的系统是 64 位，那么可以使用：[archlinuxfr]Server = <a href=\"http://repo.archlinux.fr/x86_64\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://repo.archlinux.fr/x86_64</a></p><p>接着，我们可以执行下面的命令来安装 Yaourt：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pacman -Sy yaourt</span><br></pre></td></tr></table></figure><p>另外，我们将 aurvote 和 customizepkg 这两个包也装上，前者用于对喜欢的包投票，而后者是定制 PKGBUILD 所需的：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pacman -S aurvote customizepkg</span><br></pre></td></tr></table></figure><p>同时，你需要为 aurvote 建立一个配置文件 .aurvote (位于 ~/ 目录下)：user=你的 AUR 帐号pass=该帐号的密码</p><p>如果你没有 AUR 帐号，可到 <a href=\"http://aur.archlinux.org/account.php\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://aur.archlinux.org/account.php</a>注册一个。</p><h3 id=\"Yaourt-实战\"><a href=\"#Yaourt-实战\" class=\"headerlink\" title=\"Yaourt 实战\"></a>Yaourt 实战</h3><p>为了说明 Yaourt 的使用，我们以一个实例来进行。譬如，我对 Phatch 这个批量图片处理程序非常喜欢，我希望在 Archlinux 中安装它。首先，我们来看一下，在 Archlinux 中是否存在 Phatch：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yaourt phatch</span><br><span class=\"line\">Yaourt 在搜索后返回如下结果：1 aur/phatch 0.1.bzr435-1 Phatch is a simple to use cross-platform GUI Photo Batch Processor.==&gt; Enter n° (separated by blanks, or a range) of packages to be installed Example: &apos;1 6 7 8 9&apos; or &apos;1 6-9&apos;==&gt; ----------------------------------------------</span><br></pre></td></tr></table></figure><p>从该结果我们可以断定，Phatch 在 Archlinux 的 AUR 中。现在，我们只需按 1 就可以安装它了。</p><p>在显示一些输出信息后，Yaourt 会让你作出第一个选择：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是否编辑 PKGBUILD 文件。</span><br><span class=\"line\">按 Y 回答并输入你喜欢的文本编辑器后，你可以针对 PKGBUILD 的内容进行修改。</span><br><span class=\"line\">==&gt; Edit the PKGBUILD (recommended) ? [Y/n] (&quot;A&quot; to abort)</span><br><span class=\"line\">==&gt; ----------------------------------------------</span><br></pre></td></tr></table></figure><p>然后，Yaourt 会询问是否继续编译。我们的回答当然是 Y。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt; Continue the building of &apos;phatch&apos;? [Y/n]</span><br><span class=\"line\">==&gt; ----------------------------------------------</span><br></pre></td></tr></table></figure><p>接着，Yaourt 询问是否安装已编译好的包，同样回答 Y 即可。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt; Continue installing &apos;phatch&apos;? [Y/n]</span><br><span class=\"line\">==&gt; [v]iew package contents [c]heck package with namcap</span><br><span class=\"line\">==&gt; ----------------------------------------------</span><br></pre></td></tr></table></figure><p>最后，Yaourt 将检查投票情况，并问你是否要投票，按 Y 选择投票，按 n 表示不投票。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt; Checking for phatch&apos;s vote statusYou have already voted for phatch inclusion/keeping in [community]</span><br></pre></td></tr></table></figure><p>综观 Yaourt 的命令行选项，与 Pacman 非常相似。关于 Yaourt 的更加详细的用法，通过 man yaourt 可以获得参考。其实，除了从 AUR 安装包外，Yaourt 也可以从 Archlinux 的源安装包，此不赘述。</p><h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p>PKGUILD：<a href=\"https://wiki.archlinux.org/index.php/PKGBUILD_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://wiki.archlinux.org/index.php/PKGBUILD_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29</a></p><p>ABS：<a href=\"https://wiki.archlinux.org/index.php/Arch_Build_System_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://wiki.archlinux.org/index.php/Arch_Build_System_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29</a></p><p>Archlinux：<a href=\"https://linuxtoy.org/archives/archlinux-pkgbuild-aur-and-abs.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://linuxtoy.org/archives/archlinux-pkgbuild-aur-and-abs.html</a></p><p>pkg.tar.xz包:<a href=\"http://ftp.isoft.zhcn.cc/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://ftp.isoft.zhcn.cc/</a></p><!-- rebuild by neat -->"},{"title":"ACM-2017WF-F-Posterize","comments":1,"mathjax":false,"date":"2018-09-27T08:27:00.000Z","urlname":"ACM-2017WF-F-Posterize","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n  算法课居然直接安排了一个ACM-WF的题目...弄了半天弄懂了，记笔记记笔记!\n<!--more-->\n# ACM-ICPC World Finals 2017 F.Posterize DP\n\n## 原题\n### 题意\n　　Pixels in a digital picture can be represented with three integers in the range 00 to 255255 that indicate the intensity of the red, green, and blue colors.\n\n  To compress an image or to create an artistic effect, many photo-editing tools include a “posterize” operation which works as follows.\n  \n  Each color channel is examined separately; this problem focuses only on the red channel.\n  \n  Rather than allow all integers from 00 to 255255 for the red channel, a posterized image allows at most kk integers from this range.\n  \n  Each pixel’s original red intensity is replaced with the nearest of the allowed integers.\n  \n  The photo-editing tool selects a set of kk integers that minimizes the sum of the squared errors introduced across all pixels in the original image.\n  \n  If there are nn pixels that have original red values r1,…,rnr1,…,rn, and kk allowed integers v1,…,vkv1,…,vk, the sum of squared errors is defined as\n\n　　∑i=1nmin1≤j≤k(ri−vj)2.∑i=1nmin1≤j≤k(ri−vj)2.\n\n　　Your task is to compute the minimum achievable sum of squared errors, given parameter kk and a description of the red intensities of an image’s pixels.\n\n{% note info %}\n数字图像的像素可以用三个在0到255之间的整数表示,它们分别表示红色、绿色和蓝色的强度。\n\n为了压缩图片或是为了生艺术效果,许多图像编辑工具收录了如下所述的”色调分离”操作。\n\n每个颜色通道会分别考虑,本题只考虑红\n色通道的情况。\n\n不同于在红色通道使用0到255之间全部的整数,一张色调分离后的图片只会使用这些数字里至多 k\n种整数。\n\n每个像素原来的红色强度会被替换成最相近的可用强度。\n\n图像编辑工具会选择k个整数来最小化替换过程\n引起的平方误差之和。\n\n假设原图有n个像素,它们的红色取值是r1,···,rn,而 k 种可用整数为v1,···,vk ,那么平方误差之和被定义为\n\n　　∑i=1nmin1≤j≤k(ri−vj)2.∑i=1nmin1≤j≤k(ri−vj)2.\n\n你的任务是计算可以实现的最小平方误差之和,参数k和图片的红色强度会给出。\n{% endnote %}\n\n### Input\nThe first line of the input contains two integers dd (1≤d≤2561≤d≤256), the number of distinct red values that occur in the original image, and kk (1≤k≤d1≤k≤d), the number of distinct red values allowed in the posterized image. The remaining dd lines indicate the number of pixels of the image having various red values. Each such line contains two integers rr (0≤r≤2550≤r≤255) and pp (1≤p≤2261≤p≤226), where rr is a red intensity value and pp is the number of pixels having red intensity rr. Those dd lines are given in increasing order of red value.\n\n{% note info %}\n第一行包含两个整数d(1≤d≤256)和k(1≤k≤d)  \n分别表示原图中不同的红色强度有多少种,  \n色调分离后可以使用的红色强度有多少种。  \n接下来d行描述了每种红色强度在原图中占据的像素点数量。  \n每行包含两个整数r(0≤r≤255)和p(1≤p≤226)  \n这里r是一种红色强度的取值   \n而p是这种取值对应的像素点数量。这d行信息按照红色强度取值升序给出。  \n{% endnote %}\n\n### Output \nDisplay the sum of the squared errors for an optimally chosen set of kk allowed integer values.\n\n{% note info %}\n输出最优的 k 种可选取值对应的平方误差之和。\n{% endnote %}\n\n | Sample Input 1 | Sample Output 1 |\n | -----          |  -------        |\n | 2 1            |                 |  \n | 50 20000       |                 |      \n | 150 10000      |  66670000       | \n\n | Sample Input 2 | Sample Output 2 |        \n | -----          |  -------        |\n | 2 2            |                 |  \n | 50 20000       |                 |    \n | 150 10000      | 0               |\n\n | Sample Input 3 | Sample Output 3 |        \n | -----          |  -------        |\n | 4 2            |                 |       \n | 0 30000        |                 |       \n | 25 30000       |                 |         \n | 50 30000       |                 |         \n | 255 30000      | 37500000        | \n\n### 思路\n　　主要是dp,记忆化搜索＋剪枝,看后面的代码注释和题解\n\n## 题目转化\n### 题意\n有256个位置，有d个位置上有人（每个位置上可能不止一个人），你可以在k个位置上插旗（每个位置上至多一面旗子），\n\n每个人都会走到离自己最近的旗子，求所有人走的距离的平方和的最小值。\n\n### 题解\n要解决这个问题，我们可以建立一个二维数组*f[i][j]*，（j<=i），表示前i个位置，放了j个旗子，其中第i个位置一定放了旗子，前i个位置上的所有人走到旗子上的最小距离平方和。\n\n如果我们假设第i个位置上的旗子是k个旗子中的最后一个（即第i个位置后面没有旗子），那么第i个位置后面的人只能全部走到第i个位置上，所以把_f[i][j]_加上i位置后面的人走到i位置的距离平方和就可以得到所有人走的距离平方和。\n\n因此我们可以枚举最后一个旗子插的位置i，将_f[i][j_]加上i后面的人走到i位置的距离平方和，取最小值，即为答案。\n\n*f[i][j]*数组的建立我们可以用下面的公式来计算：*f[i][j]=min{f[m][j-1]+w[m][i]},（j-1<=m< i)*，其中*w[m][i]*\n\n表示m~i这一段只有m和i位置放了旗子，这一段上的人走的距离平方和。\n\n由于第i个位置上固定了一面旗子，我们可以考虑另外j-1面旗子的位置。\n\n若j-1面旗子在前m个位置（可以假设第m个位置上一定放旗子），那么*f[i][j]*可以分解成两段计算，\n\n一段是1~m位置，放了j-1个旗子，其中第m个位置一定放了旗子，这就递归成了*f[m][j-1]*；\n\n另一段是m+1~i位置，只有m和i位置放了旗子，这一段上的人只能走到m和i，即*w[m][i]*。\n\n所以我们只要枚举m的值，取*f[m][j-1]+w[m][i]*的最小值，就可以得出*f[i][j]*的值。\n\n下面给出一个f[i][j]的实例：考虑f[8][3]，前8个位置，放了3个旗子，其中第3个位置一定放了旗子。\n\n剩余的2面旗子可能在前2/3/4/5/6/7个位置上，由此枚举出所有情况：\n\n剩余的2面旗子在：\n> 　　前2个位置：f[2][2]+w[2][8]\n> 　　前3个位置：f[3][2]+w[3][8]\n> 　　前4个位置：f[4][2]+w[4][8]\n> 　　前5个位置：f[5][2]+w[5][8]\n> 　　前6个位置：f[6][2]+w[6][8]\n> 　　前7个位置：f[7][2]+w[7][8]\n\n取出这些值中的最小值，即得到f[8][3]的值。\n\n至于w[m][i]的建立较为简单，由于只有m和i位置放了旗子，m+1~i位置上的人只能就近走到m或i位置上，\n\n我们可以求出m和i的中值，前一半的人走到m，后一半的人走到i，求出距离平方和即可。\n\n### 代码参考\n```C++\n#include <cstdio>\n#include <cstring>\n#define N 260\n#define ll long long\n\n//读数据,返回一个整数\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n\n    //判断是否有符号\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\n    //按位读取组成整数\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\n\n//一共n个位置，kk个旗子,a[N]表示每个位置的人数\nint n,kk,a[N];\n\n//f[i][j]表示前i个位置，放了j个旗子，其中第i个位置一定放了旗子的最小平方误差\nll w[N][N],f[N][N];\n\ninline ll min(ll x,ll y){return x<y?x:y;}\n\nint main(){\n    //freopen(\"a.in\",\"r\",stdin);\n    n=read();\n    kk=read(); \n\n    //旗子数不可以比位置数多\n    if(kk>=n){\n      puts(\"0\");\n      return 0;\n    }\n\n    //读取每个位置的人数\n    for(int i=1;i<=n;++i){\n        int x=read();a[x+1]=read();\n    }\n\n    //建立w[i][j],i是第一个旗子位置,j是第二个旗子的位置\n    for(int i=1;i<=256;++i)\n\n        //i~j这一段只在i和j位置放旗子的平方误差\n        for(int j=i+2;j<=256;++j){\n          int mid=i+j>>1;\n\n            //计算i到j之间所有的位置平方和\n            for(int q=i+1;q<=j-1;++q){\n                if(q>mid) \n                  w[i][j]+=(ll)(j-q)*(j-q)*a[q];\n                else \n                  w[i][j]+=(ll)(q-i)*(q-i)*a[q];\n            }\n        }\n\n    //只放一个旗子的情况,旗子在i处，遍历i之前所有的位置,累加\n    for(int i=1;i<=256;++i)\n        for(int j=1;j<i;++j)\n            f[i][1]+=(ll)(i-j)*(i-j)*a[j];\n\n    //建立f[i][j],j是旗子的数量，从２开始到kk\n    for(int j=2;j<=kk;++j)\n        //i是一共多少个位置，从j到256\n        for(int i=j;i<=256;++i){\n            f[i][j]=f[i-1][j-1];\n\n            //前j-1个旗子放在[1,m]这里，并且m处有旗子,i处也有旗子,转化成求f[m][j-1]+w[m][i]的最小值\n            for(int m=j-1;m<i-1;++m)\n                f[i][j]=min(f[i][j],f[m][j-1]+w[m][i]);\n        }\n\n    ll ans=f[256][kk];\n    //统计答案，如果最后一个旗子不在最后一个位置，就还需要加上最后一个旗子后面的位置的平方和，枚举最后一个旗子插的位置\n\n    //i是最后一个旗子的位置,j是最后一个旗子到最后一个位置的每个位置,tmp是最后这部分的平方和\n    for(int i=255;i>=kk;--i){\n        ll tmp=0;\n        for(int j=256;j>i;--j)\n          tmp+=(ll)(j-i)*(j-i)*a[j];\n\n        //比较不同位置的平方和，取最小值\n        ans=min(ans,f[i][kk]+tmp);\n    }\n\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n```\n\n-------\n","source":"_posts/ACM-2017WF-F-Posterize.md","raw":"---\ntitle: 'ACM-2017WF-F-Posterize'\ncomments: true\nmathjax: false\ndate: 2018-09-27 16:27:00\ntags: [ACM-ICPC,Learning,DP,Notes]\ncategories: Notes\nurlname: ACM-2017WF-F-Posterize\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n  算法课居然直接安排了一个ACM-WF的题目...弄了半天弄懂了，记笔记记笔记!\n<!--more-->\n# ACM-ICPC World Finals 2017 F.Posterize DP\n\n## 原题\n### 题意\n　　Pixels in a digital picture can be represented with three integers in the range 00 to 255255 that indicate the intensity of the red, green, and blue colors.\n\n  To compress an image or to create an artistic effect, many photo-editing tools include a “posterize” operation which works as follows.\n  \n  Each color channel is examined separately; this problem focuses only on the red channel.\n  \n  Rather than allow all integers from 00 to 255255 for the red channel, a posterized image allows at most kk integers from this range.\n  \n  Each pixel’s original red intensity is replaced with the nearest of the allowed integers.\n  \n  The photo-editing tool selects a set of kk integers that minimizes the sum of the squared errors introduced across all pixels in the original image.\n  \n  If there are nn pixels that have original red values r1,…,rnr1,…,rn, and kk allowed integers v1,…,vkv1,…,vk, the sum of squared errors is defined as\n\n　　∑i=1nmin1≤j≤k(ri−vj)2.∑i=1nmin1≤j≤k(ri−vj)2.\n\n　　Your task is to compute the minimum achievable sum of squared errors, given parameter kk and a description of the red intensities of an image’s pixels.\n\n{% note info %}\n数字图像的像素可以用三个在0到255之间的整数表示,它们分别表示红色、绿色和蓝色的强度。\n\n为了压缩图片或是为了生艺术效果,许多图像编辑工具收录了如下所述的”色调分离”操作。\n\n每个颜色通道会分别考虑,本题只考虑红\n色通道的情况。\n\n不同于在红色通道使用0到255之间全部的整数,一张色调分离后的图片只会使用这些数字里至多 k\n种整数。\n\n每个像素原来的红色强度会被替换成最相近的可用强度。\n\n图像编辑工具会选择k个整数来最小化替换过程\n引起的平方误差之和。\n\n假设原图有n个像素,它们的红色取值是r1,···,rn,而 k 种可用整数为v1,···,vk ,那么平方误差之和被定义为\n\n　　∑i=1nmin1≤j≤k(ri−vj)2.∑i=1nmin1≤j≤k(ri−vj)2.\n\n你的任务是计算可以实现的最小平方误差之和,参数k和图片的红色强度会给出。\n{% endnote %}\n\n### Input\nThe first line of the input contains two integers dd (1≤d≤2561≤d≤256), the number of distinct red values that occur in the original image, and kk (1≤k≤d1≤k≤d), the number of distinct red values allowed in the posterized image. The remaining dd lines indicate the number of pixels of the image having various red values. Each such line contains two integers rr (0≤r≤2550≤r≤255) and pp (1≤p≤2261≤p≤226), where rr is a red intensity value and pp is the number of pixels having red intensity rr. Those dd lines are given in increasing order of red value.\n\n{% note info %}\n第一行包含两个整数d(1≤d≤256)和k(1≤k≤d)  \n分别表示原图中不同的红色强度有多少种,  \n色调分离后可以使用的红色强度有多少种。  \n接下来d行描述了每种红色强度在原图中占据的像素点数量。  \n每行包含两个整数r(0≤r≤255)和p(1≤p≤226)  \n这里r是一种红色强度的取值   \n而p是这种取值对应的像素点数量。这d行信息按照红色强度取值升序给出。  \n{% endnote %}\n\n### Output \nDisplay the sum of the squared errors for an optimally chosen set of kk allowed integer values.\n\n{% note info %}\n输出最优的 k 种可选取值对应的平方误差之和。\n{% endnote %}\n\n | Sample Input 1 | Sample Output 1 |\n | -----          |  -------        |\n | 2 1            |                 |  \n | 50 20000       |                 |      \n | 150 10000      |  66670000       | \n\n | Sample Input 2 | Sample Output 2 |        \n | -----          |  -------        |\n | 2 2            |                 |  \n | 50 20000       |                 |    \n | 150 10000      | 0               |\n\n | Sample Input 3 | Sample Output 3 |        \n | -----          |  -------        |\n | 4 2            |                 |       \n | 0 30000        |                 |       \n | 25 30000       |                 |         \n | 50 30000       |                 |         \n | 255 30000      | 37500000        | \n\n### 思路\n　　主要是dp,记忆化搜索＋剪枝,看后面的代码注释和题解\n\n## 题目转化\n### 题意\n有256个位置，有d个位置上有人（每个位置上可能不止一个人），你可以在k个位置上插旗（每个位置上至多一面旗子），\n\n每个人都会走到离自己最近的旗子，求所有人走的距离的平方和的最小值。\n\n### 题解\n要解决这个问题，我们可以建立一个二维数组*f[i][j]*，（j<=i），表示前i个位置，放了j个旗子，其中第i个位置一定放了旗子，前i个位置上的所有人走到旗子上的最小距离平方和。\n\n如果我们假设第i个位置上的旗子是k个旗子中的最后一个（即第i个位置后面没有旗子），那么第i个位置后面的人只能全部走到第i个位置上，所以把_f[i][j]_加上i位置后面的人走到i位置的距离平方和就可以得到所有人走的距离平方和。\n\n因此我们可以枚举最后一个旗子插的位置i，将_f[i][j_]加上i后面的人走到i位置的距离平方和，取最小值，即为答案。\n\n*f[i][j]*数组的建立我们可以用下面的公式来计算：*f[i][j]=min{f[m][j-1]+w[m][i]},（j-1<=m< i)*，其中*w[m][i]*\n\n表示m~i这一段只有m和i位置放了旗子，这一段上的人走的距离平方和。\n\n由于第i个位置上固定了一面旗子，我们可以考虑另外j-1面旗子的位置。\n\n若j-1面旗子在前m个位置（可以假设第m个位置上一定放旗子），那么*f[i][j]*可以分解成两段计算，\n\n一段是1~m位置，放了j-1个旗子，其中第m个位置一定放了旗子，这就递归成了*f[m][j-1]*；\n\n另一段是m+1~i位置，只有m和i位置放了旗子，这一段上的人只能走到m和i，即*w[m][i]*。\n\n所以我们只要枚举m的值，取*f[m][j-1]+w[m][i]*的最小值，就可以得出*f[i][j]*的值。\n\n下面给出一个f[i][j]的实例：考虑f[8][3]，前8个位置，放了3个旗子，其中第3个位置一定放了旗子。\n\n剩余的2面旗子可能在前2/3/4/5/6/7个位置上，由此枚举出所有情况：\n\n剩余的2面旗子在：\n> 　　前2个位置：f[2][2]+w[2][8]\n> 　　前3个位置：f[3][2]+w[3][8]\n> 　　前4个位置：f[4][2]+w[4][8]\n> 　　前5个位置：f[5][2]+w[5][8]\n> 　　前6个位置：f[6][2]+w[6][8]\n> 　　前7个位置：f[7][2]+w[7][8]\n\n取出这些值中的最小值，即得到f[8][3]的值。\n\n至于w[m][i]的建立较为简单，由于只有m和i位置放了旗子，m+1~i位置上的人只能就近走到m或i位置上，\n\n我们可以求出m和i的中值，前一半的人走到m，后一半的人走到i，求出距离平方和即可。\n\n### 代码参考\n```C++\n#include <cstdio>\n#include <cstring>\n#define N 260\n#define ll long long\n\n//读数据,返回一个整数\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n\n    //判断是否有符号\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\n    //按位读取组成整数\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\n\n//一共n个位置，kk个旗子,a[N]表示每个位置的人数\nint n,kk,a[N];\n\n//f[i][j]表示前i个位置，放了j个旗子，其中第i个位置一定放了旗子的最小平方误差\nll w[N][N],f[N][N];\n\ninline ll min(ll x,ll y){return x<y?x:y;}\n\nint main(){\n    //freopen(\"a.in\",\"r\",stdin);\n    n=read();\n    kk=read(); \n\n    //旗子数不可以比位置数多\n    if(kk>=n){\n      puts(\"0\");\n      return 0;\n    }\n\n    //读取每个位置的人数\n    for(int i=1;i<=n;++i){\n        int x=read();a[x+1]=read();\n    }\n\n    //建立w[i][j],i是第一个旗子位置,j是第二个旗子的位置\n    for(int i=1;i<=256;++i)\n\n        //i~j这一段只在i和j位置放旗子的平方误差\n        for(int j=i+2;j<=256;++j){\n          int mid=i+j>>1;\n\n            //计算i到j之间所有的位置平方和\n            for(int q=i+1;q<=j-1;++q){\n                if(q>mid) \n                  w[i][j]+=(ll)(j-q)*(j-q)*a[q];\n                else \n                  w[i][j]+=(ll)(q-i)*(q-i)*a[q];\n            }\n        }\n\n    //只放一个旗子的情况,旗子在i处，遍历i之前所有的位置,累加\n    for(int i=1;i<=256;++i)\n        for(int j=1;j<i;++j)\n            f[i][1]+=(ll)(i-j)*(i-j)*a[j];\n\n    //建立f[i][j],j是旗子的数量，从２开始到kk\n    for(int j=2;j<=kk;++j)\n        //i是一共多少个位置，从j到256\n        for(int i=j;i<=256;++i){\n            f[i][j]=f[i-1][j-1];\n\n            //前j-1个旗子放在[1,m]这里，并且m处有旗子,i处也有旗子,转化成求f[m][j-1]+w[m][i]的最小值\n            for(int m=j-1;m<i-1;++m)\n                f[i][j]=min(f[i][j],f[m][j-1]+w[m][i]);\n        }\n\n    ll ans=f[256][kk];\n    //统计答案，如果最后一个旗子不在最后一个位置，就还需要加上最后一个旗子后面的位置的平方和，枚举最后一个旗子插的位置\n\n    //i是最后一个旗子的位置,j是最后一个旗子到最后一个位置的每个位置,tmp是最后这部分的平方和\n    for(int i=255;i>=kk;--i){\n        ll tmp=0;\n        for(int j=256;j>i;--j)\n          tmp+=(ll)(j-i)*(j-i)*a[j];\n\n        //比较不同位置的平方和，取最小值\n        ans=min(ans,f[i][kk]+tmp);\n    }\n\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n```\n\n-------\n","slug":"ACM-2017WF-F-Posterize","published":1,"updated":"2019-07-25T17:38:52.440Z","layout":"post","photos":[],"link":"","_id":"ck2424ljy0002lksbl7wddtcz","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><p></p><meta name=\"referrer\" content=\"no-referrer\"><br>算法课居然直接安排了一个ACM-WF的题目…弄了半天弄懂了，记笔记记笔记!<br><a id=\"more\"></a><p></p><h1 id=\"ACM-ICPC-World-Finals-2017-F-Posterize-DP\"><a href=\"#ACM-ICPC-World-Finals-2017-F-Posterize-DP\" class=\"headerlink\" title=\"ACM-ICPC World Finals 2017 F.Posterize DP\"></a>ACM-ICPC World Finals 2017 F.Posterize DP</h1><h2 id=\"原题\"><a href=\"#原题\" class=\"headerlink\" title=\"原题\"></a>原题</h2><h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>Pixels in a digital picture can be represented with three integers in the range 00 to 255255 that indicate the intensity of the red, green, and blue colors.</p><p>To compress an image or to create an artistic effect, many photo-editing tools include a “posterize” operation which works as follows.</p><p>Each color channel is examined separately; this problem focuses only on the red channel.</p><p>Rather than allow all integers from 00 to 255255 for the red channel, a posterized image allows at most kk integers from this range.</p><p>Each pixel’s original red intensity is replaced with the nearest of the allowed integers.</p><p>The photo-editing tool selects a set of kk integers that minimizes the sum of the squared errors introduced across all pixels in the original image.</p><p>If there are nn pixels that have original red values r1,…,rnr1,…,rn, and kk allowed integers v1,…,vkv1,…,vk, the sum of squared errors is defined as</p><p>∑i=1nmin1≤j≤k(ri−vj)2.∑i=1nmin1≤j≤k(ri−vj)2.</p><p>Your task is to compute the minimum achievable sum of squared errors, given parameter kk and a description of the red intensities of an image’s pixels.</p><div class=\"note info\"><p>数字图像的像素可以用三个在0到255之间的整数表示,它们分别表示红色、绿色和蓝色的强度。</p><p>为了压缩图片或是为了生艺术效果,许多图像编辑工具收录了如下所述的”色调分离”操作。</p><p>每个颜色通道会分别考虑,本题只考虑红<br>色通道的情况。</p><p>不同于在红色通道使用0到255之间全部的整数,一张色调分离后的图片只会使用这些数字里至多 k<br>种整数。</p><p>每个像素原来的红色强度会被替换成最相近的可用强度。</p><p>图像编辑工具会选择k个整数来最小化替换过程<br>引起的平方误差之和。</p><p>假设原图有n个像素,它们的红色取值是r1,···,rn,而 k 种可用整数为v1,···,vk ,那么平方误差之和被定义为</p><p>∑i=1nmin1≤j≤k(ri−vj)2.∑i=1nmin1≤j≤k(ri−vj)2.</p><p>你的任务是计算可以实现的最小平方误差之和,参数k和图片的红色强度会给出。</p></div><h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>The first line of the input contains two integers dd (1≤d≤2561≤d≤256), the number of distinct red values that occur in the original image, and kk (1≤k≤d1≤k≤d), the number of distinct red values allowed in the posterized image. The remaining dd lines indicate the number of pixels of the image having various red values. Each such line contains two integers rr (0≤r≤2550≤r≤255) and pp (1≤p≤2261≤p≤226), where rr is a red intensity value and pp is the number of pixels having red intensity rr. Those dd lines are given in increasing order of red value.</p><div class=\"note info\"><p>第一行包含两个整数d(1≤d≤256)和k(1≤k≤d)<br>分别表示原图中不同的红色强度有多少种,<br>色调分离后可以使用的红色强度有多少种。<br>接下来d行描述了每种红色强度在原图中占据的像素点数量。<br>每行包含两个整数r(0≤r≤255)和p(1≤p≤226)<br>这里r是一种红色强度的取值<br>而p是这种取值对应的像素点数量。这d行信息按照红色强度取值升序给出。</p></div><h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>Display the sum of the squared errors for an optimally chosen set of kk allowed integer values.</p><div class=\"note info\"><p>输出最优的 k 种可选取值对应的平方误差之和。</p></div><div class=\"table-container\"><table><thead><tr><th>Sample Input 1</th><th>Sample Output 1</th></tr></thead><tbody><tr><td>2 1</td><td></td></tr><tr><td>50 20000</td><td></td></tr><tr><td>150 10000</td><td>66670000</td></tr></tbody></table></div><div class=\"table-container\"><table><thead><tr><th>Sample Input 2</th><th>Sample Output 2</th></tr></thead><tbody><tr><td>2 2</td><td></td></tr><tr><td>50 20000</td><td></td></tr><tr><td>150 10000</td><td>0</td></tr></tbody></table></div><div class=\"table-container\"><table><thead><tr><th>Sample Input 3</th><th>Sample Output 3</th></tr></thead><tbody><tr><td>4 2</td><td></td></tr><tr><td>0 30000</td><td></td></tr><tr><td>25 30000</td><td></td></tr><tr><td>50 30000</td><td></td></tr><tr><td>255 30000</td><td>37500000</td></tr></tbody></table></div><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>主要是dp,记忆化搜索＋剪枝,看后面的代码注释和题解</p><h2 id=\"题目转化\"><a href=\"#题目转化\" class=\"headerlink\" title=\"题目转化\"></a>题目转化</h2><h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>有256个位置，有d个位置上有人（每个位置上可能不止一个人），你可以在k个位置上插旗（每个位置上至多一面旗子），</p><p>每个人都会走到离自己最近的旗子，求所有人走的距离的平方和的最小值。</p><h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>要解决这个问题，我们可以建立一个二维数组<em>f[i][j]</em>，（j&lt;=i），表示前i个位置，放了j个旗子，其中第i个位置一定放了旗子，前i个位置上的所有人走到旗子上的最小距离平方和。</p><p>如果我们假设第i个位置上的旗子是k个旗子中的最后一个（即第i个位置后面没有旗子），那么第i个位置后面的人只能全部走到第i个位置上，所以把_f[i][j]_加上i位置后面的人走到i位置的距离平方和就可以得到所有人走的距离平方和。</p><p>因此我们可以枚举最后一个旗子插的位置i，将_f[i][j_]加上i后面的人走到i位置的距离平方和，取最小值，即为答案。</p><p><em>f[i][j]</em>数组的建立我们可以用下面的公式来计算：<em>f[i][j]=min{f[m][j-1]+w[m][i]},（j-1&lt;=m&lt; i)</em>，其中<em>w[m][i]</em></p><p>表示m~i这一段只有m和i位置放了旗子，这一段上的人走的距离平方和。</p><p>由于第i个位置上固定了一面旗子，我们可以考虑另外j-1面旗子的位置。</p><p>若j-1面旗子在前m个位置（可以假设第m个位置上一定放旗子），那么<em>f[i][j]</em>可以分解成两段计算，</p><p>一段是1~m位置，放了j-1个旗子，其中第m个位置一定放了旗子，这就递归成了<em>f[m][j-1]</em>；</p><p>另一段是m+1~i位置，只有m和i位置放了旗子，这一段上的人只能走到m和i，即<em>w[m][i]</em>。</p><p>所以我们只要枚举m的值，取<em>f[m][j-1]+w[m][i]</em>的最小值，就可以得出<em>f[i][j]</em>的值。</p><p>下面给出一个f[i][j]的实例：考虑f[8][3]，前8个位置，放了3个旗子，其中第3个位置一定放了旗子。</p><p>剩余的2面旗子可能在前2/3/4/5/6/7个位置上，由此枚举出所有情况：</p><p>剩余的2面旗子在：</p><blockquote><p>前2个位置：f[2][2]+w[2][8]<br>前3个位置：f[3][2]+w[3][8]<br>前4个位置：f[4][2]+w[4][8]<br>前5个位置：f[5][2]+w[5][8]<br>前6个位置：f[6][2]+w[6][8]<br>前7个位置：f[7][2]+w[7][8]</p></blockquote><p>取出这些值中的最小值，即得到f[8][3]的值。</p><p>至于w[m][i]的建立较为简单，由于只有m和i位置放了旗子，m+1~i位置上的人只能就近走到m或i位置上，</p><p>我们可以求出m和i的中值，前一半的人走到m，后一半的人走到i，求出距离平方和即可。</p><h3 id=\"代码参考\"><a href=\"#代码参考\" class=\"headerlink\" title=\"代码参考\"></a>代码参考</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 260</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读数据,返回一个整数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x=<span class=\"number\">0</span>,f=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch=getchar();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//判断是否有符号</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&lt;<span class=\"string\">'0'</span>||ch&gt;<span class=\"string\">'9'</span>)&#123;<span class=\"keyword\">if</span>(ch==<span class=\"string\">'-'</span>)f=<span class=\"number\">-1</span>;ch=getchar();&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//按位读取组成整数</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&gt;=<span class=\"string\">'0'</span>&amp;&amp;ch&lt;=<span class=\"string\">'9'</span>) x=x*<span class=\"number\">10</span>+ch-<span class=\"string\">'0'</span>,ch=getchar();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x*f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一共n个位置，kk个旗子,a[N]表示每个位置的人数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,kk,a[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//f[i][j]表示前i个位置，放了j个旗子，其中第i个位置一定放了旗子的最小平方误差</span></span><br><span class=\"line\">ll w[N][N],f[N][N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> ll <span class=\"title\">min</span><span class=\"params\">(ll x,ll y)</span></span>&#123;<span class=\"keyword\">return</span> x&lt;y?x:y;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(\"a.in\",\"r\",stdin);</span></span><br><span class=\"line\">    n=read();</span><br><span class=\"line\">    kk=read(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//旗子数不可以比位置数多</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(kk&gt;=n)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//读取每个位置的人数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x=read();a[x+<span class=\"number\">1</span>]=read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//建立w[i][j],i是第一个旗子位置,j是第二个旗子的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">256</span>;++i)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//i~j这一段只在i和j位置放旗子的平方误差</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">2</span>;j&lt;=<span class=\"number\">256</span>;++j)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> mid=i+j&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//计算i到j之间所有的位置平方和</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> q=i+<span class=\"number\">1</span>;q&lt;=j<span class=\"number\">-1</span>;++q)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(q&gt;mid) </span><br><span class=\"line\">                  w[i][j]+=(ll)(j-q)*(j-q)*a[q];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> </span><br><span class=\"line\">                  w[i][j]+=(ll)(q-i)*(q-i)*a[q];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//只放一个旗子的情况,旗子在i处，遍历i之前所有的位置,累加</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">256</span>;++i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;i;++j)</span><br><span class=\"line\">            f[i][<span class=\"number\">1</span>]+=(ll)(i-j)*(i-j)*a[j];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//建立f[i][j],j是旗子的数量，从２开始到kk</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">2</span>;j&lt;=kk;++j)</span><br><span class=\"line\">        <span class=\"comment\">//i是一共多少个位置，从j到256</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=j;i&lt;=<span class=\"number\">256</span>;++i)&#123;</span><br><span class=\"line\">            f[i][j]=f[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//前j-1个旗子放在[1,m]这里，并且m处有旗子,i处也有旗子,转化成求f[m][j-1]+w[m][i]的最小值</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> m=j<span class=\"number\">-1</span>;m&lt;i<span class=\"number\">-1</span>;++m)</span><br><span class=\"line\">                f[i][j]=min(f[i][j],f[m][j<span class=\"number\">-1</span>]+w[m][i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans=f[<span class=\"number\">256</span>][kk];</span><br><span class=\"line\">    <span class=\"comment\">//统计答案，如果最后一个旗子不在最后一个位置，就还需要加上最后一个旗子后面的位置的平方和，枚举最后一个旗子插的位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//i是最后一个旗子的位置,j是最后一个旗子到最后一个位置的每个位置,tmp是最后这部分的平方和</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">255</span>;i&gt;=kk;--i)&#123;</span><br><span class=\"line\">        ll tmp=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">256</span>;j&gt;i;--j)</span><br><span class=\"line\">          tmp+=(ll)(j-i)*(j-i)*a[j];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//比较不同位置的平方和，取最小值</span></span><br><span class=\"line\">        ans=min(ans,f[i][kk]+tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><p></p><meta name=\"referrer\" content=\"no-referrer\"><br>算法课居然直接安排了一个ACM-WF的题目…弄了半天弄懂了，记笔记记笔记!<br>","more":"<p></p><h1 id=\"ACM-ICPC-World-Finals-2017-F-Posterize-DP\"><a href=\"#ACM-ICPC-World-Finals-2017-F-Posterize-DP\" class=\"headerlink\" title=\"ACM-ICPC World Finals 2017 F.Posterize DP\"></a>ACM-ICPC World Finals 2017 F.Posterize DP</h1><h2 id=\"原题\"><a href=\"#原题\" class=\"headerlink\" title=\"原题\"></a>原题</h2><h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>Pixels in a digital picture can be represented with three integers in the range 00 to 255255 that indicate the intensity of the red, green, and blue colors.</p><p>To compress an image or to create an artistic effect, many photo-editing tools include a “posterize” operation which works as follows.</p><p>Each color channel is examined separately; this problem focuses only on the red channel.</p><p>Rather than allow all integers from 00 to 255255 for the red channel, a posterized image allows at most kk integers from this range.</p><p>Each pixel’s original red intensity is replaced with the nearest of the allowed integers.</p><p>The photo-editing tool selects a set of kk integers that minimizes the sum of the squared errors introduced across all pixels in the original image.</p><p>If there are nn pixels that have original red values r1,…,rnr1,…,rn, and kk allowed integers v1,…,vkv1,…,vk, the sum of squared errors is defined as</p><p>∑i=1nmin1≤j≤k(ri−vj)2.∑i=1nmin1≤j≤k(ri−vj)2.</p><p>Your task is to compute the minimum achievable sum of squared errors, given parameter kk and a description of the red intensities of an image’s pixels.</p><div class=\"note info\"><p>数字图像的像素可以用三个在0到255之间的整数表示,它们分别表示红色、绿色和蓝色的强度。</p><p>为了压缩图片或是为了生艺术效果,许多图像编辑工具收录了如下所述的”色调分离”操作。</p><p>每个颜色通道会分别考虑,本题只考虑红<br>色通道的情况。</p><p>不同于在红色通道使用0到255之间全部的整数,一张色调分离后的图片只会使用这些数字里至多 k<br>种整数。</p><p>每个像素原来的红色强度会被替换成最相近的可用强度。</p><p>图像编辑工具会选择k个整数来最小化替换过程<br>引起的平方误差之和。</p><p>假设原图有n个像素,它们的红色取值是r1,···,rn,而 k 种可用整数为v1,···,vk ,那么平方误差之和被定义为</p><p>∑i=1nmin1≤j≤k(ri−vj)2.∑i=1nmin1≤j≤k(ri−vj)2.</p><p>你的任务是计算可以实现的最小平方误差之和,参数k和图片的红色强度会给出。</p></div><h3 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h3><p>The first line of the input contains two integers dd (1≤d≤2561≤d≤256), the number of distinct red values that occur in the original image, and kk (1≤k≤d1≤k≤d), the number of distinct red values allowed in the posterized image. The remaining dd lines indicate the number of pixels of the image having various red values. Each such line contains two integers rr (0≤r≤2550≤r≤255) and pp (1≤p≤2261≤p≤226), where rr is a red intensity value and pp is the number of pixels having red intensity rr. Those dd lines are given in increasing order of red value.</p><div class=\"note info\"><p>第一行包含两个整数d(1≤d≤256)和k(1≤k≤d)<br>分别表示原图中不同的红色强度有多少种,<br>色调分离后可以使用的红色强度有多少种。<br>接下来d行描述了每种红色强度在原图中占据的像素点数量。<br>每行包含两个整数r(0≤r≤255)和p(1≤p≤226)<br>这里r是一种红色强度的取值<br>而p是这种取值对应的像素点数量。这d行信息按照红色强度取值升序给出。</p></div><h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><p>Display the sum of the squared errors for an optimally chosen set of kk allowed integer values.</p><div class=\"note info\"><p>输出最优的 k 种可选取值对应的平方误差之和。</p></div><div class=\"table-container\"><table><thead><tr><th>Sample Input 1</th><th>Sample Output 1</th></tr></thead><tbody><tr><td>2 1</td><td></td></tr><tr><td>50 20000</td><td></td></tr><tr><td>150 10000</td><td>66670000</td></tr></tbody></table></div><div class=\"table-container\"><table><thead><tr><th>Sample Input 2</th><th>Sample Output 2</th></tr></thead><tbody><tr><td>2 2</td><td></td></tr><tr><td>50 20000</td><td></td></tr><tr><td>150 10000</td><td>0</td></tr></tbody></table></div><div class=\"table-container\"><table><thead><tr><th>Sample Input 3</th><th>Sample Output 3</th></tr></thead><tbody><tr><td>4 2</td><td></td></tr><tr><td>0 30000</td><td></td></tr><tr><td>25 30000</td><td></td></tr><tr><td>50 30000</td><td></td></tr><tr><td>255 30000</td><td>37500000</td></tr></tbody></table></div><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>主要是dp,记忆化搜索＋剪枝,看后面的代码注释和题解</p><h2 id=\"题目转化\"><a href=\"#题目转化\" class=\"headerlink\" title=\"题目转化\"></a>题目转化</h2><h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>有256个位置，有d个位置上有人（每个位置上可能不止一个人），你可以在k个位置上插旗（每个位置上至多一面旗子），</p><p>每个人都会走到离自己最近的旗子，求所有人走的距离的平方和的最小值。</p><h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>要解决这个问题，我们可以建立一个二维数组<em>f[i][j]</em>，（j&lt;=i），表示前i个位置，放了j个旗子，其中第i个位置一定放了旗子，前i个位置上的所有人走到旗子上的最小距离平方和。</p><p>如果我们假设第i个位置上的旗子是k个旗子中的最后一个（即第i个位置后面没有旗子），那么第i个位置后面的人只能全部走到第i个位置上，所以把_f[i][j]_加上i位置后面的人走到i位置的距离平方和就可以得到所有人走的距离平方和。</p><p>因此我们可以枚举最后一个旗子插的位置i，将_f[i][j_]加上i后面的人走到i位置的距离平方和，取最小值，即为答案。</p><p><em>f[i][j]</em>数组的建立我们可以用下面的公式来计算：<em>f[i][j]=min{f[m][j-1]+w[m][i]},（j-1&lt;=m&lt; i)</em>，其中<em>w[m][i]</em></p><p>表示m~i这一段只有m和i位置放了旗子，这一段上的人走的距离平方和。</p><p>由于第i个位置上固定了一面旗子，我们可以考虑另外j-1面旗子的位置。</p><p>若j-1面旗子在前m个位置（可以假设第m个位置上一定放旗子），那么<em>f[i][j]</em>可以分解成两段计算，</p><p>一段是1~m位置，放了j-1个旗子，其中第m个位置一定放了旗子，这就递归成了<em>f[m][j-1]</em>；</p><p>另一段是m+1~i位置，只有m和i位置放了旗子，这一段上的人只能走到m和i，即<em>w[m][i]</em>。</p><p>所以我们只要枚举m的值，取<em>f[m][j-1]+w[m][i]</em>的最小值，就可以得出<em>f[i][j]</em>的值。</p><p>下面给出一个f[i][j]的实例：考虑f[8][3]，前8个位置，放了3个旗子，其中第3个位置一定放了旗子。</p><p>剩余的2面旗子可能在前2/3/4/5/6/7个位置上，由此枚举出所有情况：</p><p>剩余的2面旗子在：</p><blockquote><p>前2个位置：f[2][2]+w[2][8]<br>前3个位置：f[3][2]+w[3][8]<br>前4个位置：f[4][2]+w[4][8]<br>前5个位置：f[5][2]+w[5][8]<br>前6个位置：f[6][2]+w[6][8]<br>前7个位置：f[7][2]+w[7][8]</p></blockquote><p>取出这些值中的最小值，即得到f[8][3]的值。</p><p>至于w[m][i]的建立较为简单，由于只有m和i位置放了旗子，m+1~i位置上的人只能就近走到m或i位置上，</p><p>我们可以求出m和i的中值，前一半的人走到m，后一半的人走到i，求出距离平方和即可。</p><h3 id=\"代码参考\"><a href=\"#代码参考\" class=\"headerlink\" title=\"代码参考\"></a>代码参考</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 260</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读数据,返回一个整数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x=<span class=\"number\">0</span>,f=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch=getchar();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//判断是否有符号</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&lt;<span class=\"string\">'0'</span>||ch&gt;<span class=\"string\">'9'</span>)&#123;<span class=\"keyword\">if</span>(ch==<span class=\"string\">'-'</span>)f=<span class=\"number\">-1</span>;ch=getchar();&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//按位读取组成整数</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&gt;=<span class=\"string\">'0'</span>&amp;&amp;ch&lt;=<span class=\"string\">'9'</span>) x=x*<span class=\"number\">10</span>+ch-<span class=\"string\">'0'</span>,ch=getchar();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x*f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一共n个位置，kk个旗子,a[N]表示每个位置的人数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,kk,a[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//f[i][j]表示前i个位置，放了j个旗子，其中第i个位置一定放了旗子的最小平方误差</span></span><br><span class=\"line\">ll w[N][N],f[N][N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> ll <span class=\"title\">min</span><span class=\"params\">(ll x,ll y)</span></span>&#123;<span class=\"keyword\">return</span> x&lt;y?x:y;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(\"a.in\",\"r\",stdin);</span></span><br><span class=\"line\">    n=read();</span><br><span class=\"line\">    kk=read(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//旗子数不可以比位置数多</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(kk&gt;=n)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//读取每个位置的人数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x=read();a[x+<span class=\"number\">1</span>]=read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//建立w[i][j],i是第一个旗子位置,j是第二个旗子的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">256</span>;++i)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//i~j这一段只在i和j位置放旗子的平方误差</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">2</span>;j&lt;=<span class=\"number\">256</span>;++j)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> mid=i+j&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//计算i到j之间所有的位置平方和</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> q=i+<span class=\"number\">1</span>;q&lt;=j<span class=\"number\">-1</span>;++q)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(q&gt;mid) </span><br><span class=\"line\">                  w[i][j]+=(ll)(j-q)*(j-q)*a[q];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> </span><br><span class=\"line\">                  w[i][j]+=(ll)(q-i)*(q-i)*a[q];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//只放一个旗子的情况,旗子在i处，遍历i之前所有的位置,累加</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">256</span>;++i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;i;++j)</span><br><span class=\"line\">            f[i][<span class=\"number\">1</span>]+=(ll)(i-j)*(i-j)*a[j];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//建立f[i][j],j是旗子的数量，从２开始到kk</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">2</span>;j&lt;=kk;++j)</span><br><span class=\"line\">        <span class=\"comment\">//i是一共多少个位置，从j到256</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=j;i&lt;=<span class=\"number\">256</span>;++i)&#123;</span><br><span class=\"line\">            f[i][j]=f[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//前j-1个旗子放在[1,m]这里，并且m处有旗子,i处也有旗子,转化成求f[m][j-1]+w[m][i]的最小值</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> m=j<span class=\"number\">-1</span>;m&lt;i<span class=\"number\">-1</span>;++m)</span><br><span class=\"line\">                f[i][j]=min(f[i][j],f[m][j<span class=\"number\">-1</span>]+w[m][i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ll ans=f[<span class=\"number\">256</span>][kk];</span><br><span class=\"line\">    <span class=\"comment\">//统计答案，如果最后一个旗子不在最后一个位置，就还需要加上最后一个旗子后面的位置的平方和，枚举最后一个旗子插的位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//i是最后一个旗子的位置,j是最后一个旗子到最后一个位置的每个位置,tmp是最后这部分的平方和</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">255</span>;i&gt;=kk;--i)&#123;</span><br><span class=\"line\">        ll tmp=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">256</span>;j&gt;i;--j)</span><br><span class=\"line\">          tmp+=(ll)(j-i)*(j-i)*a[j];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//比较不同位置的平方和，取最小值</span></span><br><span class=\"line\">        ans=min(ans,f[i][kk]+tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"ArchLinux-Gnome下触摸板设置","urlname":"ArchLinux-Gnome-Synaptics","comments":1,"mathjax":false,"date":"2019-07-22T15:58:57.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\nArch下触摸板默认是没有模拟鼠标单击双击功能的, 通过设置可以修改,具体参考[ArchWiki](https://wiki.archlinux.org/index.php/Touchpad_Synaptics)\n\n这里没有使用配置文件,只是用[Synclient](https://wiki.archlinux.org/index.php/Touchpad_Synaptics#Synclient)这个命令行工具设置\n\n如果希望长期有效，还是需要使用配置文件，配置文件样例见文末\n{% endnote %}\n<!--more-->\n## 模拟鼠标点击\n\n使用synclient查看当前触摸板设置\n\n```\n$ synclient -l\n```\n\n可以发现TapButton1, TapButton2, TapButton3, 这三个都是0\n我们修改 TapButton1=1, TapButton2=3, TapButton3=2\n\n```\n$ synclient TapButton1=1 TapButton2=3 TapButton3=2\n```\n\n## 设置自然滚动\n把VertScrollDelta 和 HorizScrollDelta设置成负数就可以了\n\n```\n$ synclient VertScrollDelta=-111 HorizScrollDelta=-111\n```\n\n## 设置触摸板禁用\n实际使用过程中，发现触摸板常常出现误触的情况，打字的时候很容易就跑偏了。\n所以设置：在鼠标存在的情况下，禁用触摸板，没有鼠标的时候才可以用\n\n使用的是gnome环境，根据wiki的说明，我们使用GNOME Shell扩展，TouchpadIndicator.\nTouchpadIndicator主页：[TouchpadIndicator](https://www.ashessin.com/TouchpadIndicator/)\n\n通过git安装:\n\n```bash\n$ git clone --depth = 1 “ https://github.com/user501254/TouchpadIndicator.git ” ; rm -rf TouchpadIndicator / .git\n$ RM -rf 〜 /。本地 / share / gnome-shell / extensions / touchpad-indicator @ orangeshirt\n$ mv TouchpadIndicator / 〜 /。本地 / share / gnome-shell / extensions / touchpad-indicator @ orangeshirt\n\n# 重启Gnome\n$ Alt+F2，r，Enter\n\n# 在gnome-tweak-tool中启用扩展\n```\n\n## 配置文件样例\n\n```\n/etc/X11/xorg.conf.d/70-synaptics.conf\n-------------------------------------------------\nSection \"InputClass\"\n      Identifier \"touchpad\"\n      Driver \"synaptics\"\n      MatchIsTouchpad \"on\"\n             Option \"TapButton1\" \"1\"\n             Option \"TapButton2\" \"3\"\n             Option \"TapButton3\" \"2\"\n             Option \"VertEdgeScroll\" \"on\"\n             Option \"VertTwoFingerScroll\" \"on\"\n             Option \"HorizEdgeScroll\" \"on\"\n             Option \"HorizTwoFingerScroll\" \"on\"\n             Option \"CircularScrolling\" \"on\"\n             Option \"CircScrollTrigger\" \"2\"\n             Option \"EmulateTwoFingerMinZ\" \"40\"\n             Option \"EmulateTwoFingerMinW\" \"8\"\n             Option \"FingerLow\" \"30\"\n             Option \"FingerHigh\" \"50\"\n             Option \"MaxTapTime\" \"125\"\nEndSection\n```\n\n\n------\n\n其他一些配置比如环形滚动什么的, 可以自己去wiki看说明.\n","source":"_posts/ArchLinux-Gnome下触摸板设置.md","raw":"---\ntitle: ArchLinux-Gnome下触摸板设置\ntags:\n  - Arch\n  - Linux\n  - Gnome\n  - Synaptics\ncategories:\n  - Linux\nurlname: ArchLinux-Gnome-Synaptics \ncomments: true\nmathjax: false\ndate: 2019-07-22 23:58:57\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\nArch下触摸板默认是没有模拟鼠标单击双击功能的, 通过设置可以修改,具体参考[ArchWiki](https://wiki.archlinux.org/index.php/Touchpad_Synaptics)\n\n这里没有使用配置文件,只是用[Synclient](https://wiki.archlinux.org/index.php/Touchpad_Synaptics#Synclient)这个命令行工具设置\n\n如果希望长期有效，还是需要使用配置文件，配置文件样例见文末\n{% endnote %}\n<!--more-->\n## 模拟鼠标点击\n\n使用synclient查看当前触摸板设置\n\n```\n$ synclient -l\n```\n\n可以发现TapButton1, TapButton2, TapButton3, 这三个都是0\n我们修改 TapButton1=1, TapButton2=3, TapButton3=2\n\n```\n$ synclient TapButton1=1 TapButton2=3 TapButton3=2\n```\n\n## 设置自然滚动\n把VertScrollDelta 和 HorizScrollDelta设置成负数就可以了\n\n```\n$ synclient VertScrollDelta=-111 HorizScrollDelta=-111\n```\n\n## 设置触摸板禁用\n实际使用过程中，发现触摸板常常出现误触的情况，打字的时候很容易就跑偏了。\n所以设置：在鼠标存在的情况下，禁用触摸板，没有鼠标的时候才可以用\n\n使用的是gnome环境，根据wiki的说明，我们使用GNOME Shell扩展，TouchpadIndicator.\nTouchpadIndicator主页：[TouchpadIndicator](https://www.ashessin.com/TouchpadIndicator/)\n\n通过git安装:\n\n```bash\n$ git clone --depth = 1 “ https://github.com/user501254/TouchpadIndicator.git ” ; rm -rf TouchpadIndicator / .git\n$ RM -rf 〜 /。本地 / share / gnome-shell / extensions / touchpad-indicator @ orangeshirt\n$ mv TouchpadIndicator / 〜 /。本地 / share / gnome-shell / extensions / touchpad-indicator @ orangeshirt\n\n# 重启Gnome\n$ Alt+F2，r，Enter\n\n# 在gnome-tweak-tool中启用扩展\n```\n\n## 配置文件样例\n\n```\n/etc/X11/xorg.conf.d/70-synaptics.conf\n-------------------------------------------------\nSection \"InputClass\"\n      Identifier \"touchpad\"\n      Driver \"synaptics\"\n      MatchIsTouchpad \"on\"\n             Option \"TapButton1\" \"1\"\n             Option \"TapButton2\" \"3\"\n             Option \"TapButton3\" \"2\"\n             Option \"VertEdgeScroll\" \"on\"\n             Option \"VertTwoFingerScroll\" \"on\"\n             Option \"HorizEdgeScroll\" \"on\"\n             Option \"HorizTwoFingerScroll\" \"on\"\n             Option \"CircularScrolling\" \"on\"\n             Option \"CircScrollTrigger\" \"2\"\n             Option \"EmulateTwoFingerMinZ\" \"40\"\n             Option \"EmulateTwoFingerMinW\" \"8\"\n             Option \"FingerLow\" \"30\"\n             Option \"FingerHigh\" \"50\"\n             Option \"MaxTapTime\" \"125\"\nEndSection\n```\n\n\n------\n\n其他一些配置比如环形滚动什么的, 可以自己去wiki看说明.\n","slug":"ArchLinux-Gnome下触摸板设置","published":1,"updated":"2019-10-02T06:28:01.250Z","layout":"post","photos":[],"link":"","_id":"ck2424lk20005lksbdsw4s1p8","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Arch下触摸板默认是没有模拟鼠标单击双击功能的, 通过设置可以修改,具体参考<a href=\"https://wiki.archlinux.org/index.php/Touchpad_Synaptics\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ArchWiki</a></p><p>这里没有使用配置文件,只是用<a href=\"https://wiki.archlinux.org/index.php/Touchpad_Synaptics#Synclient\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Synclient</a>这个命令行工具设置</p><p>如果希望长期有效，还是需要使用配置文件，配置文件样例见文末</p></div><a id=\"more\"></a><h2 id=\"模拟鼠标点击\"><a href=\"#模拟鼠标点击\" class=\"headerlink\" title=\"模拟鼠标点击\"></a>模拟鼠标点击</h2><p>使用synclient查看当前触摸板设置</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ synclient -l</span><br></pre></td></tr></table></figure><p>可以发现TapButton1, TapButton2, TapButton3, 这三个都是0<br>我们修改 TapButton1=1, TapButton2=3, TapButton3=2</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ synclient TapButton1=1 TapButton2=3 TapButton3=2</span><br></pre></td></tr></table></figure><h2 id=\"设置自然滚动\"><a href=\"#设置自然滚动\" class=\"headerlink\" title=\"设置自然滚动\"></a>设置自然滚动</h2><p>把VertScrollDelta 和 HorizScrollDelta设置成负数就可以了</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ synclient VertScrollDelta=-111 HorizScrollDelta=-111</span><br></pre></td></tr></table></figure><h2 id=\"设置触摸板禁用\"><a href=\"#设置触摸板禁用\" class=\"headerlink\" title=\"设置触摸板禁用\"></a>设置触摸板禁用</h2><p>实际使用过程中，发现触摸板常常出现误触的情况，打字的时候很容易就跑偏了。<br>所以设置：在鼠标存在的情况下，禁用触摸板，没有鼠标的时候才可以用</p><p>使用的是gnome环境，根据wiki的说明，我们使用GNOME Shell扩展，TouchpadIndicator.<br>TouchpadIndicator主页：<a href=\"https://www.ashessin.com/TouchpadIndicator/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">TouchpadIndicator</a></p><p>通过git安装:</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> --depth = 1 “ https://github.com/user501254/TouchpadIndicator.git ” ; rm -rf TouchpadIndicator / .git</span><br><span class=\"line\">$ RM -rf 〜 /。本地 / share / gnome-shell / extensions / touchpad-indicator @ orangeshirt</span><br><span class=\"line\">$ mv TouchpadIndicator / 〜 /。本地 / share / gnome-shell / extensions / touchpad-indicator @ orangeshirt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启Gnome</span></span><br><span class=\"line\">$ Alt+F2，r，Enter</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在gnome-tweak-tool中启用扩展</span></span><br></pre></td></tr></table></figure><h2 id=\"配置文件样例\"><a href=\"#配置文件样例\" class=\"headerlink\" title=\"配置文件样例\"></a>配置文件样例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/X11/xorg.conf.d/70-synaptics.conf</span><br><span class=\"line\">-------------------------------------------------</span><br><span class=\"line\">Section &quot;InputClass&quot;</span><br><span class=\"line\">      Identifier &quot;touchpad&quot;</span><br><span class=\"line\">      Driver &quot;synaptics&quot;</span><br><span class=\"line\">      MatchIsTouchpad &quot;on&quot;</span><br><span class=\"line\">             Option &quot;TapButton1&quot; &quot;1&quot;</span><br><span class=\"line\">             Option &quot;TapButton2&quot; &quot;3&quot;</span><br><span class=\"line\">             Option &quot;TapButton3&quot; &quot;2&quot;</span><br><span class=\"line\">             Option &quot;VertEdgeScroll&quot; &quot;on&quot;</span><br><span class=\"line\">             Option &quot;VertTwoFingerScroll&quot; &quot;on&quot;</span><br><span class=\"line\">             Option &quot;HorizEdgeScroll&quot; &quot;on&quot;</span><br><span class=\"line\">             Option &quot;HorizTwoFingerScroll&quot; &quot;on&quot;</span><br><span class=\"line\">             Option &quot;CircularScrolling&quot; &quot;on&quot;</span><br><span class=\"line\">             Option &quot;CircScrollTrigger&quot; &quot;2&quot;</span><br><span class=\"line\">             Option &quot;EmulateTwoFingerMinZ&quot; &quot;40&quot;</span><br><span class=\"line\">             Option &quot;EmulateTwoFingerMinW&quot; &quot;8&quot;</span><br><span class=\"line\">             Option &quot;FingerLow&quot; &quot;30&quot;</span><br><span class=\"line\">             Option &quot;FingerHigh&quot; &quot;50&quot;</span><br><span class=\"line\">             Option &quot;MaxTapTime&quot; &quot;125&quot;</span><br><span class=\"line\">EndSection</span><br></pre></td></tr></table></figure><hr><p>其他一些配置比如环形滚动什么的, 可以自己去wiki看说明.</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Arch下触摸板默认是没有模拟鼠标单击双击功能的, 通过设置可以修改,具体参考<a href=\"https://wiki.archlinux.org/index.php/Touchpad_Synaptics\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ArchWiki</a></p><p>这里没有使用配置文件,只是用<a href=\"https://wiki.archlinux.org/index.php/Touchpad_Synaptics#Synclient\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Synclient</a>这个命令行工具设置</p><p>如果希望长期有效，还是需要使用配置文件，配置文件样例见文末</p></div>","more":"<h2 id=\"模拟鼠标点击\"><a href=\"#模拟鼠标点击\" class=\"headerlink\" title=\"模拟鼠标点击\"></a>模拟鼠标点击</h2><p>使用synclient查看当前触摸板设置</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ synclient -l</span><br></pre></td></tr></table></figure><p>可以发现TapButton1, TapButton2, TapButton3, 这三个都是0<br>我们修改 TapButton1=1, TapButton2=3, TapButton3=2</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ synclient TapButton1=1 TapButton2=3 TapButton3=2</span><br></pre></td></tr></table></figure><h2 id=\"设置自然滚动\"><a href=\"#设置自然滚动\" class=\"headerlink\" title=\"设置自然滚动\"></a>设置自然滚动</h2><p>把VertScrollDelta 和 HorizScrollDelta设置成负数就可以了</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ synclient VertScrollDelta=-111 HorizScrollDelta=-111</span><br></pre></td></tr></table></figure><h2 id=\"设置触摸板禁用\"><a href=\"#设置触摸板禁用\" class=\"headerlink\" title=\"设置触摸板禁用\"></a>设置触摸板禁用</h2><p>实际使用过程中，发现触摸板常常出现误触的情况，打字的时候很容易就跑偏了。<br>所以设置：在鼠标存在的情况下，禁用触摸板，没有鼠标的时候才可以用</p><p>使用的是gnome环境，根据wiki的说明，我们使用GNOME Shell扩展，TouchpadIndicator.<br>TouchpadIndicator主页：<a href=\"https://www.ashessin.com/TouchpadIndicator/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">TouchpadIndicator</a></p><p>通过git安装:</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> --depth = 1 “ https://github.com/user501254/TouchpadIndicator.git ” ; rm -rf TouchpadIndicator / .git</span><br><span class=\"line\">$ RM -rf 〜 /。本地 / share / gnome-shell / extensions / touchpad-indicator @ orangeshirt</span><br><span class=\"line\">$ mv TouchpadIndicator / 〜 /。本地 / share / gnome-shell / extensions / touchpad-indicator @ orangeshirt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启Gnome</span></span><br><span class=\"line\">$ Alt+F2，r，Enter</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在gnome-tweak-tool中启用扩展</span></span><br></pre></td></tr></table></figure><h2 id=\"配置文件样例\"><a href=\"#配置文件样例\" class=\"headerlink\" title=\"配置文件样例\"></a>配置文件样例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/X11/xorg.conf.d/70-synaptics.conf</span><br><span class=\"line\">-------------------------------------------------</span><br><span class=\"line\">Section &quot;InputClass&quot;</span><br><span class=\"line\">      Identifier &quot;touchpad&quot;</span><br><span class=\"line\">      Driver &quot;synaptics&quot;</span><br><span class=\"line\">      MatchIsTouchpad &quot;on&quot;</span><br><span class=\"line\">             Option &quot;TapButton1&quot; &quot;1&quot;</span><br><span class=\"line\">             Option &quot;TapButton2&quot; &quot;3&quot;</span><br><span class=\"line\">             Option &quot;TapButton3&quot; &quot;2&quot;</span><br><span class=\"line\">             Option &quot;VertEdgeScroll&quot; &quot;on&quot;</span><br><span class=\"line\">             Option &quot;VertTwoFingerScroll&quot; &quot;on&quot;</span><br><span class=\"line\">             Option &quot;HorizEdgeScroll&quot; &quot;on&quot;</span><br><span class=\"line\">             Option &quot;HorizTwoFingerScroll&quot; &quot;on&quot;</span><br><span class=\"line\">             Option &quot;CircularScrolling&quot; &quot;on&quot;</span><br><span class=\"line\">             Option &quot;CircScrollTrigger&quot; &quot;2&quot;</span><br><span class=\"line\">             Option &quot;EmulateTwoFingerMinZ&quot; &quot;40&quot;</span><br><span class=\"line\">             Option &quot;EmulateTwoFingerMinW&quot; &quot;8&quot;</span><br><span class=\"line\">             Option &quot;FingerLow&quot; &quot;30&quot;</span><br><span class=\"line\">             Option &quot;FingerHigh&quot; &quot;50&quot;</span><br><span class=\"line\">             Option &quot;MaxTapTime&quot; &quot;125&quot;</span><br><span class=\"line\">EndSection</span><br></pre></td></tr></table></figure><hr><p>其他一些配置比如环形滚动什么的, 可以自己去wiki看说明.</p><!-- rebuild by neat -->"},{"title":"Fedora 26 编译内核","comments":1,"mathjax":false,"date":"2019-03-31T16:09:49.000Z","urlname":"fedora26-make-kernel","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n被迫很不情愿的编译内核...以前服务器上编译过，贼麻烦，现在又要编译，为了不让我的Arch出什么幺蛾子，新弄了个虚拟机练手了。    \n还是Fedora26的，现在都出29了，时间过得真快。\n\n<!--more-->\n# 准备工作\n## 查看自己内核版本\n    uname -a\n    Linux localhost.localdomain 4.11.8-300.fc26.x86_64 #1 SMP Thu Jun 29 20:09:48 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n\n## 下载内核并解压到/usr/src目录下\n推荐一下[上海交大的网站](http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/)，速度挺快的。  \n下载好后`tar xf linux-5.0.1.tar.gz -C /usr/src`解压到/usr/src下\n\n## 注意事项\n{% note danger %}\nmake编译内核起码预留10个G，编译完之后，不然存储会不够，又要重新弄。\nboot分区发现200M会不够用，改成500M可以，扩容还是挺麻烦的\n/ 根目录（具体来说是 /lib，没挂载/lib的话就默认是使用/目录） 要有至少4G的空余空间\n{% endnote %}\n\n# 编译安装\n## make makemenuconfig\n这是带有图形化界面的配置命令，在这里面可以定制很多功能。  \n常见的是定制内核版本，或者开启ntfs的功能。\n\n内核版本在general setup里面，找到local version -append to kernel release\n\nntfs在file-systems下面，很下面的位置，找到DOS/FAT/NT Filesystems，进入后用M键启用NTFS，用模块的方式，并在下面的NTFS write support 那里用y键启用  \n\n然后 保存退出\n\n如果想用默认配置，可以直接方向键选择**save**，然后**exit**。\n\n刚开始使用这个命令可能会一直报错，解决的基本原则是提示缺少什么包\n\n就在这个包的名字后面加上-devel，然后用dnf安装（其他版本也一样，只要换一下包管理器名）\n\n### 缺少ncurses-devel包\n    dnf install ncurses-devel\n\n### 缺少flex包\n    dnf install flex\n\n### 缺少bison包\n    dnf install bison\n\n### 报错：You are building kernel with non-retpoline compiler.\n应该升级GCC了，刚开始一直卡在这，网上也没发现non-retpoline是什么鬼，后来才发现是gcc版本太低，可能我刚装的虚拟机，没升级...      \n\n    dnf update gcc\n\n### 缺少libelf-dev, libelf-devel or elfutils-libelf-devel\n报错：error: Cannot generate ORC metadata for CONFIG_UNWINDER_ORC=y, please install libelf-dev, libelf-devel or elfutils-libelf-devel\n\n这个直接安装会发现源里面没有，可以选择rpm包安装,也可以：\n\n    dnf install binutils gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms\n\n这也是百度到的办法...当时都惊了，源里面居然都没有...\n\n这里在装dkms,kernel-devel,patch的时候，安装了elfutils-libelf-devel和zlib-devel依赖\n\n### 缺少openssl\n报错:scripts/sign-file.c:25:10: fatal error: openssl/opensslv.h: No such file or directory\n #include <openssl/opensslv.h>\n\n 这里`dnf install openssl`发现已经安装了，很奇怪，后来发现libssl-devel在redhat系这里叫**openssl-devel**\n\n所以`dnf install openssl-devel`\n\n 如果是**debian**系的，应该是安装**openss**和**libssl-devel**\n\n## make mrproper \n清除编译过程中产生的所有中间文件   \n\n假如你之前也编译过内核，而你没有用此命令去清除之前编译产生的.o文件，那么，在make的时候，可能就会产生干扰。  \n\n清除之后要重新make menuconfig 生成.config文件\n\n## make -j8\n**-j**是代表编译时用几个线程，这里开了8个线程来编译，不然太慢了。\n\n## make modules_install\n安装内核模块，这里比较快，一会会就好了，安装完后可以看到/lib/modules目录下就会出现新的内核。\n\n## make install\n安装bzImage为/boot/vmlinuz-VERSION-RELEASE，并生成initramfs文件  \n使用ls /boot就可以查看新生成的文件，注意以安装的版本结尾的文件就好\n\n查看grub.cfg, `ls /boot/grub2`, 应该就有grub.cfg引导文件了\n\n## 重启\n这时候应该就可以在启动项发现新的内核了\n\n## 删除旧内核\n- 删除/lib/modules/目录下不需要的内核库文件\n\n- 删除/usr/src/linux/目录下不需要的内核源码\n\n- 删除/boot目录下启动的内核和内核映像文件\n\n- 更改grub的配置文件，删除不需要的内核启动列表\n\n------------------\n这时候内核编译就结束了，还是挺耗时间的，特别是编译的时候。\n\n","source":"_posts/Fedora26编译内核.md","raw":"---\ntitle: Fedora 26 编译内核\ncomments: true\nmathjax: false\ndate: 2019-04-01 00:09:49\ntags: [Linux,Learning]\ncategories: Linux\nurlname: fedora26-make-kernel\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n被迫很不情愿的编译内核...以前服务器上编译过，贼麻烦，现在又要编译，为了不让我的Arch出什么幺蛾子，新弄了个虚拟机练手了。    \n还是Fedora26的，现在都出29了，时间过得真快。\n\n<!--more-->\n# 准备工作\n## 查看自己内核版本\n    uname -a\n    Linux localhost.localdomain 4.11.8-300.fc26.x86_64 #1 SMP Thu Jun 29 20:09:48 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n\n## 下载内核并解压到/usr/src目录下\n推荐一下[上海交大的网站](http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/)，速度挺快的。  \n下载好后`tar xf linux-5.0.1.tar.gz -C /usr/src`解压到/usr/src下\n\n## 注意事项\n{% note danger %}\nmake编译内核起码预留10个G，编译完之后，不然存储会不够，又要重新弄。\nboot分区发现200M会不够用，改成500M可以，扩容还是挺麻烦的\n/ 根目录（具体来说是 /lib，没挂载/lib的话就默认是使用/目录） 要有至少4G的空余空间\n{% endnote %}\n\n# 编译安装\n## make makemenuconfig\n这是带有图形化界面的配置命令，在这里面可以定制很多功能。  \n常见的是定制内核版本，或者开启ntfs的功能。\n\n内核版本在general setup里面，找到local version -append to kernel release\n\nntfs在file-systems下面，很下面的位置，找到DOS/FAT/NT Filesystems，进入后用M键启用NTFS，用模块的方式，并在下面的NTFS write support 那里用y键启用  \n\n然后 保存退出\n\n如果想用默认配置，可以直接方向键选择**save**，然后**exit**。\n\n刚开始使用这个命令可能会一直报错，解决的基本原则是提示缺少什么包\n\n就在这个包的名字后面加上-devel，然后用dnf安装（其他版本也一样，只要换一下包管理器名）\n\n### 缺少ncurses-devel包\n    dnf install ncurses-devel\n\n### 缺少flex包\n    dnf install flex\n\n### 缺少bison包\n    dnf install bison\n\n### 报错：You are building kernel with non-retpoline compiler.\n应该升级GCC了，刚开始一直卡在这，网上也没发现non-retpoline是什么鬼，后来才发现是gcc版本太低，可能我刚装的虚拟机，没升级...      \n\n    dnf update gcc\n\n### 缺少libelf-dev, libelf-devel or elfutils-libelf-devel\n报错：error: Cannot generate ORC metadata for CONFIG_UNWINDER_ORC=y, please install libelf-dev, libelf-devel or elfutils-libelf-devel\n\n这个直接安装会发现源里面没有，可以选择rpm包安装,也可以：\n\n    dnf install binutils gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms\n\n这也是百度到的办法...当时都惊了，源里面居然都没有...\n\n这里在装dkms,kernel-devel,patch的时候，安装了elfutils-libelf-devel和zlib-devel依赖\n\n### 缺少openssl\n报错:scripts/sign-file.c:25:10: fatal error: openssl/opensslv.h: No such file or directory\n #include <openssl/opensslv.h>\n\n 这里`dnf install openssl`发现已经安装了，很奇怪，后来发现libssl-devel在redhat系这里叫**openssl-devel**\n\n所以`dnf install openssl-devel`\n\n 如果是**debian**系的，应该是安装**openss**和**libssl-devel**\n\n## make mrproper \n清除编译过程中产生的所有中间文件   \n\n假如你之前也编译过内核，而你没有用此命令去清除之前编译产生的.o文件，那么，在make的时候，可能就会产生干扰。  \n\n清除之后要重新make menuconfig 生成.config文件\n\n## make -j8\n**-j**是代表编译时用几个线程，这里开了8个线程来编译，不然太慢了。\n\n## make modules_install\n安装内核模块，这里比较快，一会会就好了，安装完后可以看到/lib/modules目录下就会出现新的内核。\n\n## make install\n安装bzImage为/boot/vmlinuz-VERSION-RELEASE，并生成initramfs文件  \n使用ls /boot就可以查看新生成的文件，注意以安装的版本结尾的文件就好\n\n查看grub.cfg, `ls /boot/grub2`, 应该就有grub.cfg引导文件了\n\n## 重启\n这时候应该就可以在启动项发现新的内核了\n\n## 删除旧内核\n- 删除/lib/modules/目录下不需要的内核库文件\n\n- 删除/usr/src/linux/目录下不需要的内核源码\n\n- 删除/boot目录下启动的内核和内核映像文件\n\n- 更改grub的配置文件，删除不需要的内核启动列表\n\n------------------\n这时候内核编译就结束了，还是挺耗时间的，特别是编译的时候。\n\n","slug":"Fedora26编译内核","published":1,"updated":"2019-07-25T17:44:02.350Z","layout":"post","photos":[],"link":"","_id":"ck2424lk40006lksba8n4dxv7","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><p></p><meta name=\"referrer\" content=\"no-referrer\"><br>被迫很不情愿的编译内核…以前服务器上编译过，贼麻烦，现在又要编译，为了不让我的Arch出什么幺蛾子，新弄了个虚拟机练手了。<br>还是Fedora26的，现在都出29了，时间过得真快。<p></p><a id=\"more\"></a><h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><h2 id=\"查看自己内核版本\"><a href=\"#查看自己内核版本\" class=\"headerlink\" title=\"查看自己内核版本\"></a>查看自己内核版本</h2><pre><code>uname -a\nLinux localhost.localdomain 4.11.8-300.fc26.x86_64 #1 SMP Thu Jun 29 20:09:48 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre><h2 id=\"下载内核并解压到-usr-src目录下\"><a href=\"#下载内核并解压到-usr-src目录下\" class=\"headerlink\" title=\"下载内核并解压到/usr/src目录下\"></a>下载内核并解压到/usr/src目录下</h2><p>推荐一下<a href=\"http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">上海交大的网站</a>，速度挺快的。<br>下载好后<code>tar xf linux-5.0.1.tar.gz -C /usr/src</code>解压到/usr/src下</p><h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><div class=\"note danger\"><p>make编译内核起码预留10个G，编译完之后，不然存储会不够，又要重新弄。<br>boot分区发现200M会不够用，改成500M可以，扩容还是挺麻烦的<br>/ 根目录（具体来说是 /lib，没挂载/lib的话就默认是使用/目录） 要有至少4G的空余空间</p></div><h1 id=\"编译安装\"><a href=\"#编译安装\" class=\"headerlink\" title=\"编译安装\"></a>编译安装</h1><h2 id=\"make-makemenuconfig\"><a href=\"#make-makemenuconfig\" class=\"headerlink\" title=\"make makemenuconfig\"></a>make makemenuconfig</h2><p>这是带有图形化界面的配置命令，在这里面可以定制很多功能。<br>常见的是定制内核版本，或者开启ntfs的功能。</p><p>内核版本在general setup里面，找到local version -append to kernel release</p><p>ntfs在file-systems下面，很下面的位置，找到DOS/FAT/NT Filesystems，进入后用M键启用NTFS，用模块的方式，并在下面的NTFS write support 那里用y键启用</p><p>然后 保存退出</p><p>如果想用默认配置，可以直接方向键选择<strong>save</strong>，然后<strong>exit</strong>。</p><p>刚开始使用这个命令可能会一直报错，解决的基本原则是提示缺少什么包</p><p>就在这个包的名字后面加上-devel，然后用dnf安装（其他版本也一样，只要换一下包管理器名）</p><h3 id=\"缺少ncurses-devel包\"><a href=\"#缺少ncurses-devel包\" class=\"headerlink\" title=\"缺少ncurses-devel包\"></a>缺少ncurses-devel包</h3><pre><code>dnf install ncurses-devel\n</code></pre><h3 id=\"缺少flex包\"><a href=\"#缺少flex包\" class=\"headerlink\" title=\"缺少flex包\"></a>缺少flex包</h3><pre><code>dnf install flex\n</code></pre><h3 id=\"缺少bison包\"><a href=\"#缺少bison包\" class=\"headerlink\" title=\"缺少bison包\"></a>缺少bison包</h3><pre><code>dnf install bison\n</code></pre><h3 id=\"报错：You-are-building-kernel-with-non-retpoline-compiler\"><a href=\"#报错：You-are-building-kernel-with-non-retpoline-compiler\" class=\"headerlink\" title=\"报错：You are building kernel with non-retpoline compiler.\"></a>报错：You are building kernel with non-retpoline compiler.</h3><p>应该升级GCC了，刚开始一直卡在这，网上也没发现non-retpoline是什么鬼，后来才发现是gcc版本太低，可能我刚装的虚拟机，没升级…</p><pre><code>dnf update gcc\n</code></pre><h3 id=\"缺少libelf-dev-libelf-devel-or-elfutils-libelf-devel\"><a href=\"#缺少libelf-dev-libelf-devel-or-elfutils-libelf-devel\" class=\"headerlink\" title=\"缺少libelf-dev, libelf-devel or elfutils-libelf-devel\"></a>缺少libelf-dev, libelf-devel or elfutils-libelf-devel</h3><p>报错：error: Cannot generate ORC metadata for CONFIG_UNWINDER_ORC=y, please install libelf-dev, libelf-devel or elfutils-libelf-devel</p><p>这个直接安装会发现源里面没有，可以选择rpm包安装,也可以：</p><pre><code>dnf install binutils gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms\n</code></pre><p>这也是百度到的办法…当时都惊了，源里面居然都没有…</p><p>这里在装dkms,kernel-devel,patch的时候，安装了elfutils-libelf-devel和zlib-devel依赖</p><h3 id=\"缺少openssl\"><a href=\"#缺少openssl\" class=\"headerlink\" title=\"缺少openssl\"></a>缺少openssl</h3><p>报错:scripts/sign-file.c:25:10: fatal error: openssl/opensslv.h: No such file or directory</p><h1 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include \"></a>include<openssl opensslv.h=\"\"></openssl></h1><p>这里<code>dnf install openssl</code>发现已经安装了，很奇怪，后来发现libssl-devel在redhat系这里叫<strong>openssl-devel</strong></p><p>所以<code>dnf install openssl-devel</code></p><p>如果是<strong>debian</strong>系的，应该是安装<strong>openss</strong>和<strong>libssl-devel</strong></p><h2 id=\"make-mrproper\"><a href=\"#make-mrproper\" class=\"headerlink\" title=\"make mrproper\"></a>make mrproper</h2><p>清除编译过程中产生的所有中间文件</p><p>假如你之前也编译过内核，而你没有用此命令去清除之前编译产生的.o文件，那么，在make的时候，可能就会产生干扰。</p><p>清除之后要重新make menuconfig 生成.config文件</p><h2 id=\"make-j8\"><a href=\"#make-j8\" class=\"headerlink\" title=\"make -j8\"></a>make -j8</h2><p><strong>-j</strong>是代表编译时用几个线程，这里开了8个线程来编译，不然太慢了。</p><h2 id=\"make-modules-install\"><a href=\"#make-modules-install\" class=\"headerlink\" title=\"make modules_install\"></a>make modules_install</h2><p>安装内核模块，这里比较快，一会会就好了，安装完后可以看到/lib/modules目录下就会出现新的内核。</p><h2 id=\"make-install\"><a href=\"#make-install\" class=\"headerlink\" title=\"make install\"></a>make install</h2><p>安装bzImage为/boot/vmlinuz-VERSION-RELEASE，并生成initramfs文件<br>使用ls /boot就可以查看新生成的文件，注意以安装的版本结尾的文件就好</p><p>查看grub.cfg, <code>ls /boot/grub2</code>, 应该就有grub.cfg引导文件了</p><h2 id=\"重启\"><a href=\"#重启\" class=\"headerlink\" title=\"重启\"></a>重启</h2><p>这时候应该就可以在启动项发现新的内核了</p><h2 id=\"删除旧内核\"><a href=\"#删除旧内核\" class=\"headerlink\" title=\"删除旧内核\"></a>删除旧内核</h2><ul><li><p>删除/lib/modules/目录下不需要的内核库文件</p></li><li><p>删除/usr/src/linux/目录下不需要的内核源码</p></li><li><p>删除/boot目录下启动的内核和内核映像文件</p></li><li><p>更改grub的配置文件，删除不需要的内核启动列表</p></li></ul><hr><p>这时候内核编译就结束了，还是挺耗时间的，特别是编译的时候。</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><p></p><meta name=\"referrer\" content=\"no-referrer\"><br>被迫很不情愿的编译内核…以前服务器上编译过，贼麻烦，现在又要编译，为了不让我的Arch出什么幺蛾子，新弄了个虚拟机练手了。<br>还是Fedora26的，现在都出29了，时间过得真快。<p></p>","more":"<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><h2 id=\"查看自己内核版本\"><a href=\"#查看自己内核版本\" class=\"headerlink\" title=\"查看自己内核版本\"></a>查看自己内核版本</h2><pre><code>uname -a\nLinux localhost.localdomain 4.11.8-300.fc26.x86_64 #1 SMP Thu Jun 29 20:09:48 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre><h2 id=\"下载内核并解压到-usr-src目录下\"><a href=\"#下载内核并解压到-usr-src目录下\" class=\"headerlink\" title=\"下载内核并解压到/usr/src目录下\"></a>下载内核并解压到/usr/src目录下</h2><p>推荐一下<a href=\"http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">上海交大的网站</a>，速度挺快的。<br>下载好后<code>tar xf linux-5.0.1.tar.gz -C /usr/src</code>解压到/usr/src下</p><h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><div class=\"note danger\"><p>make编译内核起码预留10个G，编译完之后，不然存储会不够，又要重新弄。<br>boot分区发现200M会不够用，改成500M可以，扩容还是挺麻烦的<br>/ 根目录（具体来说是 /lib，没挂载/lib的话就默认是使用/目录） 要有至少4G的空余空间</p></div><h1 id=\"编译安装\"><a href=\"#编译安装\" class=\"headerlink\" title=\"编译安装\"></a>编译安装</h1><h2 id=\"make-makemenuconfig\"><a href=\"#make-makemenuconfig\" class=\"headerlink\" title=\"make makemenuconfig\"></a>make makemenuconfig</h2><p>这是带有图形化界面的配置命令，在这里面可以定制很多功能。<br>常见的是定制内核版本，或者开启ntfs的功能。</p><p>内核版本在general setup里面，找到local version -append to kernel release</p><p>ntfs在file-systems下面，很下面的位置，找到DOS/FAT/NT Filesystems，进入后用M键启用NTFS，用模块的方式，并在下面的NTFS write support 那里用y键启用</p><p>然后 保存退出</p><p>如果想用默认配置，可以直接方向键选择<strong>save</strong>，然后<strong>exit</strong>。</p><p>刚开始使用这个命令可能会一直报错，解决的基本原则是提示缺少什么包</p><p>就在这个包的名字后面加上-devel，然后用dnf安装（其他版本也一样，只要换一下包管理器名）</p><h3 id=\"缺少ncurses-devel包\"><a href=\"#缺少ncurses-devel包\" class=\"headerlink\" title=\"缺少ncurses-devel包\"></a>缺少ncurses-devel包</h3><pre><code>dnf install ncurses-devel\n</code></pre><h3 id=\"缺少flex包\"><a href=\"#缺少flex包\" class=\"headerlink\" title=\"缺少flex包\"></a>缺少flex包</h3><pre><code>dnf install flex\n</code></pre><h3 id=\"缺少bison包\"><a href=\"#缺少bison包\" class=\"headerlink\" title=\"缺少bison包\"></a>缺少bison包</h3><pre><code>dnf install bison\n</code></pre><h3 id=\"报错：You-are-building-kernel-with-non-retpoline-compiler\"><a href=\"#报错：You-are-building-kernel-with-non-retpoline-compiler\" class=\"headerlink\" title=\"报错：You are building kernel with non-retpoline compiler.\"></a>报错：You are building kernel with non-retpoline compiler.</h3><p>应该升级GCC了，刚开始一直卡在这，网上也没发现non-retpoline是什么鬼，后来才发现是gcc版本太低，可能我刚装的虚拟机，没升级…</p><pre><code>dnf update gcc\n</code></pre><h3 id=\"缺少libelf-dev-libelf-devel-or-elfutils-libelf-devel\"><a href=\"#缺少libelf-dev-libelf-devel-or-elfutils-libelf-devel\" class=\"headerlink\" title=\"缺少libelf-dev, libelf-devel or elfutils-libelf-devel\"></a>缺少libelf-dev, libelf-devel or elfutils-libelf-devel</h3><p>报错：error: Cannot generate ORC metadata for CONFIG_UNWINDER_ORC=y, please install libelf-dev, libelf-devel or elfutils-libelf-devel</p><p>这个直接安装会发现源里面没有，可以选择rpm包安装,也可以：</p><pre><code>dnf install binutils gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms\n</code></pre><p>这也是百度到的办法…当时都惊了，源里面居然都没有…</p><p>这里在装dkms,kernel-devel,patch的时候，安装了elfutils-libelf-devel和zlib-devel依赖</p><h3 id=\"缺少openssl\"><a href=\"#缺少openssl\" class=\"headerlink\" title=\"缺少openssl\"></a>缺少openssl</h3><p>报错:scripts/sign-file.c:25:10: fatal error: openssl/opensslv.h: No such file or directory</p><h1 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include \"></a>include<openssl opensslv.h=\"\"></openssl></h1><p>这里<code>dnf install openssl</code>发现已经安装了，很奇怪，后来发现libssl-devel在redhat系这里叫<strong>openssl-devel</strong></p><p>所以<code>dnf install openssl-devel</code></p><p>如果是<strong>debian</strong>系的，应该是安装<strong>openss</strong>和<strong>libssl-devel</strong></p><h2 id=\"make-mrproper\"><a href=\"#make-mrproper\" class=\"headerlink\" title=\"make mrproper\"></a>make mrproper</h2><p>清除编译过程中产生的所有中间文件</p><p>假如你之前也编译过内核，而你没有用此命令去清除之前编译产生的.o文件，那么，在make的时候，可能就会产生干扰。</p><p>清除之后要重新make menuconfig 生成.config文件</p><h2 id=\"make-j8\"><a href=\"#make-j8\" class=\"headerlink\" title=\"make -j8\"></a>make -j8</h2><p><strong>-j</strong>是代表编译时用几个线程，这里开了8个线程来编译，不然太慢了。</p><h2 id=\"make-modules-install\"><a href=\"#make-modules-install\" class=\"headerlink\" title=\"make modules_install\"></a>make modules_install</h2><p>安装内核模块，这里比较快，一会会就好了，安装完后可以看到/lib/modules目录下就会出现新的内核。</p><h2 id=\"make-install\"><a href=\"#make-install\" class=\"headerlink\" title=\"make install\"></a>make install</h2><p>安装bzImage为/boot/vmlinuz-VERSION-RELEASE，并生成initramfs文件<br>使用ls /boot就可以查看新生成的文件，注意以安装的版本结尾的文件就好</p><p>查看grub.cfg, <code>ls /boot/grub2</code>, 应该就有grub.cfg引导文件了</p><h2 id=\"重启\"><a href=\"#重启\" class=\"headerlink\" title=\"重启\"></a>重启</h2><p>这时候应该就可以在启动项发现新的内核了</p><h2 id=\"删除旧内核\"><a href=\"#删除旧内核\" class=\"headerlink\" title=\"删除旧内核\"></a>删除旧内核</h2><ul><li><p>删除/lib/modules/目录下不需要的内核库文件</p></li><li><p>删除/usr/src/linux/目录下不需要的内核源码</p></li><li><p>删除/boot目录下启动的内核和内核映像文件</p></li><li><p>更改grub的配置文件，删除不需要的内核启动列表</p></li></ul><hr><p>这时候内核编译就结束了，还是挺耗时间的，特别是编译的时候。</p><!-- rebuild by neat -->"},{"title":"CentOS搭建LNMP环境","comments":1,"mathjax":false,"date":"2017-08-12T08:12:58.000Z","urlname":"centos-lnmp","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\nwoc!因为Algolia文章长度限制...不得不把原本的<CentOS-Fedora搭建LNMP环境>改成两篇文章...佛了\n<!--more-->\n\n原本在服务器上一直用的debian系,后来转到本机Fedora搭建环境就蒙了,之前也因为这个花了不少时间,为了把踩过得坑记下来,还是写篇文章。\n\n其实所谓LNMP其实就是指Linux+Nginx+Mysql+PHP,因为Nginx发音问题,有时候也说是LEMP。\n\n**下面就是*Centos/Fedora* 搭建LNMP环境的教程.**  \n\n# 操作环境\n\nOS: Fedora 25  \nNginx Version: 1.6.2  \nMysql Version: MariaDB 10.2  \nPHP Version: PHP7.17\n\n# 安装Nginx,PHP7.1.7和PHP-FPM\n\n## 切换到root用户\n    \n    sudo -i \n    \n    ## OR ##\n    \n    su -  \n  \n  \n## 添加repositories\n\n    ## Centos 7 Remi repo ##\n    \n    rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\n    \n    rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm  \n  \n    ## Centos 7 Nginx repo ##\n    \n    vim /etc/yum.repos.d/nginx.repo\n    \n    ## 添加 ##\n    \n    [nginx]\n    \n    name=nginx repo\n    \n    baseurl=http://nginx.org/packages/centos/$releasever/$basearch/\n    \n    gpgcheck=0\n    \n    enabled=1  \n  \n  \n## 安装Nginx,PHP 7.1.7 and PHP-FPM\n\n     yum --enablerepo=remi,remi-php71 install nginx php-fpm php-common  \n  \n## 安装模块\n    \n    yum --enablerepo=remi,remi-php71 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xml  \n  \n## 关闭httpd(Apache)并打开Nginx,PHP-FPM\n\n **关闭Apache**  \n\n    /etc/init.d/httpd stop\n    \n    ## OR ## \n    \n    service httpd stop  \n  \n  \n**打开Nginx和PHP-FPM**  \n\n    systemctl start nginx.service\n    \n    systemctl start php-fpm.service  \n  \n  \n## 设置开机自启Nginx PHP-FPM\n\n **关闭httpd(Apache)的开机自启,并设置nginx和php-fpm开机自启**  \n\n    systemctl disable httpd.service\n    \n    systemctl enable nginx.service\n    \n    systemctl enable php-fpm.service  \n  \n  \n## 配置Nginx 和PHP-FPM及其他\n\n这一段的配置和fedora是一样的,可以不看了~\n\n**先做好默认配置的备份**  \n    \n    cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak\n    \n    cp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf  \n  \n  \n**修改PHP-FPM配置**  \n    \n    vim /etc/php-fpm.d/www.conf\n    \n    ## 注释掉新添加一行 ##\n    \n    ;listen = /run/php-fpm/www.sock\n    \n    listen = 127.0.0.1:9000  \n  \n**为你的站点创建相关文件夹**  \n    \n    ## 将testsite.local换成你自己的　##\n    \n    mkdir -p /srv/www/testsite.local/public_html\n    \n    mkdir /srv/www/testsite.local/logs\n    \n    chown -R apache:apache /srv/www/testsite.local\n    \n    mkdir /etc/nginx/sites-available\n    \n    mkdir /etc/nginx/sites-enabled  \n  \n  \n**在/etc/nginx/nginx.conf文件”include /etc/nginx/conf.d/*.conf”这行后面添加一行**  \n    \n    include /etc/nginx/sites-enabled/*;  \n  \n  \n**创建testsite.local 文件并配置**  \n\n    ## 这是最基本的配置 ##\n    \n    server {\n    \n        server_name testsite.local;\n    \n        access_log /srv/www/testsite.local/logs/access.log;\n    \n        error_log /srv/www/testsite.local/logs/error.log;\n    \n        root /srv/www/testsite.local/public_html;\n    \n        location / {\n    \n            index index.html index.htm index.php;\n    \n        }\n    \n        location ~ \\.php$ {\n    \n            include /etc/nginx/fastcgi_params;\n    \n            fastcgi_pass  127.0.0.1:9000;\n    \n            fastcgi_index index.php;\n    \n            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    \n        }\n    \n    }  \n  \n  \n**创建软链接到sites-enabled目录**  \n\n    cd /etc/nginx/sites-enabled/\n    \n    ln -s /etc/nginx/sites-available/testsite.local\n    \n    systemctl restart nginx.service  \n  \n  \n**将testsite.local添加到/etc/hosts中**  \n    \n    127.0.0.1               localhost.localdomain localhost testsite.local  \n  \n[更多的Nginx 和PHP-FPM配置点这里～](http://www.if-not-true-then-false.com/2011/nginx-\nand-php-fpm-configuration-and-optimizing-tips-and-tricks/)\n\n**测试是否成功**  \n创建/srv/www/testsite.local/public_html/index.php并添加以下内容:  \n\n然后访问域名或者服务器ip看是否出现phpinfo的页面。\n\n**出现403 forbidden**  \n有可能是SELinux有问题  \n    \n    chcon -R -t httpd_sys_content_t /srv/www/testsite.local/public_html  \n  \n  \n**远程链接到服务器**  \n打开防火墙的80端口  \n    \n    firewall-cmd --get-active-zones\n    \n    firewall-cmd --permanent --zone=public --add-service=http\n    \n    ## OR ##\n    \n    firewall-cmd --permanent --zone=public --add-port=80/tcp\n    \n    systemctl restart firewalld.service  \n\n# 安装MariaDB\n\n这里安装的是MariaDB,而不是Mysql,有如下几个原因\n\n  * MariaDB本来就是一个Mysql的开源版本\n  * MariaDB和Mysql类似并兼容Mysql\n  * Fedora和Centos系列的发行版已经转用MariaDB了\n\n**我这里选择安装MariaDB 10.2.7 [stable],具体安装过程如下~**\n\n  * 如果之前安装了Mysql,记得备份你的数据库和配置文件!\n  * 如果是从低版本升级的,记得执行`mysql_upgrade`~\n\n## 切换root用户\n    \n    su -\n    \n    ## OR ##\n    \n    sudo -i  \n  \n  \n## 添加MariaDB repo\n\n现在Fedora 24/25/26 用户都可以直接安装MariaDB 10.1 而不用添加其他的repo来安装~\n\n[MariaDB repository configuration\ntool](http://downloads.mariadb.org/mariadb/repositories/),这里面有repo,自己选择repo文件安装,上面也有教程~\n\n    yum install MariaDB MariaDB-server  \n\n## 打开MariaDB并配置自启\n\n    service mysql start ## use restart after update\n    \n    ## OR ##\n    \n    /etc/init.d/mysql start ## use restart after update\n    \n    chkconfig --levels 235 mysql on  \n  \n## 进行secure installation\n    \n    /usr/bin/mysql_secure_installation  \n  \n自己看提示来~第一个没设置密码呢,直接回车,下面的大多数都选Y\n\n如果不想进行secure installation 的话,emmmmm….最好还是做下吧~  \n  \n到这里其实已经结束了…233333\n\n## 连接数据库\n    \n    mysql -u root -p  \n  \n## 创建数据库和user\n    \n    ## CREATE DATABASE ##\n    \n    MariaDB [(none)]> CREATE DATABASE webdb;\n    \n    ## CREATE USER ##\n    \n    MariaDB [(none)]> CREATE USER 'webdb_user'@'10.0.15.25' IDENTIFIED BY 'password123';\n    \n    ## GRANT PERMISSIONS ##\n    \n    MariaDB [(none)]> GRANT ALL ON webdb.* TO 'webdb_user'@'10.0.15.25';\n    \n    ##  FLUSH PRIVILEGES, Tell the server to reload the grant tables  ##\n    \n    MariaDB [(none)]> FLUSH PRIVILEGES;  \n  \n## 确保数据库能远程连接\n\n    vim /etc/sysconfig/iptables-config\n    \n    ## 添加 ##\n    \n    -A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT\n    \n    ## 重启 ##\n    \n    service iptables restart\n    \n    ## OR ##\n    \n    /etc/init.d/iptables restart  \n  \n------------------- \n","source":"_posts/CentOS搭建LNMP环境.md","raw":"---\ntitle: CentOS搭建LNMP环境\ncomments: true\nmathjax: false\ndate: 2017-08-12 16:12:58\ntags: [LNMP,Linux]\ncategories: Linux\nurlname: centos-lnmp\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\nwoc!因为Algolia文章长度限制...不得不把原本的<CentOS-Fedora搭建LNMP环境>改成两篇文章...佛了\n<!--more-->\n\n原本在服务器上一直用的debian系,后来转到本机Fedora搭建环境就蒙了,之前也因为这个花了不少时间,为了把踩过得坑记下来,还是写篇文章。\n\n其实所谓LNMP其实就是指Linux+Nginx+Mysql+PHP,因为Nginx发音问题,有时候也说是LEMP。\n\n**下面就是*Centos/Fedora* 搭建LNMP环境的教程.**  \n\n# 操作环境\n\nOS: Fedora 25  \nNginx Version: 1.6.2  \nMysql Version: MariaDB 10.2  \nPHP Version: PHP7.17\n\n# 安装Nginx,PHP7.1.7和PHP-FPM\n\n## 切换到root用户\n    \n    sudo -i \n    \n    ## OR ##\n    \n    su -  \n  \n  \n## 添加repositories\n\n    ## Centos 7 Remi repo ##\n    \n    rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\n    \n    rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm  \n  \n    ## Centos 7 Nginx repo ##\n    \n    vim /etc/yum.repos.d/nginx.repo\n    \n    ## 添加 ##\n    \n    [nginx]\n    \n    name=nginx repo\n    \n    baseurl=http://nginx.org/packages/centos/$releasever/$basearch/\n    \n    gpgcheck=0\n    \n    enabled=1  \n  \n  \n## 安装Nginx,PHP 7.1.7 and PHP-FPM\n\n     yum --enablerepo=remi,remi-php71 install nginx php-fpm php-common  \n  \n## 安装模块\n    \n    yum --enablerepo=remi,remi-php71 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xml  \n  \n## 关闭httpd(Apache)并打开Nginx,PHP-FPM\n\n **关闭Apache**  \n\n    /etc/init.d/httpd stop\n    \n    ## OR ## \n    \n    service httpd stop  \n  \n  \n**打开Nginx和PHP-FPM**  \n\n    systemctl start nginx.service\n    \n    systemctl start php-fpm.service  \n  \n  \n## 设置开机自启Nginx PHP-FPM\n\n **关闭httpd(Apache)的开机自启,并设置nginx和php-fpm开机自启**  \n\n    systemctl disable httpd.service\n    \n    systemctl enable nginx.service\n    \n    systemctl enable php-fpm.service  \n  \n  \n## 配置Nginx 和PHP-FPM及其他\n\n这一段的配置和fedora是一样的,可以不看了~\n\n**先做好默认配置的备份**  \n    \n    cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak\n    \n    cp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf  \n  \n  \n**修改PHP-FPM配置**  \n    \n    vim /etc/php-fpm.d/www.conf\n    \n    ## 注释掉新添加一行 ##\n    \n    ;listen = /run/php-fpm/www.sock\n    \n    listen = 127.0.0.1:9000  \n  \n**为你的站点创建相关文件夹**  \n    \n    ## 将testsite.local换成你自己的　##\n    \n    mkdir -p /srv/www/testsite.local/public_html\n    \n    mkdir /srv/www/testsite.local/logs\n    \n    chown -R apache:apache /srv/www/testsite.local\n    \n    mkdir /etc/nginx/sites-available\n    \n    mkdir /etc/nginx/sites-enabled  \n  \n  \n**在/etc/nginx/nginx.conf文件”include /etc/nginx/conf.d/*.conf”这行后面添加一行**  \n    \n    include /etc/nginx/sites-enabled/*;  \n  \n  \n**创建testsite.local 文件并配置**  \n\n    ## 这是最基本的配置 ##\n    \n    server {\n    \n        server_name testsite.local;\n    \n        access_log /srv/www/testsite.local/logs/access.log;\n    \n        error_log /srv/www/testsite.local/logs/error.log;\n    \n        root /srv/www/testsite.local/public_html;\n    \n        location / {\n    \n            index index.html index.htm index.php;\n    \n        }\n    \n        location ~ \\.php$ {\n    \n            include /etc/nginx/fastcgi_params;\n    \n            fastcgi_pass  127.0.0.1:9000;\n    \n            fastcgi_index index.php;\n    \n            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    \n        }\n    \n    }  \n  \n  \n**创建软链接到sites-enabled目录**  \n\n    cd /etc/nginx/sites-enabled/\n    \n    ln -s /etc/nginx/sites-available/testsite.local\n    \n    systemctl restart nginx.service  \n  \n  \n**将testsite.local添加到/etc/hosts中**  \n    \n    127.0.0.1               localhost.localdomain localhost testsite.local  \n  \n[更多的Nginx 和PHP-FPM配置点这里～](http://www.if-not-true-then-false.com/2011/nginx-\nand-php-fpm-configuration-and-optimizing-tips-and-tricks/)\n\n**测试是否成功**  \n创建/srv/www/testsite.local/public_html/index.php并添加以下内容:  \n\n然后访问域名或者服务器ip看是否出现phpinfo的页面。\n\n**出现403 forbidden**  \n有可能是SELinux有问题  \n    \n    chcon -R -t httpd_sys_content_t /srv/www/testsite.local/public_html  \n  \n  \n**远程链接到服务器**  \n打开防火墙的80端口  \n    \n    firewall-cmd --get-active-zones\n    \n    firewall-cmd --permanent --zone=public --add-service=http\n    \n    ## OR ##\n    \n    firewall-cmd --permanent --zone=public --add-port=80/tcp\n    \n    systemctl restart firewalld.service  \n\n# 安装MariaDB\n\n这里安装的是MariaDB,而不是Mysql,有如下几个原因\n\n  * MariaDB本来就是一个Mysql的开源版本\n  * MariaDB和Mysql类似并兼容Mysql\n  * Fedora和Centos系列的发行版已经转用MariaDB了\n\n**我这里选择安装MariaDB 10.2.7 [stable],具体安装过程如下~**\n\n  * 如果之前安装了Mysql,记得备份你的数据库和配置文件!\n  * 如果是从低版本升级的,记得执行`mysql_upgrade`~\n\n## 切换root用户\n    \n    su -\n    \n    ## OR ##\n    \n    sudo -i  \n  \n  \n## 添加MariaDB repo\n\n现在Fedora 24/25/26 用户都可以直接安装MariaDB 10.1 而不用添加其他的repo来安装~\n\n[MariaDB repository configuration\ntool](http://downloads.mariadb.org/mariadb/repositories/),这里面有repo,自己选择repo文件安装,上面也有教程~\n\n    yum install MariaDB MariaDB-server  \n\n## 打开MariaDB并配置自启\n\n    service mysql start ## use restart after update\n    \n    ## OR ##\n    \n    /etc/init.d/mysql start ## use restart after update\n    \n    chkconfig --levels 235 mysql on  \n  \n## 进行secure installation\n    \n    /usr/bin/mysql_secure_installation  \n  \n自己看提示来~第一个没设置密码呢,直接回车,下面的大多数都选Y\n\n如果不想进行secure installation 的话,emmmmm….最好还是做下吧~  \n  \n到这里其实已经结束了…233333\n\n## 连接数据库\n    \n    mysql -u root -p  \n  \n## 创建数据库和user\n    \n    ## CREATE DATABASE ##\n    \n    MariaDB [(none)]> CREATE DATABASE webdb;\n    \n    ## CREATE USER ##\n    \n    MariaDB [(none)]> CREATE USER 'webdb_user'@'10.0.15.25' IDENTIFIED BY 'password123';\n    \n    ## GRANT PERMISSIONS ##\n    \n    MariaDB [(none)]> GRANT ALL ON webdb.* TO 'webdb_user'@'10.0.15.25';\n    \n    ##  FLUSH PRIVILEGES, Tell the server to reload the grant tables  ##\n    \n    MariaDB [(none)]> FLUSH PRIVILEGES;  \n  \n## 确保数据库能远程连接\n\n    vim /etc/sysconfig/iptables-config\n    \n    ## 添加 ##\n    \n    -A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT\n    \n    ## 重启 ##\n    \n    service iptables restart\n    \n    ## OR ##\n    \n    /etc/init.d/iptables restart  \n  \n------------------- \n","slug":"CentOS搭建LNMP环境","published":1,"updated":"2019-07-25T17:43:26.046Z","layout":"post","photos":[],"link":"","_id":"ck2424lk70007lksb669xzz3e","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>woc!因为Algolia文章长度限制…不得不把原本的<centos-fedora搭建lnmp环境>改成两篇文章…佛了<br><a id=\"more\"></a></centos-fedora搭建lnmp环境></p><p>原本在服务器上一直用的debian系,后来转到本机Fedora搭建环境就蒙了,之前也因为这个花了不少时间,为了把踩过得坑记下来,还是写篇文章。</p><p>其实所谓LNMP其实就是指Linux+Nginx+Mysql+PHP,因为Nginx发音问题,有时候也说是LEMP。</p><p><strong>下面就是<em>Centos/Fedora</em> 搭建LNMP环境的教程.</strong></p><h1 id=\"操作环境\"><a href=\"#操作环境\" class=\"headerlink\" title=\"操作环境\"></a>操作环境</h1><p>OS: Fedora 25<br>Nginx Version: 1.6.2<br>Mysql Version: MariaDB 10.2<br>PHP Version: PHP7.17</p><h1 id=\"安装Nginx-PHP7-1-7和PHP-FPM\"><a href=\"#安装Nginx-PHP7-1-7和PHP-FPM\" class=\"headerlink\" title=\"安装Nginx,PHP7.1.7和PHP-FPM\"></a>安装Nginx,PHP7.1.7和PHP-FPM</h1><h2 id=\"切换到root用户\"><a href=\"#切换到root用户\" class=\"headerlink\" title=\"切换到root用户\"></a>切换到root用户</h2><pre><code>sudo -i \n\n## OR ##\n\nsu -  \n</code></pre><h2 id=\"添加repositories\"><a href=\"#添加repositories\" class=\"headerlink\" title=\"添加repositories\"></a>添加repositories</h2><pre><code>## Centos 7 Remi repo ##\n\nrpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\n\nrpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm  \n\n## Centos 7 Nginx repo ##\n\nvim /etc/yum.repos.d/nginx.repo\n\n## 添加 ##\n\n[nginx]\n\nname=nginx repo\n\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\n\ngpgcheck=0\n\nenabled=1  \n</code></pre><h2 id=\"安装Nginx-PHP-7-1-7-and-PHP-FPM\"><a href=\"#安装Nginx-PHP-7-1-7-and-PHP-FPM\" class=\"headerlink\" title=\"安装Nginx,PHP 7.1.7 and PHP-FPM\"></a>安装Nginx,PHP 7.1.7 and PHP-FPM</h2><pre><code> yum --enablerepo=remi,remi-php71 install nginx php-fpm php-common  \n</code></pre><h2 id=\"安装模块\"><a href=\"#安装模块\" class=\"headerlink\" title=\"安装模块\"></a>安装模块</h2><pre><code>yum --enablerepo=remi,remi-php71 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xml  \n</code></pre><h2 id=\"关闭httpd-Apache-并打开Nginx-PHP-FPM\"><a href=\"#关闭httpd-Apache-并打开Nginx-PHP-FPM\" class=\"headerlink\" title=\"关闭httpd(Apache)并打开Nginx,PHP-FPM\"></a>关闭httpd(Apache)并打开Nginx,PHP-FPM</h2><p><strong>关闭Apache</strong></p><pre><code>/etc/init.d/httpd stop\n\n## OR ## \n\nservice httpd stop  \n</code></pre><p><strong>打开Nginx和PHP-FPM</strong></p><pre><code>systemctl start nginx.service\n\nsystemctl start php-fpm.service  \n</code></pre><h2 id=\"设置开机自启Nginx-PHP-FPM\"><a href=\"#设置开机自启Nginx-PHP-FPM\" class=\"headerlink\" title=\"设置开机自启Nginx PHP-FPM\"></a>设置开机自启Nginx PHP-FPM</h2><p><strong>关闭httpd(Apache)的开机自启,并设置nginx和php-fpm开机自启</strong></p><pre><code>systemctl disable httpd.service\n\nsystemctl enable nginx.service\n\nsystemctl enable php-fpm.service  \n</code></pre><h2 id=\"配置Nginx-和PHP-FPM及其他\"><a href=\"#配置Nginx-和PHP-FPM及其他\" class=\"headerlink\" title=\"配置Nginx 和PHP-FPM及其他\"></a>配置Nginx 和PHP-FPM及其他</h2><p>这一段的配置和fedora是一样的,可以不看了~</p><p><strong>先做好默认配置的备份</strong></p><pre><code>cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak\n\ncp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf  \n</code></pre><p><strong>修改PHP-FPM配置</strong></p><pre><code>vim /etc/php-fpm.d/www.conf\n\n## 注释掉新添加一行 ##\n\n;listen = /run/php-fpm/www.sock\n\nlisten = 127.0.0.1:9000  \n</code></pre><p><strong>为你的站点创建相关文件夹</strong></p><pre><code>## 将testsite.local换成你自己的　##\n\nmkdir -p /srv/www/testsite.local/public_html\n\nmkdir /srv/www/testsite.local/logs\n\nchown -R apache:apache /srv/www/testsite.local\n\nmkdir /etc/nginx/sites-available\n\nmkdir /etc/nginx/sites-enabled  \n</code></pre><p><strong>在/etc/nginx/nginx.conf文件”include /etc/nginx/conf.d/*.conf”这行后面添加一行</strong></p><pre><code>include /etc/nginx/sites-enabled/*;  \n</code></pre><p><strong>创建testsite.local 文件并配置</strong></p><pre><code>## 这是最基本的配置 ##\n\nserver {\n\n    server_name testsite.local;\n\n    access_log /srv/www/testsite.local/logs/access.log;\n\n    error_log /srv/www/testsite.local/logs/error.log;\n\n    root /srv/www/testsite.local/public_html;\n\n    location / {\n\n        index index.html index.htm index.php;\n\n    }\n\n    location ~ \\.php$ {\n\n        include /etc/nginx/fastcgi_params;\n\n        fastcgi_pass  127.0.0.1:9000;\n\n        fastcgi_index index.php;\n\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n\n    }\n\n}  \n</code></pre><p><strong>创建软链接到sites-enabled目录</strong></p><pre><code>cd /etc/nginx/sites-enabled/\n\nln -s /etc/nginx/sites-available/testsite.local\n\nsystemctl restart nginx.service  \n</code></pre><p><strong>将testsite.local添加到/etc/hosts中</strong></p><pre><code>127.0.0.1               localhost.localdomain localhost testsite.local  \n</code></pre><p><a href=\"http://www.if-not-true-then-false.com/2011/nginx-\nand-php-fpm-configuration-and-optimizing-tips-and-tricks/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">更多的Nginx 和PHP-FPM配置点这里～</a></p><p><strong>测试是否成功</strong><br>创建/srv/www/testsite.local/public_html/index.php并添加以下内容:</p><p>然后访问域名或者服务器ip看是否出现phpinfo的页面。</p><p><strong>出现403 forbidden</strong><br>有可能是SELinux有问题</p><pre><code>chcon -R -t httpd_sys_content_t /srv/www/testsite.local/public_html  \n</code></pre><p><strong>远程链接到服务器</strong><br>打开防火墙的80端口</p><pre><code>firewall-cmd --get-active-zones\n\nfirewall-cmd --permanent --zone=public --add-service=http\n\n## OR ##\n\nfirewall-cmd --permanent --zone=public --add-port=80/tcp\n\nsystemctl restart firewalld.service  \n</code></pre><h1 id=\"安装MariaDB\"><a href=\"#安装MariaDB\" class=\"headerlink\" title=\"安装MariaDB\"></a>安装MariaDB</h1><p>这里安装的是MariaDB,而不是Mysql,有如下几个原因</p><ul><li>MariaDB本来就是一个Mysql的开源版本</li><li>MariaDB和Mysql类似并兼容Mysql</li><li>Fedora和Centos系列的发行版已经转用MariaDB了</li></ul><p><strong>我这里选择安装MariaDB 10.2.7 [stable],具体安装过程如下~</strong></p><ul><li>如果之前安装了Mysql,记得备份你的数据库和配置文件!</li><li>如果是从低版本升级的,记得执行<code>mysql_upgrade</code>~</li></ul><h2 id=\"切换root用户\"><a href=\"#切换root用户\" class=\"headerlink\" title=\"切换root用户\"></a>切换root用户</h2><pre><code>su -\n\n## OR ##\n\nsudo -i  \n</code></pre><h2 id=\"添加MariaDB-repo\"><a href=\"#添加MariaDB-repo\" class=\"headerlink\" title=\"添加MariaDB repo\"></a>添加MariaDB repo</h2><p>现在Fedora 24/25/26 用户都可以直接安装MariaDB 10.1 而不用添加其他的repo来安装~</p><p><a href=\"http://downloads.mariadb.org/mariadb/repositories/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MariaDB repository configuration<br>tool</a>,这里面有repo,自己选择repo文件安装,上面也有教程~</p><pre><code>yum install MariaDB MariaDB-server  \n</code></pre><h2 id=\"打开MariaDB并配置自启\"><a href=\"#打开MariaDB并配置自启\" class=\"headerlink\" title=\"打开MariaDB并配置自启\"></a>打开MariaDB并配置自启</h2><pre><code>service mysql start ## use restart after update\n\n## OR ##\n\n/etc/init.d/mysql start ## use restart after update\n\nchkconfig --levels 235 mysql on  \n</code></pre><h2 id=\"进行secure-installation\"><a href=\"#进行secure-installation\" class=\"headerlink\" title=\"进行secure installation\"></a>进行secure installation</h2><pre><code>/usr/bin/mysql_secure_installation  \n</code></pre><p>自己看提示来~第一个没设置密码呢,直接回车,下面的大多数都选Y</p><p>如果不想进行secure installation 的话,emmmmm….最好还是做下吧~</p><p>到这里其实已经结束了…233333</p><h2 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h2><pre><code>mysql -u root -p  \n</code></pre><h2 id=\"创建数据库和user\"><a href=\"#创建数据库和user\" class=\"headerlink\" title=\"创建数据库和user\"></a>创建数据库和user</h2><pre><code>## CREATE DATABASE ##\n\nMariaDB [(none)]&gt; CREATE DATABASE webdb;\n\n## CREATE USER ##\n\nMariaDB [(none)]&gt; CREATE USER &#39;webdb_user&#39;@&#39;10.0.15.25&#39; IDENTIFIED BY &#39;password123&#39;;\n\n## GRANT PERMISSIONS ##\n\nMariaDB [(none)]&gt; GRANT ALL ON webdb.* TO &#39;webdb_user&#39;@&#39;10.0.15.25&#39;;\n\n##  FLUSH PRIVILEGES, Tell the server to reload the grant tables  ##\n\nMariaDB [(none)]&gt; FLUSH PRIVILEGES;  \n</code></pre><h2 id=\"确保数据库能远程连接\"><a href=\"#确保数据库能远程连接\" class=\"headerlink\" title=\"确保数据库能远程连接\"></a>确保数据库能远程连接</h2><pre><code>vim /etc/sysconfig/iptables-config\n\n## 添加 ##\n\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT\n\n## 重启 ##\n\nservice iptables restart\n\n## OR ##\n\n/etc/init.d/iptables restart  \n</code></pre><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>woc!因为Algolia文章长度限制…不得不把原本的<centos-fedora搭建lnmp环境>改成两篇文章…佛了<br>","more":"</centos-fedora搭建lnmp环境></p><p>原本在服务器上一直用的debian系,后来转到本机Fedora搭建环境就蒙了,之前也因为这个花了不少时间,为了把踩过得坑记下来,还是写篇文章。</p><p>其实所谓LNMP其实就是指Linux+Nginx+Mysql+PHP,因为Nginx发音问题,有时候也说是LEMP。</p><p><strong>下面就是<em>Centos/Fedora</em> 搭建LNMP环境的教程.</strong></p><h1 id=\"操作环境\"><a href=\"#操作环境\" class=\"headerlink\" title=\"操作环境\"></a>操作环境</h1><p>OS: Fedora 25<br>Nginx Version: 1.6.2<br>Mysql Version: MariaDB 10.2<br>PHP Version: PHP7.17</p><h1 id=\"安装Nginx-PHP7-1-7和PHP-FPM\"><a href=\"#安装Nginx-PHP7-1-7和PHP-FPM\" class=\"headerlink\" title=\"安装Nginx,PHP7.1.7和PHP-FPM\"></a>安装Nginx,PHP7.1.7和PHP-FPM</h1><h2 id=\"切换到root用户\"><a href=\"#切换到root用户\" class=\"headerlink\" title=\"切换到root用户\"></a>切换到root用户</h2><pre><code>sudo -i \n\n## OR ##\n\nsu -  \n</code></pre><h2 id=\"添加repositories\"><a href=\"#添加repositories\" class=\"headerlink\" title=\"添加repositories\"></a>添加repositories</h2><pre><code>## Centos 7 Remi repo ##\n\nrpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\n\nrpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm  \n\n## Centos 7 Nginx repo ##\n\nvim /etc/yum.repos.d/nginx.repo\n\n## 添加 ##\n\n[nginx]\n\nname=nginx repo\n\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\n\ngpgcheck=0\n\nenabled=1  \n</code></pre><h2 id=\"安装Nginx-PHP-7-1-7-and-PHP-FPM\"><a href=\"#安装Nginx-PHP-7-1-7-and-PHP-FPM\" class=\"headerlink\" title=\"安装Nginx,PHP 7.1.7 and PHP-FPM\"></a>安装Nginx,PHP 7.1.7 and PHP-FPM</h2><pre><code> yum --enablerepo=remi,remi-php71 install nginx php-fpm php-common  \n</code></pre><h2 id=\"安装模块\"><a href=\"#安装模块\" class=\"headerlink\" title=\"安装模块\"></a>安装模块</h2><pre><code>yum --enablerepo=remi,remi-php71 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xml  \n</code></pre><h2 id=\"关闭httpd-Apache-并打开Nginx-PHP-FPM\"><a href=\"#关闭httpd-Apache-并打开Nginx-PHP-FPM\" class=\"headerlink\" title=\"关闭httpd(Apache)并打开Nginx,PHP-FPM\"></a>关闭httpd(Apache)并打开Nginx,PHP-FPM</h2><p><strong>关闭Apache</strong></p><pre><code>/etc/init.d/httpd stop\n\n## OR ## \n\nservice httpd stop  \n</code></pre><p><strong>打开Nginx和PHP-FPM</strong></p><pre><code>systemctl start nginx.service\n\nsystemctl start php-fpm.service  \n</code></pre><h2 id=\"设置开机自启Nginx-PHP-FPM\"><a href=\"#设置开机自启Nginx-PHP-FPM\" class=\"headerlink\" title=\"设置开机自启Nginx PHP-FPM\"></a>设置开机自启Nginx PHP-FPM</h2><p><strong>关闭httpd(Apache)的开机自启,并设置nginx和php-fpm开机自启</strong></p><pre><code>systemctl disable httpd.service\n\nsystemctl enable nginx.service\n\nsystemctl enable php-fpm.service  \n</code></pre><h2 id=\"配置Nginx-和PHP-FPM及其他\"><a href=\"#配置Nginx-和PHP-FPM及其他\" class=\"headerlink\" title=\"配置Nginx 和PHP-FPM及其他\"></a>配置Nginx 和PHP-FPM及其他</h2><p>这一段的配置和fedora是一样的,可以不看了~</p><p><strong>先做好默认配置的备份</strong></p><pre><code>cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak\n\ncp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf  \n</code></pre><p><strong>修改PHP-FPM配置</strong></p><pre><code>vim /etc/php-fpm.d/www.conf\n\n## 注释掉新添加一行 ##\n\n;listen = /run/php-fpm/www.sock\n\nlisten = 127.0.0.1:9000  \n</code></pre><p><strong>为你的站点创建相关文件夹</strong></p><pre><code>## 将testsite.local换成你自己的　##\n\nmkdir -p /srv/www/testsite.local/public_html\n\nmkdir /srv/www/testsite.local/logs\n\nchown -R apache:apache /srv/www/testsite.local\n\nmkdir /etc/nginx/sites-available\n\nmkdir /etc/nginx/sites-enabled  \n</code></pre><p><strong>在/etc/nginx/nginx.conf文件”include /etc/nginx/conf.d/*.conf”这行后面添加一行</strong></p><pre><code>include /etc/nginx/sites-enabled/*;  \n</code></pre><p><strong>创建testsite.local 文件并配置</strong></p><pre><code>## 这是最基本的配置 ##\n\nserver {\n\n    server_name testsite.local;\n\n    access_log /srv/www/testsite.local/logs/access.log;\n\n    error_log /srv/www/testsite.local/logs/error.log;\n\n    root /srv/www/testsite.local/public_html;\n\n    location / {\n\n        index index.html index.htm index.php;\n\n    }\n\n    location ~ \\.php$ {\n\n        include /etc/nginx/fastcgi_params;\n\n        fastcgi_pass  127.0.0.1:9000;\n\n        fastcgi_index index.php;\n\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n\n    }\n\n}  \n</code></pre><p><strong>创建软链接到sites-enabled目录</strong></p><pre><code>cd /etc/nginx/sites-enabled/\n\nln -s /etc/nginx/sites-available/testsite.local\n\nsystemctl restart nginx.service  \n</code></pre><p><strong>将testsite.local添加到/etc/hosts中</strong></p><pre><code>127.0.0.1               localhost.localdomain localhost testsite.local  \n</code></pre><p><a href=\"http://www.if-not-true-then-false.com/2011/nginx-\nand-php-fpm-configuration-and-optimizing-tips-and-tricks/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">更多的Nginx 和PHP-FPM配置点这里～</a></p><p><strong>测试是否成功</strong><br>创建/srv/www/testsite.local/public_html/index.php并添加以下内容:</p><p>然后访问域名或者服务器ip看是否出现phpinfo的页面。</p><p><strong>出现403 forbidden</strong><br>有可能是SELinux有问题</p><pre><code>chcon -R -t httpd_sys_content_t /srv/www/testsite.local/public_html  \n</code></pre><p><strong>远程链接到服务器</strong><br>打开防火墙的80端口</p><pre><code>firewall-cmd --get-active-zones\n\nfirewall-cmd --permanent --zone=public --add-service=http\n\n## OR ##\n\nfirewall-cmd --permanent --zone=public --add-port=80/tcp\n\nsystemctl restart firewalld.service  \n</code></pre><h1 id=\"安装MariaDB\"><a href=\"#安装MariaDB\" class=\"headerlink\" title=\"安装MariaDB\"></a>安装MariaDB</h1><p>这里安装的是MariaDB,而不是Mysql,有如下几个原因</p><ul><li>MariaDB本来就是一个Mysql的开源版本</li><li>MariaDB和Mysql类似并兼容Mysql</li><li>Fedora和Centos系列的发行版已经转用MariaDB了</li></ul><p><strong>我这里选择安装MariaDB 10.2.7 [stable],具体安装过程如下~</strong></p><ul><li>如果之前安装了Mysql,记得备份你的数据库和配置文件!</li><li>如果是从低版本升级的,记得执行<code>mysql_upgrade</code>~</li></ul><h2 id=\"切换root用户\"><a href=\"#切换root用户\" class=\"headerlink\" title=\"切换root用户\"></a>切换root用户</h2><pre><code>su -\n\n## OR ##\n\nsudo -i  \n</code></pre><h2 id=\"添加MariaDB-repo\"><a href=\"#添加MariaDB-repo\" class=\"headerlink\" title=\"添加MariaDB repo\"></a>添加MariaDB repo</h2><p>现在Fedora 24/25/26 用户都可以直接安装MariaDB 10.1 而不用添加其他的repo来安装~</p><p><a href=\"http://downloads.mariadb.org/mariadb/repositories/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MariaDB repository configuration<br>tool</a>,这里面有repo,自己选择repo文件安装,上面也有教程~</p><pre><code>yum install MariaDB MariaDB-server  \n</code></pre><h2 id=\"打开MariaDB并配置自启\"><a href=\"#打开MariaDB并配置自启\" class=\"headerlink\" title=\"打开MariaDB并配置自启\"></a>打开MariaDB并配置自启</h2><pre><code>service mysql start ## use restart after update\n\n## OR ##\n\n/etc/init.d/mysql start ## use restart after update\n\nchkconfig --levels 235 mysql on  \n</code></pre><h2 id=\"进行secure-installation\"><a href=\"#进行secure-installation\" class=\"headerlink\" title=\"进行secure installation\"></a>进行secure installation</h2><pre><code>/usr/bin/mysql_secure_installation  \n</code></pre><p>自己看提示来~第一个没设置密码呢,直接回车,下面的大多数都选Y</p><p>如果不想进行secure installation 的话,emmmmm….最好还是做下吧~</p><p>到这里其实已经结束了…233333</p><h2 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h2><pre><code>mysql -u root -p  \n</code></pre><h2 id=\"创建数据库和user\"><a href=\"#创建数据库和user\" class=\"headerlink\" title=\"创建数据库和user\"></a>创建数据库和user</h2><pre><code>## CREATE DATABASE ##\n\nMariaDB [(none)]&gt; CREATE DATABASE webdb;\n\n## CREATE USER ##\n\nMariaDB [(none)]&gt; CREATE USER &#39;webdb_user&#39;@&#39;10.0.15.25&#39; IDENTIFIED BY &#39;password123&#39;;\n\n## GRANT PERMISSIONS ##\n\nMariaDB [(none)]&gt; GRANT ALL ON webdb.* TO &#39;webdb_user&#39;@&#39;10.0.15.25&#39;;\n\n##  FLUSH PRIVILEGES, Tell the server to reload the grant tables  ##\n\nMariaDB [(none)]&gt; FLUSH PRIVILEGES;  \n</code></pre><h2 id=\"确保数据库能远程连接\"><a href=\"#确保数据库能远程连接\" class=\"headerlink\" title=\"确保数据库能远程连接\"></a>确保数据库能远程连接</h2><pre><code>vim /etc/sysconfig/iptables-config\n\n## 添加 ##\n\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT\n\n## 重启 ##\n\nservice iptables restart\n\n## OR ##\n\n/etc/init.d/iptables restart  \n</code></pre><hr><!-- rebuild by neat -->"},{"title":"Fedora搭建LNMP环境","comments":1,"mathjax":false,"date":"2017-08-13T08:12:58.000Z","urlname":"fedora-lnmp","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\nwoc!因为Algolia文章长度限制...不得不把原本的<CentOS-Fedora搭建LNMP环境>改成两篇文章...佛了\n<!--more-->\n\n原本在服务器上一直用的debian系,后来转到本机Fedora搭建环境就蒙了,之前也因为这个花了不少时间,为了把踩过得坑记下来,还是写篇文章。\n\n其实所谓LNMP其实就是指Linux+Nginx+Mysql+PHP,因为Nginx发音问题,有时候也说是LEMP。\n\n**下面就是*Centos/Fedora* 搭建LNMP环境的教程.**  \n\n# 操作环境\n\nOS: Fedora 25  \nNginx Version: 1.6.2  \nMysql Version: MariaDB 10.2  \nPHP Version: PHP7.17\n\n# 安装Nginx,PHP7.1.7和PHP-FPM\n\n## 切换到root用户\n\n    sudo -i \n    \n    ## OR ##\n    \n    su -  \n  \n## 添加repositories\n    \n    ## Remi Dependency on Fedora ##\n    \n    rpm -Uvh http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-stable.noarch.rpm \n    \n    rpm -Uvh http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm\n    \n    ## The version 25 can be replaced by 26/24 ##\n    \n    rpm -Uvh http://rpms.famillecollet.com/fedora/remi-release-25.rpm  \n  \n## 安装Nginx,PHP 7.1.7 and PHP-FPM\n\n    dnf --enablerepo=remi --enablerepo=remi-php71 install nginx php-fpm php-common  \n  \n## 安装模块\n    \n    dnf --enablerepo=remi --enablerepo=remi-php71 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xml  \n  \n  \n关于这些模块的介绍可以自己百度,根据自己需要来安装,嫌麻烦的话～直接copy吧～\n\n## 关闭httpd(Apache)并打开Nginx,PHP-FPM\n\n **关闭Apache**  \n    \n    systemctl stop httpd.service  \n  \n**打开Nginx**  \n    \n    systemctl start nginx.service  \n  \n**打开PHP-FPM**  \n\n    systemctl start php-fpm.service  \n  \n## 设置开机自启Nginx PHP-FPM\n\n **关闭httpd(Apache)的开机自启**  \n    \n    systemctl disable httpd.service  \n  \n**设置Nginx和PHP-FPM开机自启**  \n    \n    systemctl enable nginx.service\n    \n    systemctl enable php-fpm.service  \n  \n## 配置Nginx 和PHP-FPM\n\n **先做好默认配置的备份**  \n    \n    cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak\n    \n    cp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf  \n  \n**修改PHP-FPM配置**  \n    \n    vim /etc/php-fpm.d/www.conf\n    \n    ## 注释掉新添加一行 ##\n    \n    ;listen = /run/php-fpm/www.sock\n    \n    listen = 127.0.0.1:9000  \n  \n**为你的站点创建相关文件夹**  \n    \n    ## 将testsite.local换成你自己的　##\n    \n    mkdir -p /srv/www/testsite.local/public_html\n    \n    mkdir /srv/www/testsite.local/logs\n    \n    chown -R apache:apache /srv/www/testsite.local\n    \n    mkdir /etc/nginx/sites-available\n    \n    mkdir /etc/nginx/sites-enabled  \n  \n这里使用apache user group是因为PHP-FPM默认运行apache,并且apache能够进入一些类似httpd这样的目录\n\n**在/etc/nginx/nginx.conf文件\\”include /etc/nginx/conf.d/*.conf\\”这行后面添加一行**  \n\n    include /etc/nginx/sites-enabled/*;  \n  \n  \n**创建testsite.local 文件并配置**  \n\n    ## 这是最基本的配置 ##\n    \n    server {\n    \n        server_name testsite.local;\n    \n        access_log /srv/www/testsite.local/logs/access.log;\n    \n        error_log /srv/www/testsite.local/logs/error.log;\n    \n        root /srv/www/testsite.local/public_html;\n    \n        location / {\n    \n            index index.html index.htm index.php;\n    \n        }\n    \n        location ~ \\.php$ {\n    \n            include /etc/nginx/fastcgi_params;\n    \n            fastcgi_pass  127.0.0.1:9000;\n    \n            fastcgi_index index.php;\n    \n            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    \n        }\n    \n    }  \n  \n  \n**创建软链接到sites-enabled目录**  \n    \n    cd /etc/nginx/sites-enabled/\n    \n    ln -s /etc/nginx/sites-available/testsite.local\n    \n    systemctl restart nginx.service  \n  \n  \n**将testsite.local添加到/etc/hosts中**  \n\n    127.0.0.1               localhost.localdomain localhost testsite.local  \n  \n  \n[更多的Nginx 和PHP-FPM配置点这里～](http://www.if-not-true-then-false.com/2011/nginx-\nand-php-fpm-configuration-and-optimizing-tips-and-tricks/)\n\n## 测试是否成功\n\n**创建/srv/www/testsite.local/public_html/index.php并添加以下内容:**  \n\n**然后访问域名或者服务器ip看是否出现phpinfo的页面。**\n\n## 出现403 forbidden\n\n**可能是SELinux有问题**  \n\n    chcon -R -t httpd_sys_content_t /srv/www/testsite.local/public_html  \n  \n  \n## 远程链接到服务器\n\n**打开防火墙的80端口**  \n\n    firewall-cmd --get-active-zones\n    \n    firewall-cmd --permanent --zone=public --add-service=http\n    \n    ## OR ##\n    \n    firewall-cmd --permanent --zone=public --add-port=80/tcp\n    \n    systemctl restart firewalld.service  \n  \n  \n**访问域名或者ip试试~**\n\n# 安装MariaDB\n\n这里安装的是MariaDB,而不是Mysql,有如下几个原因\n\n  * MariaDB本来就是一个Mysql的开源版本\n  * MariaDB和Mysql类似并兼容Mysql\n  * Fedora和Centos系列的发行版已经转用MariaDB了\n\n**我这里选择安装MariaDB 10.2.7 [stable],具体安装过程如下~**\n\n  * 如果之前安装了Mysql,记得备份你的数据库和配置文件!\n  * 如果是从低版本升级的,记得执行`mysql_upgrade`~\n\n## 切换root用户\n    \n    su -\n    \n    ## OR ##\n    \n    sudo -i  \n  \n  \n## 添加MariaDB repo\n\n现在Fedora 24/25/26 用户都可以直接安装MariaDB 10.1 而不用添加其他的repo来安装~\n\n[MariaDB repository configuration\ntool](http://downloads.mariadb.org/mariadb/repositories/),这里面有repo,自己选择repo文件安装,上面也有教程~\n\n## 更新并安装\n\n    dnf install mariadb mariadb-server  \n\n## 打开MariaDB并配置自启\n  \n    systemctl start mariadb.service ## use restart after update\n\n    systemctl enable mariadb.service  \n    \n## 进行secure installation\n    \n    /usr/bin/mysql_secure_installation  \n  \n自己看提示来~第一个没设置密码呢,直接回车,下面的大多数都选Y\n\n如果不想进行secure installation 的话,emmmmm….最好还是做下吧~  \n  \n到这里其实已经结束了…233333\n\n## 连接数据库\n    \n    mysql -u root -p  \n  \n## 创建数据库和user\n    \n    ## CREATE DATABASE ##\n    \n    MariaDB [(none)]> CREATE DATABASE webdb;\n    \n    ## CREATE USER ##\n    \n    MariaDB [(none)]> CREATE USER 'webdb_user'@'10.0.15.25' IDENTIFIED BY 'password123';\n    \n    ## GRANT PERMISSIONS ##\n    \n    MariaDB [(none)]> GRANT ALL ON webdb.* TO 'webdb_user'@'10.0.15.25';\n    \n    ##  FLUSH PRIVILEGES, Tell the server to reload the grant tables  ##\n    \n    MariaDB [(none)]> FLUSH PRIVILEGES;  \n  \n## 确保数据库能远程连接\n\n    firewall-cmd --get-active-zones\n    \n    ## 应该会输出如下 ##\n    \n    - public\n    \n    -    interfaces: wlp1s0\n    \n    firewall-cmd --permanent --zone=public --add-service=mysql\n    \n    systemctl restart firewalld.service\n    \n    mysql -h 10.0.15.25 -u myusername -p  \n  \n\n------------------- \n","source":"_posts/Fedora搭建LNMP环境.md","raw":"---\ntitle: Fedora搭建LNMP环境\ncomments: true\nmathjax: false\ndate: 2017-08-13 16:12:58\ntags: [LNMP,Linux]\ncategories: Linux\nurlname: fedora-lnmp\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\nwoc!因为Algolia文章长度限制...不得不把原本的<CentOS-Fedora搭建LNMP环境>改成两篇文章...佛了\n<!--more-->\n\n原本在服务器上一直用的debian系,后来转到本机Fedora搭建环境就蒙了,之前也因为这个花了不少时间,为了把踩过得坑记下来,还是写篇文章。\n\n其实所谓LNMP其实就是指Linux+Nginx+Mysql+PHP,因为Nginx发音问题,有时候也说是LEMP。\n\n**下面就是*Centos/Fedora* 搭建LNMP环境的教程.**  \n\n# 操作环境\n\nOS: Fedora 25  \nNginx Version: 1.6.2  \nMysql Version: MariaDB 10.2  \nPHP Version: PHP7.17\n\n# 安装Nginx,PHP7.1.7和PHP-FPM\n\n## 切换到root用户\n\n    sudo -i \n    \n    ## OR ##\n    \n    su -  \n  \n## 添加repositories\n    \n    ## Remi Dependency on Fedora ##\n    \n    rpm -Uvh http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-stable.noarch.rpm \n    \n    rpm -Uvh http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm\n    \n    ## The version 25 can be replaced by 26/24 ##\n    \n    rpm -Uvh http://rpms.famillecollet.com/fedora/remi-release-25.rpm  \n  \n## 安装Nginx,PHP 7.1.7 and PHP-FPM\n\n    dnf --enablerepo=remi --enablerepo=remi-php71 install nginx php-fpm php-common  \n  \n## 安装模块\n    \n    dnf --enablerepo=remi --enablerepo=remi-php71 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xml  \n  \n  \n关于这些模块的介绍可以自己百度,根据自己需要来安装,嫌麻烦的话～直接copy吧～\n\n## 关闭httpd(Apache)并打开Nginx,PHP-FPM\n\n **关闭Apache**  \n    \n    systemctl stop httpd.service  \n  \n**打开Nginx**  \n    \n    systemctl start nginx.service  \n  \n**打开PHP-FPM**  \n\n    systemctl start php-fpm.service  \n  \n## 设置开机自启Nginx PHP-FPM\n\n **关闭httpd(Apache)的开机自启**  \n    \n    systemctl disable httpd.service  \n  \n**设置Nginx和PHP-FPM开机自启**  \n    \n    systemctl enable nginx.service\n    \n    systemctl enable php-fpm.service  \n  \n## 配置Nginx 和PHP-FPM\n\n **先做好默认配置的备份**  \n    \n    cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak\n    \n    cp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf  \n  \n**修改PHP-FPM配置**  \n    \n    vim /etc/php-fpm.d/www.conf\n    \n    ## 注释掉新添加一行 ##\n    \n    ;listen = /run/php-fpm/www.sock\n    \n    listen = 127.0.0.1:9000  \n  \n**为你的站点创建相关文件夹**  \n    \n    ## 将testsite.local换成你自己的　##\n    \n    mkdir -p /srv/www/testsite.local/public_html\n    \n    mkdir /srv/www/testsite.local/logs\n    \n    chown -R apache:apache /srv/www/testsite.local\n    \n    mkdir /etc/nginx/sites-available\n    \n    mkdir /etc/nginx/sites-enabled  \n  \n这里使用apache user group是因为PHP-FPM默认运行apache,并且apache能够进入一些类似httpd这样的目录\n\n**在/etc/nginx/nginx.conf文件\\”include /etc/nginx/conf.d/*.conf\\”这行后面添加一行**  \n\n    include /etc/nginx/sites-enabled/*;  \n  \n  \n**创建testsite.local 文件并配置**  \n\n    ## 这是最基本的配置 ##\n    \n    server {\n    \n        server_name testsite.local;\n    \n        access_log /srv/www/testsite.local/logs/access.log;\n    \n        error_log /srv/www/testsite.local/logs/error.log;\n    \n        root /srv/www/testsite.local/public_html;\n    \n        location / {\n    \n            index index.html index.htm index.php;\n    \n        }\n    \n        location ~ \\.php$ {\n    \n            include /etc/nginx/fastcgi_params;\n    \n            fastcgi_pass  127.0.0.1:9000;\n    \n            fastcgi_index index.php;\n    \n            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    \n        }\n    \n    }  \n  \n  \n**创建软链接到sites-enabled目录**  \n    \n    cd /etc/nginx/sites-enabled/\n    \n    ln -s /etc/nginx/sites-available/testsite.local\n    \n    systemctl restart nginx.service  \n  \n  \n**将testsite.local添加到/etc/hosts中**  \n\n    127.0.0.1               localhost.localdomain localhost testsite.local  \n  \n  \n[更多的Nginx 和PHP-FPM配置点这里～](http://www.if-not-true-then-false.com/2011/nginx-\nand-php-fpm-configuration-and-optimizing-tips-and-tricks/)\n\n## 测试是否成功\n\n**创建/srv/www/testsite.local/public_html/index.php并添加以下内容:**  \n\n**然后访问域名或者服务器ip看是否出现phpinfo的页面。**\n\n## 出现403 forbidden\n\n**可能是SELinux有问题**  \n\n    chcon -R -t httpd_sys_content_t /srv/www/testsite.local/public_html  \n  \n  \n## 远程链接到服务器\n\n**打开防火墙的80端口**  \n\n    firewall-cmd --get-active-zones\n    \n    firewall-cmd --permanent --zone=public --add-service=http\n    \n    ## OR ##\n    \n    firewall-cmd --permanent --zone=public --add-port=80/tcp\n    \n    systemctl restart firewalld.service  \n  \n  \n**访问域名或者ip试试~**\n\n# 安装MariaDB\n\n这里安装的是MariaDB,而不是Mysql,有如下几个原因\n\n  * MariaDB本来就是一个Mysql的开源版本\n  * MariaDB和Mysql类似并兼容Mysql\n  * Fedora和Centos系列的发行版已经转用MariaDB了\n\n**我这里选择安装MariaDB 10.2.7 [stable],具体安装过程如下~**\n\n  * 如果之前安装了Mysql,记得备份你的数据库和配置文件!\n  * 如果是从低版本升级的,记得执行`mysql_upgrade`~\n\n## 切换root用户\n    \n    su -\n    \n    ## OR ##\n    \n    sudo -i  \n  \n  \n## 添加MariaDB repo\n\n现在Fedora 24/25/26 用户都可以直接安装MariaDB 10.1 而不用添加其他的repo来安装~\n\n[MariaDB repository configuration\ntool](http://downloads.mariadb.org/mariadb/repositories/),这里面有repo,自己选择repo文件安装,上面也有教程~\n\n## 更新并安装\n\n    dnf install mariadb mariadb-server  \n\n## 打开MariaDB并配置自启\n  \n    systemctl start mariadb.service ## use restart after update\n\n    systemctl enable mariadb.service  \n    \n## 进行secure installation\n    \n    /usr/bin/mysql_secure_installation  \n  \n自己看提示来~第一个没设置密码呢,直接回车,下面的大多数都选Y\n\n如果不想进行secure installation 的话,emmmmm….最好还是做下吧~  \n  \n到这里其实已经结束了…233333\n\n## 连接数据库\n    \n    mysql -u root -p  \n  \n## 创建数据库和user\n    \n    ## CREATE DATABASE ##\n    \n    MariaDB [(none)]> CREATE DATABASE webdb;\n    \n    ## CREATE USER ##\n    \n    MariaDB [(none)]> CREATE USER 'webdb_user'@'10.0.15.25' IDENTIFIED BY 'password123';\n    \n    ## GRANT PERMISSIONS ##\n    \n    MariaDB [(none)]> GRANT ALL ON webdb.* TO 'webdb_user'@'10.0.15.25';\n    \n    ##  FLUSH PRIVILEGES, Tell the server to reload the grant tables  ##\n    \n    MariaDB [(none)]> FLUSH PRIVILEGES;  \n  \n## 确保数据库能远程连接\n\n    firewall-cmd --get-active-zones\n    \n    ## 应该会输出如下 ##\n    \n    - public\n    \n    -    interfaces: wlp1s0\n    \n    firewall-cmd --permanent --zone=public --add-service=mysql\n    \n    systemctl restart firewalld.service\n    \n    mysql -h 10.0.15.25 -u myusername -p  \n  \n\n------------------- \n","slug":"Fedora搭建LNMP环境","published":1,"updated":"2019-07-25T17:49:59.333Z","layout":"post","photos":[],"link":"","_id":"ck2424lke000alksb9hizgy3b","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>woc!因为Algolia文章长度限制…不得不把原本的<centos-fedora搭建lnmp环境>改成两篇文章…佛了<br><a id=\"more\"></a></centos-fedora搭建lnmp环境></p><p>原本在服务器上一直用的debian系,后来转到本机Fedora搭建环境就蒙了,之前也因为这个花了不少时间,为了把踩过得坑记下来,还是写篇文章。</p><p>其实所谓LNMP其实就是指Linux+Nginx+Mysql+PHP,因为Nginx发音问题,有时候也说是LEMP。</p><p><strong>下面就是<em>Centos/Fedora</em> 搭建LNMP环境的教程.</strong></p><h1 id=\"操作环境\"><a href=\"#操作环境\" class=\"headerlink\" title=\"操作环境\"></a>操作环境</h1><p>OS: Fedora 25<br>Nginx Version: 1.6.2<br>Mysql Version: MariaDB 10.2<br>PHP Version: PHP7.17</p><h1 id=\"安装Nginx-PHP7-1-7和PHP-FPM\"><a href=\"#安装Nginx-PHP7-1-7和PHP-FPM\" class=\"headerlink\" title=\"安装Nginx,PHP7.1.7和PHP-FPM\"></a>安装Nginx,PHP7.1.7和PHP-FPM</h1><h2 id=\"切换到root用户\"><a href=\"#切换到root用户\" class=\"headerlink\" title=\"切换到root用户\"></a>切换到root用户</h2><pre><code>sudo -i \n\n## OR ##\n\nsu -  \n</code></pre><h2 id=\"添加repositories\"><a href=\"#添加repositories\" class=\"headerlink\" title=\"添加repositories\"></a>添加repositories</h2><pre><code>## Remi Dependency on Fedora ##\n\nrpm -Uvh http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-stable.noarch.rpm \n\nrpm -Uvh http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm\n\n## The version 25 can be replaced by 26/24 ##\n\nrpm -Uvh http://rpms.famillecollet.com/fedora/remi-release-25.rpm  \n</code></pre><h2 id=\"安装Nginx-PHP-7-1-7-and-PHP-FPM\"><a href=\"#安装Nginx-PHP-7-1-7-and-PHP-FPM\" class=\"headerlink\" title=\"安装Nginx,PHP 7.1.7 and PHP-FPM\"></a>安装Nginx,PHP 7.1.7 and PHP-FPM</h2><pre><code>dnf --enablerepo=remi --enablerepo=remi-php71 install nginx php-fpm php-common  \n</code></pre><h2 id=\"安装模块\"><a href=\"#安装模块\" class=\"headerlink\" title=\"安装模块\"></a>安装模块</h2><pre><code>dnf --enablerepo=remi --enablerepo=remi-php71 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xml  \n</code></pre><p>关于这些模块的介绍可以自己百度,根据自己需要来安装,嫌麻烦的话～直接copy吧～</p><h2 id=\"关闭httpd-Apache-并打开Nginx-PHP-FPM\"><a href=\"#关闭httpd-Apache-并打开Nginx-PHP-FPM\" class=\"headerlink\" title=\"关闭httpd(Apache)并打开Nginx,PHP-FPM\"></a>关闭httpd(Apache)并打开Nginx,PHP-FPM</h2><p><strong>关闭Apache</strong></p><pre><code>systemctl stop httpd.service  \n</code></pre><p><strong>打开Nginx</strong></p><pre><code>systemctl start nginx.service  \n</code></pre><p><strong>打开PHP-FPM</strong></p><pre><code>systemctl start php-fpm.service  \n</code></pre><h2 id=\"设置开机自启Nginx-PHP-FPM\"><a href=\"#设置开机自启Nginx-PHP-FPM\" class=\"headerlink\" title=\"设置开机自启Nginx PHP-FPM\"></a>设置开机自启Nginx PHP-FPM</h2><p><strong>关闭httpd(Apache)的开机自启</strong></p><pre><code>systemctl disable httpd.service  \n</code></pre><p><strong>设置Nginx和PHP-FPM开机自启</strong></p><pre><code>systemctl enable nginx.service\n\nsystemctl enable php-fpm.service  \n</code></pre><h2 id=\"配置Nginx-和PHP-FPM\"><a href=\"#配置Nginx-和PHP-FPM\" class=\"headerlink\" title=\"配置Nginx 和PHP-FPM\"></a>配置Nginx 和PHP-FPM</h2><p><strong>先做好默认配置的备份</strong></p><pre><code>cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak\n\ncp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf  \n</code></pre><p><strong>修改PHP-FPM配置</strong></p><pre><code>vim /etc/php-fpm.d/www.conf\n\n## 注释掉新添加一行 ##\n\n;listen = /run/php-fpm/www.sock\n\nlisten = 127.0.0.1:9000  \n</code></pre><p><strong>为你的站点创建相关文件夹</strong></p><pre><code>## 将testsite.local换成你自己的　##\n\nmkdir -p /srv/www/testsite.local/public_html\n\nmkdir /srv/www/testsite.local/logs\n\nchown -R apache:apache /srv/www/testsite.local\n\nmkdir /etc/nginx/sites-available\n\nmkdir /etc/nginx/sites-enabled  \n</code></pre><p>这里使用apache user group是因为PHP-FPM默认运行apache,并且apache能够进入一些类似httpd这样的目录</p><p><strong>在/etc/nginx/nginx.conf文件\\”include /etc/nginx/conf.d/*.conf\\”这行后面添加一行</strong></p><pre><code>include /etc/nginx/sites-enabled/*;  \n</code></pre><p><strong>创建testsite.local 文件并配置</strong></p><pre><code>## 这是最基本的配置 ##\n\nserver {\n\n    server_name testsite.local;\n\n    access_log /srv/www/testsite.local/logs/access.log;\n\n    error_log /srv/www/testsite.local/logs/error.log;\n\n    root /srv/www/testsite.local/public_html;\n\n    location / {\n\n        index index.html index.htm index.php;\n\n    }\n\n    location ~ \\.php$ {\n\n        include /etc/nginx/fastcgi_params;\n\n        fastcgi_pass  127.0.0.1:9000;\n\n        fastcgi_index index.php;\n\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n\n    }\n\n}  \n</code></pre><p><strong>创建软链接到sites-enabled目录</strong></p><pre><code>cd /etc/nginx/sites-enabled/\n\nln -s /etc/nginx/sites-available/testsite.local\n\nsystemctl restart nginx.service  \n</code></pre><p><strong>将testsite.local添加到/etc/hosts中</strong></p><pre><code>127.0.0.1               localhost.localdomain localhost testsite.local  \n</code></pre><p><a href=\"http://www.if-not-true-then-false.com/2011/nginx-\nand-php-fpm-configuration-and-optimizing-tips-and-tricks/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">更多的Nginx 和PHP-FPM配置点这里～</a></p><h2 id=\"测试是否成功\"><a href=\"#测试是否成功\" class=\"headerlink\" title=\"测试是否成功\"></a>测试是否成功</h2><p><strong>创建/srv/www/testsite.local/public_html/index.php并添加以下内容:</strong></p><p><strong>然后访问域名或者服务器ip看是否出现phpinfo的页面。</strong></p><h2 id=\"出现403-forbidden\"><a href=\"#出现403-forbidden\" class=\"headerlink\" title=\"出现403 forbidden\"></a>出现403 forbidden</h2><p><strong>可能是SELinux有问题</strong></p><pre><code>chcon -R -t httpd_sys_content_t /srv/www/testsite.local/public_html  \n</code></pre><h2 id=\"远程链接到服务器\"><a href=\"#远程链接到服务器\" class=\"headerlink\" title=\"远程链接到服务器\"></a>远程链接到服务器</h2><p><strong>打开防火墙的80端口</strong></p><pre><code>firewall-cmd --get-active-zones\n\nfirewall-cmd --permanent --zone=public --add-service=http\n\n## OR ##\n\nfirewall-cmd --permanent --zone=public --add-port=80/tcp\n\nsystemctl restart firewalld.service  \n</code></pre><p><strong>访问域名或者ip试试~</strong></p><h1 id=\"安装MariaDB\"><a href=\"#安装MariaDB\" class=\"headerlink\" title=\"安装MariaDB\"></a>安装MariaDB</h1><p>这里安装的是MariaDB,而不是Mysql,有如下几个原因</p><ul><li>MariaDB本来就是一个Mysql的开源版本</li><li>MariaDB和Mysql类似并兼容Mysql</li><li>Fedora和Centos系列的发行版已经转用MariaDB了</li></ul><p><strong>我这里选择安装MariaDB 10.2.7 [stable],具体安装过程如下~</strong></p><ul><li>如果之前安装了Mysql,记得备份你的数据库和配置文件!</li><li>如果是从低版本升级的,记得执行<code>mysql_upgrade</code>~</li></ul><h2 id=\"切换root用户\"><a href=\"#切换root用户\" class=\"headerlink\" title=\"切换root用户\"></a>切换root用户</h2><pre><code>su -\n\n## OR ##\n\nsudo -i  \n</code></pre><h2 id=\"添加MariaDB-repo\"><a href=\"#添加MariaDB-repo\" class=\"headerlink\" title=\"添加MariaDB repo\"></a>添加MariaDB repo</h2><p>现在Fedora 24/25/26 用户都可以直接安装MariaDB 10.1 而不用添加其他的repo来安装~</p><p><a href=\"http://downloads.mariadb.org/mariadb/repositories/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MariaDB repository configuration<br>tool</a>,这里面有repo,自己选择repo文件安装,上面也有教程~</p><h2 id=\"更新并安装\"><a href=\"#更新并安装\" class=\"headerlink\" title=\"更新并安装\"></a>更新并安装</h2><pre><code>dnf install mariadb mariadb-server  \n</code></pre><h2 id=\"打开MariaDB并配置自启\"><a href=\"#打开MariaDB并配置自启\" class=\"headerlink\" title=\"打开MariaDB并配置自启\"></a>打开MariaDB并配置自启</h2><pre><code>systemctl start mariadb.service ## use restart after update\n\nsystemctl enable mariadb.service  \n</code></pre><h2 id=\"进行secure-installation\"><a href=\"#进行secure-installation\" class=\"headerlink\" title=\"进行secure installation\"></a>进行secure installation</h2><pre><code>/usr/bin/mysql_secure_installation  \n</code></pre><p>自己看提示来~第一个没设置密码呢,直接回车,下面的大多数都选Y</p><p>如果不想进行secure installation 的话,emmmmm….最好还是做下吧~</p><p>到这里其实已经结束了…233333</p><h2 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h2><pre><code>mysql -u root -p  \n</code></pre><h2 id=\"创建数据库和user\"><a href=\"#创建数据库和user\" class=\"headerlink\" title=\"创建数据库和user\"></a>创建数据库和user</h2><pre><code>## CREATE DATABASE ##\n\nMariaDB [(none)]&gt; CREATE DATABASE webdb;\n\n## CREATE USER ##\n\nMariaDB [(none)]&gt; CREATE USER &#39;webdb_user&#39;@&#39;10.0.15.25&#39; IDENTIFIED BY &#39;password123&#39;;\n\n## GRANT PERMISSIONS ##\n\nMariaDB [(none)]&gt; GRANT ALL ON webdb.* TO &#39;webdb_user&#39;@&#39;10.0.15.25&#39;;\n\n##  FLUSH PRIVILEGES, Tell the server to reload the grant tables  ##\n\nMariaDB [(none)]&gt; FLUSH PRIVILEGES;  \n</code></pre><h2 id=\"确保数据库能远程连接\"><a href=\"#确保数据库能远程连接\" class=\"headerlink\" title=\"确保数据库能远程连接\"></a>确保数据库能远程连接</h2><pre><code>firewall-cmd --get-active-zones\n\n## 应该会输出如下 ##\n\n- public\n\n-    interfaces: wlp1s0\n\nfirewall-cmd --permanent --zone=public --add-service=mysql\n\nsystemctl restart firewalld.service\n\nmysql -h 10.0.15.25 -u myusername -p  \n</code></pre><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>woc!因为Algolia文章长度限制…不得不把原本的<centos-fedora搭建lnmp环境>改成两篇文章…佛了<br>","more":"</centos-fedora搭建lnmp环境></p><p>原本在服务器上一直用的debian系,后来转到本机Fedora搭建环境就蒙了,之前也因为这个花了不少时间,为了把踩过得坑记下来,还是写篇文章。</p><p>其实所谓LNMP其实就是指Linux+Nginx+Mysql+PHP,因为Nginx发音问题,有时候也说是LEMP。</p><p><strong>下面就是<em>Centos/Fedora</em> 搭建LNMP环境的教程.</strong></p><h1 id=\"操作环境\"><a href=\"#操作环境\" class=\"headerlink\" title=\"操作环境\"></a>操作环境</h1><p>OS: Fedora 25<br>Nginx Version: 1.6.2<br>Mysql Version: MariaDB 10.2<br>PHP Version: PHP7.17</p><h1 id=\"安装Nginx-PHP7-1-7和PHP-FPM\"><a href=\"#安装Nginx-PHP7-1-7和PHP-FPM\" class=\"headerlink\" title=\"安装Nginx,PHP7.1.7和PHP-FPM\"></a>安装Nginx,PHP7.1.7和PHP-FPM</h1><h2 id=\"切换到root用户\"><a href=\"#切换到root用户\" class=\"headerlink\" title=\"切换到root用户\"></a>切换到root用户</h2><pre><code>sudo -i \n\n## OR ##\n\nsu -  \n</code></pre><h2 id=\"添加repositories\"><a href=\"#添加repositories\" class=\"headerlink\" title=\"添加repositories\"></a>添加repositories</h2><pre><code>## Remi Dependency on Fedora ##\n\nrpm -Uvh http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-stable.noarch.rpm \n\nrpm -Uvh http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm\n\n## The version 25 can be replaced by 26/24 ##\n\nrpm -Uvh http://rpms.famillecollet.com/fedora/remi-release-25.rpm  \n</code></pre><h2 id=\"安装Nginx-PHP-7-1-7-and-PHP-FPM\"><a href=\"#安装Nginx-PHP-7-1-7-and-PHP-FPM\" class=\"headerlink\" title=\"安装Nginx,PHP 7.1.7 and PHP-FPM\"></a>安装Nginx,PHP 7.1.7 and PHP-FPM</h2><pre><code>dnf --enablerepo=remi --enablerepo=remi-php71 install nginx php-fpm php-common  \n</code></pre><h2 id=\"安装模块\"><a href=\"#安装模块\" class=\"headerlink\" title=\"安装模块\"></a>安装模块</h2><pre><code>dnf --enablerepo=remi --enablerepo=remi-php71 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xml  \n</code></pre><p>关于这些模块的介绍可以自己百度,根据自己需要来安装,嫌麻烦的话～直接copy吧～</p><h2 id=\"关闭httpd-Apache-并打开Nginx-PHP-FPM\"><a href=\"#关闭httpd-Apache-并打开Nginx-PHP-FPM\" class=\"headerlink\" title=\"关闭httpd(Apache)并打开Nginx,PHP-FPM\"></a>关闭httpd(Apache)并打开Nginx,PHP-FPM</h2><p><strong>关闭Apache</strong></p><pre><code>systemctl stop httpd.service  \n</code></pre><p><strong>打开Nginx</strong></p><pre><code>systemctl start nginx.service  \n</code></pre><p><strong>打开PHP-FPM</strong></p><pre><code>systemctl start php-fpm.service  \n</code></pre><h2 id=\"设置开机自启Nginx-PHP-FPM\"><a href=\"#设置开机自启Nginx-PHP-FPM\" class=\"headerlink\" title=\"设置开机自启Nginx PHP-FPM\"></a>设置开机自启Nginx PHP-FPM</h2><p><strong>关闭httpd(Apache)的开机自启</strong></p><pre><code>systemctl disable httpd.service  \n</code></pre><p><strong>设置Nginx和PHP-FPM开机自启</strong></p><pre><code>systemctl enable nginx.service\n\nsystemctl enable php-fpm.service  \n</code></pre><h2 id=\"配置Nginx-和PHP-FPM\"><a href=\"#配置Nginx-和PHP-FPM\" class=\"headerlink\" title=\"配置Nginx 和PHP-FPM\"></a>配置Nginx 和PHP-FPM</h2><p><strong>先做好默认配置的备份</strong></p><pre><code>cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak\n\ncp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf  \n</code></pre><p><strong>修改PHP-FPM配置</strong></p><pre><code>vim /etc/php-fpm.d/www.conf\n\n## 注释掉新添加一行 ##\n\n;listen = /run/php-fpm/www.sock\n\nlisten = 127.0.0.1:9000  \n</code></pre><p><strong>为你的站点创建相关文件夹</strong></p><pre><code>## 将testsite.local换成你自己的　##\n\nmkdir -p /srv/www/testsite.local/public_html\n\nmkdir /srv/www/testsite.local/logs\n\nchown -R apache:apache /srv/www/testsite.local\n\nmkdir /etc/nginx/sites-available\n\nmkdir /etc/nginx/sites-enabled  \n</code></pre><p>这里使用apache user group是因为PHP-FPM默认运行apache,并且apache能够进入一些类似httpd这样的目录</p><p><strong>在/etc/nginx/nginx.conf文件\\”include /etc/nginx/conf.d/*.conf\\”这行后面添加一行</strong></p><pre><code>include /etc/nginx/sites-enabled/*;  \n</code></pre><p><strong>创建testsite.local 文件并配置</strong></p><pre><code>## 这是最基本的配置 ##\n\nserver {\n\n    server_name testsite.local;\n\n    access_log /srv/www/testsite.local/logs/access.log;\n\n    error_log /srv/www/testsite.local/logs/error.log;\n\n    root /srv/www/testsite.local/public_html;\n\n    location / {\n\n        index index.html index.htm index.php;\n\n    }\n\n    location ~ \\.php$ {\n\n        include /etc/nginx/fastcgi_params;\n\n        fastcgi_pass  127.0.0.1:9000;\n\n        fastcgi_index index.php;\n\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n\n    }\n\n}  \n</code></pre><p><strong>创建软链接到sites-enabled目录</strong></p><pre><code>cd /etc/nginx/sites-enabled/\n\nln -s /etc/nginx/sites-available/testsite.local\n\nsystemctl restart nginx.service  \n</code></pre><p><strong>将testsite.local添加到/etc/hosts中</strong></p><pre><code>127.0.0.1               localhost.localdomain localhost testsite.local  \n</code></pre><p><a href=\"http://www.if-not-true-then-false.com/2011/nginx-\nand-php-fpm-configuration-and-optimizing-tips-and-tricks/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">更多的Nginx 和PHP-FPM配置点这里～</a></p><h2 id=\"测试是否成功\"><a href=\"#测试是否成功\" class=\"headerlink\" title=\"测试是否成功\"></a>测试是否成功</h2><p><strong>创建/srv/www/testsite.local/public_html/index.php并添加以下内容:</strong></p><p><strong>然后访问域名或者服务器ip看是否出现phpinfo的页面。</strong></p><h2 id=\"出现403-forbidden\"><a href=\"#出现403-forbidden\" class=\"headerlink\" title=\"出现403 forbidden\"></a>出现403 forbidden</h2><p><strong>可能是SELinux有问题</strong></p><pre><code>chcon -R -t httpd_sys_content_t /srv/www/testsite.local/public_html  \n</code></pre><h2 id=\"远程链接到服务器\"><a href=\"#远程链接到服务器\" class=\"headerlink\" title=\"远程链接到服务器\"></a>远程链接到服务器</h2><p><strong>打开防火墙的80端口</strong></p><pre><code>firewall-cmd --get-active-zones\n\nfirewall-cmd --permanent --zone=public --add-service=http\n\n## OR ##\n\nfirewall-cmd --permanent --zone=public --add-port=80/tcp\n\nsystemctl restart firewalld.service  \n</code></pre><p><strong>访问域名或者ip试试~</strong></p><h1 id=\"安装MariaDB\"><a href=\"#安装MariaDB\" class=\"headerlink\" title=\"安装MariaDB\"></a>安装MariaDB</h1><p>这里安装的是MariaDB,而不是Mysql,有如下几个原因</p><ul><li>MariaDB本来就是一个Mysql的开源版本</li><li>MariaDB和Mysql类似并兼容Mysql</li><li>Fedora和Centos系列的发行版已经转用MariaDB了</li></ul><p><strong>我这里选择安装MariaDB 10.2.7 [stable],具体安装过程如下~</strong></p><ul><li>如果之前安装了Mysql,记得备份你的数据库和配置文件!</li><li>如果是从低版本升级的,记得执行<code>mysql_upgrade</code>~</li></ul><h2 id=\"切换root用户\"><a href=\"#切换root用户\" class=\"headerlink\" title=\"切换root用户\"></a>切换root用户</h2><pre><code>su -\n\n## OR ##\n\nsudo -i  \n</code></pre><h2 id=\"添加MariaDB-repo\"><a href=\"#添加MariaDB-repo\" class=\"headerlink\" title=\"添加MariaDB repo\"></a>添加MariaDB repo</h2><p>现在Fedora 24/25/26 用户都可以直接安装MariaDB 10.1 而不用添加其他的repo来安装~</p><p><a href=\"http://downloads.mariadb.org/mariadb/repositories/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MariaDB repository configuration<br>tool</a>,这里面有repo,自己选择repo文件安装,上面也有教程~</p><h2 id=\"更新并安装\"><a href=\"#更新并安装\" class=\"headerlink\" title=\"更新并安装\"></a>更新并安装</h2><pre><code>dnf install mariadb mariadb-server  \n</code></pre><h2 id=\"打开MariaDB并配置自启\"><a href=\"#打开MariaDB并配置自启\" class=\"headerlink\" title=\"打开MariaDB并配置自启\"></a>打开MariaDB并配置自启</h2><pre><code>systemctl start mariadb.service ## use restart after update\n\nsystemctl enable mariadb.service  \n</code></pre><h2 id=\"进行secure-installation\"><a href=\"#进行secure-installation\" class=\"headerlink\" title=\"进行secure installation\"></a>进行secure installation</h2><pre><code>/usr/bin/mysql_secure_installation  \n</code></pre><p>自己看提示来~第一个没设置密码呢,直接回车,下面的大多数都选Y</p><p>如果不想进行secure installation 的话,emmmmm….最好还是做下吧~</p><p>到这里其实已经结束了…233333</p><h2 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h2><pre><code>mysql -u root -p  \n</code></pre><h2 id=\"创建数据库和user\"><a href=\"#创建数据库和user\" class=\"headerlink\" title=\"创建数据库和user\"></a>创建数据库和user</h2><pre><code>## CREATE DATABASE ##\n\nMariaDB [(none)]&gt; CREATE DATABASE webdb;\n\n## CREATE USER ##\n\nMariaDB [(none)]&gt; CREATE USER &#39;webdb_user&#39;@&#39;10.0.15.25&#39; IDENTIFIED BY &#39;password123&#39;;\n\n## GRANT PERMISSIONS ##\n\nMariaDB [(none)]&gt; GRANT ALL ON webdb.* TO &#39;webdb_user&#39;@&#39;10.0.15.25&#39;;\n\n##  FLUSH PRIVILEGES, Tell the server to reload the grant tables  ##\n\nMariaDB [(none)]&gt; FLUSH PRIVILEGES;  \n</code></pre><h2 id=\"确保数据库能远程连接\"><a href=\"#确保数据库能远程连接\" class=\"headerlink\" title=\"确保数据库能远程连接\"></a>确保数据库能远程连接</h2><pre><code>firewall-cmd --get-active-zones\n\n## 应该会输出如下 ##\n\n- public\n\n-    interfaces: wlp1s0\n\nfirewall-cmd --permanent --zone=public --add-service=mysql\n\nsystemctl restart firewalld.service\n\nmysql -h 10.0.15.25 -u myusername -p  \n</code></pre><hr><!-- rebuild by neat -->"},{"title":"Linux将deb包转为ArchLinux软件包","urlname":"linux-deb2pkg","comments":1,"mathjax":false,"date":"2019-07-03T10:35:48.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n有时候可能找不到arch用的包，只有deb包或者rpm包。\n将deb包转换为ArchLinux的包比较方便，使用了debtap这个工具\ndebtap代表了 DEB T o A rch （Linux） P ackage的意思\n{% endnote %}\n<!--more-->\n\n## 安装debtap并更新数据\n### 安装\n**[依赖关系:]** 需要提前安装好** bash， binutils ，pkgfile 和 fakeroot 包**\n如果直接安装会帮你安装依赖.\n\n```bash\nyaourt -S debtap\n```\n遇到需要编辑的就默认enter跳过，需要安装的就确认，然后等就行了\n\n### 创建/更新 pkgfile 和 debtap 数据库。\n\n```bash\nsudo debtap -u\n```\n\n## 转化\n假如要转化name.deb\n\n```bash\ndebtap name.deb\n```\n\n中间可能要输入点东西，自己看情况输入就好\n\n**其他参数：**\n- 略过除了编辑元数据之外的所有问题\n\n```bash\ndebtap -q name.deb\n```\n\n- 略过所有的问题（不推荐）\n\n```bash\ndebtap -Q name.deb\n```\n\n- 查看帮助\n\n```bash\ndebtap -h\n```\n\n## 安装软件包\n使用pacman安装软件包\n\n```bash\nsudo pacman -U <package-name>\n```\n\n---------\n","source":"_posts/Linux将deb包转为ArchLinux软件包.md","raw":"---\ntitle: Linux将deb包转为ArchLinux软件包\ntags:\n  - Deb\n  - Debtap\n  - ArchLinux\n  - Linux\ncategories:\n  - Linux\nurlname: linux-deb2pkg\ncomments: true\nmathjax: false\ndate: 2019-07-03 18:35:48\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n有时候可能找不到arch用的包，只有deb包或者rpm包。\n将deb包转换为ArchLinux的包比较方便，使用了debtap这个工具\ndebtap代表了 DEB T o A rch （Linux） P ackage的意思\n{% endnote %}\n<!--more-->\n\n## 安装debtap并更新数据\n### 安装\n**[依赖关系:]** 需要提前安装好** bash， binutils ，pkgfile 和 fakeroot 包**\n如果直接安装会帮你安装依赖.\n\n```bash\nyaourt -S debtap\n```\n遇到需要编辑的就默认enter跳过，需要安装的就确认，然后等就行了\n\n### 创建/更新 pkgfile 和 debtap 数据库。\n\n```bash\nsudo debtap -u\n```\n\n## 转化\n假如要转化name.deb\n\n```bash\ndebtap name.deb\n```\n\n中间可能要输入点东西，自己看情况输入就好\n\n**其他参数：**\n- 略过除了编辑元数据之外的所有问题\n\n```bash\ndebtap -q name.deb\n```\n\n- 略过所有的问题（不推荐）\n\n```bash\ndebtap -Q name.deb\n```\n\n- 查看帮助\n\n```bash\ndebtap -h\n```\n\n## 安装软件包\n使用pacman安装软件包\n\n```bash\nsudo pacman -U <package-name>\n```\n\n---------\n","slug":"Linux将deb包转为ArchLinux软件包","published":1,"updated":"2019-07-25T18:31:11.139Z","layout":"post","photos":[],"link":"","_id":"ck2424lkh000blksbyg7elqg6","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有时候可能找不到arch用的包，只有deb包或者rpm包。<br>将deb包转换为ArchLinux的包比较方便，使用了debtap这个工具<br>debtap代表了 DEB T o A rch （Linux） P ackage的意思</p></div><a id=\"more\"></a><h2 id=\"安装debtap并更新数据\"><a href=\"#安装debtap并更新数据\" class=\"headerlink\" title=\"安装debtap并更新数据\"></a>安装debtap并更新数据</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><strong>[依赖关系:]</strong> 需要提前安装好<strong> bash， binutils ，pkgfile 和 fakeroot 包</strong><br>如果直接安装会帮你安装依赖.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yaourt -S debtap</span><br></pre></td></tr></table></figure><p>遇到需要编辑的就默认enter跳过，需要安装的就确认，然后等就行了</p><h3 id=\"创建-更新-pkgfile-和-debtap-数据库。\"><a href=\"#创建-更新-pkgfile-和-debtap-数据库。\" class=\"headerlink\" title=\"创建/更新 pkgfile 和 debtap 数据库。\"></a>创建/更新 pkgfile 和 debtap 数据库。</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo debtap -u</span><br></pre></td></tr></table></figure><h2 id=\"转化\"><a href=\"#转化\" class=\"headerlink\" title=\"转化\"></a>转化</h2><p>假如要转化name.deb</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debtap name.deb</span><br></pre></td></tr></table></figure><p>中间可能要输入点东西，自己看情况输入就好</p><p><strong>其他参数：</strong></p><ul><li>略过除了编辑元数据之外的所有问题</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debtap -q name.deb</span><br></pre></td></tr></table></figure><ul><li>略过所有的问题（不推荐）</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debtap -Q name.deb</span><br></pre></td></tr></table></figure><ul><li>查看帮助</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debtap -h</span><br></pre></td></tr></table></figure><h2 id=\"安装软件包\"><a href=\"#安装软件包\" class=\"headerlink\" title=\"安装软件包\"></a>安装软件包</h2><p>使用pacman安装软件包</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pacman -U &lt;package-name&gt;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有时候可能找不到arch用的包，只有deb包或者rpm包。<br>将deb包转换为ArchLinux的包比较方便，使用了debtap这个工具<br>debtap代表了 DEB T o A rch （Linux） P ackage的意思</p></div>","more":"<h2 id=\"安装debtap并更新数据\"><a href=\"#安装debtap并更新数据\" class=\"headerlink\" title=\"安装debtap并更新数据\"></a>安装debtap并更新数据</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><strong>[依赖关系:]</strong> 需要提前安装好<strong> bash， binutils ，pkgfile 和 fakeroot 包</strong><br>如果直接安装会帮你安装依赖.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yaourt -S debtap</span><br></pre></td></tr></table></figure><p>遇到需要编辑的就默认enter跳过，需要安装的就确认，然后等就行了</p><h3 id=\"创建-更新-pkgfile-和-debtap-数据库。\"><a href=\"#创建-更新-pkgfile-和-debtap-数据库。\" class=\"headerlink\" title=\"创建/更新 pkgfile 和 debtap 数据库。\"></a>创建/更新 pkgfile 和 debtap 数据库。</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo debtap -u</span><br></pre></td></tr></table></figure><h2 id=\"转化\"><a href=\"#转化\" class=\"headerlink\" title=\"转化\"></a>转化</h2><p>假如要转化name.deb</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debtap name.deb</span><br></pre></td></tr></table></figure><p>中间可能要输入点东西，自己看情况输入就好</p><p><strong>其他参数：</strong></p><ul><li>略过除了编辑元数据之外的所有问题</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debtap -q name.deb</span><br></pre></td></tr></table></figure><ul><li>略过所有的问题（不推荐）</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debtap -Q name.deb</span><br></pre></td></tr></table></figure><ul><li>查看帮助</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debtap -h</span><br></pre></td></tr></table></figure><h2 id=\"安装软件包\"><a href=\"#安装软件包\" class=\"headerlink\" title=\"安装软件包\"></a>安装软件包</h2><p>使用pacman安装软件包</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pacman -U &lt;package-name&gt;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"C++优先级队列","comments":1,"mathjax":false,"date":"2019-05-23T05:42:24.000Z","urlname":"C-PriorityQueue","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n写LeetCode的时候学了优先级队列，这里总结一下STL中优先级队列的使用和实现\n{% endnote %}\n\n<!--more-->\n\n## 介绍\n\n优先级队列也是队列的一种，FIFO结构，但是和普通的队列不同的是有一个优先级的权重\n\n优先级队列有两种，一种是最小优先队列，值小的优先级越大，另一种是最大优先队列，值大的优先级越大\n\n头文件： \"queue.h\", \"functional.h\"\n\n插入和删除操作复杂度都是$$ O(lgn) $$\n\n## 使用\n\n### 构造函数\n构造函数声明如下：\n```\nstd::priority_queue<T> pq;\nstd::priority_queue<T, std::vector<T>, cmp> pq;\n```\n\n**第一种构造函数：**\n- 传入一个基本类型或者自定义类，自定义类要重载$$ < $$符号\n\n**第二种构造函数：**\n参数介绍：\n1. 是队列中元素的种类，可以是自定义的也可以是基本类型，默认是int\n2. 第二个是容纳优先级队列的容器，只需要知道默认是vector就好，使用的时候也是用vector\n3. 这个是最重要的参数，支持一个比较函数，默认是less，队列是最大优先队列。\n\n第三个参数有三种情况介绍：\n1. 自定义比较结构，使用结构体，**注意返回值！！**，最小优先队列是大于\n2. 使用默认的类型时用less()或者greater()\n3. 使用自定义类的时候重载$$ < $$符号\n\n### 常用操作\n1. q.empty(): 如果队列为空，则返回true，否则返回false\n2. q.size():  返回队列中元素的个数\n3. q.pop():   删除队首元素，但不返回其值\n4. q.top():   返回具有最高优先级的元素值，最大优先队列找最大的元素，最小优先队列找最小的，但不删除该元素\n5. q.push(item): 在基于优先级的适当位置插入新元素\n\n### 使用样例\n注意这不是一个完整的C++代码\n\n```C\n//包含头文件并使用std命名空间\n#include<functional>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n//第一种构造函数，采用默认优先级构造队列\npriority_queue<int>que;\n\n//第二种构造函数，这里使用基本的int类型，如果看其他类型，请看LeetCode 23题代码\n//自定义比较结构\nstruct cmp1{\n    bool operator ()(int &a,int &b){\n        return a>b;//最小值优先\n    }\n};\npriority_queue<int,vector<int>,cmp1>que1;//最小值优先\npriority_queue<int,vector<int>,greater<int> >que3;//注意“>>”会被认为错误，greater在functional头文件中\n\n\n//自定义数据结构并重载小于操作符\nstruct number1{\n    int x;\n    bool operator < (const number1 &a) const {\n        return x>a.x;//最小值优先\n    }\n};\npriority_queue<number1>que5; //最小优先级队列\n\nprintf(\"采用默认优先关系:/n(priority_queue<int>que;)/n\");\nprintf(\"Queue 0:/n\");\nwhile(!que.empty()){\n    printf(\"%3d\",que.top());\n    que.pop();\n}\n\n```\n\n## 实现\n引用博客：[优先队列原理与实现](https://www.cnblogs.com/luoxn28/p/5616101.html)\n推荐结合另一篇博客: [【STL学习】优先级队列Priority Queue详解与C++编程实现](https://blog.csdn.net/xiajun07061225/article/details/8556786)\n可以看这两篇博客了解插入和删除的原理，第一篇博客有图比较清楚\n\n```\npackage priorityheap;\n\nimport java.util.Arrays;\n\n/**\n * 优先队列类（最大优先队列）\n */\npublic class PriorityHeap {\n\n    // ------------------------------ Instance Variables\n\n    private int[] arr;\n    private int size;\n\n    // ------------------------------ Constructors\n\n    /**\n     * 优先队列数组默认大小为64\n     */\n    public PriorityHeap() {\n        this(64);\n    }\n\n    public PriorityHeap(int initSize) {\n        if (initSize <= 0) {\n            initSize = 64;\n        }\n        this.arr = new int[initSize];\n        this.size = 0;\n    }\n\n    // ------------------------------ Public methods\n\n    public int max() {\n        return this.arr[0];\n    }\n\n    public int maxAndRemove() {\n        int t = max();\n\n        this.arr[0] = this.arr[--size];\n        sink(0, this.arr[0]);\n        return t;\n    }\n    public void add(int data) {\n        resize(1);\n        this.arr[size++] = data;\n        pop(size - 1, data);\n    }\n\n    // ------------------------------ Private methods\n\n    /**\n     * key下沉方法\n     */\n    private void sink(int i, int key) {\n        while (2 * i <= this.size - 1) {\n            int child = 2 * i;\n            if (child < this.size - 1 && this.arr[child] < this.arr[child + 1]) {\n                child++;\n            }\n            if (this.arr[i] >= this.arr[child]) {\n                break;\n            }\n\n            swap(i, child);\n            i = child;\n        }\n    }\n\n    /**\n     * key上浮方法\n     */\n    private void pop(int i, int key) {\n        while (i > 0) {\n            int parent = i / 2;\n            if (this.arr[i] <= this.arr[parent]) {\n                break;\n            }\n            swap(i, parent);\n            i = parent;\n        }\n    }\n\n    /**\n     * 重新调整数组大小\n     */\n    private void resize(int increaseSize) {\n        if ((this.size + increaseSize) > this.arr.length) {\n            int newSize = (this.size + increaseSize) > 2 * this.arr.length ? (this.size + increaseSize) : 2 * this.arr.length;\n            int[] t = this.arr;\n\n            this.arr = Arrays.copyOf(t, newSize);\n        }\n    }\n\n    /**\n     * Swaps arr[a] with arr[b].\n     */\n    private void swap(int a, int b) {\n        int t = this.arr[a];\n        this.arr[a] = this.arr[b];\n        this.arr[b] = t;\n    }\n}\n```\n\n---------\n","source":"_posts/C-优先级队列.md","raw":"---\ntitle: C++优先级队列\ncomments: true\nmathjax: false\ndate: 2019-05-23 13:42:24\ntags: [C++, Queue, PriorityQueue, Notes]\ncategories: Notes\nurlname: C-PriorityQueue\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n写LeetCode的时候学了优先级队列，这里总结一下STL中优先级队列的使用和实现\n{% endnote %}\n\n<!--more-->\n\n## 介绍\n\n优先级队列也是队列的一种，FIFO结构，但是和普通的队列不同的是有一个优先级的权重\n\n优先级队列有两种，一种是最小优先队列，值小的优先级越大，另一种是最大优先队列，值大的优先级越大\n\n头文件： \"queue.h\", \"functional.h\"\n\n插入和删除操作复杂度都是$$ O(lgn) $$\n\n## 使用\n\n### 构造函数\n构造函数声明如下：\n```\nstd::priority_queue<T> pq;\nstd::priority_queue<T, std::vector<T>, cmp> pq;\n```\n\n**第一种构造函数：**\n- 传入一个基本类型或者自定义类，自定义类要重载$$ < $$符号\n\n**第二种构造函数：**\n参数介绍：\n1. 是队列中元素的种类，可以是自定义的也可以是基本类型，默认是int\n2. 第二个是容纳优先级队列的容器，只需要知道默认是vector就好，使用的时候也是用vector\n3. 这个是最重要的参数，支持一个比较函数，默认是less，队列是最大优先队列。\n\n第三个参数有三种情况介绍：\n1. 自定义比较结构，使用结构体，**注意返回值！！**，最小优先队列是大于\n2. 使用默认的类型时用less()或者greater()\n3. 使用自定义类的时候重载$$ < $$符号\n\n### 常用操作\n1. q.empty(): 如果队列为空，则返回true，否则返回false\n2. q.size():  返回队列中元素的个数\n3. q.pop():   删除队首元素，但不返回其值\n4. q.top():   返回具有最高优先级的元素值，最大优先队列找最大的元素，最小优先队列找最小的，但不删除该元素\n5. q.push(item): 在基于优先级的适当位置插入新元素\n\n### 使用样例\n注意这不是一个完整的C++代码\n\n```C\n//包含头文件并使用std命名空间\n#include<functional>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n//第一种构造函数，采用默认优先级构造队列\npriority_queue<int>que;\n\n//第二种构造函数，这里使用基本的int类型，如果看其他类型，请看LeetCode 23题代码\n//自定义比较结构\nstruct cmp1{\n    bool operator ()(int &a,int &b){\n        return a>b;//最小值优先\n    }\n};\npriority_queue<int,vector<int>,cmp1>que1;//最小值优先\npriority_queue<int,vector<int>,greater<int> >que3;//注意“>>”会被认为错误，greater在functional头文件中\n\n\n//自定义数据结构并重载小于操作符\nstruct number1{\n    int x;\n    bool operator < (const number1 &a) const {\n        return x>a.x;//最小值优先\n    }\n};\npriority_queue<number1>que5; //最小优先级队列\n\nprintf(\"采用默认优先关系:/n(priority_queue<int>que;)/n\");\nprintf(\"Queue 0:/n\");\nwhile(!que.empty()){\n    printf(\"%3d\",que.top());\n    que.pop();\n}\n\n```\n\n## 实现\n引用博客：[优先队列原理与实现](https://www.cnblogs.com/luoxn28/p/5616101.html)\n推荐结合另一篇博客: [【STL学习】优先级队列Priority Queue详解与C++编程实现](https://blog.csdn.net/xiajun07061225/article/details/8556786)\n可以看这两篇博客了解插入和删除的原理，第一篇博客有图比较清楚\n\n```\npackage priorityheap;\n\nimport java.util.Arrays;\n\n/**\n * 优先队列类（最大优先队列）\n */\npublic class PriorityHeap {\n\n    // ------------------------------ Instance Variables\n\n    private int[] arr;\n    private int size;\n\n    // ------------------------------ Constructors\n\n    /**\n     * 优先队列数组默认大小为64\n     */\n    public PriorityHeap() {\n        this(64);\n    }\n\n    public PriorityHeap(int initSize) {\n        if (initSize <= 0) {\n            initSize = 64;\n        }\n        this.arr = new int[initSize];\n        this.size = 0;\n    }\n\n    // ------------------------------ Public methods\n\n    public int max() {\n        return this.arr[0];\n    }\n\n    public int maxAndRemove() {\n        int t = max();\n\n        this.arr[0] = this.arr[--size];\n        sink(0, this.arr[0]);\n        return t;\n    }\n    public void add(int data) {\n        resize(1);\n        this.arr[size++] = data;\n        pop(size - 1, data);\n    }\n\n    // ------------------------------ Private methods\n\n    /**\n     * key下沉方法\n     */\n    private void sink(int i, int key) {\n        while (2 * i <= this.size - 1) {\n            int child = 2 * i;\n            if (child < this.size - 1 && this.arr[child] < this.arr[child + 1]) {\n                child++;\n            }\n            if (this.arr[i] >= this.arr[child]) {\n                break;\n            }\n\n            swap(i, child);\n            i = child;\n        }\n    }\n\n    /**\n     * key上浮方法\n     */\n    private void pop(int i, int key) {\n        while (i > 0) {\n            int parent = i / 2;\n            if (this.arr[i] <= this.arr[parent]) {\n                break;\n            }\n            swap(i, parent);\n            i = parent;\n        }\n    }\n\n    /**\n     * 重新调整数组大小\n     */\n    private void resize(int increaseSize) {\n        if ((this.size + increaseSize) > this.arr.length) {\n            int newSize = (this.size + increaseSize) > 2 * this.arr.length ? (this.size + increaseSize) : 2 * this.arr.length;\n            int[] t = this.arr;\n\n            this.arr = Arrays.copyOf(t, newSize);\n        }\n    }\n\n    /**\n     * Swaps arr[a] with arr[b].\n     */\n    private void swap(int a, int b) {\n        int t = this.arr[a];\n        this.arr[a] = this.arr[b];\n        this.arr[b] = t;\n    }\n}\n```\n\n---------\n","slug":"C-优先级队列","published":1,"updated":"2019-07-25T17:42:11.910Z","layout":"post","photos":[],"link":"","_id":"ck2424lkj000flksb57dr8b7i","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>写LeetCode的时候学了优先级队列，这里总结一下STL中优先级队列的使用和实现</p></div><a id=\"more\"></a><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>优先级队列也是队列的一种，FIFO结构，但是和普通的队列不同的是有一个优先级的权重</p><p>优先级队列有两种，一种是最小优先队列，值小的优先级越大，另一种是最大优先队列，值大的优先级越大</p><p>头文件： “queue.h”, “functional.h”</p><p>插入和删除操作复杂度都是<script type=\"math/tex\">O(lgn)</script></p><h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>构造函数声明如下：<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::priority_queue&lt;T&gt; pq;</span><br><span class=\"line\">std::priority_queue&lt;T, std::vector&lt;T&gt;, cmp&gt; pq;</span><br></pre></td></tr></table></figure><p></p><p><strong>第一种构造函数：</strong></p><ul><li>传入一个基本类型或者自定义类，自定义类要重载<script type=\"math/tex\"><</script>符号</li></ul><p><strong>第二种构造函数：</strong><br>参数介绍：</p><ol><li>是队列中元素的种类，可以是自定义的也可以是基本类型，默认是int</li><li>第二个是容纳优先级队列的容器，只需要知道默认是vector就好，使用的时候也是用vector</li><li>这个是最重要的参数，支持一个比较函数，默认是less，队列是最大优先队列。</li></ol><p>第三个参数有三种情况介绍：</p><ol><li>自定义比较结构，使用结构体，<strong>注意返回值！！</strong>，最小优先队列是大于</li><li>使用默认的类型时用less()或者greater()</li><li>使用自定义类的时候重载<script type=\"math/tex\"><</script>符号</li></ol><h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><ol><li>q.empty(): 如果队列为空，则返回true，否则返回false</li><li>q.size(): 返回队列中元素的个数</li><li>q.pop(): 删除队首元素，但不返回其值</li><li>q.top(): 返回具有最高优先级的元素值，最大优先队列找最大的元素，最小优先队列找最小的，但不删除该元素</li><li>q.push(item): 在基于优先级的适当位置插入新元素</li></ol><h3 id=\"使用样例\"><a href=\"#使用样例\" class=\"headerlink\" title=\"使用样例\"></a>使用样例</h3><p>注意这不是一个完整的C++代码</p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//包含头文件并使用std命名空间</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第一种构造函数，采用默认优先级构造队列</span></span><br><span class=\"line\">priority_queue&lt;<span class=\"keyword\">int</span>&gt;que;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二种构造函数，这里使用基本的int类型，如果看其他类型，请看LeetCode 23题代码</span></span><br><span class=\"line\"><span class=\"comment\">//自定义比较结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp1</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span> <span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;a,<span class=\"keyword\">int</span> &amp;b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a&gt;b;<span class=\"comment\">//最小值优先</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">priority_queue&lt;<span class=\"keyword\">int</span>,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;,cmp1&gt;que1;<span class=\"comment\">//最小值优先</span></span><br><span class=\"line\">priority_queue&lt;<span class=\"keyword\">int</span>,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;,greater&lt;<span class=\"keyword\">int</span>&gt; &gt;que3;<span class=\"comment\">//注意“&gt;&gt;”会被认为错误，greater在functional头文件中</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//自定义数据结构并重载小于操作符</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">number1</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> number1 &amp;a) <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x&gt;a.x;<span class=\"comment\">//最小值优先</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">priority_queue&lt;number1&gt;que5; <span class=\"comment\">//最小优先级队列</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"采用默认优先关系:/n(priority_queue&lt;int&gt;que;)/n\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"Queue 0:/n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%3d\"</span>,que.top());</span><br><span class=\"line\">    que.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>引用博客：<a href=\"https://www.cnblogs.com/luoxn28/p/5616101.html\" target=\"_blank\" rel=\"noopener\">优先队列原理与实现</a><br>推荐结合另一篇博客: <a href=\"https://blog.csdn.net/xiajun07061225/article/details/8556786\" target=\"_blank\" rel=\"noopener\">【STL学习】优先级队列Priority Queue详解与C++编程实现</a><br>可以看这两篇博客了解插入和删除的原理，第一篇博客有图比较清楚</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package priorityheap;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 优先队列类（最大优先队列）</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class PriorityHeap &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ------------------------------ Instance Variables</span><br><span class=\"line\"></span><br><span class=\"line\">    private int[] arr;</span><br><span class=\"line\">    private int size;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ------------------------------ Constructors</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 优先队列数组默认大小为64</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public PriorityHeap() &#123;</span><br><span class=\"line\">        this(64);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public PriorityHeap(int initSize) &#123;</span><br><span class=\"line\">        if (initSize &lt;= 0) &#123;</span><br><span class=\"line\">            initSize = 64;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        this.arr = new int[initSize];</span><br><span class=\"line\">        this.size = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ------------------------------ Public methods</span><br><span class=\"line\"></span><br><span class=\"line\">    public int max() &#123;</span><br><span class=\"line\">        return this.arr[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int maxAndRemove() &#123;</span><br><span class=\"line\">        int t = max();</span><br><span class=\"line\"></span><br><span class=\"line\">        this.arr[0] = this.arr[--size];</span><br><span class=\"line\">        sink(0, this.arr[0]);</span><br><span class=\"line\">        return t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void add(int data) &#123;</span><br><span class=\"line\">        resize(1);</span><br><span class=\"line\">        this.arr[size++] = data;</span><br><span class=\"line\">        pop(size - 1, data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ------------------------------ Private methods</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * key下沉方法</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void sink(int i, int key) &#123;</span><br><span class=\"line\">        while (2 * i &lt;= this.size - 1) &#123;</span><br><span class=\"line\">            int child = 2 * i;</span><br><span class=\"line\">            if (child &lt; this.size - 1 &amp;&amp; this.arr[child] &lt; this.arr[child + 1]) &#123;</span><br><span class=\"line\">                child++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (this.arr[i] &gt;= this.arr[child]) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            swap(i, child);</span><br><span class=\"line\">            i = child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * key上浮方法</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void pop(int i, int key) &#123;</span><br><span class=\"line\">        while (i &gt; 0) &#123;</span><br><span class=\"line\">            int parent = i / 2;</span><br><span class=\"line\">            if (this.arr[i] &lt;= this.arr[parent]) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            swap(i, parent);</span><br><span class=\"line\">            i = parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 重新调整数组大小</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void resize(int increaseSize) &#123;</span><br><span class=\"line\">        if ((this.size + increaseSize) &gt; this.arr.length) &#123;</span><br><span class=\"line\">            int newSize = (this.size + increaseSize) &gt; 2 * this.arr.length ? (this.size + increaseSize) : 2 * this.arr.length;</span><br><span class=\"line\">            int[] t = this.arr;</span><br><span class=\"line\"></span><br><span class=\"line\">            this.arr = Arrays.copyOf(t, newSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Swaps arr[a] with arr[b].</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void swap(int a, int b) &#123;</span><br><span class=\"line\">        int t = this.arr[a];</span><br><span class=\"line\">        this.arr[a] = this.arr[b];</span><br><span class=\"line\">        this.arr[b] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>写LeetCode的时候学了优先级队列，这里总结一下STL中优先级队列的使用和实现</p></div>","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>优先级队列也是队列的一种，FIFO结构，但是和普通的队列不同的是有一个优先级的权重</p><p>优先级队列有两种，一种是最小优先队列，值小的优先级越大，另一种是最大优先队列，值大的优先级越大</p><p>头文件： “queue.h”, “functional.h”</p><p>插入和删除操作复杂度都是<script type=\"math/tex\">O(lgn)</script></p><h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>构造函数声明如下：<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::priority_queue&lt;T&gt; pq;</span><br><span class=\"line\">std::priority_queue&lt;T, std::vector&lt;T&gt;, cmp&gt; pq;</span><br></pre></td></tr></table></figure><p></p><p><strong>第一种构造函数：</strong></p><ul><li>传入一个基本类型或者自定义类，自定义类要重载<script type=\"math/tex\"><</script>符号</li></ul><p><strong>第二种构造函数：</strong><br>参数介绍：</p><ol><li>是队列中元素的种类，可以是自定义的也可以是基本类型，默认是int</li><li>第二个是容纳优先级队列的容器，只需要知道默认是vector就好，使用的时候也是用vector</li><li>这个是最重要的参数，支持一个比较函数，默认是less，队列是最大优先队列。</li></ol><p>第三个参数有三种情况介绍：</p><ol><li>自定义比较结构，使用结构体，<strong>注意返回值！！</strong>，最小优先队列是大于</li><li>使用默认的类型时用less()或者greater()</li><li>使用自定义类的时候重载<script type=\"math/tex\"><</script>符号</li></ol><h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><ol><li>q.empty(): 如果队列为空，则返回true，否则返回false</li><li>q.size(): 返回队列中元素的个数</li><li>q.pop(): 删除队首元素，但不返回其值</li><li>q.top(): 返回具有最高优先级的元素值，最大优先队列找最大的元素，最小优先队列找最小的，但不删除该元素</li><li>q.push(item): 在基于优先级的适当位置插入新元素</li></ol><h3 id=\"使用样例\"><a href=\"#使用样例\" class=\"headerlink\" title=\"使用样例\"></a>使用样例</h3><p>注意这不是一个完整的C++代码</p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//包含头文件并使用std命名空间</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第一种构造函数，采用默认优先级构造队列</span></span><br><span class=\"line\">priority_queue&lt;<span class=\"keyword\">int</span>&gt;que;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二种构造函数，这里使用基本的int类型，如果看其他类型，请看LeetCode 23题代码</span></span><br><span class=\"line\"><span class=\"comment\">//自定义比较结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp1</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span> <span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;a,<span class=\"keyword\">int</span> &amp;b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a&gt;b;<span class=\"comment\">//最小值优先</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">priority_queue&lt;<span class=\"keyword\">int</span>,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;,cmp1&gt;que1;<span class=\"comment\">//最小值优先</span></span><br><span class=\"line\">priority_queue&lt;<span class=\"keyword\">int</span>,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;,greater&lt;<span class=\"keyword\">int</span>&gt; &gt;que3;<span class=\"comment\">//注意“&gt;&gt;”会被认为错误，greater在functional头文件中</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//自定义数据结构并重载小于操作符</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">number1</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> number1 &amp;a) <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x&gt;a.x;<span class=\"comment\">//最小值优先</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">priority_queue&lt;number1&gt;que5; <span class=\"comment\">//最小优先级队列</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"采用默认优先关系:/n(priority_queue&lt;int&gt;que;)/n\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"Queue 0:/n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%3d\"</span>,que.top());</span><br><span class=\"line\">    que.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>引用博客：<a href=\"https://www.cnblogs.com/luoxn28/p/5616101.html\" target=\"_blank\" rel=\"noopener\">优先队列原理与实现</a><br>推荐结合另一篇博客: <a href=\"https://blog.csdn.net/xiajun07061225/article/details/8556786\" target=\"_blank\" rel=\"noopener\">【STL学习】优先级队列Priority Queue详解与C++编程实现</a><br>可以看这两篇博客了解插入和删除的原理，第一篇博客有图比较清楚</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package priorityheap;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 优先队列类（最大优先队列）</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class PriorityHeap &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ------------------------------ Instance Variables</span><br><span class=\"line\"></span><br><span class=\"line\">    private int[] arr;</span><br><span class=\"line\">    private int size;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ------------------------------ Constructors</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 优先队列数组默认大小为64</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public PriorityHeap() &#123;</span><br><span class=\"line\">        this(64);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public PriorityHeap(int initSize) &#123;</span><br><span class=\"line\">        if (initSize &lt;= 0) &#123;</span><br><span class=\"line\">            initSize = 64;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        this.arr = new int[initSize];</span><br><span class=\"line\">        this.size = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ------------------------------ Public methods</span><br><span class=\"line\"></span><br><span class=\"line\">    public int max() &#123;</span><br><span class=\"line\">        return this.arr[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int maxAndRemove() &#123;</span><br><span class=\"line\">        int t = max();</span><br><span class=\"line\"></span><br><span class=\"line\">        this.arr[0] = this.arr[--size];</span><br><span class=\"line\">        sink(0, this.arr[0]);</span><br><span class=\"line\">        return t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void add(int data) &#123;</span><br><span class=\"line\">        resize(1);</span><br><span class=\"line\">        this.arr[size++] = data;</span><br><span class=\"line\">        pop(size - 1, data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ------------------------------ Private methods</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * key下沉方法</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void sink(int i, int key) &#123;</span><br><span class=\"line\">        while (2 * i &lt;= this.size - 1) &#123;</span><br><span class=\"line\">            int child = 2 * i;</span><br><span class=\"line\">            if (child &lt; this.size - 1 &amp;&amp; this.arr[child] &lt; this.arr[child + 1]) &#123;</span><br><span class=\"line\">                child++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (this.arr[i] &gt;= this.arr[child]) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            swap(i, child);</span><br><span class=\"line\">            i = child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * key上浮方法</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void pop(int i, int key) &#123;</span><br><span class=\"line\">        while (i &gt; 0) &#123;</span><br><span class=\"line\">            int parent = i / 2;</span><br><span class=\"line\">            if (this.arr[i] &lt;= this.arr[parent]) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            swap(i, parent);</span><br><span class=\"line\">            i = parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 重新调整数组大小</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void resize(int increaseSize) &#123;</span><br><span class=\"line\">        if ((this.size + increaseSize) &gt; this.arr.length) &#123;</span><br><span class=\"line\">            int newSize = (this.size + increaseSize) &gt; 2 * this.arr.length ? (this.size + increaseSize) : 2 * this.arr.length;</span><br><span class=\"line\">            int[] t = this.arr;</span><br><span class=\"line\"></span><br><span class=\"line\">            this.arr = Arrays.copyOf(t, newSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Swaps arr[a] with arr[b].</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void swap(int a, int b) &#123;</span><br><span class=\"line\">        int t = this.arr[a];</span><br><span class=\"line\">        this.arr[a] = this.arr[b];</span><br><span class=\"line\">        this.arr[b] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"Markdown学习笔记","comments":1,"mathjax":false,"date":"2017-08-02T07:52:13.000Z","urlname":"markdown-notes","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n博客初建，初学[Markdown](https://en.wikipedia.org/wiki/Markdowna)，写个学习笔记，供自己以后写文参考。\n<!--more-->\n\n# 关于Markdown\n\n## 宗旨和兼容性\n\n[Markdown](https://en.wikipedia.org/wiki/Markdowna)目标是实现易读易写，使用其编写的文件可以直接以纯文本发布。  \n[Markdown](https://en.wikipedia.org/wiki/Markdowna)兼容[HTML](https://en.wikipedia.org/wiki/HTML)，语法目标是成为一种适用于网络的书写语言。  \n\n相比HTML，Markdown是一种书写的格式，而HTML更多是一种发布的格式。  \n在Markdown文件内可以直接用HTML书写，不用额外标注。\n\n[Markdown](https://en.wikipedia.org/wiki/Markdowna)兼容[HTML](https://en.wikipedia.org/wiki/HTML)，但是在[HTML](https://en.wikipedia.org/wiki/HTML)等区块元素，比如`<div>`,`<table>`,`<pre>`,`<p>`,等标签，必须在前后加上空行和其他内容隔开，还要求他们的开始和结尾标签，不能用制表符或者空格来缩进。\n\n在[HTML](https://en.wikipedia.org/wiki/HTML)区块标签内的[Markdown](https://en.wikipedia.org/wiki/Markdowna)格式语法不会被处理  \n但是在[HTML](https://en.wikipedia.org/wiki/HTML)区段标签内，[Markdown](https://en.wikipedia.org/wiki/Markdowna)语法是有效的。比如`<span>`,`<cite>`,`<del>`\n\n## 特殊字符转换\n\n在[HTML](https://en.wikipedia.org/wiki/HTML)中，< 和 & 想要显示字符原型需要用实体的形式，`&lt` 和\n`&amp`  \n而在[Markdown](https://en.wikipedia.org/wiki/Markdowna)中，则可以自由书写字符。\n\n**注** :在code范围内，< 和 & 都会一定被转换成HTML实体，因此可以更方便的写出HTML code\n\n# 区块元素\n\n## 段落和换行\n\n段落由连续文本行组成，且允许段落内用换行符强迫换行。\n\n如果想插入`<br />`，需要在插入处按入两个以上空格然后回车。  \n段落的前后要有一个以上空行，且普通段落不可以用空格或者制表符缩进。\n\n## 标题\n\n支持两种标题的语法，类Setext和atx形式\n\n### 类Setext\n\n类Setext用底线的形式，利用任意数量=（最高阶）和－（第二阶）\n\n**栗子** :  \n\n    This is an H1\n    ============\n    \n    This is an H2\n    -------------  \n  \n### Atx\n\nAtx形式则是在行首插入一到六个#,对应标题一到六阶  \n```\n# H1\n\n##  H2\n\n##### H5  \n```\n  \n可以选择闭合#，且结尾的#和开头不用一样  \n```\n# H1 #\n\n## H2 ##\n\n### H3  ###  \n```\n  \n## 区块引用\n\n在每行前面加上>,(可以偷个懒在整个段落的第一行加上>),并且区块引用可以嵌套，只要根据层次加上不同数量的>\n\n**栗子** :  \n``` \n> This is the fiest level of quoting \n>\n>> This is nested blokquote\n>\n> back to first level  \n```\n显示为:\n> This is the fiest level of quoting \n>\n>> This is nested blokquote\n>\n> back to first level  \n  \n在引用区块内也可以使用其他[Markdown](https://en.wikipedia.org/wiki/Markdowna)语法， **栗如**\n标题、列表、代码区块  \n\n    > ## 这是一个标题。\n    >\n    > 1.   这是第一行列表项。\n    > 2.   这是第二行列表项。\n    >\n    > 给出一些例子代码：\n    >\n    >     return shell_exec(\"echo $input | $markdown_script\");  \n显示为:\n> ## 这是一个标题。\n>\n> 1.   这是第一行列表项。\n> 2.   这是第二行列表项。\n>\n> 给出一些例子代码：\n>\n>     return shell_exec(\"echo $input | $markdown_script\");  \n  \n## 列表\n\n支持有序列表和无序列表两种\n\n### 无序列表\n\n无序列表使用 + - 作为列表标记，个人偏向－，因为不用按shift\n\n### 有序列表\n\n有序列表则使用数字接着一个英文句点:  \n\n    1.  First one\n    \n    2.  Second one  \n显示为:\n\n1.  First one\n\n2.  Second one  \n\n使用不同的数字不会有问题，但是看着不舒服，不推荐，还是顺序下来。  \n或者也可以只用一个数字。\n\n**栗如**  \n\n    1.  First one\n    \n    1.  Second one\n    \n    1.  THird one  \n  \n  \n列表通常在最左边，但是也可以缩进，最多三个空格，标记后面一定要接上至少一个空格或者制表符  \n如果列表间由空行，[Markdown](https://en.wikipedia.org/wiki/Markdowna)会用\\标签将内容裹起来\n\n**栗子** ：  \n    \n    *   Bird\n    \n    *   Magic  \n  \n会被转换成：  \n    \n    >    <ul>\n    \n    >    <li><p>Bird</p></li>\n    \n    >    <li><p>Magic</p></li>\n    \n    >    </ul>  \n\n显示为:\n*   Bird\n\n*   Magic  \n  \n列表可以包含多个段落，但是记得每个段落都要缩进哦\n\n如果放引用，>也要缩进  \n如果放代码区块，这个区块就要缩进两次  \n如果要在行首输入2017. 这种数字+句点+空白，可以在句点前面加反斜杠，即2017.\n\n## 代码区块\n\n终于到这啦，代码区块最简单了，只要简单的缩进4个空格或者一个tab,或者,```这个标识,\n\n**栗子** ：  \n* ____printf(\"hello world\")\n* <Tab>printf(\"hello world\") \n* \\```   \n  printf(\"hello world\")    \n  \\```   \n\n显示为:   \n\n    printf(\"hello world\")\n  \nmarkdown 会自动在代码区块外面加上\\，而且代码区块里面& < >会自动转成[HTML](https://en.wikipedia.org/wiki/HTML)实体，所以可以想怎么写code就怎么写\n\n## 表格\n\n表格对齐方式  \n   \n    1.  居左: :----\n    \n    2.  居中: :----: 或者　-----\n    \n    3.  居右: ----:  \n  \n## 分割线\n\n可以在一行中用三个以上的*，-，_ 来建立一个分割线。行内不可以用其他东西，可以在* -中间插入空格。  \n\n    * * *\n    \n    ****\n    \n    ---\n    \n    ___  \n\n显示为:\n* * *\n\n****\n\n---\n___  \n  \n# 区段元素\n\n## 链接\n\n支持行内式和参考式两种，但都是用[]标记链接文字\n\n### 行内式\n\n在方括号后面接一个()在里面写上网址就行，如果要加title,在后面用单引号、双引号或是括弧把title文字包起来就行\n\n**栗子** ：  \n\n    This is [an example](http://example.com/ \"Title\") inline link.\n    \n    [This link](http://example.net/) has no title attribute.  \n  \n  \n如果想要链接到同主机资源，用相对路径  \n\n    See my [About](/about/) page for details.  \n  \n### 参考式\n\n参考式是在后面加上另一个[],在里面写上标记  \n    \n    This is [an example][id] reference-style link.  \n  \n可以在方括号中间加空格。。。  \n最后在文件的任意处，可以是段尾，可以是文件尾，把标记的链接定义出来  \n\n    [id]: http://example.com/  \"Optional Title Here\"  \n  \n要注意的是[]后面有一个:,还有一个以上的空格，id这个标记是不区分大小写的！链接网址可以用<>包起来。\n\n### 隐式链接\n\n隐式链接标记功能可以让你省略号指定的链接标记，这种情况标记会被视为等同于链接文字。  \n隐式链接只要在链接文字后面加上一个空的[]\n\n**栗子** ：  \n    \n    [Google][]\n    \n    [Google]: http://google.com/  \n  \n参考式链接的优点是比较好读，可以将一些标记的元数据移到段落之外，可以是段尾文件尾，这样就可以不让文章的阅读感被打断\n\n## 强调\n\n如果你的* 和_ 两边都有空白，就只会被当成普通的* _\n\n## 代码\n\n如果要标记一小段行内代码，可以用反引号｀把它包起来  \n    \n    Use the `printf()` function.  \n显示为:\n\nUse the `printf()` function.  \n\n如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：  \n\n    ``There is a literal backtick (`) here.``  \n显示为:\n\n``There is a literal backtick (`) here.``  \n  \n代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，酱紫就可以在区段开始就加入一个反引号  \n\n    A single backtick in a code span: `` ` ``\n    \n    A backtick-delimited string in a code span: `` `foo` ``  \n\n显示为:\n\nA single backtick in a code span: `` ` ``\n\nA backtick-delimited string in a code span: `` `foo` ``  \n\n  \n## 图片\n\n使用行内式和参考式\n\n### 行内式\n    \n    ![Alt text](/path/to/img.jpg)\n    \n    ![Alt text](/path/to/img.jpg \"Optional title\")  \n  \n### 参考式\n\n    ![Alt text][id]\n    \n    [id]: url/to/image  \"Optional title attribute\"  \n  \n这部分和链接是差不多的,但如果想要指定图片的宽高，可以使用普通的`<img>`标签.\n\n# 其他\n\n## 自动链接\n\n用<>包起来的，都会被自动转成链接  \n    \n    <http://example.com/>  \n  \n会被转成  \n\n    <a href=\"http://example.com/\">http://example.com/</a>  \n  \n## 反斜杠\n\n可以用\\插入一些在语法中有含义的符号  \n    \n    \\   反斜线      `   反引号\n    \n    `*   星号       _   底线`\n    \n    {}  花括号      []  方括号\n    \n    ()  括弧        #   井字号\n    \n    \\+   加号       \\-   减号\n    \n    .   英文句点    !   惊叹号  \n  \n上面就是我学[Markdown][]的一些笔记，可能会有缺少的，有看到的可以指正～。\n\n","source":"_posts/Markdown学习笔记.md","raw":"---\ntitle: Markdown学习笔记\ncomments: true\nmathjax: false\ndate: 2017-08-02 15:52:13\ntags: [Learning,Markdown,Notes]\ncategories: Notes\nurlname: markdown-notes\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n博客初建，初学[Markdown](https://en.wikipedia.org/wiki/Markdowna)，写个学习笔记，供自己以后写文参考。\n<!--more-->\n\n# 关于Markdown\n\n## 宗旨和兼容性\n\n[Markdown](https://en.wikipedia.org/wiki/Markdowna)目标是实现易读易写，使用其编写的文件可以直接以纯文本发布。  \n[Markdown](https://en.wikipedia.org/wiki/Markdowna)兼容[HTML](https://en.wikipedia.org/wiki/HTML)，语法目标是成为一种适用于网络的书写语言。  \n\n相比HTML，Markdown是一种书写的格式，而HTML更多是一种发布的格式。  \n在Markdown文件内可以直接用HTML书写，不用额外标注。\n\n[Markdown](https://en.wikipedia.org/wiki/Markdowna)兼容[HTML](https://en.wikipedia.org/wiki/HTML)，但是在[HTML](https://en.wikipedia.org/wiki/HTML)等区块元素，比如`<div>`,`<table>`,`<pre>`,`<p>`,等标签，必须在前后加上空行和其他内容隔开，还要求他们的开始和结尾标签，不能用制表符或者空格来缩进。\n\n在[HTML](https://en.wikipedia.org/wiki/HTML)区块标签内的[Markdown](https://en.wikipedia.org/wiki/Markdowna)格式语法不会被处理  \n但是在[HTML](https://en.wikipedia.org/wiki/HTML)区段标签内，[Markdown](https://en.wikipedia.org/wiki/Markdowna)语法是有效的。比如`<span>`,`<cite>`,`<del>`\n\n## 特殊字符转换\n\n在[HTML](https://en.wikipedia.org/wiki/HTML)中，< 和 & 想要显示字符原型需要用实体的形式，`&lt` 和\n`&amp`  \n而在[Markdown](https://en.wikipedia.org/wiki/Markdowna)中，则可以自由书写字符。\n\n**注** :在code范围内，< 和 & 都会一定被转换成HTML实体，因此可以更方便的写出HTML code\n\n# 区块元素\n\n## 段落和换行\n\n段落由连续文本行组成，且允许段落内用换行符强迫换行。\n\n如果想插入`<br />`，需要在插入处按入两个以上空格然后回车。  \n段落的前后要有一个以上空行，且普通段落不可以用空格或者制表符缩进。\n\n## 标题\n\n支持两种标题的语法，类Setext和atx形式\n\n### 类Setext\n\n类Setext用底线的形式，利用任意数量=（最高阶）和－（第二阶）\n\n**栗子** :  \n\n    This is an H1\n    ============\n    \n    This is an H2\n    -------------  \n  \n### Atx\n\nAtx形式则是在行首插入一到六个#,对应标题一到六阶  \n```\n# H1\n\n##  H2\n\n##### H5  \n```\n  \n可以选择闭合#，且结尾的#和开头不用一样  \n```\n# H1 #\n\n## H2 ##\n\n### H3  ###  \n```\n  \n## 区块引用\n\n在每行前面加上>,(可以偷个懒在整个段落的第一行加上>),并且区块引用可以嵌套，只要根据层次加上不同数量的>\n\n**栗子** :  \n``` \n> This is the fiest level of quoting \n>\n>> This is nested blokquote\n>\n> back to first level  \n```\n显示为:\n> This is the fiest level of quoting \n>\n>> This is nested blokquote\n>\n> back to first level  \n  \n在引用区块内也可以使用其他[Markdown](https://en.wikipedia.org/wiki/Markdowna)语法， **栗如**\n标题、列表、代码区块  \n\n    > ## 这是一个标题。\n    >\n    > 1.   这是第一行列表项。\n    > 2.   这是第二行列表项。\n    >\n    > 给出一些例子代码：\n    >\n    >     return shell_exec(\"echo $input | $markdown_script\");  \n显示为:\n> ## 这是一个标题。\n>\n> 1.   这是第一行列表项。\n> 2.   这是第二行列表项。\n>\n> 给出一些例子代码：\n>\n>     return shell_exec(\"echo $input | $markdown_script\");  \n  \n## 列表\n\n支持有序列表和无序列表两种\n\n### 无序列表\n\n无序列表使用 + - 作为列表标记，个人偏向－，因为不用按shift\n\n### 有序列表\n\n有序列表则使用数字接着一个英文句点:  \n\n    1.  First one\n    \n    2.  Second one  \n显示为:\n\n1.  First one\n\n2.  Second one  \n\n使用不同的数字不会有问题，但是看着不舒服，不推荐，还是顺序下来。  \n或者也可以只用一个数字。\n\n**栗如**  \n\n    1.  First one\n    \n    1.  Second one\n    \n    1.  THird one  \n  \n  \n列表通常在最左边，但是也可以缩进，最多三个空格，标记后面一定要接上至少一个空格或者制表符  \n如果列表间由空行，[Markdown](https://en.wikipedia.org/wiki/Markdowna)会用\\标签将内容裹起来\n\n**栗子** ：  \n    \n    *   Bird\n    \n    *   Magic  \n  \n会被转换成：  \n    \n    >    <ul>\n    \n    >    <li><p>Bird</p></li>\n    \n    >    <li><p>Magic</p></li>\n    \n    >    </ul>  \n\n显示为:\n*   Bird\n\n*   Magic  \n  \n列表可以包含多个段落，但是记得每个段落都要缩进哦\n\n如果放引用，>也要缩进  \n如果放代码区块，这个区块就要缩进两次  \n如果要在行首输入2017. 这种数字+句点+空白，可以在句点前面加反斜杠，即2017.\n\n## 代码区块\n\n终于到这啦，代码区块最简单了，只要简单的缩进4个空格或者一个tab,或者,```这个标识,\n\n**栗子** ：  \n* ____printf(\"hello world\")\n* <Tab>printf(\"hello world\") \n* \\```   \n  printf(\"hello world\")    \n  \\```   \n\n显示为:   \n\n    printf(\"hello world\")\n  \nmarkdown 会自动在代码区块外面加上\\，而且代码区块里面& < >会自动转成[HTML](https://en.wikipedia.org/wiki/HTML)实体，所以可以想怎么写code就怎么写\n\n## 表格\n\n表格对齐方式  \n   \n    1.  居左: :----\n    \n    2.  居中: :----: 或者　-----\n    \n    3.  居右: ----:  \n  \n## 分割线\n\n可以在一行中用三个以上的*，-，_ 来建立一个分割线。行内不可以用其他东西，可以在* -中间插入空格。  \n\n    * * *\n    \n    ****\n    \n    ---\n    \n    ___  \n\n显示为:\n* * *\n\n****\n\n---\n___  \n  \n# 区段元素\n\n## 链接\n\n支持行内式和参考式两种，但都是用[]标记链接文字\n\n### 行内式\n\n在方括号后面接一个()在里面写上网址就行，如果要加title,在后面用单引号、双引号或是括弧把title文字包起来就行\n\n**栗子** ：  \n\n    This is [an example](http://example.com/ \"Title\") inline link.\n    \n    [This link](http://example.net/) has no title attribute.  \n  \n  \n如果想要链接到同主机资源，用相对路径  \n\n    See my [About](/about/) page for details.  \n  \n### 参考式\n\n参考式是在后面加上另一个[],在里面写上标记  \n    \n    This is [an example][id] reference-style link.  \n  \n可以在方括号中间加空格。。。  \n最后在文件的任意处，可以是段尾，可以是文件尾，把标记的链接定义出来  \n\n    [id]: http://example.com/  \"Optional Title Here\"  \n  \n要注意的是[]后面有一个:,还有一个以上的空格，id这个标记是不区分大小写的！链接网址可以用<>包起来。\n\n### 隐式链接\n\n隐式链接标记功能可以让你省略号指定的链接标记，这种情况标记会被视为等同于链接文字。  \n隐式链接只要在链接文字后面加上一个空的[]\n\n**栗子** ：  \n    \n    [Google][]\n    \n    [Google]: http://google.com/  \n  \n参考式链接的优点是比较好读，可以将一些标记的元数据移到段落之外，可以是段尾文件尾，这样就可以不让文章的阅读感被打断\n\n## 强调\n\n如果你的* 和_ 两边都有空白，就只会被当成普通的* _\n\n## 代码\n\n如果要标记一小段行内代码，可以用反引号｀把它包起来  \n    \n    Use the `printf()` function.  \n显示为:\n\nUse the `printf()` function.  \n\n如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：  \n\n    ``There is a literal backtick (`) here.``  \n显示为:\n\n``There is a literal backtick (`) here.``  \n  \n代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，酱紫就可以在区段开始就加入一个反引号  \n\n    A single backtick in a code span: `` ` ``\n    \n    A backtick-delimited string in a code span: `` `foo` ``  \n\n显示为:\n\nA single backtick in a code span: `` ` ``\n\nA backtick-delimited string in a code span: `` `foo` ``  \n\n  \n## 图片\n\n使用行内式和参考式\n\n### 行内式\n    \n    ![Alt text](/path/to/img.jpg)\n    \n    ![Alt text](/path/to/img.jpg \"Optional title\")  \n  \n### 参考式\n\n    ![Alt text][id]\n    \n    [id]: url/to/image  \"Optional title attribute\"  \n  \n这部分和链接是差不多的,但如果想要指定图片的宽高，可以使用普通的`<img>`标签.\n\n# 其他\n\n## 自动链接\n\n用<>包起来的，都会被自动转成链接  \n    \n    <http://example.com/>  \n  \n会被转成  \n\n    <a href=\"http://example.com/\">http://example.com/</a>  \n  \n## 反斜杠\n\n可以用\\插入一些在语法中有含义的符号  \n    \n    \\   反斜线      `   反引号\n    \n    `*   星号       _   底线`\n    \n    {}  花括号      []  方括号\n    \n    ()  括弧        #   井字号\n    \n    \\+   加号       \\-   减号\n    \n    .   英文句点    !   惊叹号  \n  \n上面就是我学[Markdown][]的一些笔记，可能会有缺少的，有看到的可以指正～。\n\n","slug":"Markdown学习笔记","published":1,"updated":"2019-07-25T18:31:19.752Z","layout":"post","photos":[],"link":"","_id":"ck2424lkk000glksbhru1peui","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>博客初建，初学<a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>，写个学习笔记，供自己以后写文参考。<br><a id=\"more\"></a></p><h1 id=\"关于Markdown\"><a href=\"#关于Markdown\" class=\"headerlink\" title=\"关于Markdown\"></a>关于Markdown</h1><h2 id=\"宗旨和兼容性\"><a href=\"#宗旨和兼容性\" class=\"headerlink\" title=\"宗旨和兼容性\"></a>宗旨和兼容性</h2><p><a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>目标是实现易读易写，使用其编写的文件可以直接以纯文本发布。<br><a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>兼容<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>，语法目标是成为一种适用于网络的书写语言。</p><p>相比HTML，Markdown是一种书写的格式，而HTML更多是一种发布的格式。<br>在Markdown文件内可以直接用HTML书写，不用额外标注。</p><p><a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>兼容<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>，但是在<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>等区块元素，比如<code>&lt;div&gt;</code>,<code>&lt;table&gt;</code>,<code>&lt;pre&gt;</code>,<code>&lt;p&gt;</code>,等标签，必须在前后加上空行和其他内容隔开，还要求他们的开始和结尾标签，不能用制表符或者空格来缩进。</p><p>在<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>区块标签内的<a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>格式语法不会被处理<br>但是在<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>区段标签内，<a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>语法是有效的。比如<code>&lt;span&gt;</code>,<code>&lt;cite&gt;</code>,<code>&lt;del&gt;</code></p><h2 id=\"特殊字符转换\"><a href=\"#特殊字符转换\" class=\"headerlink\" title=\"特殊字符转换\"></a>特殊字符转换</h2><p>在<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>中，&lt; 和 &amp; 想要显示字符原型需要用实体的形式，<code>&amp;lt</code> 和<br><code>&amp;amp</code><br>而在<a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>中，则可以自由书写字符。</p><p><strong>注</strong> :在code范围内，&lt; 和 &amp; 都会一定被转换成HTML实体，因此可以更方便的写出HTML code</p><h1 id=\"区块元素\"><a href=\"#区块元素\" class=\"headerlink\" title=\"区块元素\"></a>区块元素</h1><h2 id=\"段落和换行\"><a href=\"#段落和换行\" class=\"headerlink\" title=\"段落和换行\"></a>段落和换行</h2><p>段落由连续文本行组成，且允许段落内用换行符强迫换行。</p><p>如果想插入<code>&lt;br /&gt;</code>，需要在插入处按入两个以上空格然后回车。<br>段落的前后要有一个以上空行，且普通段落不可以用空格或者制表符缩进。</p><h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>支持两种标题的语法，类Setext和atx形式</p><h3 id=\"类Setext\"><a href=\"#类Setext\" class=\"headerlink\" title=\"类Setext\"></a>类Setext</h3><p>类Setext用底线的形式，利用任意数量=（最高阶）和－（第二阶）</p><p><strong>栗子</strong> :</p><pre><code>This is an H1\n============\n\nThis is an H2\n-------------  \n</code></pre><h3 id=\"Atx\"><a href=\"#Atx\" class=\"headerlink\" title=\"Atx\"></a>Atx</h3><p>Atx形式则是在行首插入一到六个#,对应标题一到六阶<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># H1</span><br><span class=\"line\"></span><br><span class=\"line\">##  H2</span><br><span class=\"line\"></span><br><span class=\"line\">##### H5</span><br></pre></td></tr></table></figure><p></p><p>可以选择闭合#，且结尾的#和开头不用一样<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># H1 #</span><br><span class=\"line\"></span><br><span class=\"line\">## H2 ##</span><br><span class=\"line\"></span><br><span class=\"line\">### H3  ###</span><br></pre></td></tr></table></figure><p></p><h2 id=\"区块引用\"><a href=\"#区块引用\" class=\"headerlink\" title=\"区块引用\"></a>区块引用</h2><p>在每行前面加上&gt;,(可以偷个懒在整个段落的第一行加上&gt;),并且区块引用可以嵌套，只要根据层次加上不同数量的&gt;</p><p><strong>栗子</strong> :<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is the fiest level of quoting </span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;&gt; This is nested blokquote</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; back to first level</span><br></pre></td></tr></table></figure><p></p><p>显示为:</p><blockquote><p>This is the fiest level of quoting</p><blockquote><p>This is nested blokquote</p></blockquote><p>back to first level</p></blockquote><p>在引用区块内也可以使用其他<a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>语法， <strong>栗如</strong><br>标题、列表、代码区块</p><pre><code>&gt; ## 这是一个标题。\n&gt;\n&gt; 1.   这是第一行列表项。\n&gt; 2.   这是第二行列表项。\n&gt;\n&gt; 给出一些例子代码：\n&gt;\n&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);  \n</code></pre><p>显示为:</p><blockquote><h2 id=\"这是一个标题。\"><a href=\"#这是一个标题。\" class=\"headerlink\" title=\"这是一个标题。\"></a>这是一个标题。</h2><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);  \n</code></pre></blockquote><h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><p>支持有序列表和无序列表两种</p><h3 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h3><p>无序列表使用 + - 作为列表标记，个人偏向－，因为不用按shift</p><h3 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h3><p>有序列表则使用数字接着一个英文句点:</p><pre><code>1.  First one\n\n2.  Second one  \n</code></pre><p>显示为:</p><ol><li><p>First one</p></li><li><p>Second one</p></li></ol><p>使用不同的数字不会有问题，但是看着不舒服，不推荐，还是顺序下来。<br>或者也可以只用一个数字。</p><p><strong>栗如</strong></p><pre><code>1.  First one\n\n1.  Second one\n\n1.  THird one  \n</code></pre><p>列表通常在最左边，但是也可以缩进，最多三个空格，标记后面一定要接上至少一个空格或者制表符<br>如果列表间由空行，<a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>会用\\标签将内容裹起来</p><p><strong>栗子</strong> ：</p><pre><code>*   Bird\n\n*   Magic  \n</code></pre><p>会被转换成：</p><pre><code>&gt;    &lt;ul&gt;\n\n&gt;    &lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;\n\n&gt;    &lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;\n\n&gt;    &lt;/ul&gt;  \n</code></pre><p>显示为:</p><ul><li><p>Bird</p></li><li><p>Magic</p></li></ul><p>列表可以包含多个段落，但是记得每个段落都要缩进哦</p><p>如果放引用，&gt;也要缩进<br>如果放代码区块，这个区块就要缩进两次<br>如果要在行首输入2017. 这种数字+句点+空白，可以在句点前面加反斜杠，即2017.</p><h2 id=\"代码区块\"><a href=\"#代码区块\" class=\"headerlink\" title=\"代码区块\"></a>代码区块</h2><p>终于到这啦，代码区块最简单了，只要简单的缩进4个空格或者一个tab,或者,```这个标识,</p><p><strong>栗子</strong> ：</p><ul><li>____printf(“hello world”)</li><li><tab>printf(“hello world”)</tab></li><li>```<br>printf(“hello world”)<br>```</li></ul><p>显示为:</p><pre><code>printf(&quot;hello world&quot;)\n</code></pre><p>markdown 会自动在代码区块外面加上\\，而且代码区块里面&amp; &lt; &gt;会自动转成<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>实体，所以可以想怎么写code就怎么写</p><h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>表格对齐方式</p><pre><code>1.  居左: :----\n\n2.  居中: :----: 或者　-----\n\n3.  居右: ----:  \n</code></pre><h2 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h2><p>可以在一行中用三个以上的<em>，-，_ 来建立一个分割线。行内不可以用其他东西，可以在</em> -中间插入空格。</p><pre><code>* * *\n\n****\n\n---\n\n___  \n</code></pre><p>显示为:</p><hr><hr><hr><hr><h1 id=\"区段元素\"><a href=\"#区段元素\" class=\"headerlink\" title=\"区段元素\"></a>区段元素</h1><h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>支持行内式和参考式两种，但都是用[]标记链接文字</p><h3 id=\"行内式\"><a href=\"#行内式\" class=\"headerlink\" title=\"行内式\"></a>行内式</h3><p>在方括号后面接一个()在里面写上网址就行，如果要加title,在后面用单引号、双引号或是括弧把title文字包起来就行</p><p><strong>栗子</strong> ：</p><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.\n\n[This link](http://example.net/) has no title attribute.  \n</code></pre><p>如果想要链接到同主机资源，用相对路径</p><pre><code>See my [About](/about/) page for details.  \n</code></pre><h3 id=\"参考式\"><a href=\"#参考式\" class=\"headerlink\" title=\"参考式\"></a>参考式</h3><p>参考式是在后面加上另一个[],在里面写上标记</p><pre><code>This is [an example][id] reference-style link.  \n</code></pre><p>可以在方括号中间加空格。。。<br>最后在文件的任意处，可以是段尾，可以是文件尾，把标记的链接定义出来</p><pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;  \n</code></pre><p>要注意的是[]后面有一个:,还有一个以上的空格，id这个标记是不区分大小写的！链接网址可以用&lt;&gt;包起来。</p><h3 id=\"隐式链接\"><a href=\"#隐式链接\" class=\"headerlink\" title=\"隐式链接\"></a>隐式链接</h3><p>隐式链接标记功能可以让你省略号指定的链接标记，这种情况标记会被视为等同于链接文字。<br>隐式链接只要在链接文字后面加上一个空的[]</p><p><strong>栗子</strong> ：</p><pre><code>[Google][]\n\n[Google]: http://google.com/  \n</code></pre><p>参考式链接的优点是比较好读，可以将一些标记的元数据移到段落之外，可以是段尾文件尾，这样就可以不让文章的阅读感被打断</p><h2 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h2><p>如果你的<em> 和_ 两边都有空白，就只会被当成普通的</em> _</p><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>如果要标记一小段行内代码，可以用反引号｀把它包起来</p><pre><code>Use the `printf()` function.  \n</code></pre><p>显示为:</p><p>Use the <code>printf()</code> function.</p><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p><pre><code>``There is a literal backtick (`) here.``  \n</code></pre><p>显示为:</p><p><code>There is a literal backtick (`) here.</code></p><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，酱紫就可以在区段开始就加入一个反引号</p><pre><code>A single backtick in a code span: `` ` ``\n\nA backtick-delimited string in a code span: `` `foo` ``  \n</code></pre><p>显示为:</p><p>A single backtick in a code span: <code>`</code></p><p>A backtick-delimited string in a code span: <code>`foo`</code></p><h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>使用行内式和参考式</p><h3 id=\"行内式-1\"><a href=\"#行内式-1\" class=\"headerlink\" title=\"行内式\"></a>行内式</h3><pre><code>![Alt text](/path/to/img.jpg)\n\n![Alt text](/path/to/img.jpg &quot;Optional title&quot;)  \n</code></pre><h3 id=\"参考式-1\"><a href=\"#参考式-1\" class=\"headerlink\" title=\"参考式\"></a>参考式</h3><pre><code>![Alt text][id]\n\n[id]: url/to/image  &quot;Optional title attribute&quot;  \n</code></pre><p>这部分和链接是差不多的,但如果想要指定图片的宽高，可以使用普通的<code>&lt;img&gt;</code>标签.</p><h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"自动链接\"><a href=\"#自动链接\" class=\"headerlink\" title=\"自动链接\"></a>自动链接</h2><p>用&lt;&gt;包起来的，都会被自动转成链接</p><pre><code>&lt;http://example.com/&gt;  \n</code></pre><p>会被转成</p><pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;  \n</code></pre><h2 id=\"反斜杠\"><a href=\"#反斜杠\" class=\"headerlink\" title=\"反斜杠\"></a>反斜杠</h2><p>可以用\\插入一些在语法中有含义的符号</p><pre><code>\\   反斜线      `   反引号\n\n`*   星号       _   底线`\n\n{}  花括号      []  方括号\n\n()  括弧        #   井字号\n\n\\+   加号       \\-   减号\n\n.   英文句点    !   惊叹号  \n</code></pre><p>上面就是我学[Markdown][]的一些笔记，可能会有缺少的，有看到的可以指正～。</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>博客初建，初学<a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>，写个学习笔记，供自己以后写文参考。<br>","more":"</p><h1 id=\"关于Markdown\"><a href=\"#关于Markdown\" class=\"headerlink\" title=\"关于Markdown\"></a>关于Markdown</h1><h2 id=\"宗旨和兼容性\"><a href=\"#宗旨和兼容性\" class=\"headerlink\" title=\"宗旨和兼容性\"></a>宗旨和兼容性</h2><p><a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>目标是实现易读易写，使用其编写的文件可以直接以纯文本发布。<br><a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>兼容<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>，语法目标是成为一种适用于网络的书写语言。</p><p>相比HTML，Markdown是一种书写的格式，而HTML更多是一种发布的格式。<br>在Markdown文件内可以直接用HTML书写，不用额外标注。</p><p><a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>兼容<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>，但是在<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>等区块元素，比如<code>&lt;div&gt;</code>,<code>&lt;table&gt;</code>,<code>&lt;pre&gt;</code>,<code>&lt;p&gt;</code>,等标签，必须在前后加上空行和其他内容隔开，还要求他们的开始和结尾标签，不能用制表符或者空格来缩进。</p><p>在<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>区块标签内的<a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>格式语法不会被处理<br>但是在<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>区段标签内，<a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>语法是有效的。比如<code>&lt;span&gt;</code>,<code>&lt;cite&gt;</code>,<code>&lt;del&gt;</code></p><h2 id=\"特殊字符转换\"><a href=\"#特殊字符转换\" class=\"headerlink\" title=\"特殊字符转换\"></a>特殊字符转换</h2><p>在<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>中，&lt; 和 &amp; 想要显示字符原型需要用实体的形式，<code>&amp;lt</code> 和<br><code>&amp;amp</code><br>而在<a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>中，则可以自由书写字符。</p><p><strong>注</strong> :在code范围内，&lt; 和 &amp; 都会一定被转换成HTML实体，因此可以更方便的写出HTML code</p><h1 id=\"区块元素\"><a href=\"#区块元素\" class=\"headerlink\" title=\"区块元素\"></a>区块元素</h1><h2 id=\"段落和换行\"><a href=\"#段落和换行\" class=\"headerlink\" title=\"段落和换行\"></a>段落和换行</h2><p>段落由连续文本行组成，且允许段落内用换行符强迫换行。</p><p>如果想插入<code>&lt;br /&gt;</code>，需要在插入处按入两个以上空格然后回车。<br>段落的前后要有一个以上空行，且普通段落不可以用空格或者制表符缩进。</p><h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>支持两种标题的语法，类Setext和atx形式</p><h3 id=\"类Setext\"><a href=\"#类Setext\" class=\"headerlink\" title=\"类Setext\"></a>类Setext</h3><p>类Setext用底线的形式，利用任意数量=（最高阶）和－（第二阶）</p><p><strong>栗子</strong> :</p><pre><code>This is an H1\n============\n\nThis is an H2\n-------------  \n</code></pre><h3 id=\"Atx\"><a href=\"#Atx\" class=\"headerlink\" title=\"Atx\"></a>Atx</h3><p>Atx形式则是在行首插入一到六个#,对应标题一到六阶<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># H1</span><br><span class=\"line\"></span><br><span class=\"line\">##  H2</span><br><span class=\"line\"></span><br><span class=\"line\">##### H5</span><br></pre></td></tr></table></figure><p></p><p>可以选择闭合#，且结尾的#和开头不用一样<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># H1 #</span><br><span class=\"line\"></span><br><span class=\"line\">## H2 ##</span><br><span class=\"line\"></span><br><span class=\"line\">### H3  ###</span><br></pre></td></tr></table></figure><p></p><h2 id=\"区块引用\"><a href=\"#区块引用\" class=\"headerlink\" title=\"区块引用\"></a>区块引用</h2><p>在每行前面加上&gt;,(可以偷个懒在整个段落的第一行加上&gt;),并且区块引用可以嵌套，只要根据层次加上不同数量的&gt;</p><p><strong>栗子</strong> :<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; This is the fiest level of quoting </span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt;&gt; This is nested blokquote</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; back to first level</span><br></pre></td></tr></table></figure><p></p><p>显示为:</p><blockquote><p>This is the fiest level of quoting</p><blockquote><p>This is nested blokquote</p></blockquote><p>back to first level</p></blockquote><p>在引用区块内也可以使用其他<a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>语法， <strong>栗如</strong><br>标题、列表、代码区块</p><pre><code>&gt; ## 这是一个标题。\n&gt;\n&gt; 1.   这是第一行列表项。\n&gt; 2.   这是第二行列表项。\n&gt;\n&gt; 给出一些例子代码：\n&gt;\n&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);  \n</code></pre><p>显示为:</p><blockquote><h2 id=\"这是一个标题。\"><a href=\"#这是一个标题。\" class=\"headerlink\" title=\"这是一个标题。\"></a>这是一个标题。</h2><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);  \n</code></pre></blockquote><h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><p>支持有序列表和无序列表两种</p><h3 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h3><p>无序列表使用 + - 作为列表标记，个人偏向－，因为不用按shift</p><h3 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h3><p>有序列表则使用数字接着一个英文句点:</p><pre><code>1.  First one\n\n2.  Second one  \n</code></pre><p>显示为:</p><ol><li><p>First one</p></li><li><p>Second one</p></li></ol><p>使用不同的数字不会有问题，但是看着不舒服，不推荐，还是顺序下来。<br>或者也可以只用一个数字。</p><p><strong>栗如</strong></p><pre><code>1.  First one\n\n1.  Second one\n\n1.  THird one  \n</code></pre><p>列表通常在最左边，但是也可以缩进，最多三个空格，标记后面一定要接上至少一个空格或者制表符<br>如果列表间由空行，<a href=\"https://en.wikipedia.org/wiki/Markdowna\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Markdown</a>会用\\标签将内容裹起来</p><p><strong>栗子</strong> ：</p><pre><code>*   Bird\n\n*   Magic  \n</code></pre><p>会被转换成：</p><pre><code>&gt;    &lt;ul&gt;\n\n&gt;    &lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;\n\n&gt;    &lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;\n\n&gt;    &lt;/ul&gt;  \n</code></pre><p>显示为:</p><ul><li><p>Bird</p></li><li><p>Magic</p></li></ul><p>列表可以包含多个段落，但是记得每个段落都要缩进哦</p><p>如果放引用，&gt;也要缩进<br>如果放代码区块，这个区块就要缩进两次<br>如果要在行首输入2017. 这种数字+句点+空白，可以在句点前面加反斜杠，即2017.</p><h2 id=\"代码区块\"><a href=\"#代码区块\" class=\"headerlink\" title=\"代码区块\"></a>代码区块</h2><p>终于到这啦，代码区块最简单了，只要简单的缩进4个空格或者一个tab,或者,```这个标识,</p><p><strong>栗子</strong> ：</p><ul><li>____printf(“hello world”)</li><li><tab>printf(“hello world”)</tab></li><li>```<br>printf(“hello world”)<br>```</li></ul><p>显示为:</p><pre><code>printf(&quot;hello world&quot;)\n</code></pre><p>markdown 会自动在代码区块外面加上\\，而且代码区块里面&amp; &lt; &gt;会自动转成<a href=\"https://en.wikipedia.org/wiki/HTML\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HTML</a>实体，所以可以想怎么写code就怎么写</p><h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>表格对齐方式</p><pre><code>1.  居左: :----\n\n2.  居中: :----: 或者　-----\n\n3.  居右: ----:  \n</code></pre><h2 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h2><p>可以在一行中用三个以上的<em>，-，_ 来建立一个分割线。行内不可以用其他东西，可以在</em> -中间插入空格。</p><pre><code>* * *\n\n****\n\n---\n\n___  \n</code></pre><p>显示为:</p><hr><hr><hr><hr><h1 id=\"区段元素\"><a href=\"#区段元素\" class=\"headerlink\" title=\"区段元素\"></a>区段元素</h1><h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>支持行内式和参考式两种，但都是用[]标记链接文字</p><h3 id=\"行内式\"><a href=\"#行内式\" class=\"headerlink\" title=\"行内式\"></a>行内式</h3><p>在方括号后面接一个()在里面写上网址就行，如果要加title,在后面用单引号、双引号或是括弧把title文字包起来就行</p><p><strong>栗子</strong> ：</p><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.\n\n[This link](http://example.net/) has no title attribute.  \n</code></pre><p>如果想要链接到同主机资源，用相对路径</p><pre><code>See my [About](/about/) page for details.  \n</code></pre><h3 id=\"参考式\"><a href=\"#参考式\" class=\"headerlink\" title=\"参考式\"></a>参考式</h3><p>参考式是在后面加上另一个[],在里面写上标记</p><pre><code>This is [an example][id] reference-style link.  \n</code></pre><p>可以在方括号中间加空格。。。<br>最后在文件的任意处，可以是段尾，可以是文件尾，把标记的链接定义出来</p><pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;  \n</code></pre><p>要注意的是[]后面有一个:,还有一个以上的空格，id这个标记是不区分大小写的！链接网址可以用&lt;&gt;包起来。</p><h3 id=\"隐式链接\"><a href=\"#隐式链接\" class=\"headerlink\" title=\"隐式链接\"></a>隐式链接</h3><p>隐式链接标记功能可以让你省略号指定的链接标记，这种情况标记会被视为等同于链接文字。<br>隐式链接只要在链接文字后面加上一个空的[]</p><p><strong>栗子</strong> ：</p><pre><code>[Google][]\n\n[Google]: http://google.com/  \n</code></pre><p>参考式链接的优点是比较好读，可以将一些标记的元数据移到段落之外，可以是段尾文件尾，这样就可以不让文章的阅读感被打断</p><h2 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h2><p>如果你的<em> 和_ 两边都有空白，就只会被当成普通的</em> _</p><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>如果要标记一小段行内代码，可以用反引号｀把它包起来</p><pre><code>Use the `printf()` function.  \n</code></pre><p>显示为:</p><p>Use the <code>printf()</code> function.</p><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p><pre><code>``There is a literal backtick (`) here.``  \n</code></pre><p>显示为:</p><p><code>There is a literal backtick (`) here.</code></p><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，酱紫就可以在区段开始就加入一个反引号</p><pre><code>A single backtick in a code span: `` ` ``\n\nA backtick-delimited string in a code span: `` `foo` ``  \n</code></pre><p>显示为:</p><p>A single backtick in a code span: <code>`</code></p><p>A backtick-delimited string in a code span: <code>`foo`</code></p><h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>使用行内式和参考式</p><h3 id=\"行内式-1\"><a href=\"#行内式-1\" class=\"headerlink\" title=\"行内式\"></a>行内式</h3><pre><code>![Alt text](/path/to/img.jpg)\n\n![Alt text](/path/to/img.jpg &quot;Optional title&quot;)  \n</code></pre><h3 id=\"参考式-1\"><a href=\"#参考式-1\" class=\"headerlink\" title=\"参考式\"></a>参考式</h3><pre><code>![Alt text][id]\n\n[id]: url/to/image  &quot;Optional title attribute&quot;  \n</code></pre><p>这部分和链接是差不多的,但如果想要指定图片的宽高，可以使用普通的<code>&lt;img&gt;</code>标签.</p><h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"自动链接\"><a href=\"#自动链接\" class=\"headerlink\" title=\"自动链接\"></a>自动链接</h2><p>用&lt;&gt;包起来的，都会被自动转成链接</p><pre><code>&lt;http://example.com/&gt;  \n</code></pre><p>会被转成</p><pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;  \n</code></pre><h2 id=\"反斜杠\"><a href=\"#反斜杠\" class=\"headerlink\" title=\"反斜杠\"></a>反斜杠</h2><p>可以用\\插入一些在语法中有含义的符号</p><pre><code>\\   反斜线      `   反引号\n\n`*   星号       _   底线`\n\n{}  花括号      []  方括号\n\n()  括弧        #   井字号\n\n\\+   加号       \\-   减号\n\n.   英文句点    !   惊叹号  \n</code></pre><p>上面就是我学[Markdown][]的一些笔记，可能会有缺少的，有看到的可以指正～。</p><!-- rebuild by neat -->"},{"title":"Canvas中像素级别ImageData缩放","comments":1,"mathjax":false,"date":"2019-04-10T12:56:48.000Z","urlname":"canvas-imagedata","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n弄Web端手写数字识别的时候要把Canvas缩成32\\*32大小的，刚开始想的是用canvas的画布缩放，弄了好久发现行不通，然后无意中发现可以获得每个像素的RGBA的值，然后又自己尝试每个像素缩放，语法不熟悉，各种尝试...\n好了不多说了，代码在下面\n{% endnote %}\n<!--more-->\n\n## Canvas中对ImageData数据缩放\n- ctx: 原始canvas的context\n- outCtx: 输出canvas的context\n- scale: 缩放倍数\n- scaled: 缩放后的ImageData\n- imageData.data: 图像的RGBA数组，是一个一维数组\n\n```javascript\nfunction genImg() {\n  var imgData = ctx.getImageData(0,0,500,500);\n  outCtx.putImageData(scaleImageData(imgData,0.5),0,0);\n}\n\nfunction scaleImageData(imageData, scale) {\n  var scaled =\n      outCtx.createImageData(imageData.width * scale, imageData.height * scale);\n  for (var row = 0; row < imageData.height; row++) {\n    for (var col = 0; col < imageData.width; col++) {\n      var sourcePixel = [\n        imageData.data[(row * imageData.width + col) * 4 + 0],\n        imageData.data[(row * imageData.width + col) * 4 + 1],\n        imageData.data[(row * imageData.width + col) * 4 + 2],\n        imageData.data[(row * imageData.width + col) * 4 + 3]\n      ];\n      for (var y = 0; y < scale; y++) {\n        var destRow = Math.floor(row * scale) + y;\n        for (var x = 0; x < scale; x++) {\n          var destCol = Math.floor(col * scale) + x;\n          for (var i = 0; i < 4; i++) {\n            scaled.data[(destRow * scaled.width + destCol) * 4 + i] = sourcePixel[i];\n          }\n        }\n      }\n    }\n  }\n  return scaled;\n}\n```\n\n{% note %}\n主要就是scaleImageData这个函数，原型是stackoverflow上的，不过有bug，自己修改了下。\n遇到问题果然还是要看源码...\n{% endnote %}\n","source":"_posts/Canvas中像素级别ImageData缩放.md","raw":"---\ntitle: Canvas中像素级别ImageData缩放\ncomments: true\nmathjax: false\ndate: 2019-04-10 20:56:48\ntags: [Canvas, Web, ImageData, Learning, Notes]\ncategories: Notes\nurlname: canvas-imagedata\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n弄Web端手写数字识别的时候要把Canvas缩成32\\*32大小的，刚开始想的是用canvas的画布缩放，弄了好久发现行不通，然后无意中发现可以获得每个像素的RGBA的值，然后又自己尝试每个像素缩放，语法不熟悉，各种尝试...\n好了不多说了，代码在下面\n{% endnote %}\n<!--more-->\n\n## Canvas中对ImageData数据缩放\n- ctx: 原始canvas的context\n- outCtx: 输出canvas的context\n- scale: 缩放倍数\n- scaled: 缩放后的ImageData\n- imageData.data: 图像的RGBA数组，是一个一维数组\n\n```javascript\nfunction genImg() {\n  var imgData = ctx.getImageData(0,0,500,500);\n  outCtx.putImageData(scaleImageData(imgData,0.5),0,0);\n}\n\nfunction scaleImageData(imageData, scale) {\n  var scaled =\n      outCtx.createImageData(imageData.width * scale, imageData.height * scale);\n  for (var row = 0; row < imageData.height; row++) {\n    for (var col = 0; col < imageData.width; col++) {\n      var sourcePixel = [\n        imageData.data[(row * imageData.width + col) * 4 + 0],\n        imageData.data[(row * imageData.width + col) * 4 + 1],\n        imageData.data[(row * imageData.width + col) * 4 + 2],\n        imageData.data[(row * imageData.width + col) * 4 + 3]\n      ];\n      for (var y = 0; y < scale; y++) {\n        var destRow = Math.floor(row * scale) + y;\n        for (var x = 0; x < scale; x++) {\n          var destCol = Math.floor(col * scale) + x;\n          for (var i = 0; i < 4; i++) {\n            scaled.data[(destRow * scaled.width + destCol) * 4 + i] = sourcePixel[i];\n          }\n        }\n      }\n    }\n  }\n  return scaled;\n}\n```\n\n{% note %}\n主要就是scaleImageData这个函数，原型是stackoverflow上的，不过有bug，自己修改了下。\n遇到问题果然还是要看源码...\n{% endnote %}\n","slug":"Canvas中像素级别ImageData缩放","published":1,"updated":"2019-07-25T17:43:27.446Z","layout":"post","photos":[],"link":"","_id":"ck2424lko000klksb4ib0c3oc","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>弄Web端手写数字识别的时候要把Canvas缩成32*32大小的，刚开始想的是用canvas的画布缩放，弄了好久发现行不通，然后无意中发现可以获得每个像素的RGBA的值，然后又自己尝试每个像素缩放，语法不熟悉，各种尝试…<br>好了不多说了，代码在下面</p></div><a id=\"more\"></a><h2 id=\"Canvas中对ImageData数据缩放\"><a href=\"#Canvas中对ImageData数据缩放\" class=\"headerlink\" title=\"Canvas中对ImageData数据缩放\"></a>Canvas中对ImageData数据缩放</h2><ul><li>ctx: 原始canvas的context</li><li>outCtx: 输出canvas的context</li><li>scale: 缩放倍数</li><li>scaled: 缩放后的ImageData</li><li>imageData.data: 图像的RGBA数组，是一个一维数组</li></ul><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genImg</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> imgData = ctx.getImageData(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">500</span>,<span class=\"number\">500</span>);</span><br><span class=\"line\">  outCtx.putImageData(scaleImageData(imgData,<span class=\"number\">0.5</span>),<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scaleImageData</span>(<span class=\"params\">imageData, scale</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scaled =</span><br><span class=\"line\">      outCtx.createImageData(imageData.width * scale, imageData.height * scale);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> row = <span class=\"number\">0</span>; row &lt; imageData.height; row++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> col = <span class=\"number\">0</span>; col &lt; imageData.width; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> sourcePixel = [</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">0</span>],</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">1</span>],</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">2</span>],</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">3</span>]</span><br><span class=\"line\">      ];</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> y = <span class=\"number\">0</span>; y &lt; scale; y++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> destRow = <span class=\"built_in\">Math</span>.floor(row * scale) + y;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x = <span class=\"number\">0</span>; x &lt; scale; x++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> destCol = <span class=\"built_in\">Math</span>.floor(col * scale) + x;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            scaled.data[(destRow * scaled.width + destCol) * <span class=\"number\">4</span> + i] = sourcePixel[i];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> scaled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><div class=\"note\"><p>主要就是scaleImageData这个函数，原型是stackoverflow上的，不过有bug，自己修改了下。<br>遇到问题果然还是要看源码…</p></div><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>弄Web端手写数字识别的时候要把Canvas缩成32*32大小的，刚开始想的是用canvas的画布缩放，弄了好久发现行不通，然后无意中发现可以获得每个像素的RGBA的值，然后又自己尝试每个像素缩放，语法不熟悉，各种尝试…<br>好了不多说了，代码在下面</p></div>","more":"<h2 id=\"Canvas中对ImageData数据缩放\"><a href=\"#Canvas中对ImageData数据缩放\" class=\"headerlink\" title=\"Canvas中对ImageData数据缩放\"></a>Canvas中对ImageData数据缩放</h2><ul><li>ctx: 原始canvas的context</li><li>outCtx: 输出canvas的context</li><li>scale: 缩放倍数</li><li>scaled: 缩放后的ImageData</li><li>imageData.data: 图像的RGBA数组，是一个一维数组</li></ul><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genImg</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> imgData = ctx.getImageData(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">500</span>,<span class=\"number\">500</span>);</span><br><span class=\"line\">  outCtx.putImageData(scaleImageData(imgData,<span class=\"number\">0.5</span>),<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scaleImageData</span>(<span class=\"params\">imageData, scale</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scaled =</span><br><span class=\"line\">      outCtx.createImageData(imageData.width * scale, imageData.height * scale);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> row = <span class=\"number\">0</span>; row &lt; imageData.height; row++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> col = <span class=\"number\">0</span>; col &lt; imageData.width; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> sourcePixel = [</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">0</span>],</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">1</span>],</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">2</span>],</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">3</span>]</span><br><span class=\"line\">      ];</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> y = <span class=\"number\">0</span>; y &lt; scale; y++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> destRow = <span class=\"built_in\">Math</span>.floor(row * scale) + y;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x = <span class=\"number\">0</span>; x &lt; scale; x++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> destCol = <span class=\"built_in\">Math</span>.floor(col * scale) + x;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            scaled.data[(destRow * scaled.width + destCol) * <span class=\"number\">4</span> + i] = sourcePixel[i];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> scaled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><div class=\"note\"><p>主要就是scaleImageData这个函数，原型是stackoverflow上的，不过有bug，自己修改了下。<br>遇到问题果然还是要看源码…</p></div><!-- rebuild by neat -->"},{"title":"Tornado中的异步","comments":1,"mathjax":false,"date":"2019-03-17T14:32:28.000Z","urlname":"tornado-async","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# Tornado中的异步\n## 概述\n\n因为epoll主要用来解决网络IO的并发问题，所以Tornado中的异步也主要体现在网络的IO异步上，即异步web\n<!--more-->\n\n## tornado.httpclient.AsyncHttpClinet\n- 是Tornado提供的异步web请求客户端，用来进行异步web请求\n- from tornado.httpclient import AsyncHttpClinet\n\n## fetch(request, callback = None)\n- 此函数用于执行一个Web请求，并异步响应返回一个tornado.httpclient.HttpResponse\n- request可以是一个URL，也可以是一个Tornado.httpclient.HttpResponse对象,如果插入的是url，会自动生成一个request对象\n\n## HTTPRequest\n- HTTP请求类，该类的构造函数可以接收参数    \n- 参数:\n  - url: 字符串类型，要访问的网址，必传\n  - method：字符串类型，http请求方式\n  - headers：字典或者HTTPHeaders，附加的协议头\n  - body: HTTP请求体\n  \n## HTTPResponse\n- HTTP响应类\n- 属性\n  - code: 状态码\n  - reason： 状态码的描述\n  - body： 相应的数据\n  - error： 是否有异常\n\n## @tornado.web.asynchronous装饰器\n- 不关闭通信的通道\n- **实际操作发现无法使用这个装饰器**\n-------------------\n\n## 示例\n\n### 回调函数实现的异步\n**Handler代码**\n```\nclass StudentsHandler(RequestHandler):\n    def on_response(self, response):\n        if response.error:\n            self.send_error(500)\n        else:\n            data = json.loads(response.body)\n            # 这里本身无法write,要打开通道，用asynchronous装饰器\n            self.write(data)\n        self.finish()\n\n    # 不关闭通信的通道\n    #  @tornado.web.asynchronous\n    # 实操发现用不了这个装饰器\n    def get(self, *args, **kwargs):\n        url = \"http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&t=&market=360zhushou&client=android&appname=budejie&device=&jdk=1&ver=8.0.1&udid=&from=android\"\n        # 创建客户端\n        client = AsyncHTTPClient()\n        # on_response是回调函数,如果请求成功，就进行on_response回调函数\n        client.fetch(url, self.on_response)\n        #  self.write(\"OK\") \n```\n\n### 协程实现的异步\n**Handler代码**\n```\nclass Students2Handler(RequestHandler):\n    @tornado.gen.coroutine\n    def get(self, *args, **kwargs):\n        url = \"http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&t=&market=360zhushou&client=android&appname=budejie&device=&jdk=1&ver=8.0.1&udid=&from=android\"\n        client = AsyncHTTPClient()\n        # 耗时操作挂起\n        res = yield client.fetch(url)\n        if res.error:\n            self.send_error(500)\n        else:\n            data = json.loads(res.body)\n            self.write(data) \n```\n### 协程异步并将异步web请求单独出来\n\n**Handler代码**\n\n    class Students3Handler(RequestHandler):\n        # 简化get函数\n        @tornado.gen.coroutine\n        def get(self, *args, **kwargs):\n            res = yield self.getData()\n            self.write(res)\n    \n        # 这里也要加装饰器，这里也是耗时操作\n        @tornado.gen.coroutine\n        def getData(self):\n            url = \"http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&t=&market=360zhushou&client=android&appname=budejie&device=&jdk=1&ver=8.0.1&udid=&from=android\"\n            client = AsyncHTTPClient()\n            # 耗时操作\n            res = yield client.fetch(url)\n            if res.error:\n                #  表示没有结果\n                ret = {\"ret\": 0}\n            else:\n                ret = json.loads(res.body)\n            #  相当于gen.send()函数\n            raise tornado.gen.Return(ret)\n","source":"_posts/Tornado中的异步.md","raw":"---\ntitle: Tornado中的异步\ncomments: true\nmathjax: false\ndate: 2019-03-17 22:32:28\ntags: [Python,Tornado, Async]\ncategories: Notes\nurlname: tornado-async\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# Tornado中的异步\n## 概述\n\n因为epoll主要用来解决网络IO的并发问题，所以Tornado中的异步也主要体现在网络的IO异步上，即异步web\n<!--more-->\n\n## tornado.httpclient.AsyncHttpClinet\n- 是Tornado提供的异步web请求客户端，用来进行异步web请求\n- from tornado.httpclient import AsyncHttpClinet\n\n## fetch(request, callback = None)\n- 此函数用于执行一个Web请求，并异步响应返回一个tornado.httpclient.HttpResponse\n- request可以是一个URL，也可以是一个Tornado.httpclient.HttpResponse对象,如果插入的是url，会自动生成一个request对象\n\n## HTTPRequest\n- HTTP请求类，该类的构造函数可以接收参数    \n- 参数:\n  - url: 字符串类型，要访问的网址，必传\n  - method：字符串类型，http请求方式\n  - headers：字典或者HTTPHeaders，附加的协议头\n  - body: HTTP请求体\n  \n## HTTPResponse\n- HTTP响应类\n- 属性\n  - code: 状态码\n  - reason： 状态码的描述\n  - body： 相应的数据\n  - error： 是否有异常\n\n## @tornado.web.asynchronous装饰器\n- 不关闭通信的通道\n- **实际操作发现无法使用这个装饰器**\n-------------------\n\n## 示例\n\n### 回调函数实现的异步\n**Handler代码**\n```\nclass StudentsHandler(RequestHandler):\n    def on_response(self, response):\n        if response.error:\n            self.send_error(500)\n        else:\n            data = json.loads(response.body)\n            # 这里本身无法write,要打开通道，用asynchronous装饰器\n            self.write(data)\n        self.finish()\n\n    # 不关闭通信的通道\n    #  @tornado.web.asynchronous\n    # 实操发现用不了这个装饰器\n    def get(self, *args, **kwargs):\n        url = \"http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&t=&market=360zhushou&client=android&appname=budejie&device=&jdk=1&ver=8.0.1&udid=&from=android\"\n        # 创建客户端\n        client = AsyncHTTPClient()\n        # on_response是回调函数,如果请求成功，就进行on_response回调函数\n        client.fetch(url, self.on_response)\n        #  self.write(\"OK\") \n```\n\n### 协程实现的异步\n**Handler代码**\n```\nclass Students2Handler(RequestHandler):\n    @tornado.gen.coroutine\n    def get(self, *args, **kwargs):\n        url = \"http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&t=&market=360zhushou&client=android&appname=budejie&device=&jdk=1&ver=8.0.1&udid=&from=android\"\n        client = AsyncHTTPClient()\n        # 耗时操作挂起\n        res = yield client.fetch(url)\n        if res.error:\n            self.send_error(500)\n        else:\n            data = json.loads(res.body)\n            self.write(data) \n```\n### 协程异步并将异步web请求单独出来\n\n**Handler代码**\n\n    class Students3Handler(RequestHandler):\n        # 简化get函数\n        @tornado.gen.coroutine\n        def get(self, *args, **kwargs):\n            res = yield self.getData()\n            self.write(res)\n    \n        # 这里也要加装饰器，这里也是耗时操作\n        @tornado.gen.coroutine\n        def getData(self):\n            url = \"http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&t=&market=360zhushou&client=android&appname=budejie&device=&jdk=1&ver=8.0.1&udid=&from=android\"\n            client = AsyncHTTPClient()\n            # 耗时操作\n            res = yield client.fetch(url)\n            if res.error:\n                #  表示没有结果\n                ret = {\"ret\": 0}\n            else:\n                ret = json.loads(res.body)\n            #  相当于gen.send()函数\n            raise tornado.gen.Return(ret)\n","slug":"Tornado中的异步","published":1,"updated":"2019-07-25T18:34:12.896Z","layout":"post","photos":[],"link":"","_id":"ck2424llp002nlksbzwo4he1m","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><h1 id=\"Tornado中的异步\"><a href=\"#Tornado中的异步\" class=\"headerlink\" title=\"Tornado中的异步\"></a>Tornado中的异步</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>因为epoll主要用来解决网络IO的并发问题，所以Tornado中的异步也主要体现在网络的IO异步上，即异步web<br><a id=\"more\"></a></p><h2 id=\"tornado-httpclient-AsyncHttpClinet\"><a href=\"#tornado-httpclient-AsyncHttpClinet\" class=\"headerlink\" title=\"tornado.httpclient.AsyncHttpClinet\"></a>tornado.httpclient.AsyncHttpClinet</h2><ul><li>是Tornado提供的异步web请求客户端，用来进行异步web请求</li><li>from tornado.httpclient import AsyncHttpClinet</li></ul><h2 id=\"fetch-request-callback-None\"><a href=\"#fetch-request-callback-None\" class=\"headerlink\" title=\"fetch(request, callback = None)\"></a>fetch(request, callback = None)</h2><ul><li>此函数用于执行一个Web请求，并异步响应返回一个tornado.httpclient.HttpResponse</li><li>request可以是一个URL，也可以是一个Tornado.httpclient.HttpResponse对象,如果插入的是url，会自动生成一个request对象</li></ul><h2 id=\"HTTPRequest\"><a href=\"#HTTPRequest\" class=\"headerlink\" title=\"HTTPRequest\"></a>HTTPRequest</h2><ul><li>HTTP请求类，该类的构造函数可以接收参数</li><li>参数:<ul><li>url: 字符串类型，要访问的网址，必传</li><li>method：字符串类型，http请求方式</li><li>headers：字典或者HTTPHeaders，附加的协议头</li><li>body: HTTP请求体</li></ul></li></ul><h2 id=\"HTTPResponse\"><a href=\"#HTTPResponse\" class=\"headerlink\" title=\"HTTPResponse\"></a>HTTPResponse</h2><ul><li>HTTP响应类</li><li>属性<ul><li>code: 状态码</li><li>reason： 状态码的描述</li><li>body： 相应的数据</li><li>error： 是否有异常</li></ul></li></ul><h2 id=\"tornado-web-asynchronous装饰器\"><a href=\"#tornado-web-asynchronous装饰器\" class=\"headerlink\" title=\"@tornado.web.asynchronous装饰器\"></a>@tornado.web.asynchronous装饰器</h2><ul><li>不关闭通信的通道</li><li><strong>实际操作发现无法使用这个装饰器</strong></li></ul><hr><h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h3 id=\"回调函数实现的异步\"><a href=\"#回调函数实现的异步\" class=\"headerlink\" title=\"回调函数实现的异步\"></a>回调函数实现的异步</h3><p><strong>Handler代码</strong><br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StudentsHandler(RequestHandler):</span><br><span class=\"line\">    def on_response(self, response):</span><br><span class=\"line\">        if response.error:</span><br><span class=\"line\">            self.send_error(500)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            data = json.loads(response.body)</span><br><span class=\"line\">            # 这里本身无法write,要打开通道，用asynchronous装饰器</span><br><span class=\"line\">            self.write(data)</span><br><span class=\"line\">        self.finish()</span><br><span class=\"line\"></span><br><span class=\"line\">    # 不关闭通信的通道</span><br><span class=\"line\">    #  @tornado.web.asynchronous</span><br><span class=\"line\">    # 实操发现用不了这个装饰器</span><br><span class=\"line\">    def get(self, *args, **kwargs):</span><br><span class=\"line\">        url = &quot;http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&amp;t=&amp;market=360zhushou&amp;client=android&amp;appname=budejie&amp;device=&amp;jdk=1&amp;ver=8.0.1&amp;udid=&amp;from=android&quot;</span><br><span class=\"line\">        # 创建客户端</span><br><span class=\"line\">        client = AsyncHTTPClient()</span><br><span class=\"line\">        # on_response是回调函数,如果请求成功，就进行on_response回调函数</span><br><span class=\"line\">        client.fetch(url, self.on_response)</span><br><span class=\"line\">        #  self.write(&quot;OK&quot;)</span><br></pre></td></tr></table></figure><p></p><h3 id=\"协程实现的异步\"><a href=\"#协程实现的异步\" class=\"headerlink\" title=\"协程实现的异步\"></a>协程实现的异步</h3><p><strong>Handler代码</strong><br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Students2Handler(RequestHandler):</span><br><span class=\"line\">    @tornado.gen.coroutine</span><br><span class=\"line\">    def get(self, *args, **kwargs):</span><br><span class=\"line\">        url = &quot;http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&amp;t=&amp;market=360zhushou&amp;client=android&amp;appname=budejie&amp;device=&amp;jdk=1&amp;ver=8.0.1&amp;udid=&amp;from=android&quot;</span><br><span class=\"line\">        client = AsyncHTTPClient()</span><br><span class=\"line\">        # 耗时操作挂起</span><br><span class=\"line\">        res = yield client.fetch(url)</span><br><span class=\"line\">        if res.error:</span><br><span class=\"line\">            self.send_error(500)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            data = json.loads(res.body)</span><br><span class=\"line\">            self.write(data)</span><br></pre></td></tr></table></figure><p></p><h3 id=\"协程异步并将异步web请求单独出来\"><a href=\"#协程异步并将异步web请求单独出来\" class=\"headerlink\" title=\"协程异步并将异步web请求单独出来\"></a>协程异步并将异步web请求单独出来</h3><p><strong>Handler代码</strong></p><pre><code>class Students3Handler(RequestHandler):\n    # 简化get函数\n    @tornado.gen.coroutine\n    def get(self, *args, **kwargs):\n        res = yield self.getData()\n        self.write(res)\n\n    # 这里也要加装饰器，这里也是耗时操作\n    @tornado.gen.coroutine\n    def getData(self):\n        url = &quot;http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&amp;t=&amp;market=360zhushou&amp;client=android&amp;appname=budejie&amp;device=&amp;jdk=1&amp;ver=8.0.1&amp;udid=&amp;from=android&quot;\n        client = AsyncHTTPClient()\n        # 耗时操作\n        res = yield client.fetch(url)\n        if res.error:\n            #  表示没有结果\n            ret = {&quot;ret&quot;: 0}\n        else:\n            ret = json.loads(res.body)\n        #  相当于gen.send()函数\n        raise tornado.gen.Return(ret)\n</code></pre><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><h1 id=\"Tornado中的异步\"><a href=\"#Tornado中的异步\" class=\"headerlink\" title=\"Tornado中的异步\"></a>Tornado中的异步</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>因为epoll主要用来解决网络IO的并发问题，所以Tornado中的异步也主要体现在网络的IO异步上，即异步web<br>","more":"</p><h2 id=\"tornado-httpclient-AsyncHttpClinet\"><a href=\"#tornado-httpclient-AsyncHttpClinet\" class=\"headerlink\" title=\"tornado.httpclient.AsyncHttpClinet\"></a>tornado.httpclient.AsyncHttpClinet</h2><ul><li>是Tornado提供的异步web请求客户端，用来进行异步web请求</li><li>from tornado.httpclient import AsyncHttpClinet</li></ul><h2 id=\"fetch-request-callback-None\"><a href=\"#fetch-request-callback-None\" class=\"headerlink\" title=\"fetch(request, callback = None)\"></a>fetch(request, callback = None)</h2><ul><li>此函数用于执行一个Web请求，并异步响应返回一个tornado.httpclient.HttpResponse</li><li>request可以是一个URL，也可以是一个Tornado.httpclient.HttpResponse对象,如果插入的是url，会自动生成一个request对象</li></ul><h2 id=\"HTTPRequest\"><a href=\"#HTTPRequest\" class=\"headerlink\" title=\"HTTPRequest\"></a>HTTPRequest</h2><ul><li>HTTP请求类，该类的构造函数可以接收参数</li><li>参数:<ul><li>url: 字符串类型，要访问的网址，必传</li><li>method：字符串类型，http请求方式</li><li>headers：字典或者HTTPHeaders，附加的协议头</li><li>body: HTTP请求体</li></ul></li></ul><h2 id=\"HTTPResponse\"><a href=\"#HTTPResponse\" class=\"headerlink\" title=\"HTTPResponse\"></a>HTTPResponse</h2><ul><li>HTTP响应类</li><li>属性<ul><li>code: 状态码</li><li>reason： 状态码的描述</li><li>body： 相应的数据</li><li>error： 是否有异常</li></ul></li></ul><h2 id=\"tornado-web-asynchronous装饰器\"><a href=\"#tornado-web-asynchronous装饰器\" class=\"headerlink\" title=\"@tornado.web.asynchronous装饰器\"></a>@tornado.web.asynchronous装饰器</h2><ul><li>不关闭通信的通道</li><li><strong>实际操作发现无法使用这个装饰器</strong></li></ul><hr><h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h3 id=\"回调函数实现的异步\"><a href=\"#回调函数实现的异步\" class=\"headerlink\" title=\"回调函数实现的异步\"></a>回调函数实现的异步</h3><p><strong>Handler代码</strong><br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StudentsHandler(RequestHandler):</span><br><span class=\"line\">    def on_response(self, response):</span><br><span class=\"line\">        if response.error:</span><br><span class=\"line\">            self.send_error(500)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            data = json.loads(response.body)</span><br><span class=\"line\">            # 这里本身无法write,要打开通道，用asynchronous装饰器</span><br><span class=\"line\">            self.write(data)</span><br><span class=\"line\">        self.finish()</span><br><span class=\"line\"></span><br><span class=\"line\">    # 不关闭通信的通道</span><br><span class=\"line\">    #  @tornado.web.asynchronous</span><br><span class=\"line\">    # 实操发现用不了这个装饰器</span><br><span class=\"line\">    def get(self, *args, **kwargs):</span><br><span class=\"line\">        url = &quot;http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&amp;t=&amp;market=360zhushou&amp;client=android&amp;appname=budejie&amp;device=&amp;jdk=1&amp;ver=8.0.1&amp;udid=&amp;from=android&quot;</span><br><span class=\"line\">        # 创建客户端</span><br><span class=\"line\">        client = AsyncHTTPClient()</span><br><span class=\"line\">        # on_response是回调函数,如果请求成功，就进行on_response回调函数</span><br><span class=\"line\">        client.fetch(url, self.on_response)</span><br><span class=\"line\">        #  self.write(&quot;OK&quot;)</span><br></pre></td></tr></table></figure><p></p><h3 id=\"协程实现的异步\"><a href=\"#协程实现的异步\" class=\"headerlink\" title=\"协程实现的异步\"></a>协程实现的异步</h3><p><strong>Handler代码</strong><br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Students2Handler(RequestHandler):</span><br><span class=\"line\">    @tornado.gen.coroutine</span><br><span class=\"line\">    def get(self, *args, **kwargs):</span><br><span class=\"line\">        url = &quot;http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&amp;t=&amp;market=360zhushou&amp;client=android&amp;appname=budejie&amp;device=&amp;jdk=1&amp;ver=8.0.1&amp;udid=&amp;from=android&quot;</span><br><span class=\"line\">        client = AsyncHTTPClient()</span><br><span class=\"line\">        # 耗时操作挂起</span><br><span class=\"line\">        res = yield client.fetch(url)</span><br><span class=\"line\">        if res.error:</span><br><span class=\"line\">            self.send_error(500)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            data = json.loads(res.body)</span><br><span class=\"line\">            self.write(data)</span><br></pre></td></tr></table></figure><p></p><h3 id=\"协程异步并将异步web请求单独出来\"><a href=\"#协程异步并将异步web请求单独出来\" class=\"headerlink\" title=\"协程异步并将异步web请求单独出来\"></a>协程异步并将异步web请求单独出来</h3><p><strong>Handler代码</strong></p><pre><code>class Students3Handler(RequestHandler):\n    # 简化get函数\n    @tornado.gen.coroutine\n    def get(self, *args, **kwargs):\n        res = yield self.getData()\n        self.write(res)\n\n    # 这里也要加装饰器，这里也是耗时操作\n    @tornado.gen.coroutine\n    def getData(self):\n        url = &quot;http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&amp;t=&amp;market=360zhushou&amp;client=android&amp;appname=budejie&amp;device=&amp;jdk=1&amp;ver=8.0.1&amp;udid=&amp;from=android&quot;\n        client = AsyncHTTPClient()\n        # 耗时操作\n        res = yield client.fetch(url)\n        if res.error:\n            #  表示没有结果\n            ret = {&quot;ret&quot;: 0}\n        else:\n            ret = json.loads(res.body)\n        #  相当于gen.send()函数\n        raise tornado.gen.Return(ret)\n</code></pre><!-- rebuild by neat -->"},{"title":"Python中的异步","comments":1,"mathjax":false,"date":"2019-03-17T12:28:26.000Z","urlname":"python-async","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n学Tornado的异步之前学了下Python的同步和异步机制，下面是三种实现Python中同步的方法。主要是用yield和装饰器以及threading模块实现。\n\n<!--more-->\n# python中异步的理解\n\n## 同步\n\n> 按部就班的依次执行\n> 如果在请求中添加一个耗时操作，则必须等耗时操作结束才继续下去\n> 一般不会用同步\n\n## 异步\n\n### 概述\n\n对于耗时的操作，一般会交给另一个线程处理，我们继续向下执行，当别人结束耗时操作后再将结果返回给我们\n\n### 回调函数实现异步\n\n```python\nimport time\nimport threading\n\n# Tornado中不用我们写这个函数\n# handler获取数据（数据库、其他服务器、循环耗时）\ndef longIo(callback):\n  def run(cb):\n    print(\"开始耗时操作\")\n    time.sleep(5)\n    print(\"结束耗时操作\")\n    #耗时操作结束执行回调函数\n    cb(\" 我是返回的数据\")\n  #创建一个线程，处理耗时操作threading传参args=()\n  threading.Thread(target=run,args=(callback,)).start()\n\n# 函数（回调函数）\ndef finish(data):\n  print(\"开始处理回调函数\")\n  print(\"接收到longIo的相应数据:\",data)\n  print(\"结束处理回调函数\")\n\n# 一个客户的请求\ndef reqA():\n  print(\"开始处理reqA\")\n  longIo(finish)\n  print(\"结束处理reqA\")\n\ndef reqB():\n  print(\"开始处理reqB\")\n  longIo(finish)\n  print(\"结束处理reqB\")\n\n#Tornado服务\ndef main():\n  reqA()\n  reqB()\n  while 1:\n    time.sleep(0.1)\n    pass\n\nif __name__=='__main__':\n  main()\n\n```\n\n### 协程实现异步\n\n#### 版本1\n```python\nimport time\n\n# 全局变量生成器\ngen = None\n\ndef longIo(callback):\n  def run(cb):\n    print(\"开始耗时操作\")\n    time.sleep(5)\n    try:\n      引进全局变量并且用生成器回发数据\n      global gen\n      gen.send(\"我是返回的数据\")\n    except StopIteration as e:\n      pass\n    print(\"结束耗时操作\")\n  #创建一个线程，处理耗时操作,不会影响A和B\n  threading.Thread(target=run).start()\n\n# 一个客户的请求\ndef reqA():\n  print(\"开始处理reqA\")\n  # 接受返回结果\n  # 此处相当于挂起,执行longIo,不影响执行reqB\n  res = yield longIo()\n  print(\"接收longIo的相应数据:\",res)\n  print(\"结束处理reqA\")\n\ndef reqB():\n  print(\"开始处理reqB\")\n  time.sleep(2)\n  print(\"结束处理reqB\")\n\n#Tornado服务\ndef main():\n  # 创建一个reqA的生成器\n  global gen\n  gen = reqA()\n  # 在这里真正执行reqA\n  next(gen)\n\n  reqB()\n  while 1:\n    time.sleep(0.1)\n    pass\n\nif __name__=='__main__':\n  main()\n\n```\n\n#### 版本2\n**问题**    \n> 版本1中调用reqA的时候不能将其视为一个简单的函数，而是要作为生成器来对待\n> 很明显要在主函数中要用三行调用reqA，只要用一行调用reqB。\n\n**解决办法**\n> 给reqA添加一个装饰器\n\n```python\nimport time\n\n# 全局变量生成器\ngen\n\ndef longIo(callback):\n  def run(cb):\n    print(\"开始耗时操作\")\n    time.sleep(5)\n    try:\n      引进全局变量并且用生成器回发数据\n      global gen\n      gen.send(\"我是返回的数据\")\n    except StopIteration as e:\n      pass\n    print(\"结束耗时操作\")\n  #创建一个线程，处理耗时操作,不会影响A和B\n  threading.Thread(target=run).start()\n\n# 装饰器\ndef genCoroutine(func):\n  def wrapper(*args, **kwargs):\n    global gen\n    gen = func(*args, **kwargs)\n    next(gen)\n  # 返回内部函数的时候不可以加括号，这里不可以加括号\n  return wrapper\n  \n\n# 一个客户的请求\n@genCoroutine\ndef reqA():\n  print(\"开始处理reqA\")\n  # 接受返回结果\n  # 此处相当于挂起,执行longIo,不影响执行reqB\n  res = yield longIo()\n  print(\"接收longIo的相应数据:\",res)\n  print(\"结束处理reqA\")\n\ndef reqB():\n  print(\"开始处理reqB\")\n  time.sleep(2)\n  print(\"结束处理reqB\")\n\n#Tornado服务\ndef main():\n  reqA()\n  reqB()\n  while 1:\n    time.sleep(0.1)\n    pass\n\nif __name__=='__main__':\n  main()\n```\n\n#### 版本3\n**问题**\n> 版本2中存在一个全局变量gen，需要消除\n**解决办法**\n\n```python\nimport time\n\n# 装饰器\ndef genCoroutine(func):\n  def wrapper(*args, **kwargs):\n    #reqA的生成器\n    gen1 = func()\n    #longIo的生成器\n    gen2 = next(gen1)\n    def run(g):\n      #gen2,即longIo的返回数据\n      res = next(g) \n      try:\n        gen1.send(res)#返回给reqA数据\n      except StopIteration as e:\n        pass\n    threading.Thread(target=run,args=(gen2,)).start()\n\n  # 返回内部函数的时候不可以加括号，这里不可以加括号\n  return wrapper\n  \n#这次在这里不管线程了\ndef longIo(callback):\n    print(\"开始耗时操作\")\n    time.sleep(5)\n    print(\"结束耗时操作\")\n    #要返回数据，挂起\n    yield \"我是返回的数据\"\n\n# 一个客户的请求\n@genCoroutine\ndef reqA():\n  print(\"开始处理reqA\")\n  # 接受返回结果\n  # 此处相当于挂起,执行longIo,不影响执行reqB\n  res = yield longIo()\n  print(\"接收longIo的相应数据:\",res)\n  print(\"结束处理reqA\")\n\ndef reqB():\n  print(\"开始处理reqB\")\n  time.sleep(2)\n  print(\"结束处理reqB\")\n\n#Tornado服务\ndef main():\n  reqA()\n  reqB()\n  while 1:\n    time.sleep(0.1)\n    pass\n\nif __name__=='__main__':\n  main()\n```\n-----------------------------\n","source":"_posts/Python中的异步.md","raw":"---\ntitle: Python中的异步\ncomments: true\nmathjax: false\ndate: 2019-03-17 20:28:26\ntags: [Python, Async]\ncategories: Notes\nurlname: python-async\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n学Tornado的异步之前学了下Python的同步和异步机制，下面是三种实现Python中同步的方法。主要是用yield和装饰器以及threading模块实现。\n\n<!--more-->\n# python中异步的理解\n\n## 同步\n\n> 按部就班的依次执行\n> 如果在请求中添加一个耗时操作，则必须等耗时操作结束才继续下去\n> 一般不会用同步\n\n## 异步\n\n### 概述\n\n对于耗时的操作，一般会交给另一个线程处理，我们继续向下执行，当别人结束耗时操作后再将结果返回给我们\n\n### 回调函数实现异步\n\n```python\nimport time\nimport threading\n\n# Tornado中不用我们写这个函数\n# handler获取数据（数据库、其他服务器、循环耗时）\ndef longIo(callback):\n  def run(cb):\n    print(\"开始耗时操作\")\n    time.sleep(5)\n    print(\"结束耗时操作\")\n    #耗时操作结束执行回调函数\n    cb(\" 我是返回的数据\")\n  #创建一个线程，处理耗时操作threading传参args=()\n  threading.Thread(target=run,args=(callback,)).start()\n\n# 函数（回调函数）\ndef finish(data):\n  print(\"开始处理回调函数\")\n  print(\"接收到longIo的相应数据:\",data)\n  print(\"结束处理回调函数\")\n\n# 一个客户的请求\ndef reqA():\n  print(\"开始处理reqA\")\n  longIo(finish)\n  print(\"结束处理reqA\")\n\ndef reqB():\n  print(\"开始处理reqB\")\n  longIo(finish)\n  print(\"结束处理reqB\")\n\n#Tornado服务\ndef main():\n  reqA()\n  reqB()\n  while 1:\n    time.sleep(0.1)\n    pass\n\nif __name__=='__main__':\n  main()\n\n```\n\n### 协程实现异步\n\n#### 版本1\n```python\nimport time\n\n# 全局变量生成器\ngen = None\n\ndef longIo(callback):\n  def run(cb):\n    print(\"开始耗时操作\")\n    time.sleep(5)\n    try:\n      引进全局变量并且用生成器回发数据\n      global gen\n      gen.send(\"我是返回的数据\")\n    except StopIteration as e:\n      pass\n    print(\"结束耗时操作\")\n  #创建一个线程，处理耗时操作,不会影响A和B\n  threading.Thread(target=run).start()\n\n# 一个客户的请求\ndef reqA():\n  print(\"开始处理reqA\")\n  # 接受返回结果\n  # 此处相当于挂起,执行longIo,不影响执行reqB\n  res = yield longIo()\n  print(\"接收longIo的相应数据:\",res)\n  print(\"结束处理reqA\")\n\ndef reqB():\n  print(\"开始处理reqB\")\n  time.sleep(2)\n  print(\"结束处理reqB\")\n\n#Tornado服务\ndef main():\n  # 创建一个reqA的生成器\n  global gen\n  gen = reqA()\n  # 在这里真正执行reqA\n  next(gen)\n\n  reqB()\n  while 1:\n    time.sleep(0.1)\n    pass\n\nif __name__=='__main__':\n  main()\n\n```\n\n#### 版本2\n**问题**    \n> 版本1中调用reqA的时候不能将其视为一个简单的函数，而是要作为生成器来对待\n> 很明显要在主函数中要用三行调用reqA，只要用一行调用reqB。\n\n**解决办法**\n> 给reqA添加一个装饰器\n\n```python\nimport time\n\n# 全局变量生成器\ngen\n\ndef longIo(callback):\n  def run(cb):\n    print(\"开始耗时操作\")\n    time.sleep(5)\n    try:\n      引进全局变量并且用生成器回发数据\n      global gen\n      gen.send(\"我是返回的数据\")\n    except StopIteration as e:\n      pass\n    print(\"结束耗时操作\")\n  #创建一个线程，处理耗时操作,不会影响A和B\n  threading.Thread(target=run).start()\n\n# 装饰器\ndef genCoroutine(func):\n  def wrapper(*args, **kwargs):\n    global gen\n    gen = func(*args, **kwargs)\n    next(gen)\n  # 返回内部函数的时候不可以加括号，这里不可以加括号\n  return wrapper\n  \n\n# 一个客户的请求\n@genCoroutine\ndef reqA():\n  print(\"开始处理reqA\")\n  # 接受返回结果\n  # 此处相当于挂起,执行longIo,不影响执行reqB\n  res = yield longIo()\n  print(\"接收longIo的相应数据:\",res)\n  print(\"结束处理reqA\")\n\ndef reqB():\n  print(\"开始处理reqB\")\n  time.sleep(2)\n  print(\"结束处理reqB\")\n\n#Tornado服务\ndef main():\n  reqA()\n  reqB()\n  while 1:\n    time.sleep(0.1)\n    pass\n\nif __name__=='__main__':\n  main()\n```\n\n#### 版本3\n**问题**\n> 版本2中存在一个全局变量gen，需要消除\n**解决办法**\n\n```python\nimport time\n\n# 装饰器\ndef genCoroutine(func):\n  def wrapper(*args, **kwargs):\n    #reqA的生成器\n    gen1 = func()\n    #longIo的生成器\n    gen2 = next(gen1)\n    def run(g):\n      #gen2,即longIo的返回数据\n      res = next(g) \n      try:\n        gen1.send(res)#返回给reqA数据\n      except StopIteration as e:\n        pass\n    threading.Thread(target=run,args=(gen2,)).start()\n\n  # 返回内部函数的时候不可以加括号，这里不可以加括号\n  return wrapper\n  \n#这次在这里不管线程了\ndef longIo(callback):\n    print(\"开始耗时操作\")\n    time.sleep(5)\n    print(\"结束耗时操作\")\n    #要返回数据，挂起\n    yield \"我是返回的数据\"\n\n# 一个客户的请求\n@genCoroutine\ndef reqA():\n  print(\"开始处理reqA\")\n  # 接受返回结果\n  # 此处相当于挂起,执行longIo,不影响执行reqB\n  res = yield longIo()\n  print(\"接收longIo的相应数据:\",res)\n  print(\"结束处理reqA\")\n\ndef reqB():\n  print(\"开始处理reqB\")\n  time.sleep(2)\n  print(\"结束处理reqB\")\n\n#Tornado服务\ndef main():\n  reqA()\n  reqB()\n  while 1:\n    time.sleep(0.1)\n    pass\n\nif __name__=='__main__':\n  main()\n```\n-----------------------------\n","slug":"Python中的异步","published":1,"updated":"2019-07-25T18:33:19.546Z","layout":"post","photos":[],"link":"","_id":"ck2424llr002plksbej35ub5d","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><p>学Tornado的异步之前学了下Python的同步和异步机制，下面是三种实现Python中同步的方法。主要是用yield和装饰器以及threading模块实现。</p><a id=\"more\"></a><h1 id=\"python中异步的理解\"><a href=\"#python中异步的理解\" class=\"headerlink\" title=\"python中异步的理解\"></a>python中异步的理解</h1><h2 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h2><blockquote><p>按部就班的依次执行<br>如果在请求中添加一个耗时操作，则必须等耗时操作结束才继续下去<br>一般不会用同步</p></blockquote><h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>对于耗时的操作，一般会交给另一个线程处理，我们继续向下执行，当别人结束耗时操作后再将结果返回给我们</p><h3 id=\"回调函数实现异步\"><a href=\"#回调函数实现异步\" class=\"headerlink\" title=\"回调函数实现异步\"></a>回调函数实现异步</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Tornado中不用我们写这个函数</span></span><br><span class=\"line\"><span class=\"comment\"># handler获取数据（数据库、其他服务器、循环耗时）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longIo</span><span class=\"params\">(callback)</span>:</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(cb)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"开始耗时操作\"</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"结束耗时操作\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">#耗时操作结束执行回调函数</span></span><br><span class=\"line\">    cb(<span class=\"string\">\" 我是返回的数据\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">#创建一个线程，处理耗时操作threading传参args=()</span></span><br><span class=\"line\">  threading.Thread(target=run,args=(callback,)).start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 函数（回调函数）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">finish</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理回调函数\"</span>)</span><br><span class=\"line\">  print(<span class=\"string\">\"接收到longIo的相应数据:\"</span>,data)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理回调函数\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个客户的请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqA</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqA\"</span>)</span><br><span class=\"line\">  longIo(finish)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqA\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqB</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqB\"</span>)</span><br><span class=\"line\">  longIo(finish)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqB\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Tornado服务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  reqA()</span><br><span class=\"line\">  reqB()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">  main()</span><br></pre></td></tr></table></figure><h3 id=\"协程实现异步\"><a href=\"#协程实现异步\" class=\"headerlink\" title=\"协程实现异步\"></a>协程实现异步</h3><h4 id=\"版本1\"><a href=\"#版本1\" class=\"headerlink\" title=\"版本1\"></a>版本1</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局变量生成器</span></span><br><span class=\"line\">gen = <span class=\"keyword\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longIo</span><span class=\"params\">(callback)</span>:</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(cb)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"开始耗时操作\"</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">      引进全局变量并且用生成器回发数据</span><br><span class=\"line\">      <span class=\"keyword\">global</span> gen</span><br><span class=\"line\">      gen.send(<span class=\"string\">\"我是返回的数据\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> StopIteration <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">      <span class=\"keyword\">pass</span></span><br><span class=\"line\">    print(<span class=\"string\">\"结束耗时操作\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">#创建一个线程，处理耗时操作,不会影响A和B</span></span><br><span class=\"line\">  threading.Thread(target=run).start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个客户的请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqA</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqA\"</span>)</span><br><span class=\"line\">  <span class=\"comment\"># 接受返回结果</span></span><br><span class=\"line\">  <span class=\"comment\"># 此处相当于挂起,执行longIo,不影响执行reqB</span></span><br><span class=\"line\">  res = <span class=\"keyword\">yield</span> longIo()</span><br><span class=\"line\">  print(<span class=\"string\">\"接收longIo的相应数据:\"</span>,res)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqA\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqB</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqB\"</span>)</span><br><span class=\"line\">  time.sleep(<span class=\"number\">2</span>)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqB\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Tornado服务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  <span class=\"comment\"># 创建一个reqA的生成器</span></span><br><span class=\"line\">  <span class=\"keyword\">global</span> gen</span><br><span class=\"line\">  gen = reqA()</span><br><span class=\"line\">  <span class=\"comment\"># 在这里真正执行reqA</span></span><br><span class=\"line\">  next(gen)</span><br><span class=\"line\"></span><br><span class=\"line\">  reqB()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">  main()</span><br></pre></td></tr></table></figure><h4 id=\"版本2\"><a href=\"#版本2\" class=\"headerlink\" title=\"版本2\"></a>版本2</h4><p><strong>问题</strong></p><blockquote><p>版本1中调用reqA的时候不能将其视为一个简单的函数，而是要作为生成器来对待<br>很明显要在主函数中要用三行调用reqA，只要用一行调用reqB。</p></blockquote><p><strong>解决办法</strong></p><blockquote><p>给reqA添加一个装饰器</p></blockquote><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局变量生成器</span></span><br><span class=\"line\">gen</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longIo</span><span class=\"params\">(callback)</span>:</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(cb)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"开始耗时操作\"</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">      引进全局变量并且用生成器回发数据</span><br><span class=\"line\">      <span class=\"keyword\">global</span> gen</span><br><span class=\"line\">      gen.send(<span class=\"string\">\"我是返回的数据\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> StopIteration <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">      <span class=\"keyword\">pass</span></span><br><span class=\"line\">    print(<span class=\"string\">\"结束耗时操作\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">#创建一个线程，处理耗时操作,不会影响A和B</span></span><br><span class=\"line\">  threading.Thread(target=run).start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 装饰器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">genCoroutine</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> gen</span><br><span class=\"line\">    gen = func(*args, **kwargs)</span><br><span class=\"line\">    next(gen)</span><br><span class=\"line\">  <span class=\"comment\"># 返回内部函数的时候不可以加括号，这里不可以加括号</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个客户的请求</span></span><br><span class=\"line\"><span class=\"meta\">@genCoroutine</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqA</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqA\"</span>)</span><br><span class=\"line\">  <span class=\"comment\"># 接受返回结果</span></span><br><span class=\"line\">  <span class=\"comment\"># 此处相当于挂起,执行longIo,不影响执行reqB</span></span><br><span class=\"line\">  res = <span class=\"keyword\">yield</span> longIo()</span><br><span class=\"line\">  print(<span class=\"string\">\"接收longIo的相应数据:\"</span>,res)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqA\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqB</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqB\"</span>)</span><br><span class=\"line\">  time.sleep(<span class=\"number\">2</span>)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqB\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Tornado服务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  reqA()</span><br><span class=\"line\">  reqB()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">  main()</span><br></pre></td></tr></table></figure><h4 id=\"版本3\"><a href=\"#版本3\" class=\"headerlink\" title=\"版本3\"></a>版本3</h4><p><strong>问题</strong></p><blockquote><p>版本2中存在一个全局变量gen，需要消除<br><strong>解决办法</strong></p></blockquote><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 装饰器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">genCoroutine</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\">#reqA的生成器</span></span><br><span class=\"line\">    gen1 = func()</span><br><span class=\"line\">    <span class=\"comment\">#longIo的生成器</span></span><br><span class=\"line\">    gen2 = next(gen1)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(g)</span>:</span></span><br><span class=\"line\">      <span class=\"comment\">#gen2,即longIo的返回数据</span></span><br><span class=\"line\">      res = next(g) </span><br><span class=\"line\">      <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        gen1.send(res)<span class=\"comment\">#返回给reqA数据</span></span><br><span class=\"line\">      <span class=\"keyword\">except</span> StopIteration <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    threading.Thread(target=run,args=(gen2,)).start()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 返回内部函数的时候不可以加括号，这里不可以加括号</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">#这次在这里不管线程了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longIo</span><span class=\"params\">(callback)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"开始耗时操作\"</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"结束耗时操作\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">#要返回数据，挂起</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">\"我是返回的数据\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个客户的请求</span></span><br><span class=\"line\"><span class=\"meta\">@genCoroutine</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqA</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqA\"</span>)</span><br><span class=\"line\">  <span class=\"comment\"># 接受返回结果</span></span><br><span class=\"line\">  <span class=\"comment\"># 此处相当于挂起,执行longIo,不影响执行reqB</span></span><br><span class=\"line\">  res = <span class=\"keyword\">yield</span> longIo()</span><br><span class=\"line\">  print(<span class=\"string\">\"接收longIo的相应数据:\"</span>,res)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqA\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqB</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqB\"</span>)</span><br><span class=\"line\">  time.sleep(<span class=\"number\">2</span>)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqB\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Tornado服务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  reqA()</span><br><span class=\"line\">  reqB()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">  main()</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><p>学Tornado的异步之前学了下Python的同步和异步机制，下面是三种实现Python中同步的方法。主要是用yield和装饰器以及threading模块实现。</p>","more":"<h1 id=\"python中异步的理解\"><a href=\"#python中异步的理解\" class=\"headerlink\" title=\"python中异步的理解\"></a>python中异步的理解</h1><h2 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h2><blockquote><p>按部就班的依次执行<br>如果在请求中添加一个耗时操作，则必须等耗时操作结束才继续下去<br>一般不会用同步</p></blockquote><h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>对于耗时的操作，一般会交给另一个线程处理，我们继续向下执行，当别人结束耗时操作后再将结果返回给我们</p><h3 id=\"回调函数实现异步\"><a href=\"#回调函数实现异步\" class=\"headerlink\" title=\"回调函数实现异步\"></a>回调函数实现异步</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Tornado中不用我们写这个函数</span></span><br><span class=\"line\"><span class=\"comment\"># handler获取数据（数据库、其他服务器、循环耗时）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longIo</span><span class=\"params\">(callback)</span>:</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(cb)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"开始耗时操作\"</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"结束耗时操作\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">#耗时操作结束执行回调函数</span></span><br><span class=\"line\">    cb(<span class=\"string\">\" 我是返回的数据\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">#创建一个线程，处理耗时操作threading传参args=()</span></span><br><span class=\"line\">  threading.Thread(target=run,args=(callback,)).start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 函数（回调函数）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">finish</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理回调函数\"</span>)</span><br><span class=\"line\">  print(<span class=\"string\">\"接收到longIo的相应数据:\"</span>,data)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理回调函数\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个客户的请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqA</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqA\"</span>)</span><br><span class=\"line\">  longIo(finish)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqA\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqB</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqB\"</span>)</span><br><span class=\"line\">  longIo(finish)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqB\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Tornado服务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  reqA()</span><br><span class=\"line\">  reqB()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">  main()</span><br></pre></td></tr></table></figure><h3 id=\"协程实现异步\"><a href=\"#协程实现异步\" class=\"headerlink\" title=\"协程实现异步\"></a>协程实现异步</h3><h4 id=\"版本1\"><a href=\"#版本1\" class=\"headerlink\" title=\"版本1\"></a>版本1</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局变量生成器</span></span><br><span class=\"line\">gen = <span class=\"keyword\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longIo</span><span class=\"params\">(callback)</span>:</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(cb)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"开始耗时操作\"</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">      引进全局变量并且用生成器回发数据</span><br><span class=\"line\">      <span class=\"keyword\">global</span> gen</span><br><span class=\"line\">      gen.send(<span class=\"string\">\"我是返回的数据\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> StopIteration <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">      <span class=\"keyword\">pass</span></span><br><span class=\"line\">    print(<span class=\"string\">\"结束耗时操作\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">#创建一个线程，处理耗时操作,不会影响A和B</span></span><br><span class=\"line\">  threading.Thread(target=run).start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个客户的请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqA</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqA\"</span>)</span><br><span class=\"line\">  <span class=\"comment\"># 接受返回结果</span></span><br><span class=\"line\">  <span class=\"comment\"># 此处相当于挂起,执行longIo,不影响执行reqB</span></span><br><span class=\"line\">  res = <span class=\"keyword\">yield</span> longIo()</span><br><span class=\"line\">  print(<span class=\"string\">\"接收longIo的相应数据:\"</span>,res)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqA\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqB</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqB\"</span>)</span><br><span class=\"line\">  time.sleep(<span class=\"number\">2</span>)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqB\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Tornado服务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  <span class=\"comment\"># 创建一个reqA的生成器</span></span><br><span class=\"line\">  <span class=\"keyword\">global</span> gen</span><br><span class=\"line\">  gen = reqA()</span><br><span class=\"line\">  <span class=\"comment\"># 在这里真正执行reqA</span></span><br><span class=\"line\">  next(gen)</span><br><span class=\"line\"></span><br><span class=\"line\">  reqB()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">  main()</span><br></pre></td></tr></table></figure><h4 id=\"版本2\"><a href=\"#版本2\" class=\"headerlink\" title=\"版本2\"></a>版本2</h4><p><strong>问题</strong></p><blockquote><p>版本1中调用reqA的时候不能将其视为一个简单的函数，而是要作为生成器来对待<br>很明显要在主函数中要用三行调用reqA，只要用一行调用reqB。</p></blockquote><p><strong>解决办法</strong></p><blockquote><p>给reqA添加一个装饰器</p></blockquote><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局变量生成器</span></span><br><span class=\"line\">gen</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longIo</span><span class=\"params\">(callback)</span>:</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(cb)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"开始耗时操作\"</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">      引进全局变量并且用生成器回发数据</span><br><span class=\"line\">      <span class=\"keyword\">global</span> gen</span><br><span class=\"line\">      gen.send(<span class=\"string\">\"我是返回的数据\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> StopIteration <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">      <span class=\"keyword\">pass</span></span><br><span class=\"line\">    print(<span class=\"string\">\"结束耗时操作\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">#创建一个线程，处理耗时操作,不会影响A和B</span></span><br><span class=\"line\">  threading.Thread(target=run).start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 装饰器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">genCoroutine</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> gen</span><br><span class=\"line\">    gen = func(*args, **kwargs)</span><br><span class=\"line\">    next(gen)</span><br><span class=\"line\">  <span class=\"comment\"># 返回内部函数的时候不可以加括号，这里不可以加括号</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个客户的请求</span></span><br><span class=\"line\"><span class=\"meta\">@genCoroutine</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqA</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqA\"</span>)</span><br><span class=\"line\">  <span class=\"comment\"># 接受返回结果</span></span><br><span class=\"line\">  <span class=\"comment\"># 此处相当于挂起,执行longIo,不影响执行reqB</span></span><br><span class=\"line\">  res = <span class=\"keyword\">yield</span> longIo()</span><br><span class=\"line\">  print(<span class=\"string\">\"接收longIo的相应数据:\"</span>,res)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqA\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqB</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqB\"</span>)</span><br><span class=\"line\">  time.sleep(<span class=\"number\">2</span>)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqB\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Tornado服务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  reqA()</span><br><span class=\"line\">  reqB()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">  main()</span><br></pre></td></tr></table></figure><h4 id=\"版本3\"><a href=\"#版本3\" class=\"headerlink\" title=\"版本3\"></a>版本3</h4><p><strong>问题</strong></p><blockquote><p>版本2中存在一个全局变量gen，需要消除<br><strong>解决办法</strong></p></blockquote><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 装饰器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">genCoroutine</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\">#reqA的生成器</span></span><br><span class=\"line\">    gen1 = func()</span><br><span class=\"line\">    <span class=\"comment\">#longIo的生成器</span></span><br><span class=\"line\">    gen2 = next(gen1)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(g)</span>:</span></span><br><span class=\"line\">      <span class=\"comment\">#gen2,即longIo的返回数据</span></span><br><span class=\"line\">      res = next(g) </span><br><span class=\"line\">      <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        gen1.send(res)<span class=\"comment\">#返回给reqA数据</span></span><br><span class=\"line\">      <span class=\"keyword\">except</span> StopIteration <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    threading.Thread(target=run,args=(gen2,)).start()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 返回内部函数的时候不可以加括号，这里不可以加括号</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">#这次在这里不管线程了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longIo</span><span class=\"params\">(callback)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"开始耗时操作\"</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"结束耗时操作\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">#要返回数据，挂起</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">\"我是返回的数据\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个客户的请求</span></span><br><span class=\"line\"><span class=\"meta\">@genCoroutine</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqA</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqA\"</span>)</span><br><span class=\"line\">  <span class=\"comment\"># 接受返回结果</span></span><br><span class=\"line\">  <span class=\"comment\"># 此处相当于挂起,执行longIo,不影响执行reqB</span></span><br><span class=\"line\">  res = <span class=\"keyword\">yield</span> longIo()</span><br><span class=\"line\">  print(<span class=\"string\">\"接收longIo的相应数据:\"</span>,res)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqA\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reqB</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  print(<span class=\"string\">\"开始处理reqB\"</span>)</span><br><span class=\"line\">  time.sleep(<span class=\"number\">2</span>)</span><br><span class=\"line\">  print(<span class=\"string\">\"结束处理reqB\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Tornado服务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  reqA()</span><br><span class=\"line\">  reqB()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">  main()</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"Arch安装和Gnome配置教程","urlname":"archLinux-gnome-install","comments":1,"mathjax":false,"date":"2019-07-20T13:13:37.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n# 前言\n两天前,我的arch,被我不小心升级glibc搞坏了..很久前就想重装下系统的,因此也就懒得重新再修复了,直接重装一个也挺好.\n\n但是!隔了这么久重装系统搞得我心态都快崩了,各种找资料.\n现在终于弄好啦,还是决定记录一下,以后就不用那么担心教程靠不靠谱\n{% endnote %}\n<!--more-->\n\n# 说明\n- 已有系统: Win10\n- 安装系统: archlinux-2019.07.1-x86_64\n- 安装磁盘: 机械硬盘的后半部分(前半部分是windows的数据)\n- 启动方式: UEFI\n- 分区格式: GPT\n- 桌面系统: Gnome3\n- 参考链接: [ArchWiki](https://wiki.archlinux.org/index.php/Installation_guide_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87)\n- 参考链接: [Arch安装教程](http://blog.lucode.net/linux/archlinux-install-tutorial.html)\n- 参考链接: [Arch安装图文教程](https://blog.csdn.net/r8l8q8/article/details/76516523)\n\n\n# 准备工作\n## 准备安装介质\n说的简单点就是为制作启动盘做准备,安装系统当然需要这个系统的镜像文件.\n可以到[Arch Download](https://www.archlinux.org/download/)这里下载镜像\n一直往下可以看到CHINA的标志, 推荐选择163的源下载,[链接在这](http://mirrors.163.com/archlinux/iso/2019.07.01/)\n\n## 制作LiveCD\n如果在windows环境制作的,可以使用[USBwriter](http://sourceforge.net/p/usbwriter/wiki/Documentation/),或者其他一些工具\n\n因为我电脑有现成的fedora media writer,所以用这个也可以制作\n\n## 网络\n身边需要可以连接的网络,有线网或者无线网\n\n如果没有wifi可以连,当然,这个wifi不能是校园网,不然没办法直接命令行连接.\n没wifi可以手机开热点啊,hhh\n\n## 磁盘空间\n从widows盘那边分出一部分给linux,我选择先压缩卷,然后新建简单卷,之后的安装就安装在这个简单卷上.\n\n选择新建简单卷还是因为安装的时候能够看的更清楚第一个分区的开始扇区\n\n## 设置usb启动\n如果以前设置过usb启动优先就不用管了\n\n进入BIOS,设置开机选项,调整开机顺序,让usb启动排在第一位\n完事之后就可以直接插入你的U盘,开始装系统!\n\n# 安装准备\n## 联网\n后面需要安装很多东西,所以最好先联网\n\n```\n# wifi-menu\n```\n\n会跳出来wifi选择的页面,自己选之前准备好的wifi连上就成\n\n## 编辑mirrorlist\n目的是为了后面下载的时候速度能快点,国外的镜像站太慢啦.\n\n```\n# vi /etc/pacman.d/mirrorlist\n# 按下面描述修改mirrorlist\n# pacman -Syy\n```\n\n我默认你已经会vim了,找163关键词,然后把163的镜像站复制粘贴到第一个镜像站前面.一堆的网址就是镜像站啦.\n\n如果不放心,还可以找关键词China,把其他的ustc之类的都放前面去.\n记得,保存后`pacman -Syy`\n\n## 分区\n**最重要的一步来咯**\n我选择了UEFI启动,对应使用GPT分区\n我的机械硬盘是/dev/sdb\n\n### 分区规划\n创建4个分区如下\n- /boot　200M　/dev/sdb3\n- /swap　8G　　/dev/sdb4\n- /root　60G　 /dev/sdb5\n- /home　150G　/dev/sdb6\n\n别问我为什么/root设置这么大，为什么人家都推荐30G左右...\n重装的其中一个原因就是/root爆了，扩容又麻烦，原本设置的是40G\n/swap设置的是和我物理内存一样的大小\n\n### 查看磁盘情况\n确定你要安装的磁盘是sd几，然后使用gdisk划分磁盘\n\n```\n# fdisk -l\n```\n你看到的东西应该类似下面的\n> Disk /dev/sdb: 931.53 GiB, 1000204886016 bytes, 1953525168 sectors\n> Disk model: HGST HTS721010A9\n> Units: sectors of 1 * 512 = 512 bytes\n> Sector size (logical/physical): 512 bytes / 4096 bytes\n> I/O size (minimum/optimal): 4096 bytes / 4096 bytes\n> Disklabel type: gpt\n> Disk identifier: 94717E4F-9437-4814-96AA-5CD870012F36\n> \n> Device          Start        End   Sectors  Size Type\n> /dev/sdb1        2048  587202559 587200512  280G Microsoft basic data\n> /dev/sdb2   587202560 1468008447 880805888  420G Microsoft basic data\n> /dev/sdb3  1468008448 1468418047    409600  200M EFI System\n> /dev/sdb4  1468418048 1485195263  16777216    8G Linux swap\n> /dev/sdb5  1485195264 1611024383 125829120   60G Linux root (x86)\n> /dev/sdb6  1611024384 1925597183 314572800  150G Linux home\n> \n> \n> Disk /dev/sda: 119.25 GiB, 128035676160 bytes, 250069680 sectors\n> Disk model: SanDisk SD8SNAT-\n> Units: sectors of 1 * 512 = 512 bytes\n> Sector size (logical/physical): 512 bytes / 4096 bytes\n> I/O size (minimum/optimal): 4096 bytes / 4096 bytes\n> Disklabel type: gpt\n> Disk identifier: A7EA8BD9-4B05-4419-AEFA-7B4F01E54CC2\n> \n> Device         Start       End   Sectors   Size Type\n> /dev/sda1       2048    534527    532480   260M EFI System\n> /dev/sda2     534528    567295     32768    16M Microsoft reserved\n> /dev/sda3     567296 246266737 245699442 117.2G Microsoft basic data\n> /dev/sda4  246267904 250058751   3790848   1.8G Windows recovery environment\n\n通过容量判断我要安装的磁盘是sda还是sdb\n\n通过Type可以看到sdb1和sdb2都是Microsoft basic data,那是我的D盘和F盘\n\n### 分区\n\n```\ngdisk /dev/sdb\n```\n记得这里sdb要换成你自己的sd..\n\ngdisk的使用很简单，先使用？打印帮助，使用p打印分区表\n\n如果你的磁盘是空的，使用o新建一个gpt分区表，如果不是空磁盘，别这么做\n\n接着使用ｎ命令新建一个磁盘分区,然后输入分区号，默认回车就可以\n然后设置开始扇区，如果没啥意外，直接回车\n设置结束扇区，可以使用**+60G**这样的方式，不用自己计算，很方便\n接着设置Hex code, 这个很重要,可以使用L查看所有的codes,下面列出要用的\n> /boot: EF00\n> /swap: 8200\n> /root: 8303\n> /home: 8302\n\n### 格式化分区\n格式化EFI分区/boot\n\n```\n# mkfs.fat -F32 /dev/sdb3\n```\n\n格式化/root和/home\n\n```\n# mkfs.ext4 /dev/sdb5\n# mkfs.ext4 /dev/sdb6\n```\n\n开启swap分区/swap\n\n```\n# mkwsap /dev/sdb4\n# swapon /dev/sdb4\n```\n\n### 挂载分区\n一般是将根分区/挂载到/mnt下,然后将/boot和/home挂载到/mnt/boot和/mnt/home\n\n```\n# mount /dev/sdb5 /mnt\n# mkdir /mnt/{boot, home}\n# mount /dev/sdb6 /mnt/home\n# mount /dev/sdb3 /mnt/boot\n```\n\n# 安装基本系统\n## 部署基本系统\n\n```\n# pacstrap -i /mnt base base-devel net-tools\n```\n这里的net-tools提供了netstat和ifconfig等命令,可以选择不装,差别不大\n\n## 生成fstab\nfstab中记录了挂载信息,使用下面命令生成\n\n```\n# genfstab -U -p /mnt >> /mnt/etc/fstab\n```\n使用`cat /mnt/etc/fstab`检查\n\n## 基本系统设置\n### 切换到新系统\n\n```\n# arch-chroot /mnt /bin/bash\n```\n### 设置locale\n\n```\n# vim /etc/locale.gen\n```\n这里是配置本地语言环境,起码要中英文的UTF-8,所以把`en_US.UTF-8\nUTF-8`和`zh_CN.UTF-8 UTF-8`取消注释, 然后保存退出\n然后执行: \n\n```\n# locale-gen\n# # echo LANG=en_US.UTF-8 > /etc/locale.conf\n```\n\n### 设置时区\n执行如下代码:\n\n```\n# ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n```\n\n### 设置硬件时间\n执行如下代码:\n\n```\n# hwclock --systohc --utc\n```\n\n### 设置主机名\n建议使用小写\n\n```\n# echo 主机名 > /etc/hostname\n# vim /etc/hosts\n```\nhosts文件中有如下内容\n> 127.0.0.1\tlocalhost\n> ::1\t\tlocalhost\n> 127.0.1.1\tmyhostname.localdomain\tmyhostname\n\n如果系统有一个永久的 IP 地址，请使用这个永久的 IP 地址而不是 127.0.1.1\n\n### 生成Initramfs\n注意,这步只对 LVM、 system encryption 或 RAID有效\n正常情况下,在执行pacstrap的时候已经安装linux,并且mkinitcpio自动运行\n\n```\n# mkinitcpio -p linux\n```\n\n### 用户设置\n修改root用户密码,并且创建一个新用户,同样修改密码\n建议root密码和用户密码不要设置成一样的,平时用普通用户就可以\n\n**如果需要用root,必须清楚自己每一步会有什么后果!**\n\n```\n# passwd\n# ****你的密码****\n# useradd -m -g users -s /bin/bash 用户名\n# passwd 用户名\n# ****用户密码****\n```\n\n为用户添加sudo权限\n\n```\n# vim /etc/sudoers\n# 在root ALL=(ALL) ALL下面添加如下内容\n用户名 ALL=(ALL) ALL\n\n# 保存退出\n# :wq\n```\n\n### 配置UEFI引导(重点)\n(这里网上看到的都有点不太一样, 导致我安装完之后电脑一直找不到Linux的引导项,\n一直进不来linux, 后来在archwiki上看到了正确的方法, 记录如下)\n\n这里使用UEFI引导,而不是BIOS,两者的区别自行百度\n\n关于启动加载器可以自己查看[ArchWiki](https://wiki.archlinux.org/index.php/Arch_boot_process_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%99%A8),里面讲的很清楚\n\n我们选择GRUB [ArchWiki](https://wiki.archlinux.org/index.php/GRUB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)来引导系统,具体过程在archwiki中也讲的很清楚,这里不多赘述\n\n安装必要软件包, efibootmgr是efi引导才要用的, ntfs-3g是为了能够识别windows的ntfs文件系统\n\n```\n# pacman -S dosfstools grub efibootmgr ntfs-3g\n```\n**注意,我们选择的EFI系统分区是之前的/boot, 选择的启动引导器标识是GRUB,\n不懂可以不管, 直接执行**\n\n执行下面的命令来将 GRUB EFI 应用 `grubx64.efi` 安装到\n`/boot/EFI/GRUB/`，并将其模块安装到 `/boot/grub/x86_64-efi/`。\n\n```\n# grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB\n```\n\n安装完之后GRUB目录位于在/boot/grub/\n\n然后执行下面命令生成主配置文件`grub.cfg`\n\n```\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\n在/boot目录使用`tree -d`会有如下内容\n> .\n> ├── EFI\n> │   └── GRUB\n> ├── grub\n> │   ├── fonts\n> │   ├── themes\n> │   │   └── starfield\n> │   └── x86_64-efi\n> └── syslinux\n\n### 退出chroot重启\n笔记本退出之前要先安装dialog\n\n```\n# pacman -S iw wpa_supplicant dialog\n# exit\n# umount /mnt/{boot, home}\n# umount /mnt\n# reboot\n```\n\n其实不重启也可以, 这时候还连着网, 直接把需要安装的一次性装了,\n然后直接进到图形界面, 不然联网会很麻烦. 图形界面可以用networkmanager连网\n\n# 驱动安装\n## 显卡驱动\n具体的驱动匹配表可以查看[ArchWiki](https://wiki.archlinux.org/index.php/Xorg_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%AE%89%E8%A3%85)\n\n再次折腾了一次Nvidia驱动, 失败告终, 难受\n显卡驱动默认的vesa可以兼容大部分显卡了\n我是双显卡, 安装了下面三个显卡驱动\n\n```\n# pacman -S xf86-video-vesa     通用驱动\n# pacman -S xf86-video-intel    intel集显驱动\n# pacman -S xf86-video-nouveau  开源的N卡驱动\n```\n\n## 触摸板驱动\n\n```\n# pacman -S xf86-input-synaptics\n```\n\n## Xorg显示服务器\nxorg是其他例如xfce和gnome, kde一些桌面环境的基础, 提供图形环境基本框架\n\n```\n# pacman -S xorg\n```\n\n# 安装Gnome以及配置\n## Gnome和优化工具\ngnome是基本环境, gnome-extra是一个包合集, 里面有一些软件啥的,\n如果是喜欢干干净净的可以不装extra, 以后缺啥装啥\n\ngnome-tweak-tool是gnome桌面美化的很重要的工具\n\n```\n# pacman -S gnome gnome-extra gnome-tweak-tool\n```\n\n## 窗口管理服务gdm\ngnome一般用gdm, deepin用lightdm, xfce使用lxdm, kde使用sddm\n我们安装gdm之后要启用它\n\n```\n# pacman -S gdm\n# systemctl enable gdm\n```\n\n## 网络管理工具NetworkManager\n这一步做完之后就可以重启进入电脑啦, 其他的东西, 最好进入图形界面再做,\n边做边看效果\n\n```\n# pacman -S networkmanager\n# systemctl enable NetworkManager\n# reboot\n```\n\n## 添加archlinux-cn源\n官方仓库里面有很多我们常用但是没有的, 添加这个源会好很多\n\n```\n# sudo vim /etc/pacman.conf\n# 在末尾添加如下内容\n[archlinuxcn]\nSigLevel=Never\nServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch\n```\n\n# 其他常用软件和工具安装\n## 自带商店gnome-software\n可以自己先逛逛自带的gnome-software, 商店里面有很多工具类的\n\n如果发现商店打开后提示No application data found.可以按照如下操作恢复\n1. 在设置中将语言改成其他语言,英到中\n2. 重启\n3. 将语言改回原来的, 中到英\n4. 重启\n这样就可以啦\n\n## 字体\n下面这几个字体一般够用了, ttf-consolas-with-yahei是consolas和yahei结合体,\n英文consolas, 中文yahei\n\n```\n# sudo pacman -S ttf-consolas-with-yahei\n# sudo pacman -S wqy-microhei tf-dejavu wqy-zenhei\n```\n\n## fcitx输入法\n\n```\n# pacman -S fcitx-im fcitx fcitx-configtool\n# pacman -S fcitx-cloudpinyin fcitx-sogoupinyin\n```\n\n安装完之后还需要编辑配置文件, 具体可以看[ArchWiki](https://wiki.archlinux.org/index.php/Fcitx)\n一些常见的问题wiki里面也都说到了,所以如果下面的过程出现未知错误, 移步wiki查看\n\n修改配置文件, gnome on wayland, 无法读取~/.xprofile, 所以修改/etc/environment\n如果在登陆的时候选择Xorg的Gnome, 可以新建~/.xprofile, 添加如下内容\n然后重启生效\n\n```\n# vim /etc/environment\n# 添加如下内容\nGTK_IM_MODULE=fcitx\nQT_IM_MODULE=fcitx\nXMODIFIERS=@im=fcitx\n# reboot\n```\n\n使用fcitx-configtool进行进一步配置, 启用cloudpinyin等\n\n```\n# fcitx-configtool\n# 在input method那里点加号, 添加Pinyin\n# 在global-config进行全局配置\n# 在Apperance进行字体大小调整和状态显示\n# Addon进行插件管理, 双击插件进行设置\n```\n\n安装皮肤, 这里推荐一款简单好看的fcitx-skin-material\n\n```\n# sudo pacman -S fcitx-skin-material\n```\n\n如果出现在gnome-terminal中Ctrl+Space调不出fcitx\n\n```\n# gsettings set org.gnome.settings-daemon.plugins.xsettings overrides \"{'Gtk/IMModule':<'fcitx'>}\"\n```\n\n## 安装yaourt\n安装yaourt这个工具来使用AUR\n\n```\n# sudo pacman -S yaourt\n```\n\n## 安装oh-my-fish\n首先要安装fish, 相对于bash来说, 好用太多啦\n\n```\n# sudo pacman -S fish\n```\n然后去github上找到[oh-my-fish](https://github.com/oh-my-fish/oh-my-fish),\nREADME上说的很清楚很详细. 下面通过git安装\n\n```\n# with git\n# git clone https://github.com/oh-my-fish/oh-my-fish\n# cd oh-my-fish\n# bin/install --offline\n```\n\n然后安装主题, 可以自己去github上挑选, [传送门](https://github.com/oh-my-fish/oh-my-fish/blob/master/docs/Themes.md)\n我这里安装**batman**这个主题\n\n```\n# omf install batman\n# omf theme batman\n```\n编辑配置文件, 设置一些全局变量方便使用\n\n```\n# vim $OMF_CONFIG/init.fish\n# 添加你的变量和function\n# 例如\n# set -xg dow $HOME/Documents/\n# function c\n#   clear\n# end\n```\n\nfish的使用请\n\n## 浏览器\nfirefox和chrome我都用\n\n```\n# sudo pacman -S firefox google-chrome\n```\n\n## wps-office\n\n```\n# sudo pacman -S wps-office\n```\n\n## 音乐和视频\n网易云和vlc, 以及视频解码包\n\n```\n# sudo pacman -S netease-cloud-music\n# sudo pacman -S vlc gstreamer0.10-plugins\n```\n## 压缩和解压\ntar unzip zip unrar rar 一般用tar就足够啦\n\n```\n# sudo pacman -S tar unzip zip unrar rar\n```\n\n# Gnome桌面美化\n推荐自己去[Gnome-Look](https://www.gnome-look.org/)找喜欢的主题和图标样式之类的\n## GTK主题\n我使用的是[flat-remix-blue](https://www.gnome-look.org/p/1214931/)\n\n安装步骤\n- [下载主题](https://www.gnome-look.org/p/1214931/startdownload?file_id=1563444013&file_name=05-Flat-Remix-GTK-Blue-Dark_20190718.tar.xz&file_type=application/x-xz&file_size=480876)\n- 解压 `tar -xvf 05-Flat-Remix-GTK-Blue-Dark_20190718.tar.xz`\n- 将Flat-Remix-GTK-Blue-Dark目录放到~/.themes目录下 `mv Flat-Remix-GTK-Blue-Dark/ ~/.themes/`\n- 在gnome-tweaks里面启用\n\n## Gnome-Shell主题\n我使用的是[Flat Remix GNOME/Ubuntu/GDM theme](https://www.gnome-look.org/p/1013030/)\n\n安装步骤\n- [下载shell主题](https://www.gnome-look.org/p/1013030/)\n- 解压 `tar -xvf Flat-Remix-Dark-fullPanel_20190616.tar.xz`\n- 将其移动到~/.themes目录下\n- 在gnome-tweaks里面的Extensions里面, 将User themes启用, 重启gnome-tweaks\n- 在gnome-tweaks里面选择shell主题\n\n## GDM主题\n推荐[High_Ubunterra](https://www.gnome-look.org/p/1207015/)\n\n安装步骤\n- 下载主题\n- 解压\n- cd High_Ubunterra_DD-2.4(noPass)\n- chmod +x install.sh\n- ./install.sh\n\n## icon主题\n推荐[Tela Icon Theme](https://www.gnome-look.org/p/1279924/)\n可以自己选择目录样式的颜色, 我安装的是manjaro\n具体可以看[github](https://github.com/vinceliuice/Tela-icon-theme)\n\n安装步骤\n- git clone https://github.com/vinceliuice/Tela-icon-theme.git\n- cd Tela-icon-theme\n- ./install.sh -n Tela-manjaro\n\n## screenfetch\nscreenfetch可以在终端里输出你的系统logo和状态。\n如果需要打开终端自动输出, 可以在~/.bashrc添加: screenfetch\n\n```\n# sudo pacman -S screenfetch\n```\n\n## dock栏\n既然是mac风, 那肯定还是要有dock比较好看, gnome on wayland\n安装dash-to-dock插件, 具体参考[安装文档](https://micheleg.github.io/dash-to-dock/download.html#installation-from-source)\n\n安装方法\n1. 安装包解压缩后，重命名（删除邮箱后面的字符）后复制到目录~/.local/share/gnome-shell/extensions/下，然后重启 GNOME，再打开 Tweaks，应该就能在Extensions上看到 \n2. 下载github上的源码包,然后make, make install, 重启gnome, 参考[README](https://github.com/micheleg/dash-to-dock)\n\n## gnome-terminal背景透明\n\n```\n# yaourt -S gnome-terminal-transparency\n```\n安装过程会提示和gnome-terminal冲突,确认删除就可以.\n然后重启gnome-terminal, preference里面可以看到背景透明度设置\n\n# 结语\n写了很多, 妈妈再也不用担心我重装系统啦!\n作为一个参考吧, 以后总会因为各种原因需要重装. \n所以记录一下, 也分享给新人使用, 岂不乐哉\n\n---------\n","source":"_posts/arch安装和gnome配置教程.md","raw":"---\ntitle: Arch安装和Gnome配置教程\ntags:\n  - Arch\n  - Gnome\n  - UEFI\n  - GPT\n  - 双系统\n  - Install\ncategories:\n  - Linux\nurlname: archLinux-gnome-install\ncomments: true\nmathjax: false\ndate: 2019-07-20 21:13:37\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n# 前言\n两天前,我的arch,被我不小心升级glibc搞坏了..很久前就想重装下系统的,因此也就懒得重新再修复了,直接重装一个也挺好.\n\n但是!隔了这么久重装系统搞得我心态都快崩了,各种找资料.\n现在终于弄好啦,还是决定记录一下,以后就不用那么担心教程靠不靠谱\n{% endnote %}\n<!--more-->\n\n# 说明\n- 已有系统: Win10\n- 安装系统: archlinux-2019.07.1-x86_64\n- 安装磁盘: 机械硬盘的后半部分(前半部分是windows的数据)\n- 启动方式: UEFI\n- 分区格式: GPT\n- 桌面系统: Gnome3\n- 参考链接: [ArchWiki](https://wiki.archlinux.org/index.php/Installation_guide_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87)\n- 参考链接: [Arch安装教程](http://blog.lucode.net/linux/archlinux-install-tutorial.html)\n- 参考链接: [Arch安装图文教程](https://blog.csdn.net/r8l8q8/article/details/76516523)\n\n\n# 准备工作\n## 准备安装介质\n说的简单点就是为制作启动盘做准备,安装系统当然需要这个系统的镜像文件.\n可以到[Arch Download](https://www.archlinux.org/download/)这里下载镜像\n一直往下可以看到CHINA的标志, 推荐选择163的源下载,[链接在这](http://mirrors.163.com/archlinux/iso/2019.07.01/)\n\n## 制作LiveCD\n如果在windows环境制作的,可以使用[USBwriter](http://sourceforge.net/p/usbwriter/wiki/Documentation/),或者其他一些工具\n\n因为我电脑有现成的fedora media writer,所以用这个也可以制作\n\n## 网络\n身边需要可以连接的网络,有线网或者无线网\n\n如果没有wifi可以连,当然,这个wifi不能是校园网,不然没办法直接命令行连接.\n没wifi可以手机开热点啊,hhh\n\n## 磁盘空间\n从widows盘那边分出一部分给linux,我选择先压缩卷,然后新建简单卷,之后的安装就安装在这个简单卷上.\n\n选择新建简单卷还是因为安装的时候能够看的更清楚第一个分区的开始扇区\n\n## 设置usb启动\n如果以前设置过usb启动优先就不用管了\n\n进入BIOS,设置开机选项,调整开机顺序,让usb启动排在第一位\n完事之后就可以直接插入你的U盘,开始装系统!\n\n# 安装准备\n## 联网\n后面需要安装很多东西,所以最好先联网\n\n```\n# wifi-menu\n```\n\n会跳出来wifi选择的页面,自己选之前准备好的wifi连上就成\n\n## 编辑mirrorlist\n目的是为了后面下载的时候速度能快点,国外的镜像站太慢啦.\n\n```\n# vi /etc/pacman.d/mirrorlist\n# 按下面描述修改mirrorlist\n# pacman -Syy\n```\n\n我默认你已经会vim了,找163关键词,然后把163的镜像站复制粘贴到第一个镜像站前面.一堆的网址就是镜像站啦.\n\n如果不放心,还可以找关键词China,把其他的ustc之类的都放前面去.\n记得,保存后`pacman -Syy`\n\n## 分区\n**最重要的一步来咯**\n我选择了UEFI启动,对应使用GPT分区\n我的机械硬盘是/dev/sdb\n\n### 分区规划\n创建4个分区如下\n- /boot　200M　/dev/sdb3\n- /swap　8G　　/dev/sdb4\n- /root　60G　 /dev/sdb5\n- /home　150G　/dev/sdb6\n\n别问我为什么/root设置这么大，为什么人家都推荐30G左右...\n重装的其中一个原因就是/root爆了，扩容又麻烦，原本设置的是40G\n/swap设置的是和我物理内存一样的大小\n\n### 查看磁盘情况\n确定你要安装的磁盘是sd几，然后使用gdisk划分磁盘\n\n```\n# fdisk -l\n```\n你看到的东西应该类似下面的\n> Disk /dev/sdb: 931.53 GiB, 1000204886016 bytes, 1953525168 sectors\n> Disk model: HGST HTS721010A9\n> Units: sectors of 1 * 512 = 512 bytes\n> Sector size (logical/physical): 512 bytes / 4096 bytes\n> I/O size (minimum/optimal): 4096 bytes / 4096 bytes\n> Disklabel type: gpt\n> Disk identifier: 94717E4F-9437-4814-96AA-5CD870012F36\n> \n> Device          Start        End   Sectors  Size Type\n> /dev/sdb1        2048  587202559 587200512  280G Microsoft basic data\n> /dev/sdb2   587202560 1468008447 880805888  420G Microsoft basic data\n> /dev/sdb3  1468008448 1468418047    409600  200M EFI System\n> /dev/sdb4  1468418048 1485195263  16777216    8G Linux swap\n> /dev/sdb5  1485195264 1611024383 125829120   60G Linux root (x86)\n> /dev/sdb6  1611024384 1925597183 314572800  150G Linux home\n> \n> \n> Disk /dev/sda: 119.25 GiB, 128035676160 bytes, 250069680 sectors\n> Disk model: SanDisk SD8SNAT-\n> Units: sectors of 1 * 512 = 512 bytes\n> Sector size (logical/physical): 512 bytes / 4096 bytes\n> I/O size (minimum/optimal): 4096 bytes / 4096 bytes\n> Disklabel type: gpt\n> Disk identifier: A7EA8BD9-4B05-4419-AEFA-7B4F01E54CC2\n> \n> Device         Start       End   Sectors   Size Type\n> /dev/sda1       2048    534527    532480   260M EFI System\n> /dev/sda2     534528    567295     32768    16M Microsoft reserved\n> /dev/sda3     567296 246266737 245699442 117.2G Microsoft basic data\n> /dev/sda4  246267904 250058751   3790848   1.8G Windows recovery environment\n\n通过容量判断我要安装的磁盘是sda还是sdb\n\n通过Type可以看到sdb1和sdb2都是Microsoft basic data,那是我的D盘和F盘\n\n### 分区\n\n```\ngdisk /dev/sdb\n```\n记得这里sdb要换成你自己的sd..\n\ngdisk的使用很简单，先使用？打印帮助，使用p打印分区表\n\n如果你的磁盘是空的，使用o新建一个gpt分区表，如果不是空磁盘，别这么做\n\n接着使用ｎ命令新建一个磁盘分区,然后输入分区号，默认回车就可以\n然后设置开始扇区，如果没啥意外，直接回车\n设置结束扇区，可以使用**+60G**这样的方式，不用自己计算，很方便\n接着设置Hex code, 这个很重要,可以使用L查看所有的codes,下面列出要用的\n> /boot: EF00\n> /swap: 8200\n> /root: 8303\n> /home: 8302\n\n### 格式化分区\n格式化EFI分区/boot\n\n```\n# mkfs.fat -F32 /dev/sdb3\n```\n\n格式化/root和/home\n\n```\n# mkfs.ext4 /dev/sdb5\n# mkfs.ext4 /dev/sdb6\n```\n\n开启swap分区/swap\n\n```\n# mkwsap /dev/sdb4\n# swapon /dev/sdb4\n```\n\n### 挂载分区\n一般是将根分区/挂载到/mnt下,然后将/boot和/home挂载到/mnt/boot和/mnt/home\n\n```\n# mount /dev/sdb5 /mnt\n# mkdir /mnt/{boot, home}\n# mount /dev/sdb6 /mnt/home\n# mount /dev/sdb3 /mnt/boot\n```\n\n# 安装基本系统\n## 部署基本系统\n\n```\n# pacstrap -i /mnt base base-devel net-tools\n```\n这里的net-tools提供了netstat和ifconfig等命令,可以选择不装,差别不大\n\n## 生成fstab\nfstab中记录了挂载信息,使用下面命令生成\n\n```\n# genfstab -U -p /mnt >> /mnt/etc/fstab\n```\n使用`cat /mnt/etc/fstab`检查\n\n## 基本系统设置\n### 切换到新系统\n\n```\n# arch-chroot /mnt /bin/bash\n```\n### 设置locale\n\n```\n# vim /etc/locale.gen\n```\n这里是配置本地语言环境,起码要中英文的UTF-8,所以把`en_US.UTF-8\nUTF-8`和`zh_CN.UTF-8 UTF-8`取消注释, 然后保存退出\n然后执行: \n\n```\n# locale-gen\n# # echo LANG=en_US.UTF-8 > /etc/locale.conf\n```\n\n### 设置时区\n执行如下代码:\n\n```\n# ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n```\n\n### 设置硬件时间\n执行如下代码:\n\n```\n# hwclock --systohc --utc\n```\n\n### 设置主机名\n建议使用小写\n\n```\n# echo 主机名 > /etc/hostname\n# vim /etc/hosts\n```\nhosts文件中有如下内容\n> 127.0.0.1\tlocalhost\n> ::1\t\tlocalhost\n> 127.0.1.1\tmyhostname.localdomain\tmyhostname\n\n如果系统有一个永久的 IP 地址，请使用这个永久的 IP 地址而不是 127.0.1.1\n\n### 生成Initramfs\n注意,这步只对 LVM、 system encryption 或 RAID有效\n正常情况下,在执行pacstrap的时候已经安装linux,并且mkinitcpio自动运行\n\n```\n# mkinitcpio -p linux\n```\n\n### 用户设置\n修改root用户密码,并且创建一个新用户,同样修改密码\n建议root密码和用户密码不要设置成一样的,平时用普通用户就可以\n\n**如果需要用root,必须清楚自己每一步会有什么后果!**\n\n```\n# passwd\n# ****你的密码****\n# useradd -m -g users -s /bin/bash 用户名\n# passwd 用户名\n# ****用户密码****\n```\n\n为用户添加sudo权限\n\n```\n# vim /etc/sudoers\n# 在root ALL=(ALL) ALL下面添加如下内容\n用户名 ALL=(ALL) ALL\n\n# 保存退出\n# :wq\n```\n\n### 配置UEFI引导(重点)\n(这里网上看到的都有点不太一样, 导致我安装完之后电脑一直找不到Linux的引导项,\n一直进不来linux, 后来在archwiki上看到了正确的方法, 记录如下)\n\n这里使用UEFI引导,而不是BIOS,两者的区别自行百度\n\n关于启动加载器可以自己查看[ArchWiki](https://wiki.archlinux.org/index.php/Arch_boot_process_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%99%A8),里面讲的很清楚\n\n我们选择GRUB [ArchWiki](https://wiki.archlinux.org/index.php/GRUB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)来引导系统,具体过程在archwiki中也讲的很清楚,这里不多赘述\n\n安装必要软件包, efibootmgr是efi引导才要用的, ntfs-3g是为了能够识别windows的ntfs文件系统\n\n```\n# pacman -S dosfstools grub efibootmgr ntfs-3g\n```\n**注意,我们选择的EFI系统分区是之前的/boot, 选择的启动引导器标识是GRUB,\n不懂可以不管, 直接执行**\n\n执行下面的命令来将 GRUB EFI 应用 `grubx64.efi` 安装到\n`/boot/EFI/GRUB/`，并将其模块安装到 `/boot/grub/x86_64-efi/`。\n\n```\n# grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB\n```\n\n安装完之后GRUB目录位于在/boot/grub/\n\n然后执行下面命令生成主配置文件`grub.cfg`\n\n```\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\n在/boot目录使用`tree -d`会有如下内容\n> .\n> ├── EFI\n> │   └── GRUB\n> ├── grub\n> │   ├── fonts\n> │   ├── themes\n> │   │   └── starfield\n> │   └── x86_64-efi\n> └── syslinux\n\n### 退出chroot重启\n笔记本退出之前要先安装dialog\n\n```\n# pacman -S iw wpa_supplicant dialog\n# exit\n# umount /mnt/{boot, home}\n# umount /mnt\n# reboot\n```\n\n其实不重启也可以, 这时候还连着网, 直接把需要安装的一次性装了,\n然后直接进到图形界面, 不然联网会很麻烦. 图形界面可以用networkmanager连网\n\n# 驱动安装\n## 显卡驱动\n具体的驱动匹配表可以查看[ArchWiki](https://wiki.archlinux.org/index.php/Xorg_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%AE%89%E8%A3%85)\n\n再次折腾了一次Nvidia驱动, 失败告终, 难受\n显卡驱动默认的vesa可以兼容大部分显卡了\n我是双显卡, 安装了下面三个显卡驱动\n\n```\n# pacman -S xf86-video-vesa     通用驱动\n# pacman -S xf86-video-intel    intel集显驱动\n# pacman -S xf86-video-nouveau  开源的N卡驱动\n```\n\n## 触摸板驱动\n\n```\n# pacman -S xf86-input-synaptics\n```\n\n## Xorg显示服务器\nxorg是其他例如xfce和gnome, kde一些桌面环境的基础, 提供图形环境基本框架\n\n```\n# pacman -S xorg\n```\n\n# 安装Gnome以及配置\n## Gnome和优化工具\ngnome是基本环境, gnome-extra是一个包合集, 里面有一些软件啥的,\n如果是喜欢干干净净的可以不装extra, 以后缺啥装啥\n\ngnome-tweak-tool是gnome桌面美化的很重要的工具\n\n```\n# pacman -S gnome gnome-extra gnome-tweak-tool\n```\n\n## 窗口管理服务gdm\ngnome一般用gdm, deepin用lightdm, xfce使用lxdm, kde使用sddm\n我们安装gdm之后要启用它\n\n```\n# pacman -S gdm\n# systemctl enable gdm\n```\n\n## 网络管理工具NetworkManager\n这一步做完之后就可以重启进入电脑啦, 其他的东西, 最好进入图形界面再做,\n边做边看效果\n\n```\n# pacman -S networkmanager\n# systemctl enable NetworkManager\n# reboot\n```\n\n## 添加archlinux-cn源\n官方仓库里面有很多我们常用但是没有的, 添加这个源会好很多\n\n```\n# sudo vim /etc/pacman.conf\n# 在末尾添加如下内容\n[archlinuxcn]\nSigLevel=Never\nServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch\n```\n\n# 其他常用软件和工具安装\n## 自带商店gnome-software\n可以自己先逛逛自带的gnome-software, 商店里面有很多工具类的\n\n如果发现商店打开后提示No application data found.可以按照如下操作恢复\n1. 在设置中将语言改成其他语言,英到中\n2. 重启\n3. 将语言改回原来的, 中到英\n4. 重启\n这样就可以啦\n\n## 字体\n下面这几个字体一般够用了, ttf-consolas-with-yahei是consolas和yahei结合体,\n英文consolas, 中文yahei\n\n```\n# sudo pacman -S ttf-consolas-with-yahei\n# sudo pacman -S wqy-microhei tf-dejavu wqy-zenhei\n```\n\n## fcitx输入法\n\n```\n# pacman -S fcitx-im fcitx fcitx-configtool\n# pacman -S fcitx-cloudpinyin fcitx-sogoupinyin\n```\n\n安装完之后还需要编辑配置文件, 具体可以看[ArchWiki](https://wiki.archlinux.org/index.php/Fcitx)\n一些常见的问题wiki里面也都说到了,所以如果下面的过程出现未知错误, 移步wiki查看\n\n修改配置文件, gnome on wayland, 无法读取~/.xprofile, 所以修改/etc/environment\n如果在登陆的时候选择Xorg的Gnome, 可以新建~/.xprofile, 添加如下内容\n然后重启生效\n\n```\n# vim /etc/environment\n# 添加如下内容\nGTK_IM_MODULE=fcitx\nQT_IM_MODULE=fcitx\nXMODIFIERS=@im=fcitx\n# reboot\n```\n\n使用fcitx-configtool进行进一步配置, 启用cloudpinyin等\n\n```\n# fcitx-configtool\n# 在input method那里点加号, 添加Pinyin\n# 在global-config进行全局配置\n# 在Apperance进行字体大小调整和状态显示\n# Addon进行插件管理, 双击插件进行设置\n```\n\n安装皮肤, 这里推荐一款简单好看的fcitx-skin-material\n\n```\n# sudo pacman -S fcitx-skin-material\n```\n\n如果出现在gnome-terminal中Ctrl+Space调不出fcitx\n\n```\n# gsettings set org.gnome.settings-daemon.plugins.xsettings overrides \"{'Gtk/IMModule':<'fcitx'>}\"\n```\n\n## 安装yaourt\n安装yaourt这个工具来使用AUR\n\n```\n# sudo pacman -S yaourt\n```\n\n## 安装oh-my-fish\n首先要安装fish, 相对于bash来说, 好用太多啦\n\n```\n# sudo pacman -S fish\n```\n然后去github上找到[oh-my-fish](https://github.com/oh-my-fish/oh-my-fish),\nREADME上说的很清楚很详细. 下面通过git安装\n\n```\n# with git\n# git clone https://github.com/oh-my-fish/oh-my-fish\n# cd oh-my-fish\n# bin/install --offline\n```\n\n然后安装主题, 可以自己去github上挑选, [传送门](https://github.com/oh-my-fish/oh-my-fish/blob/master/docs/Themes.md)\n我这里安装**batman**这个主题\n\n```\n# omf install batman\n# omf theme batman\n```\n编辑配置文件, 设置一些全局变量方便使用\n\n```\n# vim $OMF_CONFIG/init.fish\n# 添加你的变量和function\n# 例如\n# set -xg dow $HOME/Documents/\n# function c\n#   clear\n# end\n```\n\nfish的使用请\n\n## 浏览器\nfirefox和chrome我都用\n\n```\n# sudo pacman -S firefox google-chrome\n```\n\n## wps-office\n\n```\n# sudo pacman -S wps-office\n```\n\n## 音乐和视频\n网易云和vlc, 以及视频解码包\n\n```\n# sudo pacman -S netease-cloud-music\n# sudo pacman -S vlc gstreamer0.10-plugins\n```\n## 压缩和解压\ntar unzip zip unrar rar 一般用tar就足够啦\n\n```\n# sudo pacman -S tar unzip zip unrar rar\n```\n\n# Gnome桌面美化\n推荐自己去[Gnome-Look](https://www.gnome-look.org/)找喜欢的主题和图标样式之类的\n## GTK主题\n我使用的是[flat-remix-blue](https://www.gnome-look.org/p/1214931/)\n\n安装步骤\n- [下载主题](https://www.gnome-look.org/p/1214931/startdownload?file_id=1563444013&file_name=05-Flat-Remix-GTK-Blue-Dark_20190718.tar.xz&file_type=application/x-xz&file_size=480876)\n- 解压 `tar -xvf 05-Flat-Remix-GTK-Blue-Dark_20190718.tar.xz`\n- 将Flat-Remix-GTK-Blue-Dark目录放到~/.themes目录下 `mv Flat-Remix-GTK-Blue-Dark/ ~/.themes/`\n- 在gnome-tweaks里面启用\n\n## Gnome-Shell主题\n我使用的是[Flat Remix GNOME/Ubuntu/GDM theme](https://www.gnome-look.org/p/1013030/)\n\n安装步骤\n- [下载shell主题](https://www.gnome-look.org/p/1013030/)\n- 解压 `tar -xvf Flat-Remix-Dark-fullPanel_20190616.tar.xz`\n- 将其移动到~/.themes目录下\n- 在gnome-tweaks里面的Extensions里面, 将User themes启用, 重启gnome-tweaks\n- 在gnome-tweaks里面选择shell主题\n\n## GDM主题\n推荐[High_Ubunterra](https://www.gnome-look.org/p/1207015/)\n\n安装步骤\n- 下载主题\n- 解压\n- cd High_Ubunterra_DD-2.4(noPass)\n- chmod +x install.sh\n- ./install.sh\n\n## icon主题\n推荐[Tela Icon Theme](https://www.gnome-look.org/p/1279924/)\n可以自己选择目录样式的颜色, 我安装的是manjaro\n具体可以看[github](https://github.com/vinceliuice/Tela-icon-theme)\n\n安装步骤\n- git clone https://github.com/vinceliuice/Tela-icon-theme.git\n- cd Tela-icon-theme\n- ./install.sh -n Tela-manjaro\n\n## screenfetch\nscreenfetch可以在终端里输出你的系统logo和状态。\n如果需要打开终端自动输出, 可以在~/.bashrc添加: screenfetch\n\n```\n# sudo pacman -S screenfetch\n```\n\n## dock栏\n既然是mac风, 那肯定还是要有dock比较好看, gnome on wayland\n安装dash-to-dock插件, 具体参考[安装文档](https://micheleg.github.io/dash-to-dock/download.html#installation-from-source)\n\n安装方法\n1. 安装包解压缩后，重命名（删除邮箱后面的字符）后复制到目录~/.local/share/gnome-shell/extensions/下，然后重启 GNOME，再打开 Tweaks，应该就能在Extensions上看到 \n2. 下载github上的源码包,然后make, make install, 重启gnome, 参考[README](https://github.com/micheleg/dash-to-dock)\n\n## gnome-terminal背景透明\n\n```\n# yaourt -S gnome-terminal-transparency\n```\n安装过程会提示和gnome-terminal冲突,确认删除就可以.\n然后重启gnome-terminal, preference里面可以看到背景透明度设置\n\n# 结语\n写了很多, 妈妈再也不用担心我重装系统啦!\n作为一个参考吧, 以后总会因为各种原因需要重装. \n所以记录一下, 也分享给新人使用, 岂不乐哉\n\n---------\n","slug":"arch安装和gnome配置教程","published":1,"updated":"2019-07-25T18:24:46.936Z","layout":"post","photos":[],"link":"","_id":"ck2424llt002slksb2d4tkywt","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>两天前,我的arch,被我不小心升级glibc搞坏了..很久前就想重装下系统的,因此也就懒得重新再修复了,直接重装一个也挺好.</p><p>但是!隔了这么久重装系统搞得我心态都快崩了,各种找资料.<br>现在终于弄好啦,还是决定记录一下,以后就不用那么担心教程靠不靠谱</p></div><a id=\"more\"></a><h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><ul><li>已有系统: Win10</li><li>安装系统: archlinux-2019.07.1-x86_64</li><li>安装磁盘: 机械硬盘的后半部分(前半部分是windows的数据)</li><li>启动方式: UEFI</li><li>分区格式: GPT</li><li>桌面系统: Gnome3</li><li>参考链接: <a href=\"https://wiki.archlinux.org/index.php/Installation_guide_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ArchWiki</a></li><li>参考链接: <a href=\"http://blog.lucode.net/linux/archlinux-install-tutorial.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Arch安装教程</a></li><li>参考链接: <a href=\"https://blog.csdn.net/r8l8q8/article/details/76516523\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Arch安装图文教程</a></li></ul><h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><h2 id=\"准备安装介质\"><a href=\"#准备安装介质\" class=\"headerlink\" title=\"准备安装介质\"></a>准备安装介质</h2><p>说的简单点就是为制作启动盘做准备,安装系统当然需要这个系统的镜像文件.<br>可以到<a href=\"https://www.archlinux.org/download/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Arch Download</a>这里下载镜像<br>一直往下可以看到CHINA的标志, 推荐选择163的源下载,<a href=\"http://mirrors.163.com/archlinux/iso/2019.07.01/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">链接在这</a></p><h2 id=\"制作LiveCD\"><a href=\"#制作LiveCD\" class=\"headerlink\" title=\"制作LiveCD\"></a>制作LiveCD</h2><p>如果在windows环境制作的,可以使用<a href=\"http://sourceforge.net/p/usbwriter/wiki/Documentation/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">USBwriter</a>,或者其他一些工具</p><p>因为我电脑有现成的fedora media writer,所以用这个也可以制作</p><h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>身边需要可以连接的网络,有线网或者无线网</p><p>如果没有wifi可以连,当然,这个wifi不能是校园网,不然没办法直接命令行连接.<br>没wifi可以手机开热点啊,hhh</p><h2 id=\"磁盘空间\"><a href=\"#磁盘空间\" class=\"headerlink\" title=\"磁盘空间\"></a>磁盘空间</h2><p>从widows盘那边分出一部分给linux,我选择先压缩卷,然后新建简单卷,之后的安装就安装在这个简单卷上.</p><p>选择新建简单卷还是因为安装的时候能够看的更清楚第一个分区的开始扇区</p><h2 id=\"设置usb启动\"><a href=\"#设置usb启动\" class=\"headerlink\" title=\"设置usb启动\"></a>设置usb启动</h2><p>如果以前设置过usb启动优先就不用管了</p><p>进入BIOS,设置开机选项,调整开机顺序,让usb启动排在第一位<br>完事之后就可以直接插入你的U盘,开始装系统!</p><h1 id=\"安装准备\"><a href=\"#安装准备\" class=\"headerlink\" title=\"安装准备\"></a>安装准备</h1><h2 id=\"联网\"><a href=\"#联网\" class=\"headerlink\" title=\"联网\"></a>联网</h2><p>后面需要安装很多东西,所以最好先联网</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># wifi-menu</span><br></pre></td></tr></table></figure><p>会跳出来wifi选择的页面,自己选之前准备好的wifi连上就成</p><h2 id=\"编辑mirrorlist\"><a href=\"#编辑mirrorlist\" class=\"headerlink\" title=\"编辑mirrorlist\"></a>编辑mirrorlist</h2><p>目的是为了后面下载的时候速度能快点,国外的镜像站太慢啦.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vi /etc/pacman.d/mirrorlist</span><br><span class=\"line\"># 按下面描述修改mirrorlist</span><br><span class=\"line\"># pacman -Syy</span><br></pre></td></tr></table></figure><p>我默认你已经会vim了,找163关键词,然后把163的镜像站复制粘贴到第一个镜像站前面.一堆的网址就是镜像站啦.</p><p>如果不放心,还可以找关键词China,把其他的ustc之类的都放前面去.<br>记得,保存后<code>pacman -Syy</code></p><h2 id=\"分区\"><a href=\"#分区\" class=\"headerlink\" title=\"分区\"></a>分区</h2><p><strong>最重要的一步来咯</strong><br>我选择了UEFI启动,对应使用GPT分区<br>我的机械硬盘是/dev/sdb</p><h3 id=\"分区规划\"><a href=\"#分区规划\" class=\"headerlink\" title=\"分区规划\"></a>分区规划</h3><p>创建4个分区如下</p><ul><li>/boot　200M　/dev/sdb3</li><li>/swap　8G　　/dev/sdb4</li><li>/root　60G　 /dev/sdb5</li><li>/home　150G　/dev/sdb6</li></ul><p>别问我为什么/root设置这么大，为什么人家都推荐30G左右…<br>重装的其中一个原因就是/root爆了，扩容又麻烦，原本设置的是40G<br>/swap设置的是和我物理内存一样的大小</p><h3 id=\"查看磁盘情况\"><a href=\"#查看磁盘情况\" class=\"headerlink\" title=\"查看磁盘情况\"></a>查看磁盘情况</h3><p>确定你要安装的磁盘是sd几，然后使用gdisk划分磁盘</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># fdisk -l</span><br></pre></td></tr></table></figure><p>你看到的东西应该类似下面的</p><blockquote><p>Disk /dev/sdb: 931.53 GiB, 1000204886016 bytes, 1953525168 sectors<br>Disk model: HGST HTS721010A9<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 4096 bytes<br>I/O size (minimum/optimal): 4096 bytes / 4096 bytes<br>Disklabel type: gpt<br>Disk identifier: 94717E4F-9437-4814-96AA-5CD870012F36</p><p>Device Start End Sectors Size Type<br>/dev/sdb1 2048 587202559 587200512 280G Microsoft basic data<br>/dev/sdb2 587202560 1468008447 880805888 420G Microsoft basic data<br>/dev/sdb3 1468008448 1468418047 409600 200M EFI System<br>/dev/sdb4 1468418048 1485195263 16777216 8G Linux swap<br>/dev/sdb5 1485195264 1611024383 125829120 60G Linux root (x86)<br>/dev/sdb6 1611024384 1925597183 314572800 150G Linux home</p><p>Disk /dev/sda: 119.25 GiB, 128035676160 bytes, 250069680 sectors<br>Disk model: SanDisk SD8SNAT-<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 4096 bytes<br>I/O size (minimum/optimal): 4096 bytes / 4096 bytes<br>Disklabel type: gpt<br>Disk identifier: A7EA8BD9-4B05-4419-AEFA-7B4F01E54CC2</p><p>Device Start End Sectors Size Type<br>/dev/sda1 2048 534527 532480 260M EFI System<br>/dev/sda2 534528 567295 32768 16M Microsoft reserved<br>/dev/sda3 567296 246266737 245699442 117.2G Microsoft basic data<br>/dev/sda4 246267904 250058751 3790848 1.8G Windows recovery environment</p></blockquote><p>通过容量判断我要安装的磁盘是sda还是sdb</p><p>通过Type可以看到sdb1和sdb2都是Microsoft basic data,那是我的D盘和F盘</p><h3 id=\"分区-1\"><a href=\"#分区-1\" class=\"headerlink\" title=\"分区\"></a>分区</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdisk /dev/sdb</span><br></pre></td></tr></table></figure><p>记得这里sdb要换成你自己的sd..</p><p>gdisk的使用很简单，先使用？打印帮助，使用p打印分区表</p><p>如果你的磁盘是空的，使用o新建一个gpt分区表，如果不是空磁盘，别这么做</p><p>接着使用ｎ命令新建一个磁盘分区,然后输入分区号，默认回车就可以<br>然后设置开始扇区，如果没啥意外，直接回车<br>设置结束扇区，可以使用<strong>+60G</strong>这样的方式，不用自己计算，很方便<br>接着设置Hex code, 这个很重要,可以使用L查看所有的codes,下面列出要用的</p><blockquote><p>/boot: EF00<br>/swap: 8200<br>/root: 8303<br>/home: 8302</p></blockquote><h3 id=\"格式化分区\"><a href=\"#格式化分区\" class=\"headerlink\" title=\"格式化分区\"></a>格式化分区</h3><p>格式化EFI分区/boot</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># mkfs.fat -F32 /dev/sdb3</span><br></pre></td></tr></table></figure><p>格式化/root和/home</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># mkfs.ext4 /dev/sdb5</span><br><span class=\"line\"># mkfs.ext4 /dev/sdb6</span><br></pre></td></tr></table></figure><p>开启swap分区/swap</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># mkwsap /dev/sdb4</span><br><span class=\"line\"># swapon /dev/sdb4</span><br></pre></td></tr></table></figure><h3 id=\"挂载分区\"><a href=\"#挂载分区\" class=\"headerlink\" title=\"挂载分区\"></a>挂载分区</h3><p>一般是将根分区/挂载到/mnt下,然后将/boot和/home挂载到/mnt/boot和/mnt/home</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># mount /dev/sdb5 /mnt</span><br><span class=\"line\"># mkdir /mnt/&#123;boot, home&#125;</span><br><span class=\"line\"># mount /dev/sdb6 /mnt/home</span><br><span class=\"line\"># mount /dev/sdb3 /mnt/boot</span><br></pre></td></tr></table></figure><h1 id=\"安装基本系统\"><a href=\"#安装基本系统\" class=\"headerlink\" title=\"安装基本系统\"></a>安装基本系统</h1><h2 id=\"部署基本系统\"><a href=\"#部署基本系统\" class=\"headerlink\" title=\"部署基本系统\"></a>部署基本系统</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacstrap -i /mnt base base-devel net-tools</span><br></pre></td></tr></table></figure><p>这里的net-tools提供了netstat和ifconfig等命令,可以选择不装,差别不大</p><h2 id=\"生成fstab\"><a href=\"#生成fstab\" class=\"headerlink\" title=\"生成fstab\"></a>生成fstab</h2><p>fstab中记录了挂载信息,使用下面命令生成</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>使用<code>cat /mnt/etc/fstab</code>检查</p><h2 id=\"基本系统设置\"><a href=\"#基本系统设置\" class=\"headerlink\" title=\"基本系统设置\"></a>基本系统设置</h2><h3 id=\"切换到新系统\"><a href=\"#切换到新系统\" class=\"headerlink\" title=\"切换到新系统\"></a>切换到新系统</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># arch-chroot /mnt /bin/bash</span><br></pre></td></tr></table></figure><h3 id=\"设置locale\"><a href=\"#设置locale\" class=\"headerlink\" title=\"设置locale\"></a>设置locale</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vim /etc/locale.gen</span><br></pre></td></tr></table></figure><p>这里是配置本地语言环境,起码要中英文的UTF-8,所以把<code>en_US.UTF-8 UTF-8</code>和<code>zh_CN.UTF-8 UTF-8</code>取消注释, 然后保存退出<br>然后执行:</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># locale-gen</span><br><span class=\"line\"># # echo LANG=en_US.UTF-8 &gt; /etc/locale.conf</span><br></pre></td></tr></table></figure><h3 id=\"设置时区\"><a href=\"#设置时区\" class=\"headerlink\" title=\"设置时区\"></a>设置时区</h3><p>执行如下代码:</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><h3 id=\"设置硬件时间\"><a href=\"#设置硬件时间\" class=\"headerlink\" title=\"设置硬件时间\"></a>设置硬件时间</h3><p>执行如下代码:</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># hwclock --systohc --utc</span><br></pre></td></tr></table></figure><h3 id=\"设置主机名\"><a href=\"#设置主机名\" class=\"headerlink\" title=\"设置主机名\"></a>设置主机名</h3><p>建议使用小写</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># echo 主机名 &gt; /etc/hostname</span><br><span class=\"line\"># vim /etc/hosts</span><br></pre></td></tr></table></figure><p>hosts文件中有如下内容</p><blockquote><p>127.0.0.1 localhost<br>::1 localhost<br>127.0.1.1 myhostname.localdomain myhostname</p></blockquote><p>如果系统有一个永久的 IP 地址，请使用这个永久的 IP 地址而不是 127.0.1.1</p><h3 id=\"生成Initramfs\"><a href=\"#生成Initramfs\" class=\"headerlink\" title=\"生成Initramfs\"></a>生成Initramfs</h3><p>注意,这步只对 LVM、 system encryption 或 RAID有效<br>正常情况下,在执行pacstrap的时候已经安装linux,并且mkinitcpio自动运行</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># mkinitcpio -p linux</span><br></pre></td></tr></table></figure><h3 id=\"用户设置\"><a href=\"#用户设置\" class=\"headerlink\" title=\"用户设置\"></a>用户设置</h3><p>修改root用户密码,并且创建一个新用户,同样修改密码<br>建议root密码和用户密码不要设置成一样的,平时用普通用户就可以</p><p><strong>如果需要用root,必须清楚自己每一步会有什么后果!</strong></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># passwd</span><br><span class=\"line\"># ****你的密码****</span><br><span class=\"line\"># useradd -m -g users -s /bin/bash 用户名</span><br><span class=\"line\"># passwd 用户名</span><br><span class=\"line\"># ****用户密码****</span><br></pre></td></tr></table></figure><p>为用户添加sudo权限</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vim /etc/sudoers</span><br><span class=\"line\"># 在root ALL=(ALL) ALL下面添加如下内容</span><br><span class=\"line\">用户名 ALL=(ALL) ALL</span><br><span class=\"line\"></span><br><span class=\"line\"># 保存退出</span><br><span class=\"line\"># :wq</span><br></pre></td></tr></table></figure><h3 id=\"配置UEFI引导-重点\"><a href=\"#配置UEFI引导-重点\" class=\"headerlink\" title=\"配置UEFI引导(重点)\"></a>配置UEFI引导(重点)</h3><p>(这里网上看到的都有点不太一样, 导致我安装完之后电脑一直找不到Linux的引导项,<br>一直进不来linux, 后来在archwiki上看到了正确的方法, 记录如下)</p><p>这里使用UEFI引导,而不是BIOS,两者的区别自行百度</p><p>关于启动加载器可以自己查看<a href=\"https://wiki.archlinux.org/index.php/Arch_boot_process_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%99%A8\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ArchWiki</a>,里面讲的很清楚</p><p>我们选择GRUB <a href=\"https://wiki.archlinux.org/index.php/GRUB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ArchWiki</a>来引导系统,具体过程在archwiki中也讲的很清楚,这里不多赘述</p><p>安装必要软件包, efibootmgr是efi引导才要用的, ntfs-3g是为了能够识别windows的ntfs文件系统</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S dosfstools grub efibootmgr ntfs-3g</span><br></pre></td></tr></table></figure><p><strong>注意,我们选择的EFI系统分区是之前的/boot, 选择的启动引导器标识是GRUB,<br>不懂可以不管, 直接执行</strong></p><p>执行下面的命令来将 GRUB EFI 应用 <code>grubx64.efi</code> 安装到<br><code>/boot/EFI/GRUB/</code>，并将其模块安装到 <code>/boot/grub/x86_64-efi/</code>。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</span><br></pre></td></tr></table></figure><p>安装完之后GRUB目录位于在/boot/grub/</p><p>然后执行下面命令生成主配置文件<code>grub.cfg</code></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>在/boot目录使用<code>tree -d</code>会有如下内容</p><blockquote><p>.<br>├── EFI<br>│ └── GRUB<br>├── grub<br>│ ├── fonts<br>│ ├── themes<br>│ │ └── starfield<br>│ └── x86_64-efi<br>└── syslinux</p></blockquote><h3 id=\"退出chroot重启\"><a href=\"#退出chroot重启\" class=\"headerlink\" title=\"退出chroot重启\"></a>退出chroot重启</h3><p>笔记本退出之前要先安装dialog</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S iw wpa_supplicant dialog</span><br><span class=\"line\"># exit</span><br><span class=\"line\"># umount /mnt/&#123;boot, home&#125;</span><br><span class=\"line\"># umount /mnt</span><br><span class=\"line\"># reboot</span><br></pre></td></tr></table></figure><p>其实不重启也可以, 这时候还连着网, 直接把需要安装的一次性装了,<br>然后直接进到图形界面, 不然联网会很麻烦. 图形界面可以用networkmanager连网</p><h1 id=\"驱动安装\"><a href=\"#驱动安装\" class=\"headerlink\" title=\"驱动安装\"></a>驱动安装</h1><h2 id=\"显卡驱动\"><a href=\"#显卡驱动\" class=\"headerlink\" title=\"显卡驱动\"></a>显卡驱动</h2><p>具体的驱动匹配表可以查看<a href=\"https://wiki.archlinux.org/index.php/Xorg_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%AE%89%E8%A3%85\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ArchWiki</a></p><p>再次折腾了一次Nvidia驱动, 失败告终, 难受<br>显卡驱动默认的vesa可以兼容大部分显卡了<br>我是双显卡, 安装了下面三个显卡驱动</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S xf86-video-vesa     通用驱动</span><br><span class=\"line\"># pacman -S xf86-video-intel    intel集显驱动</span><br><span class=\"line\"># pacman -S xf86-video-nouveau  开源的N卡驱动</span><br></pre></td></tr></table></figure><h2 id=\"触摸板驱动\"><a href=\"#触摸板驱动\" class=\"headerlink\" title=\"触摸板驱动\"></a>触摸板驱动</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S xf86-input-synaptics</span><br></pre></td></tr></table></figure><h2 id=\"Xorg显示服务器\"><a href=\"#Xorg显示服务器\" class=\"headerlink\" title=\"Xorg显示服务器\"></a>Xorg显示服务器</h2><p>xorg是其他例如xfce和gnome, kde一些桌面环境的基础, 提供图形环境基本框架</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S xorg</span><br></pre></td></tr></table></figure><h1 id=\"安装Gnome以及配置\"><a href=\"#安装Gnome以及配置\" class=\"headerlink\" title=\"安装Gnome以及配置\"></a>安装Gnome以及配置</h1><h2 id=\"Gnome和优化工具\"><a href=\"#Gnome和优化工具\" class=\"headerlink\" title=\"Gnome和优化工具\"></a>Gnome和优化工具</h2><p>gnome是基本环境, gnome-extra是一个包合集, 里面有一些软件啥的,<br>如果是喜欢干干净净的可以不装extra, 以后缺啥装啥</p><p>gnome-tweak-tool是gnome桌面美化的很重要的工具</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S gnome gnome-extra gnome-tweak-tool</span><br></pre></td></tr></table></figure><h2 id=\"窗口管理服务gdm\"><a href=\"#窗口管理服务gdm\" class=\"headerlink\" title=\"窗口管理服务gdm\"></a>窗口管理服务gdm</h2><p>gnome一般用gdm, deepin用lightdm, xfce使用lxdm, kde使用sddm<br>我们安装gdm之后要启用它</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S gdm</span><br><span class=\"line\"># systemctl enable gdm</span><br></pre></td></tr></table></figure><h2 id=\"网络管理工具NetworkManager\"><a href=\"#网络管理工具NetworkManager\" class=\"headerlink\" title=\"网络管理工具NetworkManager\"></a>网络管理工具NetworkManager</h2><p>这一步做完之后就可以重启进入电脑啦, 其他的东西, 最好进入图形界面再做,<br>边做边看效果</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S networkmanager</span><br><span class=\"line\"># systemctl enable NetworkManager</span><br><span class=\"line\"># reboot</span><br></pre></td></tr></table></figure><h2 id=\"添加archlinux-cn源\"><a href=\"#添加archlinux-cn源\" class=\"headerlink\" title=\"添加archlinux-cn源\"></a>添加archlinux-cn源</h2><p>官方仓库里面有很多我们常用但是没有的, 添加这个源会好很多</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo vim /etc/pacman.conf</span><br><span class=\"line\"># 在末尾添加如下内容</span><br><span class=\"line\">[archlinuxcn]</span><br><span class=\"line\">SigLevel=Never</span><br><span class=\"line\">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><h1 id=\"其他常用软件和工具安装\"><a href=\"#其他常用软件和工具安装\" class=\"headerlink\" title=\"其他常用软件和工具安装\"></a>其他常用软件和工具安装</h1><h2 id=\"自带商店gnome-software\"><a href=\"#自带商店gnome-software\" class=\"headerlink\" title=\"自带商店gnome-software\"></a>自带商店gnome-software</h2><p>可以自己先逛逛自带的gnome-software, 商店里面有很多工具类的</p><p>如果发现商店打开后提示No application data found.可以按照如下操作恢复</p><ol><li>在设置中将语言改成其他语言,英到中</li><li>重启</li><li>将语言改回原来的, 中到英</li><li>重启<br>这样就可以啦</li></ol><h2 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h2><p>下面这几个字体一般够用了, ttf-consolas-with-yahei是consolas和yahei结合体,<br>英文consolas, 中文yahei</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S ttf-consolas-with-yahei</span><br><span class=\"line\"># sudo pacman -S wqy-microhei tf-dejavu wqy-zenhei</span><br></pre></td></tr></table></figure><h2 id=\"fcitx输入法\"><a href=\"#fcitx输入法\" class=\"headerlink\" title=\"fcitx输入法\"></a>fcitx输入法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S fcitx-im fcitx fcitx-configtool</span><br><span class=\"line\"># pacman -S fcitx-cloudpinyin fcitx-sogoupinyin</span><br></pre></td></tr></table></figure><p>安装完之后还需要编辑配置文件, 具体可以看<a href=\"https://wiki.archlinux.org/index.php/Fcitx\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ArchWiki</a><br>一些常见的问题wiki里面也都说到了,所以如果下面的过程出现未知错误, 移步wiki查看</p><p>修改配置文件, gnome on wayland, 无法读取~/.xprofile, 所以修改/etc/environment<br>如果在登陆的时候选择Xorg的Gnome, 可以新建~/.xprofile, 添加如下内容<br>然后重启生效</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vim /etc/environment</span><br><span class=\"line\"># 添加如下内容</span><br><span class=\"line\">GTK_IM_MODULE=fcitx</span><br><span class=\"line\">QT_IM_MODULE=fcitx</span><br><span class=\"line\">XMODIFIERS=@im=fcitx</span><br><span class=\"line\"># reboot</span><br></pre></td></tr></table></figure><p>使用fcitx-configtool进行进一步配置, 启用cloudpinyin等</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># fcitx-configtool</span><br><span class=\"line\"># 在input method那里点加号, 添加Pinyin</span><br><span class=\"line\"># 在global-config进行全局配置</span><br><span class=\"line\"># 在Apperance进行字体大小调整和状态显示</span><br><span class=\"line\"># Addon进行插件管理, 双击插件进行设置</span><br></pre></td></tr></table></figure><p>安装皮肤, 这里推荐一款简单好看的fcitx-skin-material</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S fcitx-skin-material</span><br></pre></td></tr></table></figure><p>如果出现在gnome-terminal中Ctrl+Space调不出fcitx</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># gsettings set org.gnome.settings-daemon.plugins.xsettings overrides &quot;&#123;&apos;Gtk/IMModule&apos;:&lt;&apos;fcitx&apos;&gt;&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id=\"安装yaourt\"><a href=\"#安装yaourt\" class=\"headerlink\" title=\"安装yaourt\"></a>安装yaourt</h2><p>安装yaourt这个工具来使用AUR</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S yaourt</span><br></pre></td></tr></table></figure><h2 id=\"安装oh-my-fish\"><a href=\"#安装oh-my-fish\" class=\"headerlink\" title=\"安装oh-my-fish\"></a>安装oh-my-fish</h2><p>首先要安装fish, 相对于bash来说, 好用太多啦</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S fish</span><br></pre></td></tr></table></figure><p>然后去github上找到<a href=\"https://github.com/oh-my-fish/oh-my-fish\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">oh-my-fish</a>,<br>README上说的很清楚很详细. 下面通过git安装</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># with git</span><br><span class=\"line\"># git clone https://github.com/oh-my-fish/oh-my-fish</span><br><span class=\"line\"># cd oh-my-fish</span><br><span class=\"line\"># bin/install --offline</span><br></pre></td></tr></table></figure><p>然后安装主题, 可以自己去github上挑选, <a href=\"https://github.com/oh-my-fish/oh-my-fish/blob/master/docs/Themes.md\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">传送门</a><br>我这里安装<strong>batman</strong>这个主题</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># omf install batman</span><br><span class=\"line\"># omf theme batman</span><br></pre></td></tr></table></figure><p>编辑配置文件, 设置一些全局变量方便使用</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vim $OMF_CONFIG/init.fish</span><br><span class=\"line\"># 添加你的变量和function</span><br><span class=\"line\"># 例如</span><br><span class=\"line\"># set -xg dow $HOME/Documents/</span><br><span class=\"line\"># function c</span><br><span class=\"line\">#   clear</span><br><span class=\"line\"># end</span><br></pre></td></tr></table></figure><p>fish的使用请</p><h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><p>firefox和chrome我都用</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S firefox google-chrome</span><br></pre></td></tr></table></figure><h2 id=\"wps-office\"><a href=\"#wps-office\" class=\"headerlink\" title=\"wps-office\"></a>wps-office</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S wps-office</span><br></pre></td></tr></table></figure><h2 id=\"音乐和视频\"><a href=\"#音乐和视频\" class=\"headerlink\" title=\"音乐和视频\"></a>音乐和视频</h2><p>网易云和vlc, 以及视频解码包</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S netease-cloud-music</span><br><span class=\"line\"># sudo pacman -S vlc gstreamer0.10-plugins</span><br></pre></td></tr></table></figure><h2 id=\"压缩和解压\"><a href=\"#压缩和解压\" class=\"headerlink\" title=\"压缩和解压\"></a>压缩和解压</h2><p>tar unzip zip unrar rar 一般用tar就足够啦</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S tar unzip zip unrar rar</span><br></pre></td></tr></table></figure><h1 id=\"Gnome桌面美化\"><a href=\"#Gnome桌面美化\" class=\"headerlink\" title=\"Gnome桌面美化\"></a>Gnome桌面美化</h1><p>推荐自己去<a href=\"https://www.gnome-look.org/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Gnome-Look</a>找喜欢的主题和图标样式之类的</p><h2 id=\"GTK主题\"><a href=\"#GTK主题\" class=\"headerlink\" title=\"GTK主题\"></a>GTK主题</h2><p>我使用的是<a href=\"https://www.gnome-look.org/p/1214931/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">flat-remix-blue</a></p><p>安装步骤</p><ul><li><a href=\"https://www.gnome-look.org/p/1214931/startdownload?file_id=1563444013&amp;file_name=05-Flat-Remix-GTK-Blue-Dark_20190718.tar.xz&amp;file_type=application/x-xz&amp;file_size=480876\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">下载主题</a></li><li>解压 <code>tar -xvf 05-Flat-Remix-GTK-Blue-Dark_20190718.tar.xz</code></li><li>将Flat-Remix-GTK-Blue-Dark目录放到~/.themes目录下 <code>mv Flat-Remix-GTK-Blue-Dark/ ~/.themes/</code></li><li>在gnome-tweaks里面启用</li></ul><h2 id=\"Gnome-Shell主题\"><a href=\"#Gnome-Shell主题\" class=\"headerlink\" title=\"Gnome-Shell主题\"></a>Gnome-Shell主题</h2><p>我使用的是<a href=\"https://www.gnome-look.org/p/1013030/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Flat Remix GNOME/Ubuntu/GDM theme</a></p><p>安装步骤</p><ul><li><a href=\"https://www.gnome-look.org/p/1013030/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">下载shell主题</a></li><li>解压 <code>tar -xvf Flat-Remix-Dark-fullPanel_20190616.tar.xz</code></li><li>将其移动到~/.themes目录下</li><li>在gnome-tweaks里面的Extensions里面, 将User themes启用, 重启gnome-tweaks</li><li>在gnome-tweaks里面选择shell主题</li></ul><h2 id=\"GDM主题\"><a href=\"#GDM主题\" class=\"headerlink\" title=\"GDM主题\"></a>GDM主题</h2><p>推荐<a href=\"https://www.gnome-look.org/p/1207015/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">High_Ubunterra</a></p><p>安装步骤</p><ul><li>下载主题</li><li>解压</li><li>cd High_Ubunterra_DD-2.4(noPass)</li><li>chmod +x install.sh</li><li>./install.sh</li></ul><h2 id=\"icon主题\"><a href=\"#icon主题\" class=\"headerlink\" title=\"icon主题\"></a>icon主题</h2><p>推荐<a href=\"https://www.gnome-look.org/p/1279924/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Tela Icon Theme</a><br>可以自己选择目录样式的颜色, 我安装的是manjaro<br>具体可以看<a href=\"https://github.com/vinceliuice/Tela-icon-theme\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">github</a></p><p>安装步骤</p><ul><li>git clone <a href=\"https://github.com/vinceliuice/Tela-icon-theme.git\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://github.com/vinceliuice/Tela-icon-theme.git</a></li><li>cd Tela-icon-theme</li><li>./install.sh -n Tela-manjaro</li></ul><h2 id=\"screenfetch\"><a href=\"#screenfetch\" class=\"headerlink\" title=\"screenfetch\"></a>screenfetch</h2><p>screenfetch可以在终端里输出你的系统logo和状态。<br>如果需要打开终端自动输出, 可以在~/.bashrc添加: screenfetch</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S screenfetch</span><br></pre></td></tr></table></figure><h2 id=\"dock栏\"><a href=\"#dock栏\" class=\"headerlink\" title=\"dock栏\"></a>dock栏</h2><p>既然是mac风, 那肯定还是要有dock比较好看, gnome on wayland<br>安装dash-to-dock插件, 具体参考<a href=\"https://micheleg.github.io/dash-to-dock/download.html#installation-from-source\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">安装文档</a></p><p>安装方法</p><ol><li>安装包解压缩后，重命名（删除邮箱后面的字符）后复制到目录~/.local/share/gnome-shell/extensions/下，然后重启 GNOME，再打开 Tweaks，应该就能在Extensions上看到</li><li>下载github上的源码包,然后make, make install, 重启gnome, 参考<a href=\"https://github.com/micheleg/dash-to-dock\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">README</a></li></ol><h2 id=\"gnome-terminal背景透明\"><a href=\"#gnome-terminal背景透明\" class=\"headerlink\" title=\"gnome-terminal背景透明\"></a>gnome-terminal背景透明</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># yaourt -S gnome-terminal-transparency</span><br></pre></td></tr></table></figure><p>安装过程会提示和gnome-terminal冲突,确认删除就可以.<br>然后重启gnome-terminal, preference里面可以看到背景透明度设置</p><h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>写了很多, 妈妈再也不用担心我重装系统啦!<br>作为一个参考吧, 以后总会因为各种原因需要重装.<br>所以记录一下, 也分享给新人使用, 岂不乐哉</p><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>两天前,我的arch,被我不小心升级glibc搞坏了..很久前就想重装下系统的,因此也就懒得重新再修复了,直接重装一个也挺好.</p><p>但是!隔了这么久重装系统搞得我心态都快崩了,各种找资料.<br>现在终于弄好啦,还是决定记录一下,以后就不用那么担心教程靠不靠谱</p></div>","more":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><ul><li>已有系统: Win10</li><li>安装系统: archlinux-2019.07.1-x86_64</li><li>安装磁盘: 机械硬盘的后半部分(前半部分是windows的数据)</li><li>启动方式: UEFI</li><li>分区格式: GPT</li><li>桌面系统: Gnome3</li><li>参考链接: <a href=\"https://wiki.archlinux.org/index.php/Installation_guide_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ArchWiki</a></li><li>参考链接: <a href=\"http://blog.lucode.net/linux/archlinux-install-tutorial.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Arch安装教程</a></li><li>参考链接: <a href=\"https://blog.csdn.net/r8l8q8/article/details/76516523\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Arch安装图文教程</a></li></ul><h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><h2 id=\"准备安装介质\"><a href=\"#准备安装介质\" class=\"headerlink\" title=\"准备安装介质\"></a>准备安装介质</h2><p>说的简单点就是为制作启动盘做准备,安装系统当然需要这个系统的镜像文件.<br>可以到<a href=\"https://www.archlinux.org/download/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Arch Download</a>这里下载镜像<br>一直往下可以看到CHINA的标志, 推荐选择163的源下载,<a href=\"http://mirrors.163.com/archlinux/iso/2019.07.01/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">链接在这</a></p><h2 id=\"制作LiveCD\"><a href=\"#制作LiveCD\" class=\"headerlink\" title=\"制作LiveCD\"></a>制作LiveCD</h2><p>如果在windows环境制作的,可以使用<a href=\"http://sourceforge.net/p/usbwriter/wiki/Documentation/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">USBwriter</a>,或者其他一些工具</p><p>因为我电脑有现成的fedora media writer,所以用这个也可以制作</p><h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>身边需要可以连接的网络,有线网或者无线网</p><p>如果没有wifi可以连,当然,这个wifi不能是校园网,不然没办法直接命令行连接.<br>没wifi可以手机开热点啊,hhh</p><h2 id=\"磁盘空间\"><a href=\"#磁盘空间\" class=\"headerlink\" title=\"磁盘空间\"></a>磁盘空间</h2><p>从widows盘那边分出一部分给linux,我选择先压缩卷,然后新建简单卷,之后的安装就安装在这个简单卷上.</p><p>选择新建简单卷还是因为安装的时候能够看的更清楚第一个分区的开始扇区</p><h2 id=\"设置usb启动\"><a href=\"#设置usb启动\" class=\"headerlink\" title=\"设置usb启动\"></a>设置usb启动</h2><p>如果以前设置过usb启动优先就不用管了</p><p>进入BIOS,设置开机选项,调整开机顺序,让usb启动排在第一位<br>完事之后就可以直接插入你的U盘,开始装系统!</p><h1 id=\"安装准备\"><a href=\"#安装准备\" class=\"headerlink\" title=\"安装准备\"></a>安装准备</h1><h2 id=\"联网\"><a href=\"#联网\" class=\"headerlink\" title=\"联网\"></a>联网</h2><p>后面需要安装很多东西,所以最好先联网</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># wifi-menu</span><br></pre></td></tr></table></figure><p>会跳出来wifi选择的页面,自己选之前准备好的wifi连上就成</p><h2 id=\"编辑mirrorlist\"><a href=\"#编辑mirrorlist\" class=\"headerlink\" title=\"编辑mirrorlist\"></a>编辑mirrorlist</h2><p>目的是为了后面下载的时候速度能快点,国外的镜像站太慢啦.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vi /etc/pacman.d/mirrorlist</span><br><span class=\"line\"># 按下面描述修改mirrorlist</span><br><span class=\"line\"># pacman -Syy</span><br></pre></td></tr></table></figure><p>我默认你已经会vim了,找163关键词,然后把163的镜像站复制粘贴到第一个镜像站前面.一堆的网址就是镜像站啦.</p><p>如果不放心,还可以找关键词China,把其他的ustc之类的都放前面去.<br>记得,保存后<code>pacman -Syy</code></p><h2 id=\"分区\"><a href=\"#分区\" class=\"headerlink\" title=\"分区\"></a>分区</h2><p><strong>最重要的一步来咯</strong><br>我选择了UEFI启动,对应使用GPT分区<br>我的机械硬盘是/dev/sdb</p><h3 id=\"分区规划\"><a href=\"#分区规划\" class=\"headerlink\" title=\"分区规划\"></a>分区规划</h3><p>创建4个分区如下</p><ul><li>/boot　200M　/dev/sdb3</li><li>/swap　8G　　/dev/sdb4</li><li>/root　60G　 /dev/sdb5</li><li>/home　150G　/dev/sdb6</li></ul><p>别问我为什么/root设置这么大，为什么人家都推荐30G左右…<br>重装的其中一个原因就是/root爆了，扩容又麻烦，原本设置的是40G<br>/swap设置的是和我物理内存一样的大小</p><h3 id=\"查看磁盘情况\"><a href=\"#查看磁盘情况\" class=\"headerlink\" title=\"查看磁盘情况\"></a>查看磁盘情况</h3><p>确定你要安装的磁盘是sd几，然后使用gdisk划分磁盘</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># fdisk -l</span><br></pre></td></tr></table></figure><p>你看到的东西应该类似下面的</p><blockquote><p>Disk /dev/sdb: 931.53 GiB, 1000204886016 bytes, 1953525168 sectors<br>Disk model: HGST HTS721010A9<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 4096 bytes<br>I/O size (minimum/optimal): 4096 bytes / 4096 bytes<br>Disklabel type: gpt<br>Disk identifier: 94717E4F-9437-4814-96AA-5CD870012F36</p><p>Device Start End Sectors Size Type<br>/dev/sdb1 2048 587202559 587200512 280G Microsoft basic data<br>/dev/sdb2 587202560 1468008447 880805888 420G Microsoft basic data<br>/dev/sdb3 1468008448 1468418047 409600 200M EFI System<br>/dev/sdb4 1468418048 1485195263 16777216 8G Linux swap<br>/dev/sdb5 1485195264 1611024383 125829120 60G Linux root (x86)<br>/dev/sdb6 1611024384 1925597183 314572800 150G Linux home</p><p>Disk /dev/sda: 119.25 GiB, 128035676160 bytes, 250069680 sectors<br>Disk model: SanDisk SD8SNAT-<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 4096 bytes<br>I/O size (minimum/optimal): 4096 bytes / 4096 bytes<br>Disklabel type: gpt<br>Disk identifier: A7EA8BD9-4B05-4419-AEFA-7B4F01E54CC2</p><p>Device Start End Sectors Size Type<br>/dev/sda1 2048 534527 532480 260M EFI System<br>/dev/sda2 534528 567295 32768 16M Microsoft reserved<br>/dev/sda3 567296 246266737 245699442 117.2G Microsoft basic data<br>/dev/sda4 246267904 250058751 3790848 1.8G Windows recovery environment</p></blockquote><p>通过容量判断我要安装的磁盘是sda还是sdb</p><p>通过Type可以看到sdb1和sdb2都是Microsoft basic data,那是我的D盘和F盘</p><h3 id=\"分区-1\"><a href=\"#分区-1\" class=\"headerlink\" title=\"分区\"></a>分区</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdisk /dev/sdb</span><br></pre></td></tr></table></figure><p>记得这里sdb要换成你自己的sd..</p><p>gdisk的使用很简单，先使用？打印帮助，使用p打印分区表</p><p>如果你的磁盘是空的，使用o新建一个gpt分区表，如果不是空磁盘，别这么做</p><p>接着使用ｎ命令新建一个磁盘分区,然后输入分区号，默认回车就可以<br>然后设置开始扇区，如果没啥意外，直接回车<br>设置结束扇区，可以使用<strong>+60G</strong>这样的方式，不用自己计算，很方便<br>接着设置Hex code, 这个很重要,可以使用L查看所有的codes,下面列出要用的</p><blockquote><p>/boot: EF00<br>/swap: 8200<br>/root: 8303<br>/home: 8302</p></blockquote><h3 id=\"格式化分区\"><a href=\"#格式化分区\" class=\"headerlink\" title=\"格式化分区\"></a>格式化分区</h3><p>格式化EFI分区/boot</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># mkfs.fat -F32 /dev/sdb3</span><br></pre></td></tr></table></figure><p>格式化/root和/home</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># mkfs.ext4 /dev/sdb5</span><br><span class=\"line\"># mkfs.ext4 /dev/sdb6</span><br></pre></td></tr></table></figure><p>开启swap分区/swap</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># mkwsap /dev/sdb4</span><br><span class=\"line\"># swapon /dev/sdb4</span><br></pre></td></tr></table></figure><h3 id=\"挂载分区\"><a href=\"#挂载分区\" class=\"headerlink\" title=\"挂载分区\"></a>挂载分区</h3><p>一般是将根分区/挂载到/mnt下,然后将/boot和/home挂载到/mnt/boot和/mnt/home</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># mount /dev/sdb5 /mnt</span><br><span class=\"line\"># mkdir /mnt/&#123;boot, home&#125;</span><br><span class=\"line\"># mount /dev/sdb6 /mnt/home</span><br><span class=\"line\"># mount /dev/sdb3 /mnt/boot</span><br></pre></td></tr></table></figure><h1 id=\"安装基本系统\"><a href=\"#安装基本系统\" class=\"headerlink\" title=\"安装基本系统\"></a>安装基本系统</h1><h2 id=\"部署基本系统\"><a href=\"#部署基本系统\" class=\"headerlink\" title=\"部署基本系统\"></a>部署基本系统</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacstrap -i /mnt base base-devel net-tools</span><br></pre></td></tr></table></figure><p>这里的net-tools提供了netstat和ifconfig等命令,可以选择不装,差别不大</p><h2 id=\"生成fstab\"><a href=\"#生成fstab\" class=\"headerlink\" title=\"生成fstab\"></a>生成fstab</h2><p>fstab中记录了挂载信息,使用下面命令生成</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>使用<code>cat /mnt/etc/fstab</code>检查</p><h2 id=\"基本系统设置\"><a href=\"#基本系统设置\" class=\"headerlink\" title=\"基本系统设置\"></a>基本系统设置</h2><h3 id=\"切换到新系统\"><a href=\"#切换到新系统\" class=\"headerlink\" title=\"切换到新系统\"></a>切换到新系统</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># arch-chroot /mnt /bin/bash</span><br></pre></td></tr></table></figure><h3 id=\"设置locale\"><a href=\"#设置locale\" class=\"headerlink\" title=\"设置locale\"></a>设置locale</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vim /etc/locale.gen</span><br></pre></td></tr></table></figure><p>这里是配置本地语言环境,起码要中英文的UTF-8,所以把<code>en_US.UTF-8 UTF-8</code>和<code>zh_CN.UTF-8 UTF-8</code>取消注释, 然后保存退出<br>然后执行:</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># locale-gen</span><br><span class=\"line\"># # echo LANG=en_US.UTF-8 &gt; /etc/locale.conf</span><br></pre></td></tr></table></figure><h3 id=\"设置时区\"><a href=\"#设置时区\" class=\"headerlink\" title=\"设置时区\"></a>设置时区</h3><p>执行如下代码:</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><h3 id=\"设置硬件时间\"><a href=\"#设置硬件时间\" class=\"headerlink\" title=\"设置硬件时间\"></a>设置硬件时间</h3><p>执行如下代码:</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># hwclock --systohc --utc</span><br></pre></td></tr></table></figure><h3 id=\"设置主机名\"><a href=\"#设置主机名\" class=\"headerlink\" title=\"设置主机名\"></a>设置主机名</h3><p>建议使用小写</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># echo 主机名 &gt; /etc/hostname</span><br><span class=\"line\"># vim /etc/hosts</span><br></pre></td></tr></table></figure><p>hosts文件中有如下内容</p><blockquote><p>127.0.0.1 localhost<br>::1 localhost<br>127.0.1.1 myhostname.localdomain myhostname</p></blockquote><p>如果系统有一个永久的 IP 地址，请使用这个永久的 IP 地址而不是 127.0.1.1</p><h3 id=\"生成Initramfs\"><a href=\"#生成Initramfs\" class=\"headerlink\" title=\"生成Initramfs\"></a>生成Initramfs</h3><p>注意,这步只对 LVM、 system encryption 或 RAID有效<br>正常情况下,在执行pacstrap的时候已经安装linux,并且mkinitcpio自动运行</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># mkinitcpio -p linux</span><br></pre></td></tr></table></figure><h3 id=\"用户设置\"><a href=\"#用户设置\" class=\"headerlink\" title=\"用户设置\"></a>用户设置</h3><p>修改root用户密码,并且创建一个新用户,同样修改密码<br>建议root密码和用户密码不要设置成一样的,平时用普通用户就可以</p><p><strong>如果需要用root,必须清楚自己每一步会有什么后果!</strong></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># passwd</span><br><span class=\"line\"># ****你的密码****</span><br><span class=\"line\"># useradd -m -g users -s /bin/bash 用户名</span><br><span class=\"line\"># passwd 用户名</span><br><span class=\"line\"># ****用户密码****</span><br></pre></td></tr></table></figure><p>为用户添加sudo权限</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vim /etc/sudoers</span><br><span class=\"line\"># 在root ALL=(ALL) ALL下面添加如下内容</span><br><span class=\"line\">用户名 ALL=(ALL) ALL</span><br><span class=\"line\"></span><br><span class=\"line\"># 保存退出</span><br><span class=\"line\"># :wq</span><br></pre></td></tr></table></figure><h3 id=\"配置UEFI引导-重点\"><a href=\"#配置UEFI引导-重点\" class=\"headerlink\" title=\"配置UEFI引导(重点)\"></a>配置UEFI引导(重点)</h3><p>(这里网上看到的都有点不太一样, 导致我安装完之后电脑一直找不到Linux的引导项,<br>一直进不来linux, 后来在archwiki上看到了正确的方法, 记录如下)</p><p>这里使用UEFI引导,而不是BIOS,两者的区别自行百度</p><p>关于启动加载器可以自己查看<a href=\"https://wiki.archlinux.org/index.php/Arch_boot_process_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%99%A8\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ArchWiki</a>,里面讲的很清楚</p><p>我们选择GRUB <a href=\"https://wiki.archlinux.org/index.php/GRUB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ArchWiki</a>来引导系统,具体过程在archwiki中也讲的很清楚,这里不多赘述</p><p>安装必要软件包, efibootmgr是efi引导才要用的, ntfs-3g是为了能够识别windows的ntfs文件系统</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S dosfstools grub efibootmgr ntfs-3g</span><br></pre></td></tr></table></figure><p><strong>注意,我们选择的EFI系统分区是之前的/boot, 选择的启动引导器标识是GRUB,<br>不懂可以不管, 直接执行</strong></p><p>执行下面的命令来将 GRUB EFI 应用 <code>grubx64.efi</code> 安装到<br><code>/boot/EFI/GRUB/</code>，并将其模块安装到 <code>/boot/grub/x86_64-efi/</code>。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</span><br></pre></td></tr></table></figure><p>安装完之后GRUB目录位于在/boot/grub/</p><p>然后执行下面命令生成主配置文件<code>grub.cfg</code></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>在/boot目录使用<code>tree -d</code>会有如下内容</p><blockquote><p>.<br>├── EFI<br>│ └── GRUB<br>├── grub<br>│ ├── fonts<br>│ ├── themes<br>│ │ └── starfield<br>│ └── x86_64-efi<br>└── syslinux</p></blockquote><h3 id=\"退出chroot重启\"><a href=\"#退出chroot重启\" class=\"headerlink\" title=\"退出chroot重启\"></a>退出chroot重启</h3><p>笔记本退出之前要先安装dialog</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S iw wpa_supplicant dialog</span><br><span class=\"line\"># exit</span><br><span class=\"line\"># umount /mnt/&#123;boot, home&#125;</span><br><span class=\"line\"># umount /mnt</span><br><span class=\"line\"># reboot</span><br></pre></td></tr></table></figure><p>其实不重启也可以, 这时候还连着网, 直接把需要安装的一次性装了,<br>然后直接进到图形界面, 不然联网会很麻烦. 图形界面可以用networkmanager连网</p><h1 id=\"驱动安装\"><a href=\"#驱动安装\" class=\"headerlink\" title=\"驱动安装\"></a>驱动安装</h1><h2 id=\"显卡驱动\"><a href=\"#显卡驱动\" class=\"headerlink\" title=\"显卡驱动\"></a>显卡驱动</h2><p>具体的驱动匹配表可以查看<a href=\"https://wiki.archlinux.org/index.php/Xorg_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%AE%89%E8%A3%85\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ArchWiki</a></p><p>再次折腾了一次Nvidia驱动, 失败告终, 难受<br>显卡驱动默认的vesa可以兼容大部分显卡了<br>我是双显卡, 安装了下面三个显卡驱动</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S xf86-video-vesa     通用驱动</span><br><span class=\"line\"># pacman -S xf86-video-intel    intel集显驱动</span><br><span class=\"line\"># pacman -S xf86-video-nouveau  开源的N卡驱动</span><br></pre></td></tr></table></figure><h2 id=\"触摸板驱动\"><a href=\"#触摸板驱动\" class=\"headerlink\" title=\"触摸板驱动\"></a>触摸板驱动</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S xf86-input-synaptics</span><br></pre></td></tr></table></figure><h2 id=\"Xorg显示服务器\"><a href=\"#Xorg显示服务器\" class=\"headerlink\" title=\"Xorg显示服务器\"></a>Xorg显示服务器</h2><p>xorg是其他例如xfce和gnome, kde一些桌面环境的基础, 提供图形环境基本框架</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S xorg</span><br></pre></td></tr></table></figure><h1 id=\"安装Gnome以及配置\"><a href=\"#安装Gnome以及配置\" class=\"headerlink\" title=\"安装Gnome以及配置\"></a>安装Gnome以及配置</h1><h2 id=\"Gnome和优化工具\"><a href=\"#Gnome和优化工具\" class=\"headerlink\" title=\"Gnome和优化工具\"></a>Gnome和优化工具</h2><p>gnome是基本环境, gnome-extra是一个包合集, 里面有一些软件啥的,<br>如果是喜欢干干净净的可以不装extra, 以后缺啥装啥</p><p>gnome-tweak-tool是gnome桌面美化的很重要的工具</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S gnome gnome-extra gnome-tweak-tool</span><br></pre></td></tr></table></figure><h2 id=\"窗口管理服务gdm\"><a href=\"#窗口管理服务gdm\" class=\"headerlink\" title=\"窗口管理服务gdm\"></a>窗口管理服务gdm</h2><p>gnome一般用gdm, deepin用lightdm, xfce使用lxdm, kde使用sddm<br>我们安装gdm之后要启用它</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S gdm</span><br><span class=\"line\"># systemctl enable gdm</span><br></pre></td></tr></table></figure><h2 id=\"网络管理工具NetworkManager\"><a href=\"#网络管理工具NetworkManager\" class=\"headerlink\" title=\"网络管理工具NetworkManager\"></a>网络管理工具NetworkManager</h2><p>这一步做完之后就可以重启进入电脑啦, 其他的东西, 最好进入图形界面再做,<br>边做边看效果</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S networkmanager</span><br><span class=\"line\"># systemctl enable NetworkManager</span><br><span class=\"line\"># reboot</span><br></pre></td></tr></table></figure><h2 id=\"添加archlinux-cn源\"><a href=\"#添加archlinux-cn源\" class=\"headerlink\" title=\"添加archlinux-cn源\"></a>添加archlinux-cn源</h2><p>官方仓库里面有很多我们常用但是没有的, 添加这个源会好很多</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo vim /etc/pacman.conf</span><br><span class=\"line\"># 在末尾添加如下内容</span><br><span class=\"line\">[archlinuxcn]</span><br><span class=\"line\">SigLevel=Never</span><br><span class=\"line\">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><h1 id=\"其他常用软件和工具安装\"><a href=\"#其他常用软件和工具安装\" class=\"headerlink\" title=\"其他常用软件和工具安装\"></a>其他常用软件和工具安装</h1><h2 id=\"自带商店gnome-software\"><a href=\"#自带商店gnome-software\" class=\"headerlink\" title=\"自带商店gnome-software\"></a>自带商店gnome-software</h2><p>可以自己先逛逛自带的gnome-software, 商店里面有很多工具类的</p><p>如果发现商店打开后提示No application data found.可以按照如下操作恢复</p><ol><li>在设置中将语言改成其他语言,英到中</li><li>重启</li><li>将语言改回原来的, 中到英</li><li>重启<br>这样就可以啦</li></ol><h2 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h2><p>下面这几个字体一般够用了, ttf-consolas-with-yahei是consolas和yahei结合体,<br>英文consolas, 中文yahei</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S ttf-consolas-with-yahei</span><br><span class=\"line\"># sudo pacman -S wqy-microhei tf-dejavu wqy-zenhei</span><br></pre></td></tr></table></figure><h2 id=\"fcitx输入法\"><a href=\"#fcitx输入法\" class=\"headerlink\" title=\"fcitx输入法\"></a>fcitx输入法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># pacman -S fcitx-im fcitx fcitx-configtool</span><br><span class=\"line\"># pacman -S fcitx-cloudpinyin fcitx-sogoupinyin</span><br></pre></td></tr></table></figure><p>安装完之后还需要编辑配置文件, 具体可以看<a href=\"https://wiki.archlinux.org/index.php/Fcitx\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ArchWiki</a><br>一些常见的问题wiki里面也都说到了,所以如果下面的过程出现未知错误, 移步wiki查看</p><p>修改配置文件, gnome on wayland, 无法读取~/.xprofile, 所以修改/etc/environment<br>如果在登陆的时候选择Xorg的Gnome, 可以新建~/.xprofile, 添加如下内容<br>然后重启生效</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vim /etc/environment</span><br><span class=\"line\"># 添加如下内容</span><br><span class=\"line\">GTK_IM_MODULE=fcitx</span><br><span class=\"line\">QT_IM_MODULE=fcitx</span><br><span class=\"line\">XMODIFIERS=@im=fcitx</span><br><span class=\"line\"># reboot</span><br></pre></td></tr></table></figure><p>使用fcitx-configtool进行进一步配置, 启用cloudpinyin等</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># fcitx-configtool</span><br><span class=\"line\"># 在input method那里点加号, 添加Pinyin</span><br><span class=\"line\"># 在global-config进行全局配置</span><br><span class=\"line\"># 在Apperance进行字体大小调整和状态显示</span><br><span class=\"line\"># Addon进行插件管理, 双击插件进行设置</span><br></pre></td></tr></table></figure><p>安装皮肤, 这里推荐一款简单好看的fcitx-skin-material</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S fcitx-skin-material</span><br></pre></td></tr></table></figure><p>如果出现在gnome-terminal中Ctrl+Space调不出fcitx</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># gsettings set org.gnome.settings-daemon.plugins.xsettings overrides &quot;&#123;&apos;Gtk/IMModule&apos;:&lt;&apos;fcitx&apos;&gt;&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id=\"安装yaourt\"><a href=\"#安装yaourt\" class=\"headerlink\" title=\"安装yaourt\"></a>安装yaourt</h2><p>安装yaourt这个工具来使用AUR</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S yaourt</span><br></pre></td></tr></table></figure><h2 id=\"安装oh-my-fish\"><a href=\"#安装oh-my-fish\" class=\"headerlink\" title=\"安装oh-my-fish\"></a>安装oh-my-fish</h2><p>首先要安装fish, 相对于bash来说, 好用太多啦</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S fish</span><br></pre></td></tr></table></figure><p>然后去github上找到<a href=\"https://github.com/oh-my-fish/oh-my-fish\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">oh-my-fish</a>,<br>README上说的很清楚很详细. 下面通过git安装</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># with git</span><br><span class=\"line\"># git clone https://github.com/oh-my-fish/oh-my-fish</span><br><span class=\"line\"># cd oh-my-fish</span><br><span class=\"line\"># bin/install --offline</span><br></pre></td></tr></table></figure><p>然后安装主题, 可以自己去github上挑选, <a href=\"https://github.com/oh-my-fish/oh-my-fish/blob/master/docs/Themes.md\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">传送门</a><br>我这里安装<strong>batman</strong>这个主题</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># omf install batman</span><br><span class=\"line\"># omf theme batman</span><br></pre></td></tr></table></figure><p>编辑配置文件, 设置一些全局变量方便使用</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vim $OMF_CONFIG/init.fish</span><br><span class=\"line\"># 添加你的变量和function</span><br><span class=\"line\"># 例如</span><br><span class=\"line\"># set -xg dow $HOME/Documents/</span><br><span class=\"line\"># function c</span><br><span class=\"line\">#   clear</span><br><span class=\"line\"># end</span><br></pre></td></tr></table></figure><p>fish的使用请</p><h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><p>firefox和chrome我都用</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S firefox google-chrome</span><br></pre></td></tr></table></figure><h2 id=\"wps-office\"><a href=\"#wps-office\" class=\"headerlink\" title=\"wps-office\"></a>wps-office</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S wps-office</span><br></pre></td></tr></table></figure><h2 id=\"音乐和视频\"><a href=\"#音乐和视频\" class=\"headerlink\" title=\"音乐和视频\"></a>音乐和视频</h2><p>网易云和vlc, 以及视频解码包</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S netease-cloud-music</span><br><span class=\"line\"># sudo pacman -S vlc gstreamer0.10-plugins</span><br></pre></td></tr></table></figure><h2 id=\"压缩和解压\"><a href=\"#压缩和解压\" class=\"headerlink\" title=\"压缩和解压\"></a>压缩和解压</h2><p>tar unzip zip unrar rar 一般用tar就足够啦</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S tar unzip zip unrar rar</span><br></pre></td></tr></table></figure><h1 id=\"Gnome桌面美化\"><a href=\"#Gnome桌面美化\" class=\"headerlink\" title=\"Gnome桌面美化\"></a>Gnome桌面美化</h1><p>推荐自己去<a href=\"https://www.gnome-look.org/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Gnome-Look</a>找喜欢的主题和图标样式之类的</p><h2 id=\"GTK主题\"><a href=\"#GTK主题\" class=\"headerlink\" title=\"GTK主题\"></a>GTK主题</h2><p>我使用的是<a href=\"https://www.gnome-look.org/p/1214931/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">flat-remix-blue</a></p><p>安装步骤</p><ul><li><a href=\"https://www.gnome-look.org/p/1214931/startdownload?file_id=1563444013&amp;file_name=05-Flat-Remix-GTK-Blue-Dark_20190718.tar.xz&amp;file_type=application/x-xz&amp;file_size=480876\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">下载主题</a></li><li>解压 <code>tar -xvf 05-Flat-Remix-GTK-Blue-Dark_20190718.tar.xz</code></li><li>将Flat-Remix-GTK-Blue-Dark目录放到~/.themes目录下 <code>mv Flat-Remix-GTK-Blue-Dark/ ~/.themes/</code></li><li>在gnome-tweaks里面启用</li></ul><h2 id=\"Gnome-Shell主题\"><a href=\"#Gnome-Shell主题\" class=\"headerlink\" title=\"Gnome-Shell主题\"></a>Gnome-Shell主题</h2><p>我使用的是<a href=\"https://www.gnome-look.org/p/1013030/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Flat Remix GNOME/Ubuntu/GDM theme</a></p><p>安装步骤</p><ul><li><a href=\"https://www.gnome-look.org/p/1013030/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">下载shell主题</a></li><li>解压 <code>tar -xvf Flat-Remix-Dark-fullPanel_20190616.tar.xz</code></li><li>将其移动到~/.themes目录下</li><li>在gnome-tweaks里面的Extensions里面, 将User themes启用, 重启gnome-tweaks</li><li>在gnome-tweaks里面选择shell主题</li></ul><h2 id=\"GDM主题\"><a href=\"#GDM主题\" class=\"headerlink\" title=\"GDM主题\"></a>GDM主题</h2><p>推荐<a href=\"https://www.gnome-look.org/p/1207015/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">High_Ubunterra</a></p><p>安装步骤</p><ul><li>下载主题</li><li>解压</li><li>cd High_Ubunterra_DD-2.4(noPass)</li><li>chmod +x install.sh</li><li>./install.sh</li></ul><h2 id=\"icon主题\"><a href=\"#icon主题\" class=\"headerlink\" title=\"icon主题\"></a>icon主题</h2><p>推荐<a href=\"https://www.gnome-look.org/p/1279924/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Tela Icon Theme</a><br>可以自己选择目录样式的颜色, 我安装的是manjaro<br>具体可以看<a href=\"https://github.com/vinceliuice/Tela-icon-theme\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">github</a></p><p>安装步骤</p><ul><li>git clone <a href=\"https://github.com/vinceliuice/Tela-icon-theme.git\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://github.com/vinceliuice/Tela-icon-theme.git</a></li><li>cd Tela-icon-theme</li><li>./install.sh -n Tela-manjaro</li></ul><h2 id=\"screenfetch\"><a href=\"#screenfetch\" class=\"headerlink\" title=\"screenfetch\"></a>screenfetch</h2><p>screenfetch可以在终端里输出你的系统logo和状态。<br>如果需要打开终端自动输出, 可以在~/.bashrc添加: screenfetch</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># sudo pacman -S screenfetch</span><br></pre></td></tr></table></figure><h2 id=\"dock栏\"><a href=\"#dock栏\" class=\"headerlink\" title=\"dock栏\"></a>dock栏</h2><p>既然是mac风, 那肯定还是要有dock比较好看, gnome on wayland<br>安装dash-to-dock插件, 具体参考<a href=\"https://micheleg.github.io/dash-to-dock/download.html#installation-from-source\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">安装文档</a></p><p>安装方法</p><ol><li>安装包解压缩后，重命名（删除邮箱后面的字符）后复制到目录~/.local/share/gnome-shell/extensions/下，然后重启 GNOME，再打开 Tweaks，应该就能在Extensions上看到</li><li>下载github上的源码包,然后make, make install, 重启gnome, 参考<a href=\"https://github.com/micheleg/dash-to-dock\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">README</a></li></ol><h2 id=\"gnome-terminal背景透明\"><a href=\"#gnome-terminal背景透明\" class=\"headerlink\" title=\"gnome-terminal背景透明\"></a>gnome-terminal背景透明</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># yaourt -S gnome-terminal-transparency</span><br></pre></td></tr></table></figure><p>安装过程会提示和gnome-terminal冲突,确认删除就可以.<br>然后重启gnome-terminal, preference里面可以看到背景透明度设置</p><h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>写了很多, 妈妈再也不用担心我重装系统啦!<br>作为一个参考吧, 以后总会因为各种原因需要重装.<br>所以记录一下, 也分享给新人使用, 岂不乐哉</p><hr><!-- rebuild by neat -->"},{"title":"cannot start gnome-tweaks","comments":1,"mathjax":false,"date":"2019-03-20T12:36:47.000Z","urlname":"gnometweaks-broken","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n今天在用Gnome-tweaks的时候发现打不开了???很莫名其妙,怀疑是滚动更新滚炸了。bing了一下在stackoverflow上找到了解决办法。\n<!--more-->\n\n# 无法打开gnome-tweaks\n\n## 报错信息\n```\n [sudo] password for root: \n Traceback (most recent call last):\n   File \"/usr/bin/gnome-tweaks\", line 13, in <module>\n     import gi\n ModuleNotFoundError: No module named 'gi'\n```\n\n## 解决办法\n\n参照了[stackoverflow](https://stackoverflow.com/questions/32640083/gnome-terminal-not-starting-due-to-error-in-python-script-related-to-gi)\n\n**步骤如下**\n- 在命令行进入python2、python3测试import gi，看有没有gi这个包\n- 发现只有python3.7下面有这个包\n- $ sudo vim /usr/bin/gnome-tweaks\n- 编辑第一行，把`#!/usr/bin/env python`改成`#!/usr/bin/python`\n- 我这里`python->python3.7`,如果不是的话要写成`!/usr/bin/python3.7`\n- 重新运行gnome-tweaks\n- 注意不要带sudo,我这里sudo出现了如下报错\n```\nNo protocol specified\nUnable to init server: Could not connect: Connection refused\n```\n\n---------\nOK，问题解决\n","source":"_posts/cannot-start-gnome-tweaks.md","raw":"---\ntitle: cannot start gnome-tweaks\ncomments: true\nmathjax: false\ndate: 2019-03-20 20:36:47\ntags: [Gnome-tweaks,Linux]\ncategories: Linux\nurlname: gnometweaks-broken\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n今天在用Gnome-tweaks的时候发现打不开了???很莫名其妙,怀疑是滚动更新滚炸了。bing了一下在stackoverflow上找到了解决办法。\n<!--more-->\n\n# 无法打开gnome-tweaks\n\n## 报错信息\n```\n [sudo] password for root: \n Traceback (most recent call last):\n   File \"/usr/bin/gnome-tweaks\", line 13, in <module>\n     import gi\n ModuleNotFoundError: No module named 'gi'\n```\n\n## 解决办法\n\n参照了[stackoverflow](https://stackoverflow.com/questions/32640083/gnome-terminal-not-starting-due-to-error-in-python-script-related-to-gi)\n\n**步骤如下**\n- 在命令行进入python2、python3测试import gi，看有没有gi这个包\n- 发现只有python3.7下面有这个包\n- $ sudo vim /usr/bin/gnome-tweaks\n- 编辑第一行，把`#!/usr/bin/env python`改成`#!/usr/bin/python`\n- 我这里`python->python3.7`,如果不是的话要写成`!/usr/bin/python3.7`\n- 重新运行gnome-tweaks\n- 注意不要带sudo,我这里sudo出现了如下报错\n```\nNo protocol specified\nUnable to init server: Could not connect: Connection refused\n```\n\n---------\nOK，问题解决\n","slug":"cannot-start-gnome-tweaks","published":1,"updated":"2019-07-25T18:24:44.859Z","layout":"post","photos":[],"link":"","_id":"ck2424llu002tlksb1bty1clb","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><p>今天在用Gnome-tweaks的时候发现打不开了???很莫名其妙,怀疑是滚动更新滚炸了。bing了一下在stackoverflow上找到了解决办法。<br><a id=\"more\"></a></p><h1 id=\"无法打开gnome-tweaks\"><a href=\"#无法打开gnome-tweaks\" class=\"headerlink\" title=\"无法打开gnome-tweaks\"></a>无法打开gnome-tweaks</h1><h2 id=\"报错信息\"><a href=\"#报错信息\" class=\"headerlink\" title=\"报错信息\"></a>报错信息</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] password for root: </span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;/usr/bin/gnome-tweaks&quot;, line 13, in &lt;module&gt;</span><br><span class=\"line\">    import gi</span><br><span class=\"line\">ModuleNotFoundError: No module named &apos;gi&apos;</span><br></pre></td></tr></table></figure><h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>参照了<a href=\"https://stackoverflow.com/questions/32640083/gnome-terminal-not-starting-due-to-error-in-python-script-related-to-gi\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">stackoverflow</a></p><p><strong>步骤如下</strong></p><ul><li>在命令行进入python2、python3测试import gi，看有没有gi这个包</li><li>发现只有python3.7下面有这个包</li><li>$ sudo vim /usr/bin/gnome-tweaks</li><li>编辑第一行，把<code>#!/usr/bin/env python</code>改成<code>#!/usr/bin/python</code></li><li>我这里<code>python-&gt;python3.7</code>,如果不是的话要写成<code>!/usr/bin/python3.7</code></li><li>重新运行gnome-tweaks</li><li>注意不要带sudo,我这里sudo出现了如下报错<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No protocol specified</span><br><span class=\"line\">Unable to init server: Could not connect: Connection refused</span><br></pre></td></tr></table></figure></li></ul><hr><p>OK，问题解决</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><p>今天在用Gnome-tweaks的时候发现打不开了???很莫名其妙,怀疑是滚动更新滚炸了。bing了一下在stackoverflow上找到了解决办法。<br>","more":"</p><h1 id=\"无法打开gnome-tweaks\"><a href=\"#无法打开gnome-tweaks\" class=\"headerlink\" title=\"无法打开gnome-tweaks\"></a>无法打开gnome-tweaks</h1><h2 id=\"报错信息\"><a href=\"#报错信息\" class=\"headerlink\" title=\"报错信息\"></a>报错信息</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] password for root: </span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;/usr/bin/gnome-tweaks&quot;, line 13, in &lt;module&gt;</span><br><span class=\"line\">    import gi</span><br><span class=\"line\">ModuleNotFoundError: No module named &apos;gi&apos;</span><br></pre></td></tr></table></figure><h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>参照了<a href=\"https://stackoverflow.com/questions/32640083/gnome-terminal-not-starting-due-to-error-in-python-script-related-to-gi\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">stackoverflow</a></p><p><strong>步骤如下</strong></p><ul><li>在命令行进入python2、python3测试import gi，看有没有gi这个包</li><li>发现只有python3.7下面有这个包</li><li>$ sudo vim /usr/bin/gnome-tweaks</li><li>编辑第一行，把<code>#!/usr/bin/env python</code>改成<code>#!/usr/bin/python</code></li><li>我这里<code>python-&gt;python3.7</code>,如果不是的话要写成<code>!/usr/bin/python3.7</code></li><li>重新运行gnome-tweaks</li><li>注意不要带sudo,我这里sudo出现了如下报错<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No protocol specified</span><br><span class=\"line\">Unable to init server: Could not connect: Connection refused</span><br></pre></td></tr></table></figure></li></ul><hr><p>OK，问题解决</p><!-- rebuild by neat -->"},{"title":"numpy.dot()函数","comments":1,"mathjax":false,"date":"2018-09-10T17:08:32.000Z","urlname":"numpy-function-dot","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n#Numpy\n　　numpy(Numerical Python extensions)是一个第三方的Python包，用于科学计算。本文主要讲学习Numpy过程中遇到的一个问题，关于numpy.dot()是怎运算的。<!--more-->\n\n##Numpy中多维数组的轴\n　　多维数组可以用numpy包生成，关于多维数组的运算以及定义等自行百度,主要讲多维数组的轴,这也是我学习时不懂的地方。\n\n{% note default %}\n　　多维数组的轴(axis)和该数组的size(或者)shape元素对应 。轴数从0开始，如果是二维，０轴是竖行，１轴是横行。具体看代码\n{% endnote %}\n\n```python\nx = np.random.randint(0,5,[3,2,2])\nprint(x)\nOut:\n  [[[5 2]\n    [4 2]]\n\n   [[1 3]\n    [2 3]]\n\n   [[1 1]\n    [0 1]]]\n\nx.sum(axis=0)\nOut:\n  array([[7, 6],\n        [6, 6]])\n\nx.sum(axis=1)\nOut:\n  array([[9, 4],\n         [3, 6],\n         [1, 2]])\n\nx.sum(axis=2)\nOut:\n  array([[7, 6],\n       [4, 5],\n       [2, 1]])\n```\n\n{% note info %} \n　　如果将三维数组的每一个二维看做一个平面（plane，X[0, :, :], X[1, :, :], X[2, :, :]），三维数组即是这些二维平面层叠（stacked）出来的结果。则（axis=0）表示全部平面上的对应位置，（axis=1），每一个平面的每一列，（axis=2），每一个平面的每一行。\n{% endnote %}\n\n#numpy.dot()\n　　*numpy.dot(a,b,out=None)*\n\n- 如果a和b都是一维数组，则进行内积运算\n\n```python\nnp.dot(3, 4)\nOut:\n  12\n\nnp.dot([2j, 3+3j], [2j, 3j])\nOut:\n  (-13+9j)\n```\n\n- 如果都是二维数组，就进行矩阵乘法，推荐`a@b`\n\n```python\na = [[1, 0], [0, 1]]\nb = [[4, 1], [2, 2]]\nnp.dot(a, b)\nOut:\n  array([[4, 1],\n         [2, 2]])\n```\n\n- 如果其中一个矩阵０秩，即标量，就进行`a*b`的运算，相乘\n- 如果a是N-D矩阵且b是1-D矩阵,就进行a的最后一个轴上的数据和b相乘并求和\n\n```python\n  a = array([[[ 1.,  2.,  3.,  4.],\n       [ 5.,  6.,  7.,  8.],\n       [ 9., 10., 11., 12.]],\n\n      [[ 1.,  2.,  3.,  4.],\n       [ 5.,  6.,  7.,  8.],\n       [ 9., 10., 11., 12.]]])\n  b = np.array([1,2,3,4])\n  np.dot(a, b)\n  Out:\n    array([[ 30.,  70., 110.],\n         [ 30.,  70., 110.]])\n```\n- 如果都是多维矩阵，则_a的最后一个轴和b的倒数第二个轴上的数据乘积累加_,类似第四种情况\n  `dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])`\n\n```python\n  a = np.arange(3*4*5*6).reshape((3,4,5,6))\n  b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))\n  np.dot(a, b)[2,3,2,1,2,2]\n  Out:\n    499128\n  sum(a[2,3,2,:] * b[1,2,:,2])\n  Out:\n    499128\n```\n\n&nbsp;&nbsp;\n\n","source":"_posts/numpy-dot-函数.md","raw":"---\ntitle: numpy.dot()函数\ncomments: true\nmathjax: false\ndate: 2018-09-11 01:08:32\ntags: [Python,Numpy,MachineLearning]\ncategories: MachineLearning\nurlname: numpy-function-dot\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n#Numpy\n　　numpy(Numerical Python extensions)是一个第三方的Python包，用于科学计算。本文主要讲学习Numpy过程中遇到的一个问题，关于numpy.dot()是怎运算的。<!--more-->\n\n##Numpy中多维数组的轴\n　　多维数组可以用numpy包生成，关于多维数组的运算以及定义等自行百度,主要讲多维数组的轴,这也是我学习时不懂的地方。\n\n{% note default %}\n　　多维数组的轴(axis)和该数组的size(或者)shape元素对应 。轴数从0开始，如果是二维，０轴是竖行，１轴是横行。具体看代码\n{% endnote %}\n\n```python\nx = np.random.randint(0,5,[3,2,2])\nprint(x)\nOut:\n  [[[5 2]\n    [4 2]]\n\n   [[1 3]\n    [2 3]]\n\n   [[1 1]\n    [0 1]]]\n\nx.sum(axis=0)\nOut:\n  array([[7, 6],\n        [6, 6]])\n\nx.sum(axis=1)\nOut:\n  array([[9, 4],\n         [3, 6],\n         [1, 2]])\n\nx.sum(axis=2)\nOut:\n  array([[7, 6],\n       [4, 5],\n       [2, 1]])\n```\n\n{% note info %} \n　　如果将三维数组的每一个二维看做一个平面（plane，X[0, :, :], X[1, :, :], X[2, :, :]），三维数组即是这些二维平面层叠（stacked）出来的结果。则（axis=0）表示全部平面上的对应位置，（axis=1），每一个平面的每一列，（axis=2），每一个平面的每一行。\n{% endnote %}\n\n#numpy.dot()\n　　*numpy.dot(a,b,out=None)*\n\n- 如果a和b都是一维数组，则进行内积运算\n\n```python\nnp.dot(3, 4)\nOut:\n  12\n\nnp.dot([2j, 3+3j], [2j, 3j])\nOut:\n  (-13+9j)\n```\n\n- 如果都是二维数组，就进行矩阵乘法，推荐`a@b`\n\n```python\na = [[1, 0], [0, 1]]\nb = [[4, 1], [2, 2]]\nnp.dot(a, b)\nOut:\n  array([[4, 1],\n         [2, 2]])\n```\n\n- 如果其中一个矩阵０秩，即标量，就进行`a*b`的运算，相乘\n- 如果a是N-D矩阵且b是1-D矩阵,就进行a的最后一个轴上的数据和b相乘并求和\n\n```python\n  a = array([[[ 1.,  2.,  3.,  4.],\n       [ 5.,  6.,  7.,  8.],\n       [ 9., 10., 11., 12.]],\n\n      [[ 1.,  2.,  3.,  4.],\n       [ 5.,  6.,  7.,  8.],\n       [ 9., 10., 11., 12.]]])\n  b = np.array([1,2,3,4])\n  np.dot(a, b)\n  Out:\n    array([[ 30.,  70., 110.],\n         [ 30.,  70., 110.]])\n```\n- 如果都是多维矩阵，则_a的最后一个轴和b的倒数第二个轴上的数据乘积累加_,类似第四种情况\n  `dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])`\n\n```python\n  a = np.arange(3*4*5*6).reshape((3,4,5,6))\n  b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))\n  np.dot(a, b)[2,3,2,1,2,2]\n  Out:\n    499128\n  sum(a[2,3,2,:] * b[1,2,:,2])\n  Out:\n    499128\n```\n\n&nbsp;&nbsp;\n\n","slug":"numpy-dot-函数","published":1,"updated":"2019-07-25T18:33:05.699Z","layout":"post","photos":[],"link":"","_id":"ck2424llw002vlksbv0cgs1et","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><h1 id=\"Numpy\"><a href=\"#Numpy\" class=\"headerlink\" title=\"Numpy\"></a>Numpy</h1><p>numpy(Numerical Python extensions)是一个第三方的Python包，用于科学计算。本文主要讲学习Numpy过程中遇到的一个问题，关于numpy.dot()是怎运算的。<a id=\"more\"></a></p><h2 id=\"Numpy中多维数组的轴\"><a href=\"#Numpy中多维数组的轴\" class=\"headerlink\" title=\"Numpy中多维数组的轴\"></a>Numpy中多维数组的轴</h2><p>多维数组可以用numpy包生成，关于多维数组的运算以及定义等自行百度,主要讲多维数组的轴,这也是我学习时不懂的地方。</p><div class=\"note default\"><p>多维数组的轴(axis)和该数组的size(或者)shape元素对应 。轴数从0开始，如果是二维，０轴是竖行，１轴是横行。具体看代码</p></div><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = np.random.randint(<span class=\"number\">0</span>,<span class=\"number\">5</span>,[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>])</span><br><span class=\"line\">print(x)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  [[[<span class=\"number\">5</span> <span class=\"number\">2</span>]</span><br><span class=\"line\">    [<span class=\"number\">4</span> <span class=\"number\">2</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">   [[<span class=\"number\">1</span> <span class=\"number\">3</span>]</span><br><span class=\"line\">    [<span class=\"number\">2</span> <span class=\"number\">3</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">   [[<span class=\"number\">1</span> <span class=\"number\">1</span>]</span><br><span class=\"line\">    [<span class=\"number\">0</span> <span class=\"number\">1</span>]]]</span><br><span class=\"line\"></span><br><span class=\"line\">x.sum(axis=<span class=\"number\">0</span>)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  array([[<span class=\"number\">7</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">        [<span class=\"number\">6</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\">x.sum(axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  array([[<span class=\"number\">9</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">         [<span class=\"number\">3</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>, <span class=\"number\">2</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\">x.sum(axis=<span class=\"number\">2</span>)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  array([[<span class=\"number\">7</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">       [<span class=\"number\">4</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">       [<span class=\"number\">2</span>, <span class=\"number\">1</span>]])</span><br></pre></td></tr></table></figure><div class=\"note info\"><p>如果将三维数组的每一个二维看做一个平面（plane，X[0, :, :], X[1, :, :], X[2, :, :]），三维数组即是这些二维平面层叠（stacked）出来的结果。则（axis=0）表示全部平面上的对应位置，（axis=1），每一个平面的每一列，（axis=2），每一个平面的每一行。</p></div><h1 id=\"numpy-dot\"><a href=\"#numpy-dot\" class=\"headerlink\" title=\"numpy.dot()\"></a>numpy.dot()</h1><p><em>numpy.dot(a,b,out=None)</em></p><ul><li>如果a和b都是一维数组，则进行内积运算</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.dot(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  <span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\">np.dot([<span class=\"number\">2j</span>, <span class=\"number\">3</span>+<span class=\"number\">3j</span>], [<span class=\"number\">2j</span>, <span class=\"number\">3j</span>])</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  (<span class=\"number\">-13</span>+<span class=\"number\">9j</span>)</span><br></pre></td></tr></table></figure><ul><li>如果都是二维数组，就进行矩阵乘法，推荐<code>a@b</code></li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [[<span class=\"number\">1</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">1</span>]]</span><br><span class=\"line\">b = [[<span class=\"number\">4</span>, <span class=\"number\">1</span>], [<span class=\"number\">2</span>, <span class=\"number\">2</span>]]</span><br><span class=\"line\">np.dot(a, b)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  array([[<span class=\"number\">4</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">         [<span class=\"number\">2</span>, <span class=\"number\">2</span>]])</span><br></pre></td></tr></table></figure><ul><li>如果其中一个矩阵０秩，即标量，就进行<code>a*b</code>的运算，相乘</li><li>如果a是N-D矩阵且b是1-D矩阵,就进行a的最后一个轴上的数据和b相乘并求和</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = array([[[ <span class=\"number\">1.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">3.</span>,  <span class=\"number\">4.</span>],</span><br><span class=\"line\">     [ <span class=\"number\">5.</span>,  <span class=\"number\">6.</span>,  <span class=\"number\">7.</span>,  <span class=\"number\">8.</span>],</span><br><span class=\"line\">     [ <span class=\"number\">9.</span>, <span class=\"number\">10.</span>, <span class=\"number\">11.</span>, <span class=\"number\">12.</span>]],</span><br><span class=\"line\"></span><br><span class=\"line\">    [[ <span class=\"number\">1.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">3.</span>,  <span class=\"number\">4.</span>],</span><br><span class=\"line\">     [ <span class=\"number\">5.</span>,  <span class=\"number\">6.</span>,  <span class=\"number\">7.</span>,  <span class=\"number\">8.</span>],</span><br><span class=\"line\">     [ <span class=\"number\">9.</span>, <span class=\"number\">10.</span>, <span class=\"number\">11.</span>, <span class=\"number\">12.</span>]]])</span><br><span class=\"line\">b = np.array([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>])</span><br><span class=\"line\">np.dot(a, b)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  array([[ <span class=\"number\">30.</span>,  <span class=\"number\">70.</span>, <span class=\"number\">110.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">30.</span>,  <span class=\"number\">70.</span>, <span class=\"number\">110.</span>]])</span><br></pre></td></tr></table></figure><ul><li>如果都是多维矩阵，则_a的最后一个轴和b的倒数第二个轴上的数据乘积累加_,类似第四种情况<br><code>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</code></li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = np.arange(<span class=\"number\">3</span>*<span class=\"number\">4</span>*<span class=\"number\">5</span>*<span class=\"number\">6</span>).reshape((<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>))</span><br><span class=\"line\">b = np.arange(<span class=\"number\">3</span>*<span class=\"number\">4</span>*<span class=\"number\">5</span>*<span class=\"number\">6</span>)[::<span class=\"number\">-1</span>].reshape((<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>))</span><br><span class=\"line\">np.dot(a, b)[<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  <span class=\"number\">499128</span></span><br><span class=\"line\">sum(a[<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,:] * b[<span class=\"number\">1</span>,<span class=\"number\">2</span>,:,<span class=\"number\">2</span>])</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  <span class=\"number\">499128</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><h1 id=\"Numpy\"><a href=\"#Numpy\" class=\"headerlink\" title=\"Numpy\"></a>Numpy</h1><p>numpy(Numerical Python extensions)是一个第三方的Python包，用于科学计算。本文主要讲学习Numpy过程中遇到的一个问题，关于numpy.dot()是怎运算的。","more":"</p><h2 id=\"Numpy中多维数组的轴\"><a href=\"#Numpy中多维数组的轴\" class=\"headerlink\" title=\"Numpy中多维数组的轴\"></a>Numpy中多维数组的轴</h2><p>多维数组可以用numpy包生成，关于多维数组的运算以及定义等自行百度,主要讲多维数组的轴,这也是我学习时不懂的地方。</p><div class=\"note default\"><p>多维数组的轴(axis)和该数组的size(或者)shape元素对应 。轴数从0开始，如果是二维，０轴是竖行，１轴是横行。具体看代码</p></div><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = np.random.randint(<span class=\"number\">0</span>,<span class=\"number\">5</span>,[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>])</span><br><span class=\"line\">print(x)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  [[[<span class=\"number\">5</span> <span class=\"number\">2</span>]</span><br><span class=\"line\">    [<span class=\"number\">4</span> <span class=\"number\">2</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">   [[<span class=\"number\">1</span> <span class=\"number\">3</span>]</span><br><span class=\"line\">    [<span class=\"number\">2</span> <span class=\"number\">3</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">   [[<span class=\"number\">1</span> <span class=\"number\">1</span>]</span><br><span class=\"line\">    [<span class=\"number\">0</span> <span class=\"number\">1</span>]]]</span><br><span class=\"line\"></span><br><span class=\"line\">x.sum(axis=<span class=\"number\">0</span>)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  array([[<span class=\"number\">7</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">        [<span class=\"number\">6</span>, <span class=\"number\">6</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\">x.sum(axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  array([[<span class=\"number\">9</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">         [<span class=\"number\">3</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">         [<span class=\"number\">1</span>, <span class=\"number\">2</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\">x.sum(axis=<span class=\"number\">2</span>)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  array([[<span class=\"number\">7</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">       [<span class=\"number\">4</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">       [<span class=\"number\">2</span>, <span class=\"number\">1</span>]])</span><br></pre></td></tr></table></figure><div class=\"note info\"><p>如果将三维数组的每一个二维看做一个平面（plane，X[0, :, :], X[1, :, :], X[2, :, :]），三维数组即是这些二维平面层叠（stacked）出来的结果。则（axis=0）表示全部平面上的对应位置，（axis=1），每一个平面的每一列，（axis=2），每一个平面的每一行。</p></div><h1 id=\"numpy-dot\"><a href=\"#numpy-dot\" class=\"headerlink\" title=\"numpy.dot()\"></a>numpy.dot()</h1><p><em>numpy.dot(a,b,out=None)</em></p><ul><li>如果a和b都是一维数组，则进行内积运算</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.dot(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  <span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\">np.dot([<span class=\"number\">2j</span>, <span class=\"number\">3</span>+<span class=\"number\">3j</span>], [<span class=\"number\">2j</span>, <span class=\"number\">3j</span>])</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  (<span class=\"number\">-13</span>+<span class=\"number\">9j</span>)</span><br></pre></td></tr></table></figure><ul><li>如果都是二维数组，就进行矩阵乘法，推荐<code>a@b</code></li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [[<span class=\"number\">1</span>, <span class=\"number\">0</span>], [<span class=\"number\">0</span>, <span class=\"number\">1</span>]]</span><br><span class=\"line\">b = [[<span class=\"number\">4</span>, <span class=\"number\">1</span>], [<span class=\"number\">2</span>, <span class=\"number\">2</span>]]</span><br><span class=\"line\">np.dot(a, b)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  array([[<span class=\"number\">4</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">         [<span class=\"number\">2</span>, <span class=\"number\">2</span>]])</span><br></pre></td></tr></table></figure><ul><li>如果其中一个矩阵０秩，即标量，就进行<code>a*b</code>的运算，相乘</li><li>如果a是N-D矩阵且b是1-D矩阵,就进行a的最后一个轴上的数据和b相乘并求和</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = array([[[ <span class=\"number\">1.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">3.</span>,  <span class=\"number\">4.</span>],</span><br><span class=\"line\">     [ <span class=\"number\">5.</span>,  <span class=\"number\">6.</span>,  <span class=\"number\">7.</span>,  <span class=\"number\">8.</span>],</span><br><span class=\"line\">     [ <span class=\"number\">9.</span>, <span class=\"number\">10.</span>, <span class=\"number\">11.</span>, <span class=\"number\">12.</span>]],</span><br><span class=\"line\"></span><br><span class=\"line\">    [[ <span class=\"number\">1.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">3.</span>,  <span class=\"number\">4.</span>],</span><br><span class=\"line\">     [ <span class=\"number\">5.</span>,  <span class=\"number\">6.</span>,  <span class=\"number\">7.</span>,  <span class=\"number\">8.</span>],</span><br><span class=\"line\">     [ <span class=\"number\">9.</span>, <span class=\"number\">10.</span>, <span class=\"number\">11.</span>, <span class=\"number\">12.</span>]]])</span><br><span class=\"line\">b = np.array([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>])</span><br><span class=\"line\">np.dot(a, b)</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  array([[ <span class=\"number\">30.</span>,  <span class=\"number\">70.</span>, <span class=\"number\">110.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">30.</span>,  <span class=\"number\">70.</span>, <span class=\"number\">110.</span>]])</span><br></pre></td></tr></table></figure><ul><li>如果都是多维矩阵，则_a的最后一个轴和b的倒数第二个轴上的数据乘积累加_,类似第四种情况<br><code>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</code></li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = np.arange(<span class=\"number\">3</span>*<span class=\"number\">4</span>*<span class=\"number\">5</span>*<span class=\"number\">6</span>).reshape((<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>))</span><br><span class=\"line\">b = np.arange(<span class=\"number\">3</span>*<span class=\"number\">4</span>*<span class=\"number\">5</span>*<span class=\"number\">6</span>)[::<span class=\"number\">-1</span>].reshape((<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>))</span><br><span class=\"line\">np.dot(a, b)[<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  <span class=\"number\">499128</span></span><br><span class=\"line\">sum(a[<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,:] * b[<span class=\"number\">1</span>,<span class=\"number\">2</span>,:,<span class=\"number\">2</span>])</span><br><span class=\"line\">Out:</span><br><span class=\"line\">  <span class=\"number\">499128</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;</p><!-- rebuild by neat -->"},{"title":"Python复习","comments":1,"mathjax":false,"date":"2019-08-28T10:20:16.000Z","urlname":"python-review","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n系统的复习一下Python的知识点, 做一些笔记\n{% endnote %}\n<!--more-->\n# CH1. Python语言基础\n\n## 1.1 常量与变量\n### 概念和注意点\n1. 内存是以字节为单位的一片连续的存储空间, 变量名是内存单元的名称, 变量值是变量所对应的内存单元的内容, 变量地址是变量对应内存单元的地址.\n2. 动态类型语言, 确定变量类型是在变量赋值的时候, **每次赋值**都可能改变类型\n3. 是基于值的内存管理方式, 不同的值分配不同的空间.   \n  因此, 变量值改变时, 改变的是变量的指向关系, 使得变量指向另一个内存空间.  \n  在C语言中是改变变量内存空间的内容, 变量对应的内存空间是固定的.  \n  使用** id()函数 **可以查看对象的内存地址.\n3. python中的变量是对一个对象的引用, 变量和变量之间的赋值是对同一个对象的引用, 变量指向一个对象或内存空间, 内存空间的内容可以修改\n4. 这里需要注意的是, 一些简单的对象, 比如较小的整型对象, Python采用对象重用的方法.   \n举例: a=2, b=2, 不会分配两次内存, a和b同时指向一个对象\n\n### 变量命名\n1. 变量命名规则: 数字+字母+下划线, 不可以数字开头, 区分大小写. 单独的下划线是表示上一次运算的结果\n2. 变量名不可以是,关键词:\n```python\n>>> import keyword\n>>> print(keyword.kwlist)\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n```\n\n### 变量作用域\n分局部变量和全局变量\n\n函数外就是全局变量, 如果要在函数中修改全局变量, 使用`global`语句声明它是全局变量\n\n如果同一程序中, 全局变量和局部变量同名, 则, 在局部变量作用范围内, 全局变量失效\n\n如果在内层函数要修改外层函数变量:\n- 使用global\n- 使用nonlocal关键字, 在内层函数中使用nonlocal声明变量\n- nonlocal  适用于在局部函数中的局部函数，把最内层的局部 变量设置成外层局部可用，但是还不是全局的。并且nonlocal必须绑定一个局部变量,不然报错\n\n```python\ndef scope_test():\n    def do_local():\n        spam = \"local spam\"   #和外面的spam不一样\n    def do_nonlocal():\n        nonlocal  spam        #使用外层的spam变量\n        spam = \"nonlocal spam\"\n    def do_global():\n        global spam\n        spam = \"global spam\"\n    spam = \"test spam\"\n    do_local()\n    print(\"After local assignmane:\", spam)\n    do_nonlocal()\n    print(\"After nonlocal assignment:\",spam)\n    do_global()\n    print(\"After global assignment:\",spam)\n\nscope_test()\nprint(\"In global scope:\",spam)\n\n# 输出\nAfter local assignmane: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\n```\n\n## 1.2 数据类型\n\n### 1.2.1 数值类型\n三种类型: 整型int, 浮点型float, 复数型complex\n\n1. 整型数据:   \n整数, 不带小数点, 可以有正负号.   \n数据的值不固定长度, 只要内存允许, 可以**任意长度** \n四种表示:  \n - 十进制\n - 二进制, 0b或者0B开头\n - 八进制, 0o或者0O开头\n - 十六进制, 0x或者0X开头\n\n2. 浮点类型:  \n两种表示:    \n - 十进制小数: 数字+小数点, 小数点后面可以没有数字, 如: 3.23, 34.0, 0.0, 34.\n - 指数形式: 科学计数法表示的, e或者E表示10为底的指数. 两部分比如同时出现, 指数必须整数. 如4e-5, 45e-6. 提供17位**有效数字**精度, **不是17位小数!**\n - 注意可能选择题, 1234567890123456789.0 + 1 - 1234567890123456789 = 0.0, 1234567890123456789.0 - 1234567890123456789 + 1 = 1.0, 前者因为+1之后超过精度, 用科学计数法表示, +1 被忽略了, 所以结果为0. \n\n3. 复数类型:  \n - 表示形式: a+bJ, a是实部, b是虚部, J是-1的平方根, 是虚数单位, 也可写成j, 注意不是数学上的i\n - 用x.real和x.imag获得实部和虚部, 结果都是**浮点型**\n\n### 1.2.2 字符串类型\n1. 使用单引号, 双引号, 或者三引号定义标准字符串, 三引号的字符串可以多行\n2. 使用下表访问字符串中的字符\n3. 字符串中字符不可改变, 只能重新赋值\n4. 使用转义字符控制输出  \n注意\\0: 空字符, \\a:响铃, \\r: 回车, 表示对当前行重叠输出, 只回车不换行\n5. 字符串前面加r表示原始字符串, 不转义\n6. **eval()函数**: 把字符串内容当作python语句执行, eval('1+1'), 结果为2\n7. **len()函数**: 返回长度\n\n### 1.2.3 布尔类型\n1. True和False, 注意开头大写\n2. 实际上分别用整型值**1和0**参与运算\n\n### 1.2.4 复合数据类型\n1. 包含多个相关联的数据元素,因此称为复合数据类型.\n2. 列表, 元组和字符串是又顺序的, 称为序列.  \n字典和集合是无顺序的.\n3. 列表:  \n - 中括号, 逗号分隔, 类型可不同\n - 可以嵌套\n - 列表元素可以改变\n4. 元组:   \n - 1,2,3 这样省略括号的默认为**元组**\n - 小括号, 逗号分隔, 类型可不同\n - 元组元素不可修改\n - () 表示空元组\n - **(9, )**只有一个元素, 要用逗号结尾\n - (9)表示整数9\n5. 字典:  \n - 大括号, 逗号分隔\n - 关键字: 值, 关键字必须不可变类型且互不相同\n - {} 空字典\n6. 集合:  \n - 无序, 不重复\n - 大括号或者set()函数创建\n - set() 空集合\n\n## 1.3常用模块和函数\n三种导包\n```python\nimport math\nmath.sqrt(2)\n====\nfrom math import sqrt\nsqrt(2)\n===\nfrom math import *\nsqrt(2)\n```\n### 1.3.1 math模块  \n常量: e, pi  \nfabs(), sqrt(), pow(x, y), exp(x), ceil(x), floor(x), fmod(y, x)  \nsin(x), cos(x), tan(x)...  \n\n### 1.3.2 cmath模块\n相对math支持复数运算  \npolar(x): 复数笛卡儿坐标换为极坐标  \nrect(r,p): 复数极坐标换为笛卡儿坐\n\n### 1.3.3 random模块\n- seed(x)随机数种子, 种子相同, 随机数相同, 默认种子是时间  \n- choice([0,1,2])随机挑选一个  \n- sample(seq, k): 从序列中挑k个  \n- shuffle(seq): 随机排序\n- random(): [0, 1)内实数\n- randint(a, b): [a, b]内整数\n- uniform(a,b): [a,b]内实数\n\n### 1.3.4 time模块\n- time(): 返回时间戳\n- localtime(secs): 接收一个时间戳, 返回时间元组\n- asctime([]): 接收一个时间元组, 返回一个日期时间字符串\n- asctime(localtime(time())), 可以这样用\n- ctime(time())和上面的结果相同\n\n### 1.3.5 calendar模块\n- 提供日历相关功能\n- calendar.isleap(), 这个函数可以用来判断是否闰年\n\n### 1.3.6 **内置函数**\n\n- range([start,]end[,step]): 开始和步长可省, 默认开始0, 步长1, \\[start, end),不包括end哦! 如果要使用step, 需要写start. range()函数返回的还是可迭代对象\n- range()可以和list()或者tuple()结合: list(range(5)), tuple(range(5))\n\n\n- ord(): 将字符转化为相应编码值\n- chr(): 将整数转化为相应unicode字符\n\n\n- repr(object): 返回一个对象的string格式, [菜鸟教程](https://www.runoob.com/python/python-func-repr.html)\n- str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式\n- iter(可迭代对象): 用于产生一个可迭代对象的迭代器, 可用next(it)得到迭代器下一个元素\n\n\n- abs()\n- pow(x,y[,z]): x^y%z\n- round(x[,n]): 这个函数尽量不要用! 不是严格的四舍五入, 和浮点数精度有关, 具体可以参考[Python 中关于 round 函数的小坑](https://www.runoob.com/w3cnote/python-round-func-note.html)浮点数x, n为精确到小数点后的位数,可省默认保留整数, 结果仍浮点型\n- divmod(x, y): 结果为(商,余数), divmod(7,4)==(1,3)\n\n## 1.4 基本运算\n\n### 1.4.1 算术运算\n+, -, \\*, /(返回浮点数), //(整除), %, \\*\\*(乘方)  \n这里注意下//这个运算:\n1. 如果是正数, 那就是去掉小数部分, **关键是负数, 需要向绝对值更大的方向进位**.   \n举例: 4//3 == 1, -4//3 == -2, -7//3 == -3, -8//3 == -3\n2. 如果a//b, a或b是浮点数, 那结果也是浮点型, 只有**两个都是整型**, 结果才是整型\n举例: 4//3 == 1, 4.1//3 == 1.0  \n\n注意取模运算的结果,只有**两个都是整型**才是整型, 例: 5%3 == 2, 5%3.0 == 2.0\n\n### 1.4.2 计算误差\n浮点数有效位有效, 17位, 所以肯定有误差.  \n因此, 比较符点数的时候, == 运算符要小心使用, 应该判断是否约等于  \n举例: abs(2.2-1.2-1)<1e-6, 取一个很小的误差就好  \n\n```python\n>>> 2.2-1\n1.2000000000000002\n>>> 2.2-1-1.2\n2.220446049250313e-16\n```\n\n### 1.4.3 数据类型转换\n整型+浮点型, 会自动将整型转换为浮点型  \n**强制转换:**\n- int(x)\n- float(x)\n- complex(x), 将x转换为复数, 实部为x, 虚部为0\n- complex(x, y), x为实部, y为虚部\n\n### 1.4.4 位运算\n- &: 按位与, 全1为1, |: 按位或, 有1为1, ^: 按位异或,不一样为1, ~: 按位取反, <<: 左移, 低位补0, >>: 右移,高位补0\n\n## 1.5 输入与输出\n### 1.5.1 标准输入\n格式:\n- input([提示字符串])    \n\n提示字符串可选, input读入一行, 并返回一个字符串.  \n如果需要数值数据, 需要使用类型将字符串转化成数值   \n可以给多变量赋值, 使用eval(input())\n\n```python\n# 读整数\n>>> x=int(input())\n12\n>>> x\n12\n\n# 读多个变量\n>>> x,y=eval(input())\n1,2\n>> x\n1\n>>> y\n2\n# 相当于x,y=(3,4)\n```\n\n### 1.5.2 标准输出\n格式:\n- print([输出项1,输出项2,..输出项n]\\[,seq=分隔符][,end=结束符])\n\nseq默认空格, end默认回车换行\n没有输出项则输出空行. print()从左到右输出每个项\n\n```python\n>>> print(10, 20)\n10 20\n>>> print(10, 20, seq=',')\n10,20\n>>> print(10, 20, seq=',',end='*')\n10,20*\n#并且没换行\n```\n\n### 1.5.3 格式化输出\n三种格式化输出方式:\n- 用%\n- 用format()内置函数\n- 用字符串的format方法\n\n#### 1.5.3.1 格式化运算符%\n格式化字符串%(输出项1,输出项2...输出项n)\n\n%的运算结果是字符串  \n\n格式符:\n- %% 百分号, %c 字符, %s 字符串, %d 带符号整数, %o 八进制, %x/X, %e/E 科学记数法, %f/F 浮点数, %g/G 根据值大小选%e还是%f\n- 不管什么类型,都可以用%s\n\n```python\n>>> print('Values are %s, %s, %s'%(1,2.3,['one','two','three']))\n\n# 表示总长度为6, 小数部分2位, 输出不足用0补齐, 小数点也占一位\n# 0可以用-, +代替, -左对齐, +表在正数前加上+号,默认不加\n>>> '%06.2f'%1.234\n'001.24'\n\n# 用字典输出时特殊用法, 这时候值由键确定\n# '%(key)06.1f'%{'key':value}\n>>> '%(name)s:%(score)06.1f'%{'score':9.5,'name':'Lucy'}\n'Lucy:0009.5'\n\n# %*.*f 运行中确定的\n>>> '%0*.*f'%(6,2,2.345)\n'002.35'\n```\n\n#### 1.5.3.2 format()内置函数\n\n```\nformat(输出项[,格式字符串])\n```\n\n省略格式符等价与str()函数   \n\n格式符:\n- d, b(二进制), o, x, X\n- f, F, e, E, g, G\n- c(整数为编码的字符)\n- %(输出百分号)\n- <(左对齐), >(右对齐), ^(居中对齐), =(填充字符位于符号和数字之间), +(表正号)\n\n```python\n>>> print(format(65,'c'),format(3.145,'f'))\nA 3.145000\n>>> print(format(3.145,'6.2f'),format(3.145,'05.3'))\n  3.15 03.15\n>>> print(format(3.145,'0=+10'),format('test','>20'))\n+00003.145                 test\n```\n\n#### 1.5.3.3 字符串的format()方法\n属于字符串的类方法, 尽量用字符串的format()方法\n\n```python\n### \n'格式化字符串'.format(输出项1, 输出项2, 输出项3...输出项n)\n\n格式字符串格式:\n{[序号或者键]: 格式说明符} 冒号不能丢\n\n格式化字符中, 普通字符原样输出, 格式说明符对应输出项\n\n序号从0开始! 如果全部省略就按照顺序输出\n### \n\n# 省略\n>>> print('i am {}, {}'.format('Brenden','Welcome!'))\ni am Brenden, Welcome!\n\n# 序号\n>>> print('first:{1}, second:{0}, third:{2}'.format(1,2,3))\nfirst:2, second:1, third:3\n\n# 混用序号和键\n>>> print('hello, i am {name}, {0}'.format('Welcome',name=\"xiaoming\"))\nhello, i am xiaoming, Welcome\n\n# 结合格式符\n>>> print('{0:*^15}'.format(12345678))\n***12345678****\n>>> print('{0:<15}'.format(12345678))\n12345678\n>>> print('{0:>15}'.format(12345678))\n       12345678\n```\n\n## 1.6 缩进和注释\n### 1.6.1 缩进\n我认为, Python相对其他语言, 缩进真的是一个很坑的点, 同一程序中最好是一样的缩进, 否则经常出现缩进错误   \n一般是四个空格或者一个TAB   \n\n### 1.6.2 注释\n如果注释里面有中文,记得要在开头使用`#coding=utf-8`或者`#coding=gbk`\n\n- 单行注释: #开头, #后的就是注释\n- 多行注释: 三个单引号或者双引号, **多行注释不可以使用反斜杠续行!!**\n\n## 1.7赋值语句\n### 1.7.1 一般格式\n变量=表达式\n### 1.7.2 复合赋值语句\n\n```\n+=, -=, *=, /=, //=, **=, <<=, >>=, &=, |=, ^=\n```\n\n**注意!** `x*y+5==x*(y+5)`\n\n### 1.7.3 多变量赋值\n1. 链式赋值\n - 变量1=变量2=变量.....=变量n=表达式\n - a=b=10 等价于 a=10;b=10\n - 要注意的是, 上例, a和b同时指向一个整型对象10\n2. 同步赋值\n - 变量1,变量2,变量3...=表达式1,表达式2...表达式n\n - a,b,c=1,2,3\n - 注意同步赋值不是单一赋值语句的先后执行!!!\n\n```\n>>> x,x=2,-50 \n# x结果为-50\n\n>>> x=-11\n>>> x,y=12,x\n# 此时x=12, 但是y=-11 !!!要小心使用\n\n>>> a,b=1,2\n>>> a,b=b,a\n# 此时a, b分别为2, 1\n# 可以用a,b=b,a省略一个中间变量\n```\n\n## 1.8 条件的描述\n### 1.8.1 关系运算符\n优先级小于算术运算符, 就是先算算术运算符, 再比较\n```\n<, <=, >, >=, ==, !=\n```\n\n### 1.8.2 逻辑运算\n\n```\nand(与), or(或), not(非)\n```\n\n优先级: \n- not > and > or\n\n逻辑与: 前面的False就不算后面的\n逻辑或: 前面的True就不算后面的\n\n### 1.8.3 成员测试\n\n```\nin: 在序列中查找, 返回True或者False\nnot in: 么找到返回True\nis: 测试两个变量是否, 指向同一个变量\n```\n\n{% cq %}\n**end CH1**\n{% endcq %}\n\n# CH2. Python程序结构\n## 2.1 算法及其描述\n算法+数据结构=程序, 计算机解决问题的方法和步骤就是算法   \n算法描述: \n1. 传统流程图\n2. 结构化流程图:\n    - 程序的三种基本结构: 顺序结构, 选择结构, 循环结构\n    - 结构化流程图(N-S图): 顺序结构, 选择结构, 当型循环结构, 直到型循环结构, 各单元顺序执行\n\n## 2.2 顺序结构\n简单的按照出现顺序执行\n\n## 2.3 选择结构\n### 2.3.1 if-elif-else\n\n要注意的是, if的表达式可以使任意的, 比如 if 'B':   \n嵌套的时候根据对齐来配对\n\n```python\n# 单分支\nif ...:\n  表达式\n\n# 双分支\nif ...:\n  语句\nelse:\n  ...\n\n# 多分支\nif ...:\n  ...\nelif ...:\n  ...\nelif ...:\n  ...\nelse:\n  ...\n```\n\n### 2.3.2 条件运算\n\n**可以作为一个运算量, 而不是一个单独的语句**\n\n```python\n表达式1 if 表达式 else 表达式2\n\n>>> z= x if x>y else y\n# 其中z=后面的就是一个条件运算\n\n>>> i=0\n>>> 'a' if i else 'A'\n'A'\n```\n\n## 2.4 循环结构\n### 2.4.1 while\nwhile和if有一个相同的地方就是, 如果循环体只哟一个语句, 可以写在一行\n\n```python\nwhile ...:\n  ....\n\n# 可以结合else语句\n# 但是只可以在while部分正常退出的时候才执行else部分\n# 如果是break退出的, 不执行else部分\nwhile ...:\n  ....\nelse:\n  ....\n```\n\n### 2.4.2 for\n可结合range()函数, 看1.3.6部分\n\n> range([start,]end[,step]): 开始和步长可省, 默认开始0, 步长1, [start, end),不包括end哦! 如果要使用step, 需要写start. range()返回可迭代对象\n> for循环中会自动调用iter()函数,和next()函数获得range里的元素\n\n```python\n# 这个序列可以是: 字符串, 元组, 列表...\nfor 变量 in 序列:\n  语句块\n\n# 也可以用else语句\n# 没碰到break就可以执行\nfor 变量 in 序列:\n  语句块\nelse:\n  ....\n\n# 结合range函数\n>>> for i in range(5):\n>>>   print(i, end=',')\n0,1,2,3,4\n>>> for i in range(0,5,2):\n>>>   print(i, end=',')\n0,2,4\n```\n\n## 2.5 循环控制语句\n有`break`和`pass`和`continue`这三个\n\npass语句代表空语句,空操作, 相当于占位符\n\n{% cq %}\n**end CH2**\n{% endcq %}\n\n# CH3. 字符串和正则\n## 3.1 字符串\n关于编码的两个函数\n- 默认unicode编码, encode: 编码为, decode: 解码为unicode\n- s.encode('utf-8')或者s.encode('gbk')\n- s.decode('utf-8')或者s.decode('gbk')\n\n### 索引和分片\n\n索引分为正向和反向\n\n|  H | e  |  l | l  |  o |\n|:--:|:--:|:--:|:--:|:--:|\n| s[0] | s[1] | s[2] | s[3] | s[4]|\n| s[-5] | s[-4] | s[-3] | s[-2] | s[-1]|\n\n分片使用中括号和如下格式:\n- s[i:j:k]\n- i: 开始位置下标, j: 结束位置下标, 不包括j位置的字符, k: 步长\n- i,j,k都可以省略, i默认0或-1, j默认到最后一个字符, k默认1\n- 一定要注意, 不管k是正还是负, 都不包括j位置的字符\n- i和j都可以超过字符串的长度\n\n示例:\n\n```python\n>>> s='hello'\n>>> print(s[0:4:1])\nhell\n>>> print(s[0:5:2])\nhlo\n\n>>> print(s[-1:-5:-1])\nolle\n>>> print(s[-1:-6:-1])\nolleh\n\n>>> print(s[0:len(s)])\nhello\n>>> print(s[-len(s):-1])\nhell\n\n# 都省了\n>>> print(s[:])\nhello\n>>> print(s[::2])\nhlo\n>>> print(s[::-1])\nolleh\n# 省略了步长\n>>> print(s[:-1])\nhell\n```\n\n### 字符串连接\n使用`+`连接, 如果不是字符串类型, 使用str()函数或者repr()函数转换成字符串\n\n字符串不可用下标修改, 所以可以用连接操作改某个字符\n\n```python\n>>> s='abcd'\n>>> s=s[0]+9+s[2]\n>>> s\n'a9cd'\n```\n\n可以使用`*`进行重复连接, n\\*s或者s\\*n  \n可以使用+=或者\\*=这样的操作\n\n如果是连加操作, +的效率很低, 可以使用s.join()函数代替, s是分隔符\n\n```python\n>>> '-'.join(['Python','and','Program'])\n'Python-and-Program'\n```\n\n### 字符串比较\n- 单子符就直接比较ASCII码\n- 相同长度从左到右比较ASCII\n- 不同长度补全空格再从左到右比较ASCII\n\n### 字符串成员关系\n用`in`和`not in`: 字符串1 [not] in 字符串2  \n返回True或者False\n\n### 字符串常用方法\n字符串是一个类, 有许多类方法.这里只记常用的  \n\n#### 大小写和对齐\n- s.upper()/lower()\n- s.ljust(width, [fillchar]): 输出width长度, 左对齐, 不足部分fillchar补齐, 默认空格\n- s.rjust()/center(): 参数同上, 右对齐和居中\n\n#### 字符串搜索\n- s.find(sub,[start,[end]]): 返回sub的第一个字符编号, 没有返回-1\n- s.index(sub,[start,[end]]): 和find相同, 不过没有时,返回一个错误\n- s.rfind(sub,[start,[end]]): 从后往前找sub,第一个字符编号,没有返回-1\n- s.rindex(sub,[start,[end]])\n- s.count(substr,[start,[end]]): 返回出现次数\n- s.startswith(prefix,[start,[end]])\n- s.endswith(suffix,[start,[end]])\n\n#### 字符串替换\n- s.replace(oldstr,newstr,[count]): old替换为new\n- s.strip([chars]): 默认去前后空格, s前后的chars中的字符去掉\n- s.lstrip([chars])/rstrip()\n- s.expandtabs([tabsize]): s中tab替换为空格, tabsize为空格的数量, 默认8个\n\n#### 字符串拆分\n- s.split([sep,[maxsplit]]): sep:分隔符,默认空格, 按sep把s拆成一个列表, maxsplit:拆分次数,默认-1无限制\n- s.rsplit([sep,[maxsplit]]): 从右侧拆\n- s.splitlines([keepends]): 按行拆成列表, keepends为true: 保留每行分隔符\n- s.partition(sub): 拆成三个元素的元组(sub左, sub, sub右), 如果没sub, 返回(s, '', '')\n- s.rpartition(sub): 从右边找sub\n\n#### 字符串连接\n- s.join(seq): seq为序列, s为分隔符\n通常和list(s)结合使用, 修改string某个字符\n\n```python\n>>> s='abcd'\n>>> s=list(s)\n>>> s[0]='t'\n>>> s=\"\".join(s)\n>>> s\n'tbcd'\n```\n\n#### 字符串类型判断\n- s.isalnum(): 字母和数字, 至少一个字符\n- s.isalpha(): 全字母,至少一个字符\n- s.isdigit(): 全数字,至少一个字符\n- s.isspace(): 全空格,至少一个字符\n- s.islower()/isupper()/istitle()\n\n### 字节类型bytes\nbytes和string不一样, 可以用string.encode()方法和bytes.decode()方法进行两者转换.  \nbytes可以使用bytearray(by)的方式将bytes转换为bytearray对象   \nbytes对象不可修改, bytearray可修改\n\n## 3.2 正则表达式\n太多了, 附上[菜鸟教程](https://www.runoob.com/python/python-reg-expressions.html)\n\n{% cq %}\n**end CH3**\n{% endcq %}\n\n# CH4. 复合数据类型\n## 4.1 序列\n序列包括**字符串, 列表, 元组**, 按照位置编号存取\n\n### 4.1.1 通用操作\n- 索引, 用下标访问, num[0], 支持反向索引, 从-1开始\n- 分片, 注意不改变原序列, 而是产生一个新序列, 下面是常用分片用法\n\n```python\n>>> num=[1,2,3,4,5,6,7,8,9,10]\n# 常见用法\n>>> num[3:6]\n[4, 5, 6]\n\n# 可以从末尾计数, 负数索引, 效果相同\n>>> num[7:10]\n[8, 9, 10]\n>>> num[-3:]\n[8, 9, 10]\n\n# 省略部分下标\n>>> num[:3]\n[1, 2, 3]\n>>> num[:]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# 设置步长\n>>> num[:len(num):2]\n[1, 3, 5, 7, 9]\n\n# 开始索引可以超过列表长度, 视作从最后一个开始\n>>> num[11:0:-1]\n[10, 9, 8, 7, 6, 5, 4, 3, 2]\n>>> num[8:0:-1]\n[9, 8, 7, 6, 5, 4, 3, 2]\n\n# 如果步长为负数, 开始索引必须大于终止索引\n>>> num[0:10:-1]\n[]\n\n# 从id可以看出分片是新序列, 和赋值不一样\n>>> x=[1,2,3]\n>>> y=x[:]\n>>> id(x),id(y)\n(140158585788768, 140158585103696)\n>>> z=x\n>>> id(x),id(z)\n(140158585788768, 140158585788768)\n\n```\n\n- 同类型序列可用+直接相加\n- 可以用\\*进行乘法, 生成新序列, n<1会返回一个空列表\n\n```python\n>>> s=[None]*10\n>>> s\n[None, None, None, None, None, None, None, None, None, None]\n```\n\n- 字符串部分介绍过, 可以直接比较, 同样适用于列表和元组, 但是列表和元组不可以比较\n- 用in和notin判断成员资格\n- 常用函数: len(), max(), min(), sum():要求元素必须为数值\n- 常用函数: s.count(x), s.index(x)\n- enumerate(seq): 接收可迭代对象, 返回enumerate对象, 由每个元素的索引和值组成(索引, 值)\n- zip(seq1,seq2..seqn)\n- sorted(iterable, key=None, reverse=False): 返回排序后的列表, 返回的是副本,不改变源. reverse=False升序, reverse=True降序\n- reversed(iterable): 逆序排列, 返回新的对象\n- all(seq): seq元素都是True则返回True\n- any(seq): seq任一为True则返回True\n- 序列拆分: 变量个数不一致时, 要用\\*, \\*只能有1个\n\n```python\n>>> x=[1,2,3]\n>>> a,b,c=x\n>>> a,b,c\n(1, 2, 3)\n>>> a,*b=x\n>>> a,b\n(1, [2, 3])\n>>> *a,b=x\n>>> a,b\n([1, 2], 3)\n```\n\n### 4.1.2 列表专用操作\n- 列表可修改, 可元素赋值\n- del seq[index]/ del seq : 删除某元素或对象\n- 分片赋值: 可以做到增加, 删除, 修改\n\n```python\n>>> name=list('Perl')\n\n# 修改\n>>> name[2:]=list('ar')\n>>> name\n['P', 'e', 'a', 'r']\n\n# 修改并增加, 后面那部分可以比前面的长\n>>> name[1:]=list('ython')\n>>> name\n['P', 'y', 't', 'h', 'o', 'n']\n\n# 可以插入序列\n>>> name=[1,4]\n>>> name[1:1]=[2,3]\n>>> name\n[1, 2, 3, 4]\n\n# 删除部分元素\n>>> name[1:3]=[]\n>>> name\n[1, 4]\n\n# 如果步长不等于1, 那么前后数量必须相同\n>>> name[:4:2]=[2,3]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: attempt to assign sequence of size 2 to extended slice of size 1\n```\n\n- 列表解析, 表达式可以任意, for循环可嵌套, if可选\n\n```python\n>>> [i for i in range(4)]\n[0, 1, 2, 3]\n>>> [ord(x) for x in 'python']\n[112, 121, 116, 104, 111, 110]\n>>> [(x,y) for x in range(5) if x%2==0 for y in range(5) if y%2==1]\n[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]\n```\n\n- 以下方法都是在源列表上操作, 会修改原列表\n 1. s.append(x): 末尾添加单个元素\n 1. s.extend(seq): 在s末尾添加seq所有元素\n 1. s.sort(reverse=False, key=None) 和 sorted(seq)这个函数功能一样, 但是sorted是返回副本\n 1. s.reverse(): 同reversed(seq)\n 1. s.pop([index]): 删除并返回index位置的元素, 默认最后一个, 超范围报错\n 1. s.insert(index,x): index处插入x, index大于列表长度,则插在最后\n 1. s.remove(x): 如果有多个, 只删除第一个\n\n### 4.1.3 元组和列表\n都是有序序列, 常可替换\n\n**区别:**\n1. 元组不可变\n2. 元组小括号,列表中括号\n3. 元组可以在字典中作为key\n\n元组不可变, 但是可以用元组创建新元组   \n如果元组内元素为可变的, 如列表或字符串, 则可以修改  \n使用 list()和tuple()函数相互转换\n\n## 4.2 字典和集合\n字典主要是元素的检索, 插入和删除.   \n集合主要考虑集合间的并, 交和差操作.  \n\n### 4.2.1 字典\n注意点:\n- 关键是是不可变的, 如果元组里有可变类型比如列表, 就不可以作为key. python对key进行哈希, 根据计算结果决定存储地址, 所以可以用hash()函数判断是否可以作为key\n- 字典是可变类型, 可以在原处增长或者缩短, 无需生成副本.\n- 字典是异构的, 可以抱含任何类型数据: 元素可以是字典,列表,元组, 支持任意层次嵌套.\n- {}和dict()是空字典\n\n```python\n>>> d1=dict()\n>>> d1\n{}\n\n# dict参数可以是列表和元组\n>>> d2=dict((['x',1],['y',2]))\n>>> d2\n{'x': 1, 'y': 2}\n\n>>> d2=dict([['x',1],['y',2]])\n>>> d2\n{'x': 1, 'y': 2}\n\n# 可以直接指定key和val\n>>> d3=dict(name='allen',age=15)\n>>> d3\n{'name': 'allen', 'age': 15}\n```\n\n- 更新和添加: 字典的更新直接用dict[key]=new_val就可以, 如果没有就直接增加一个新元素\n- 删除: del 字典名[key] 或者 del 字典名\n- 判断key是否存在: key in / not in dict\n- len(dict)\n- 只支持==和！=\n- list(dict)返回key\n\n常用方法：\n- fromkeys(序列[,值])\n- keys(), values(), items()\n- d.copy(), d.clear(), d.pop(key), d.popitem()\n- d.get(key[,value]): 返回key对应的val值, 若没有, 则返回value\n- d.setdefault(key,[value]): 存在则返回值, 不存在则插入key:value, value默认none\n- d2.update(d1): d1合并到d2, d1不变\n- has_key(key): 存在key返回true, 用in和not in就可以\n\n### 4.2.2 集合\n#### 注意点\n1. 空集合是set()\n2. 用大括号\n3. 字符串,列表, 元组都可以转set\n4. set()创建可变集合, frozenset()创建不可变集合\n5. 可变集合的元素只能是数值, 字符串, 元组这些不可修改的, 可修改的列表,字典和可变集合都不可作为元素\n\n#### 集合的运算\n- 并： |, |=, s1.union(s2...sn)\n- 交： & , s1.intersection(s2...sn)\n- 差： -, s1.difference(s2...sn)\n- 对称差： ^, s1.symmetric_difference(s2...sn)\n- ==\n- ！=\n- s1\\<s2: s1是s2真子集,  \n- s1\\<=s2: s1是s2子集, s1.issubset(s2)\n- s1\\>s2: 超集\n- s1\\>=s2: 相当于s1.issuperset(s2)\n- s.copy()\n\n#### 适用于可变集合的方法\n- s.add(x)\n- s.remove(x): 不存在会报错; s.discard(x): 不存在不报错\n- s.pop(): 删除任意一个元素并返回\n- s.clear()\n\n\n- s.update(s1,s2...): s=s|s1|s2...sn\n- s.intersection_update(s1,s2..sn): s=s&s1&s2..&sn\n- s.difference_update(s1,s2..s2): s=s-s1-s2..-sn\n- s.symmetric_difference_update(s1): s=s^s1\n\n{% cq %}\n**end CH4**\n{% endcq %}\n\n# CH5. 函数\n和其他的语言一样, 函数先定义再使用\n\n## 5.1 参数\n参数传递的方式是\"值传递\"\n\n**要注意的是:**\n- 形参重新赋值重新分配对象, 指向别的对象, 不会改变实参\n- 如果仅修改形参内容, 比如列表, 字典这样的可修改对象, 则会影响实参\n\n### 参数类型\n- 位置参数: 参数按照位置对应\n- 关键字参数: 形参名=值\n\n```python\ndef mykey(x,y):\n  print(x, y)\nmykey(y=10, x=1)\n```\n\n- 默认参数: 形参=默认值, 必须在参数列表右边, 在可变长度参数之前\n- 可变长度参数: 参数数量不固定时, 针对元组和字典两种. 其他所有类型参数都必须在可变长度参数之前\n\n```python\n# 元组一个*\ndef myvarl(*t):\n  print(t)\nmyvarl(1,2,3)\n\n# 字典两个*\ndef myvarl(**t):\n  print(t)\nmyvarl('y'=1,'x'=2,'z'=3)\n\n```\n\n## 5.2 匿名函数\n\n```python\n# 参数也可以使用默认值, 返回值是表达式结果\nlambda [参数1[,参数2,...,参数n]]: 表达式\n\n# 例如\nlambda x,y: x+y\n\n# 调用\n>>> f=lambda x,y: x+y\n>>> f(5,10)\n15\n\n# 把匿名函数作为普通函数返回值\ndef f():\n  return lambda x,y:x+y\n\n# 匿名函数作为序列或者字典元素\n列表名=[匿名1, 匿名2,...匿名n]\n# 调用\n列表名[index](参数)\n```\n\n## 5.3 装饰器\n这里只记录一些注意点, 比较全面的看书上或者[Python 函数装饰器|菜鸟教程](https://www.runoob.com/w3cnote/python-func-decorators.html), 这个讲的很全\n\n- 概念: 装饰器是用来包装函数的函数, 用来为已经存在的函数添加额外功能\n- 返回对象: 装饰器输入是被装饰的函数对象, 返回新的函数对象.\n- 调用: 使用@调用装饰器\n- 调用的时候,本质上, 是将对象名重新指向一个新返回的函数, 达到修改函数的目的\n- 返回: 装饰器最里面那层, 要返回被装饰的函数\n- 在装饰器中,返回值, 例如 return func, func后面没有(), 加上()表示调用.\n- 外层里层函数关系: 最外面的那层函数返回值, 是里面一层函数的函数名\n- 多重装饰器: 执行顺序是从下往上, 最后执行被装饰函数内容\n\n## 5.4 \\_\\_name\\_\\_\n主动调用\\_\\_name\\_\\_值为\\_\\_main\\_\\_, 被导包时值为模块名\n把一个程序文件既当作模块, 有可以主动调用时, 程序入口前加if:\n\n```python\ndef test():\n  pass\nif __name__=='__main__':\n  test()\n```\n\n{% cq %}\n**end CH5**\n{% endcq %}\n\n# CH6. 类\n\n## 6.1 属性\n\n| |格式|访问控制|添加|修改|作用域|\n|:-|:-|:-|:-|:-|:-|\n|私有属性|类里函数外, 以\\_\\_开头的属性|只能通过类方法中使用self.\\_\\_name使用,类外无法直接访问|只能在类里面添加|在类方法里用self修改, 不影响其他对象|单个|\n|类属性|直接在类里函数外定义的非私有属性,所有对象公有|类外通过类名和实例对象(不推荐)调用|类外可以通过类名.类属性添加|类外:类名修改,类里:类方法|所有|\n|实例属性|在\\_\\_init\\_\\_里面定义或者通过实例对象引用定义|类外只有实例对象可以访问,类里面可以在类方法中调用|类里面在init方法中添加,类外使用实例对象.实例属性添加|用self修改或实例对象.实例属性修改|单个|\n\n注意点:\n- 千万不要尝试实例对象创建类属性, 会自动创建一个同名实例属性,并屏蔽掉类属性\n- 不可以用实例对象直接修改类属性, 要用类方法修改\n- 使用del 删除实例属性和实例对象\n\n## 6.2 方法\n\n| |特征|调用|和属性关系|\n|:-|:-|:-|:-|\n|构造方法|\\_\\_init\\_\\_(self)|生成对象自动调用|里面用self定义的都是实例属性|\n|析构方法|\\_\\_del\\_\\_(self)|释放对象自动调用|可以在里面进行释放资源的操作|\n|类方法|@classmethod修饰器,第一个参数为cls|实例对象和类对象访问|引用的是类属性\n|实例方法|第一个参数为self|只能实例对象调用|实例属性优先级高于类属性,实例方法中实例属性会屏蔽类属性|\n|静态方法|@staticmethod修饰器,无需多定义参数|类名和实例对象都可以访问|不绑定类或者实例, 引用类属性需要使用类名引用|\n\n注意点:\n- 静态方法和实例方法不同的是, 静态方法不会自动绑定到类上, 类方法会自动绑定. 静态方法不需要引用类或者实例\n- 静态方法很像我们在类外定义的函数，只不过静态方法可以通过类或者实例来调用而已。\n- 实例方法中引用属性, 若存在同名类属性和实例属性, 则引用实例属性, 若无实例属性, 则引用类属性\n- 实例方法中修改属性, 若存在同名类属性和实例属性, 则修改实例属性, 若无实例属性, 则创建新实例属性\n\n## 6.3 继承\n\n```python\n# 可以多重继承\nclass 子类名(父类名1,父类名2,..):\n  类体\n```\n\n注: \n- 如果子类中没有重新定义构造方法, 会执行第一个父类的构造方法\n- 使用内置方法issubclass(Child, Parent)判断一个类是否是另一个类的子孙类, 返回True或者False\n- 小心使用多重继承, 能不用就不用, 可以用组合\n- 多重继承函数的搜索顺序是广度优先, 从左到右找, 没有就下一个\n- super(Child,self).\\_\\_init\\_\\_()相当于Parent.\\_\\_init\\_\\_(self)\n- 子类继承父类所有属性和方法, 如果没有覆盖掉, 则调用父类方法\n- 可以使用父类名Parent.fun(self)或者super(Child,self).fun()来调用父类方法, 但是一定要传self\n\n\n对于init函数:\n- 如果子类没有定义自己的初始化函数，父类的初始化函数会被默认调用；但是如果要实例化子类的对象，则只能传入父类的初始化函数对应的参数，否则会出错。\n- 如果子类定义了自己的初始化函数，而在子类中没有显示调用父类的初始化函数，则父类的属性不会被初始化\n- 如果子类定义了自己的初始化函数，在子类中显示调用父类，子类和父类的属性都会被初始化\n\n详细的看下面这几个链接:\n　　[python中的类，对象，方法，属性初认识（一）](http://blog.csdn.net/brucewong0516/article/details/79114977)    \n　　[详解类class的属性：类数据属性、实例数据属性、特殊的类属性、属性隐藏（二）](http://blog.csdn.net/brucewong0516/article/details/79118703)   \n　　[详解类class的方法：实例方法、类方法、静态方法（三）](http://blog.csdn.net/brucewong0516/article/details/79119551)   \n　　[详解类class的访问控制：单下划线与双下划线（四）](http://blog.csdn.net/brucewong0516/article/details/79120841)   \n　　[详解类class的继承、__init__初始化、super方法](https://blog.csdn.net/brucewong0516/article/details/79121179)\n\n# CH7. 文件操作\n\n具体的可看[Python 文件I/O | 菜鸟教程](https://www.runoob.com/python/python-files-io.html)和[python 文件操作，最全的一个 | CSDN](https://blog.csdn.net/m0_38059843/article/details/78240835)\n\n# CH8. 注意点\n1. 整除是//不是/, 看1.4.1\n2. 判断在不在用in\n3. 正则的使用\n4. \\$是匹配结尾,如果是一行里面的不要用\\$符号,匹配所有单词只需要`[a-zA-Z]+`就可以\n4. read()没有参数就是读全部\n3. write()写字符串的时候可以用字符串.format()方法格式化输出到文件\n4. open()之后要记得close()\n4. dict.items()之后要使用list()转换一下才可以用\n4. 没有返回值的函数说明是要在序列内部修改, 注意不要修改引用, 只改内容\n1. 文件操作要记得使用try-except\n1. **大量的数据**统计要最好用字典,字典使用哈希会很快 \n","source":"_posts/Python复习.md","raw":"---\ntitle: Python复习\ntags:\n  - Python\n  - Review\n  - Notes\ncategories:\n  - Notes\ncomments: true\nmathjax: false\ndate: 2019-08-28 18:20:16\nurlname: python-review\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n系统的复习一下Python的知识点, 做一些笔记\n{% endnote %}\n<!--more-->\n# CH1. Python语言基础\n\n## 1.1 常量与变量\n### 概念和注意点\n1. 内存是以字节为单位的一片连续的存储空间, 变量名是内存单元的名称, 变量值是变量所对应的内存单元的内容, 变量地址是变量对应内存单元的地址.\n2. 动态类型语言, 确定变量类型是在变量赋值的时候, **每次赋值**都可能改变类型\n3. 是基于值的内存管理方式, 不同的值分配不同的空间.   \n  因此, 变量值改变时, 改变的是变量的指向关系, 使得变量指向另一个内存空间.  \n  在C语言中是改变变量内存空间的内容, 变量对应的内存空间是固定的.  \n  使用** id()函数 **可以查看对象的内存地址.\n3. python中的变量是对一个对象的引用, 变量和变量之间的赋值是对同一个对象的引用, 变量指向一个对象或内存空间, 内存空间的内容可以修改\n4. 这里需要注意的是, 一些简单的对象, 比如较小的整型对象, Python采用对象重用的方法.   \n举例: a=2, b=2, 不会分配两次内存, a和b同时指向一个对象\n\n### 变量命名\n1. 变量命名规则: 数字+字母+下划线, 不可以数字开头, 区分大小写. 单独的下划线是表示上一次运算的结果\n2. 变量名不可以是,关键词:\n```python\n>>> import keyword\n>>> print(keyword.kwlist)\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n```\n\n### 变量作用域\n分局部变量和全局变量\n\n函数外就是全局变量, 如果要在函数中修改全局变量, 使用`global`语句声明它是全局变量\n\n如果同一程序中, 全局变量和局部变量同名, 则, 在局部变量作用范围内, 全局变量失效\n\n如果在内层函数要修改外层函数变量:\n- 使用global\n- 使用nonlocal关键字, 在内层函数中使用nonlocal声明变量\n- nonlocal  适用于在局部函数中的局部函数，把最内层的局部 变量设置成外层局部可用，但是还不是全局的。并且nonlocal必须绑定一个局部变量,不然报错\n\n```python\ndef scope_test():\n    def do_local():\n        spam = \"local spam\"   #和外面的spam不一样\n    def do_nonlocal():\n        nonlocal  spam        #使用外层的spam变量\n        spam = \"nonlocal spam\"\n    def do_global():\n        global spam\n        spam = \"global spam\"\n    spam = \"test spam\"\n    do_local()\n    print(\"After local assignmane:\", spam)\n    do_nonlocal()\n    print(\"After nonlocal assignment:\",spam)\n    do_global()\n    print(\"After global assignment:\",spam)\n\nscope_test()\nprint(\"In global scope:\",spam)\n\n# 输出\nAfter local assignmane: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\n```\n\n## 1.2 数据类型\n\n### 1.2.1 数值类型\n三种类型: 整型int, 浮点型float, 复数型complex\n\n1. 整型数据:   \n整数, 不带小数点, 可以有正负号.   \n数据的值不固定长度, 只要内存允许, 可以**任意长度** \n四种表示:  \n - 十进制\n - 二进制, 0b或者0B开头\n - 八进制, 0o或者0O开头\n - 十六进制, 0x或者0X开头\n\n2. 浮点类型:  \n两种表示:    \n - 十进制小数: 数字+小数点, 小数点后面可以没有数字, 如: 3.23, 34.0, 0.0, 34.\n - 指数形式: 科学计数法表示的, e或者E表示10为底的指数. 两部分比如同时出现, 指数必须整数. 如4e-5, 45e-6. 提供17位**有效数字**精度, **不是17位小数!**\n - 注意可能选择题, 1234567890123456789.0 + 1 - 1234567890123456789 = 0.0, 1234567890123456789.0 - 1234567890123456789 + 1 = 1.0, 前者因为+1之后超过精度, 用科学计数法表示, +1 被忽略了, 所以结果为0. \n\n3. 复数类型:  \n - 表示形式: a+bJ, a是实部, b是虚部, J是-1的平方根, 是虚数单位, 也可写成j, 注意不是数学上的i\n - 用x.real和x.imag获得实部和虚部, 结果都是**浮点型**\n\n### 1.2.2 字符串类型\n1. 使用单引号, 双引号, 或者三引号定义标准字符串, 三引号的字符串可以多行\n2. 使用下表访问字符串中的字符\n3. 字符串中字符不可改变, 只能重新赋值\n4. 使用转义字符控制输出  \n注意\\0: 空字符, \\a:响铃, \\r: 回车, 表示对当前行重叠输出, 只回车不换行\n5. 字符串前面加r表示原始字符串, 不转义\n6. **eval()函数**: 把字符串内容当作python语句执行, eval('1+1'), 结果为2\n7. **len()函数**: 返回长度\n\n### 1.2.3 布尔类型\n1. True和False, 注意开头大写\n2. 实际上分别用整型值**1和0**参与运算\n\n### 1.2.4 复合数据类型\n1. 包含多个相关联的数据元素,因此称为复合数据类型.\n2. 列表, 元组和字符串是又顺序的, 称为序列.  \n字典和集合是无顺序的.\n3. 列表:  \n - 中括号, 逗号分隔, 类型可不同\n - 可以嵌套\n - 列表元素可以改变\n4. 元组:   \n - 1,2,3 这样省略括号的默认为**元组**\n - 小括号, 逗号分隔, 类型可不同\n - 元组元素不可修改\n - () 表示空元组\n - **(9, )**只有一个元素, 要用逗号结尾\n - (9)表示整数9\n5. 字典:  \n - 大括号, 逗号分隔\n - 关键字: 值, 关键字必须不可变类型且互不相同\n - {} 空字典\n6. 集合:  \n - 无序, 不重复\n - 大括号或者set()函数创建\n - set() 空集合\n\n## 1.3常用模块和函数\n三种导包\n```python\nimport math\nmath.sqrt(2)\n====\nfrom math import sqrt\nsqrt(2)\n===\nfrom math import *\nsqrt(2)\n```\n### 1.3.1 math模块  \n常量: e, pi  \nfabs(), sqrt(), pow(x, y), exp(x), ceil(x), floor(x), fmod(y, x)  \nsin(x), cos(x), tan(x)...  \n\n### 1.3.2 cmath模块\n相对math支持复数运算  \npolar(x): 复数笛卡儿坐标换为极坐标  \nrect(r,p): 复数极坐标换为笛卡儿坐\n\n### 1.3.3 random模块\n- seed(x)随机数种子, 种子相同, 随机数相同, 默认种子是时间  \n- choice([0,1,2])随机挑选一个  \n- sample(seq, k): 从序列中挑k个  \n- shuffle(seq): 随机排序\n- random(): [0, 1)内实数\n- randint(a, b): [a, b]内整数\n- uniform(a,b): [a,b]内实数\n\n### 1.3.4 time模块\n- time(): 返回时间戳\n- localtime(secs): 接收一个时间戳, 返回时间元组\n- asctime([]): 接收一个时间元组, 返回一个日期时间字符串\n- asctime(localtime(time())), 可以这样用\n- ctime(time())和上面的结果相同\n\n### 1.3.5 calendar模块\n- 提供日历相关功能\n- calendar.isleap(), 这个函数可以用来判断是否闰年\n\n### 1.3.6 **内置函数**\n\n- range([start,]end[,step]): 开始和步长可省, 默认开始0, 步长1, \\[start, end),不包括end哦! 如果要使用step, 需要写start. range()函数返回的还是可迭代对象\n- range()可以和list()或者tuple()结合: list(range(5)), tuple(range(5))\n\n\n- ord(): 将字符转化为相应编码值\n- chr(): 将整数转化为相应unicode字符\n\n\n- repr(object): 返回一个对象的string格式, [菜鸟教程](https://www.runoob.com/python/python-func-repr.html)\n- str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式\n- iter(可迭代对象): 用于产生一个可迭代对象的迭代器, 可用next(it)得到迭代器下一个元素\n\n\n- abs()\n- pow(x,y[,z]): x^y%z\n- round(x[,n]): 这个函数尽量不要用! 不是严格的四舍五入, 和浮点数精度有关, 具体可以参考[Python 中关于 round 函数的小坑](https://www.runoob.com/w3cnote/python-round-func-note.html)浮点数x, n为精确到小数点后的位数,可省默认保留整数, 结果仍浮点型\n- divmod(x, y): 结果为(商,余数), divmod(7,4)==(1,3)\n\n## 1.4 基本运算\n\n### 1.4.1 算术运算\n+, -, \\*, /(返回浮点数), //(整除), %, \\*\\*(乘方)  \n这里注意下//这个运算:\n1. 如果是正数, 那就是去掉小数部分, **关键是负数, 需要向绝对值更大的方向进位**.   \n举例: 4//3 == 1, -4//3 == -2, -7//3 == -3, -8//3 == -3\n2. 如果a//b, a或b是浮点数, 那结果也是浮点型, 只有**两个都是整型**, 结果才是整型\n举例: 4//3 == 1, 4.1//3 == 1.0  \n\n注意取模运算的结果,只有**两个都是整型**才是整型, 例: 5%3 == 2, 5%3.0 == 2.0\n\n### 1.4.2 计算误差\n浮点数有效位有效, 17位, 所以肯定有误差.  \n因此, 比较符点数的时候, == 运算符要小心使用, 应该判断是否约等于  \n举例: abs(2.2-1.2-1)<1e-6, 取一个很小的误差就好  \n\n```python\n>>> 2.2-1\n1.2000000000000002\n>>> 2.2-1-1.2\n2.220446049250313e-16\n```\n\n### 1.4.3 数据类型转换\n整型+浮点型, 会自动将整型转换为浮点型  \n**强制转换:**\n- int(x)\n- float(x)\n- complex(x), 将x转换为复数, 实部为x, 虚部为0\n- complex(x, y), x为实部, y为虚部\n\n### 1.4.4 位运算\n- &: 按位与, 全1为1, |: 按位或, 有1为1, ^: 按位异或,不一样为1, ~: 按位取反, <<: 左移, 低位补0, >>: 右移,高位补0\n\n## 1.5 输入与输出\n### 1.5.1 标准输入\n格式:\n- input([提示字符串])    \n\n提示字符串可选, input读入一行, 并返回一个字符串.  \n如果需要数值数据, 需要使用类型将字符串转化成数值   \n可以给多变量赋值, 使用eval(input())\n\n```python\n# 读整数\n>>> x=int(input())\n12\n>>> x\n12\n\n# 读多个变量\n>>> x,y=eval(input())\n1,2\n>> x\n1\n>>> y\n2\n# 相当于x,y=(3,4)\n```\n\n### 1.5.2 标准输出\n格式:\n- print([输出项1,输出项2,..输出项n]\\[,seq=分隔符][,end=结束符])\n\nseq默认空格, end默认回车换行\n没有输出项则输出空行. print()从左到右输出每个项\n\n```python\n>>> print(10, 20)\n10 20\n>>> print(10, 20, seq=',')\n10,20\n>>> print(10, 20, seq=',',end='*')\n10,20*\n#并且没换行\n```\n\n### 1.5.3 格式化输出\n三种格式化输出方式:\n- 用%\n- 用format()内置函数\n- 用字符串的format方法\n\n#### 1.5.3.1 格式化运算符%\n格式化字符串%(输出项1,输出项2...输出项n)\n\n%的运算结果是字符串  \n\n格式符:\n- %% 百分号, %c 字符, %s 字符串, %d 带符号整数, %o 八进制, %x/X, %e/E 科学记数法, %f/F 浮点数, %g/G 根据值大小选%e还是%f\n- 不管什么类型,都可以用%s\n\n```python\n>>> print('Values are %s, %s, %s'%(1,2.3,['one','two','three']))\n\n# 表示总长度为6, 小数部分2位, 输出不足用0补齐, 小数点也占一位\n# 0可以用-, +代替, -左对齐, +表在正数前加上+号,默认不加\n>>> '%06.2f'%1.234\n'001.24'\n\n# 用字典输出时特殊用法, 这时候值由键确定\n# '%(key)06.1f'%{'key':value}\n>>> '%(name)s:%(score)06.1f'%{'score':9.5,'name':'Lucy'}\n'Lucy:0009.5'\n\n# %*.*f 运行中确定的\n>>> '%0*.*f'%(6,2,2.345)\n'002.35'\n```\n\n#### 1.5.3.2 format()内置函数\n\n```\nformat(输出项[,格式字符串])\n```\n\n省略格式符等价与str()函数   \n\n格式符:\n- d, b(二进制), o, x, X\n- f, F, e, E, g, G\n- c(整数为编码的字符)\n- %(输出百分号)\n- <(左对齐), >(右对齐), ^(居中对齐), =(填充字符位于符号和数字之间), +(表正号)\n\n```python\n>>> print(format(65,'c'),format(3.145,'f'))\nA 3.145000\n>>> print(format(3.145,'6.2f'),format(3.145,'05.3'))\n  3.15 03.15\n>>> print(format(3.145,'0=+10'),format('test','>20'))\n+00003.145                 test\n```\n\n#### 1.5.3.3 字符串的format()方法\n属于字符串的类方法, 尽量用字符串的format()方法\n\n```python\n### \n'格式化字符串'.format(输出项1, 输出项2, 输出项3...输出项n)\n\n格式字符串格式:\n{[序号或者键]: 格式说明符} 冒号不能丢\n\n格式化字符中, 普通字符原样输出, 格式说明符对应输出项\n\n序号从0开始! 如果全部省略就按照顺序输出\n### \n\n# 省略\n>>> print('i am {}, {}'.format('Brenden','Welcome!'))\ni am Brenden, Welcome!\n\n# 序号\n>>> print('first:{1}, second:{0}, third:{2}'.format(1,2,3))\nfirst:2, second:1, third:3\n\n# 混用序号和键\n>>> print('hello, i am {name}, {0}'.format('Welcome',name=\"xiaoming\"))\nhello, i am xiaoming, Welcome\n\n# 结合格式符\n>>> print('{0:*^15}'.format(12345678))\n***12345678****\n>>> print('{0:<15}'.format(12345678))\n12345678\n>>> print('{0:>15}'.format(12345678))\n       12345678\n```\n\n## 1.6 缩进和注释\n### 1.6.1 缩进\n我认为, Python相对其他语言, 缩进真的是一个很坑的点, 同一程序中最好是一样的缩进, 否则经常出现缩进错误   \n一般是四个空格或者一个TAB   \n\n### 1.6.2 注释\n如果注释里面有中文,记得要在开头使用`#coding=utf-8`或者`#coding=gbk`\n\n- 单行注释: #开头, #后的就是注释\n- 多行注释: 三个单引号或者双引号, **多行注释不可以使用反斜杠续行!!**\n\n## 1.7赋值语句\n### 1.7.1 一般格式\n变量=表达式\n### 1.7.2 复合赋值语句\n\n```\n+=, -=, *=, /=, //=, **=, <<=, >>=, &=, |=, ^=\n```\n\n**注意!** `x*y+5==x*(y+5)`\n\n### 1.7.3 多变量赋值\n1. 链式赋值\n - 变量1=变量2=变量.....=变量n=表达式\n - a=b=10 等价于 a=10;b=10\n - 要注意的是, 上例, a和b同时指向一个整型对象10\n2. 同步赋值\n - 变量1,变量2,变量3...=表达式1,表达式2...表达式n\n - a,b,c=1,2,3\n - 注意同步赋值不是单一赋值语句的先后执行!!!\n\n```\n>>> x,x=2,-50 \n# x结果为-50\n\n>>> x=-11\n>>> x,y=12,x\n# 此时x=12, 但是y=-11 !!!要小心使用\n\n>>> a,b=1,2\n>>> a,b=b,a\n# 此时a, b分别为2, 1\n# 可以用a,b=b,a省略一个中间变量\n```\n\n## 1.8 条件的描述\n### 1.8.1 关系运算符\n优先级小于算术运算符, 就是先算算术运算符, 再比较\n```\n<, <=, >, >=, ==, !=\n```\n\n### 1.8.2 逻辑运算\n\n```\nand(与), or(或), not(非)\n```\n\n优先级: \n- not > and > or\n\n逻辑与: 前面的False就不算后面的\n逻辑或: 前面的True就不算后面的\n\n### 1.8.3 成员测试\n\n```\nin: 在序列中查找, 返回True或者False\nnot in: 么找到返回True\nis: 测试两个变量是否, 指向同一个变量\n```\n\n{% cq %}\n**end CH1**\n{% endcq %}\n\n# CH2. Python程序结构\n## 2.1 算法及其描述\n算法+数据结构=程序, 计算机解决问题的方法和步骤就是算法   \n算法描述: \n1. 传统流程图\n2. 结构化流程图:\n    - 程序的三种基本结构: 顺序结构, 选择结构, 循环结构\n    - 结构化流程图(N-S图): 顺序结构, 选择结构, 当型循环结构, 直到型循环结构, 各单元顺序执行\n\n## 2.2 顺序结构\n简单的按照出现顺序执行\n\n## 2.3 选择结构\n### 2.3.1 if-elif-else\n\n要注意的是, if的表达式可以使任意的, 比如 if 'B':   \n嵌套的时候根据对齐来配对\n\n```python\n# 单分支\nif ...:\n  表达式\n\n# 双分支\nif ...:\n  语句\nelse:\n  ...\n\n# 多分支\nif ...:\n  ...\nelif ...:\n  ...\nelif ...:\n  ...\nelse:\n  ...\n```\n\n### 2.3.2 条件运算\n\n**可以作为一个运算量, 而不是一个单独的语句**\n\n```python\n表达式1 if 表达式 else 表达式2\n\n>>> z= x if x>y else y\n# 其中z=后面的就是一个条件运算\n\n>>> i=0\n>>> 'a' if i else 'A'\n'A'\n```\n\n## 2.4 循环结构\n### 2.4.1 while\nwhile和if有一个相同的地方就是, 如果循环体只哟一个语句, 可以写在一行\n\n```python\nwhile ...:\n  ....\n\n# 可以结合else语句\n# 但是只可以在while部分正常退出的时候才执行else部分\n# 如果是break退出的, 不执行else部分\nwhile ...:\n  ....\nelse:\n  ....\n```\n\n### 2.4.2 for\n可结合range()函数, 看1.3.6部分\n\n> range([start,]end[,step]): 开始和步长可省, 默认开始0, 步长1, [start, end),不包括end哦! 如果要使用step, 需要写start. range()返回可迭代对象\n> for循环中会自动调用iter()函数,和next()函数获得range里的元素\n\n```python\n# 这个序列可以是: 字符串, 元组, 列表...\nfor 变量 in 序列:\n  语句块\n\n# 也可以用else语句\n# 没碰到break就可以执行\nfor 变量 in 序列:\n  语句块\nelse:\n  ....\n\n# 结合range函数\n>>> for i in range(5):\n>>>   print(i, end=',')\n0,1,2,3,4\n>>> for i in range(0,5,2):\n>>>   print(i, end=',')\n0,2,4\n```\n\n## 2.5 循环控制语句\n有`break`和`pass`和`continue`这三个\n\npass语句代表空语句,空操作, 相当于占位符\n\n{% cq %}\n**end CH2**\n{% endcq %}\n\n# CH3. 字符串和正则\n## 3.1 字符串\n关于编码的两个函数\n- 默认unicode编码, encode: 编码为, decode: 解码为unicode\n- s.encode('utf-8')或者s.encode('gbk')\n- s.decode('utf-8')或者s.decode('gbk')\n\n### 索引和分片\n\n索引分为正向和反向\n\n|  H | e  |  l | l  |  o |\n|:--:|:--:|:--:|:--:|:--:|\n| s[0] | s[1] | s[2] | s[3] | s[4]|\n| s[-5] | s[-4] | s[-3] | s[-2] | s[-1]|\n\n分片使用中括号和如下格式:\n- s[i:j:k]\n- i: 开始位置下标, j: 结束位置下标, 不包括j位置的字符, k: 步长\n- i,j,k都可以省略, i默认0或-1, j默认到最后一个字符, k默认1\n- 一定要注意, 不管k是正还是负, 都不包括j位置的字符\n- i和j都可以超过字符串的长度\n\n示例:\n\n```python\n>>> s='hello'\n>>> print(s[0:4:1])\nhell\n>>> print(s[0:5:2])\nhlo\n\n>>> print(s[-1:-5:-1])\nolle\n>>> print(s[-1:-6:-1])\nolleh\n\n>>> print(s[0:len(s)])\nhello\n>>> print(s[-len(s):-1])\nhell\n\n# 都省了\n>>> print(s[:])\nhello\n>>> print(s[::2])\nhlo\n>>> print(s[::-1])\nolleh\n# 省略了步长\n>>> print(s[:-1])\nhell\n```\n\n### 字符串连接\n使用`+`连接, 如果不是字符串类型, 使用str()函数或者repr()函数转换成字符串\n\n字符串不可用下标修改, 所以可以用连接操作改某个字符\n\n```python\n>>> s='abcd'\n>>> s=s[0]+9+s[2]\n>>> s\n'a9cd'\n```\n\n可以使用`*`进行重复连接, n\\*s或者s\\*n  \n可以使用+=或者\\*=这样的操作\n\n如果是连加操作, +的效率很低, 可以使用s.join()函数代替, s是分隔符\n\n```python\n>>> '-'.join(['Python','and','Program'])\n'Python-and-Program'\n```\n\n### 字符串比较\n- 单子符就直接比较ASCII码\n- 相同长度从左到右比较ASCII\n- 不同长度补全空格再从左到右比较ASCII\n\n### 字符串成员关系\n用`in`和`not in`: 字符串1 [not] in 字符串2  \n返回True或者False\n\n### 字符串常用方法\n字符串是一个类, 有许多类方法.这里只记常用的  \n\n#### 大小写和对齐\n- s.upper()/lower()\n- s.ljust(width, [fillchar]): 输出width长度, 左对齐, 不足部分fillchar补齐, 默认空格\n- s.rjust()/center(): 参数同上, 右对齐和居中\n\n#### 字符串搜索\n- s.find(sub,[start,[end]]): 返回sub的第一个字符编号, 没有返回-1\n- s.index(sub,[start,[end]]): 和find相同, 不过没有时,返回一个错误\n- s.rfind(sub,[start,[end]]): 从后往前找sub,第一个字符编号,没有返回-1\n- s.rindex(sub,[start,[end]])\n- s.count(substr,[start,[end]]): 返回出现次数\n- s.startswith(prefix,[start,[end]])\n- s.endswith(suffix,[start,[end]])\n\n#### 字符串替换\n- s.replace(oldstr,newstr,[count]): old替换为new\n- s.strip([chars]): 默认去前后空格, s前后的chars中的字符去掉\n- s.lstrip([chars])/rstrip()\n- s.expandtabs([tabsize]): s中tab替换为空格, tabsize为空格的数量, 默认8个\n\n#### 字符串拆分\n- s.split([sep,[maxsplit]]): sep:分隔符,默认空格, 按sep把s拆成一个列表, maxsplit:拆分次数,默认-1无限制\n- s.rsplit([sep,[maxsplit]]): 从右侧拆\n- s.splitlines([keepends]): 按行拆成列表, keepends为true: 保留每行分隔符\n- s.partition(sub): 拆成三个元素的元组(sub左, sub, sub右), 如果没sub, 返回(s, '', '')\n- s.rpartition(sub): 从右边找sub\n\n#### 字符串连接\n- s.join(seq): seq为序列, s为分隔符\n通常和list(s)结合使用, 修改string某个字符\n\n```python\n>>> s='abcd'\n>>> s=list(s)\n>>> s[0]='t'\n>>> s=\"\".join(s)\n>>> s\n'tbcd'\n```\n\n#### 字符串类型判断\n- s.isalnum(): 字母和数字, 至少一个字符\n- s.isalpha(): 全字母,至少一个字符\n- s.isdigit(): 全数字,至少一个字符\n- s.isspace(): 全空格,至少一个字符\n- s.islower()/isupper()/istitle()\n\n### 字节类型bytes\nbytes和string不一样, 可以用string.encode()方法和bytes.decode()方法进行两者转换.  \nbytes可以使用bytearray(by)的方式将bytes转换为bytearray对象   \nbytes对象不可修改, bytearray可修改\n\n## 3.2 正则表达式\n太多了, 附上[菜鸟教程](https://www.runoob.com/python/python-reg-expressions.html)\n\n{% cq %}\n**end CH3**\n{% endcq %}\n\n# CH4. 复合数据类型\n## 4.1 序列\n序列包括**字符串, 列表, 元组**, 按照位置编号存取\n\n### 4.1.1 通用操作\n- 索引, 用下标访问, num[0], 支持反向索引, 从-1开始\n- 分片, 注意不改变原序列, 而是产生一个新序列, 下面是常用分片用法\n\n```python\n>>> num=[1,2,3,4,5,6,7,8,9,10]\n# 常见用法\n>>> num[3:6]\n[4, 5, 6]\n\n# 可以从末尾计数, 负数索引, 效果相同\n>>> num[7:10]\n[8, 9, 10]\n>>> num[-3:]\n[8, 9, 10]\n\n# 省略部分下标\n>>> num[:3]\n[1, 2, 3]\n>>> num[:]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# 设置步长\n>>> num[:len(num):2]\n[1, 3, 5, 7, 9]\n\n# 开始索引可以超过列表长度, 视作从最后一个开始\n>>> num[11:0:-1]\n[10, 9, 8, 7, 6, 5, 4, 3, 2]\n>>> num[8:0:-1]\n[9, 8, 7, 6, 5, 4, 3, 2]\n\n# 如果步长为负数, 开始索引必须大于终止索引\n>>> num[0:10:-1]\n[]\n\n# 从id可以看出分片是新序列, 和赋值不一样\n>>> x=[1,2,3]\n>>> y=x[:]\n>>> id(x),id(y)\n(140158585788768, 140158585103696)\n>>> z=x\n>>> id(x),id(z)\n(140158585788768, 140158585788768)\n\n```\n\n- 同类型序列可用+直接相加\n- 可以用\\*进行乘法, 生成新序列, n<1会返回一个空列表\n\n```python\n>>> s=[None]*10\n>>> s\n[None, None, None, None, None, None, None, None, None, None]\n```\n\n- 字符串部分介绍过, 可以直接比较, 同样适用于列表和元组, 但是列表和元组不可以比较\n- 用in和notin判断成员资格\n- 常用函数: len(), max(), min(), sum():要求元素必须为数值\n- 常用函数: s.count(x), s.index(x)\n- enumerate(seq): 接收可迭代对象, 返回enumerate对象, 由每个元素的索引和值组成(索引, 值)\n- zip(seq1,seq2..seqn)\n- sorted(iterable, key=None, reverse=False): 返回排序后的列表, 返回的是副本,不改变源. reverse=False升序, reverse=True降序\n- reversed(iterable): 逆序排列, 返回新的对象\n- all(seq): seq元素都是True则返回True\n- any(seq): seq任一为True则返回True\n- 序列拆分: 变量个数不一致时, 要用\\*, \\*只能有1个\n\n```python\n>>> x=[1,2,3]\n>>> a,b,c=x\n>>> a,b,c\n(1, 2, 3)\n>>> a,*b=x\n>>> a,b\n(1, [2, 3])\n>>> *a,b=x\n>>> a,b\n([1, 2], 3)\n```\n\n### 4.1.2 列表专用操作\n- 列表可修改, 可元素赋值\n- del seq[index]/ del seq : 删除某元素或对象\n- 分片赋值: 可以做到增加, 删除, 修改\n\n```python\n>>> name=list('Perl')\n\n# 修改\n>>> name[2:]=list('ar')\n>>> name\n['P', 'e', 'a', 'r']\n\n# 修改并增加, 后面那部分可以比前面的长\n>>> name[1:]=list('ython')\n>>> name\n['P', 'y', 't', 'h', 'o', 'n']\n\n# 可以插入序列\n>>> name=[1,4]\n>>> name[1:1]=[2,3]\n>>> name\n[1, 2, 3, 4]\n\n# 删除部分元素\n>>> name[1:3]=[]\n>>> name\n[1, 4]\n\n# 如果步长不等于1, 那么前后数量必须相同\n>>> name[:4:2]=[2,3]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: attempt to assign sequence of size 2 to extended slice of size 1\n```\n\n- 列表解析, 表达式可以任意, for循环可嵌套, if可选\n\n```python\n>>> [i for i in range(4)]\n[0, 1, 2, 3]\n>>> [ord(x) for x in 'python']\n[112, 121, 116, 104, 111, 110]\n>>> [(x,y) for x in range(5) if x%2==0 for y in range(5) if y%2==1]\n[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]\n```\n\n- 以下方法都是在源列表上操作, 会修改原列表\n 1. s.append(x): 末尾添加单个元素\n 1. s.extend(seq): 在s末尾添加seq所有元素\n 1. s.sort(reverse=False, key=None) 和 sorted(seq)这个函数功能一样, 但是sorted是返回副本\n 1. s.reverse(): 同reversed(seq)\n 1. s.pop([index]): 删除并返回index位置的元素, 默认最后一个, 超范围报错\n 1. s.insert(index,x): index处插入x, index大于列表长度,则插在最后\n 1. s.remove(x): 如果有多个, 只删除第一个\n\n### 4.1.3 元组和列表\n都是有序序列, 常可替换\n\n**区别:**\n1. 元组不可变\n2. 元组小括号,列表中括号\n3. 元组可以在字典中作为key\n\n元组不可变, 但是可以用元组创建新元组   \n如果元组内元素为可变的, 如列表或字符串, 则可以修改  \n使用 list()和tuple()函数相互转换\n\n## 4.2 字典和集合\n字典主要是元素的检索, 插入和删除.   \n集合主要考虑集合间的并, 交和差操作.  \n\n### 4.2.1 字典\n注意点:\n- 关键是是不可变的, 如果元组里有可变类型比如列表, 就不可以作为key. python对key进行哈希, 根据计算结果决定存储地址, 所以可以用hash()函数判断是否可以作为key\n- 字典是可变类型, 可以在原处增长或者缩短, 无需生成副本.\n- 字典是异构的, 可以抱含任何类型数据: 元素可以是字典,列表,元组, 支持任意层次嵌套.\n- {}和dict()是空字典\n\n```python\n>>> d1=dict()\n>>> d1\n{}\n\n# dict参数可以是列表和元组\n>>> d2=dict((['x',1],['y',2]))\n>>> d2\n{'x': 1, 'y': 2}\n\n>>> d2=dict([['x',1],['y',2]])\n>>> d2\n{'x': 1, 'y': 2}\n\n# 可以直接指定key和val\n>>> d3=dict(name='allen',age=15)\n>>> d3\n{'name': 'allen', 'age': 15}\n```\n\n- 更新和添加: 字典的更新直接用dict[key]=new_val就可以, 如果没有就直接增加一个新元素\n- 删除: del 字典名[key] 或者 del 字典名\n- 判断key是否存在: key in / not in dict\n- len(dict)\n- 只支持==和！=\n- list(dict)返回key\n\n常用方法：\n- fromkeys(序列[,值])\n- keys(), values(), items()\n- d.copy(), d.clear(), d.pop(key), d.popitem()\n- d.get(key[,value]): 返回key对应的val值, 若没有, 则返回value\n- d.setdefault(key,[value]): 存在则返回值, 不存在则插入key:value, value默认none\n- d2.update(d1): d1合并到d2, d1不变\n- has_key(key): 存在key返回true, 用in和not in就可以\n\n### 4.2.2 集合\n#### 注意点\n1. 空集合是set()\n2. 用大括号\n3. 字符串,列表, 元组都可以转set\n4. set()创建可变集合, frozenset()创建不可变集合\n5. 可变集合的元素只能是数值, 字符串, 元组这些不可修改的, 可修改的列表,字典和可变集合都不可作为元素\n\n#### 集合的运算\n- 并： |, |=, s1.union(s2...sn)\n- 交： & , s1.intersection(s2...sn)\n- 差： -, s1.difference(s2...sn)\n- 对称差： ^, s1.symmetric_difference(s2...sn)\n- ==\n- ！=\n- s1\\<s2: s1是s2真子集,  \n- s1\\<=s2: s1是s2子集, s1.issubset(s2)\n- s1\\>s2: 超集\n- s1\\>=s2: 相当于s1.issuperset(s2)\n- s.copy()\n\n#### 适用于可变集合的方法\n- s.add(x)\n- s.remove(x): 不存在会报错; s.discard(x): 不存在不报错\n- s.pop(): 删除任意一个元素并返回\n- s.clear()\n\n\n- s.update(s1,s2...): s=s|s1|s2...sn\n- s.intersection_update(s1,s2..sn): s=s&s1&s2..&sn\n- s.difference_update(s1,s2..s2): s=s-s1-s2..-sn\n- s.symmetric_difference_update(s1): s=s^s1\n\n{% cq %}\n**end CH4**\n{% endcq %}\n\n# CH5. 函数\n和其他的语言一样, 函数先定义再使用\n\n## 5.1 参数\n参数传递的方式是\"值传递\"\n\n**要注意的是:**\n- 形参重新赋值重新分配对象, 指向别的对象, 不会改变实参\n- 如果仅修改形参内容, 比如列表, 字典这样的可修改对象, 则会影响实参\n\n### 参数类型\n- 位置参数: 参数按照位置对应\n- 关键字参数: 形参名=值\n\n```python\ndef mykey(x,y):\n  print(x, y)\nmykey(y=10, x=1)\n```\n\n- 默认参数: 形参=默认值, 必须在参数列表右边, 在可变长度参数之前\n- 可变长度参数: 参数数量不固定时, 针对元组和字典两种. 其他所有类型参数都必须在可变长度参数之前\n\n```python\n# 元组一个*\ndef myvarl(*t):\n  print(t)\nmyvarl(1,2,3)\n\n# 字典两个*\ndef myvarl(**t):\n  print(t)\nmyvarl('y'=1,'x'=2,'z'=3)\n\n```\n\n## 5.2 匿名函数\n\n```python\n# 参数也可以使用默认值, 返回值是表达式结果\nlambda [参数1[,参数2,...,参数n]]: 表达式\n\n# 例如\nlambda x,y: x+y\n\n# 调用\n>>> f=lambda x,y: x+y\n>>> f(5,10)\n15\n\n# 把匿名函数作为普通函数返回值\ndef f():\n  return lambda x,y:x+y\n\n# 匿名函数作为序列或者字典元素\n列表名=[匿名1, 匿名2,...匿名n]\n# 调用\n列表名[index](参数)\n```\n\n## 5.3 装饰器\n这里只记录一些注意点, 比较全面的看书上或者[Python 函数装饰器|菜鸟教程](https://www.runoob.com/w3cnote/python-func-decorators.html), 这个讲的很全\n\n- 概念: 装饰器是用来包装函数的函数, 用来为已经存在的函数添加额外功能\n- 返回对象: 装饰器输入是被装饰的函数对象, 返回新的函数对象.\n- 调用: 使用@调用装饰器\n- 调用的时候,本质上, 是将对象名重新指向一个新返回的函数, 达到修改函数的目的\n- 返回: 装饰器最里面那层, 要返回被装饰的函数\n- 在装饰器中,返回值, 例如 return func, func后面没有(), 加上()表示调用.\n- 外层里层函数关系: 最外面的那层函数返回值, 是里面一层函数的函数名\n- 多重装饰器: 执行顺序是从下往上, 最后执行被装饰函数内容\n\n## 5.4 \\_\\_name\\_\\_\n主动调用\\_\\_name\\_\\_值为\\_\\_main\\_\\_, 被导包时值为模块名\n把一个程序文件既当作模块, 有可以主动调用时, 程序入口前加if:\n\n```python\ndef test():\n  pass\nif __name__=='__main__':\n  test()\n```\n\n{% cq %}\n**end CH5**\n{% endcq %}\n\n# CH6. 类\n\n## 6.1 属性\n\n| |格式|访问控制|添加|修改|作用域|\n|:-|:-|:-|:-|:-|:-|\n|私有属性|类里函数外, 以\\_\\_开头的属性|只能通过类方法中使用self.\\_\\_name使用,类外无法直接访问|只能在类里面添加|在类方法里用self修改, 不影响其他对象|单个|\n|类属性|直接在类里函数外定义的非私有属性,所有对象公有|类外通过类名和实例对象(不推荐)调用|类外可以通过类名.类属性添加|类外:类名修改,类里:类方法|所有|\n|实例属性|在\\_\\_init\\_\\_里面定义或者通过实例对象引用定义|类外只有实例对象可以访问,类里面可以在类方法中调用|类里面在init方法中添加,类外使用实例对象.实例属性添加|用self修改或实例对象.实例属性修改|单个|\n\n注意点:\n- 千万不要尝试实例对象创建类属性, 会自动创建一个同名实例属性,并屏蔽掉类属性\n- 不可以用实例对象直接修改类属性, 要用类方法修改\n- 使用del 删除实例属性和实例对象\n\n## 6.2 方法\n\n| |特征|调用|和属性关系|\n|:-|:-|:-|:-|\n|构造方法|\\_\\_init\\_\\_(self)|生成对象自动调用|里面用self定义的都是实例属性|\n|析构方法|\\_\\_del\\_\\_(self)|释放对象自动调用|可以在里面进行释放资源的操作|\n|类方法|@classmethod修饰器,第一个参数为cls|实例对象和类对象访问|引用的是类属性\n|实例方法|第一个参数为self|只能实例对象调用|实例属性优先级高于类属性,实例方法中实例属性会屏蔽类属性|\n|静态方法|@staticmethod修饰器,无需多定义参数|类名和实例对象都可以访问|不绑定类或者实例, 引用类属性需要使用类名引用|\n\n注意点:\n- 静态方法和实例方法不同的是, 静态方法不会自动绑定到类上, 类方法会自动绑定. 静态方法不需要引用类或者实例\n- 静态方法很像我们在类外定义的函数，只不过静态方法可以通过类或者实例来调用而已。\n- 实例方法中引用属性, 若存在同名类属性和实例属性, 则引用实例属性, 若无实例属性, 则引用类属性\n- 实例方法中修改属性, 若存在同名类属性和实例属性, 则修改实例属性, 若无实例属性, 则创建新实例属性\n\n## 6.3 继承\n\n```python\n# 可以多重继承\nclass 子类名(父类名1,父类名2,..):\n  类体\n```\n\n注: \n- 如果子类中没有重新定义构造方法, 会执行第一个父类的构造方法\n- 使用内置方法issubclass(Child, Parent)判断一个类是否是另一个类的子孙类, 返回True或者False\n- 小心使用多重继承, 能不用就不用, 可以用组合\n- 多重继承函数的搜索顺序是广度优先, 从左到右找, 没有就下一个\n- super(Child,self).\\_\\_init\\_\\_()相当于Parent.\\_\\_init\\_\\_(self)\n- 子类继承父类所有属性和方法, 如果没有覆盖掉, 则调用父类方法\n- 可以使用父类名Parent.fun(self)或者super(Child,self).fun()来调用父类方法, 但是一定要传self\n\n\n对于init函数:\n- 如果子类没有定义自己的初始化函数，父类的初始化函数会被默认调用；但是如果要实例化子类的对象，则只能传入父类的初始化函数对应的参数，否则会出错。\n- 如果子类定义了自己的初始化函数，而在子类中没有显示调用父类的初始化函数，则父类的属性不会被初始化\n- 如果子类定义了自己的初始化函数，在子类中显示调用父类，子类和父类的属性都会被初始化\n\n详细的看下面这几个链接:\n　　[python中的类，对象，方法，属性初认识（一）](http://blog.csdn.net/brucewong0516/article/details/79114977)    \n　　[详解类class的属性：类数据属性、实例数据属性、特殊的类属性、属性隐藏（二）](http://blog.csdn.net/brucewong0516/article/details/79118703)   \n　　[详解类class的方法：实例方法、类方法、静态方法（三）](http://blog.csdn.net/brucewong0516/article/details/79119551)   \n　　[详解类class的访问控制：单下划线与双下划线（四）](http://blog.csdn.net/brucewong0516/article/details/79120841)   \n　　[详解类class的继承、__init__初始化、super方法](https://blog.csdn.net/brucewong0516/article/details/79121179)\n\n# CH7. 文件操作\n\n具体的可看[Python 文件I/O | 菜鸟教程](https://www.runoob.com/python/python-files-io.html)和[python 文件操作，最全的一个 | CSDN](https://blog.csdn.net/m0_38059843/article/details/78240835)\n\n# CH8. 注意点\n1. 整除是//不是/, 看1.4.1\n2. 判断在不在用in\n3. 正则的使用\n4. \\$是匹配结尾,如果是一行里面的不要用\\$符号,匹配所有单词只需要`[a-zA-Z]+`就可以\n4. read()没有参数就是读全部\n3. write()写字符串的时候可以用字符串.format()方法格式化输出到文件\n4. open()之后要记得close()\n4. dict.items()之后要使用list()转换一下才可以用\n4. 没有返回值的函数说明是要在序列内部修改, 注意不要修改引用, 只改内容\n1. 文件操作要记得使用try-except\n1. **大量的数据**统计要最好用字典,字典使用哈希会很快 \n","slug":"Python复习","published":1,"updated":"2019-09-12T12:55:26.551Z","layout":"post","photos":[],"link":"","_id":"ck2424llx002ylksbob4dzxo1","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>系统的复习一下Python的知识点, 做一些笔记</p></div><a id=\"more\"></a><h1 id=\"CH1-Python语言基础\"><a href=\"#CH1-Python语言基础\" class=\"headerlink\" title=\"CH1. Python语言基础\"></a>CH1. Python语言基础</h1><h2 id=\"1-1-常量与变量\"><a href=\"#1-1-常量与变量\" class=\"headerlink\" title=\"1.1 常量与变量\"></a>1.1 常量与变量</h2><h3 id=\"概念和注意点\"><a href=\"#概念和注意点\" class=\"headerlink\" title=\"概念和注意点\"></a>概念和注意点</h3><ol><li>内存是以字节为单位的一片连续的存储空间, 变量名是内存单元的名称, 变量值是变量所对应的内存单元的内容, 变量地址是变量对应内存单元的地址.</li><li>动态类型语言, 确定变量类型是在变量赋值的时候, <strong>每次赋值</strong>都可能改变类型</li><li>是基于值的内存管理方式, 不同的值分配不同的空间.<br>因此, 变量值改变时, 改变的是变量的指向关系, 使得变量指向另一个内存空间.<br>在C语言中是改变变量内存空间的内容, 变量对应的内存空间是固定的.<br>使用<strong> id()函数 </strong>可以查看对象的内存地址.</li><li>python中的变量是对一个对象的引用, 变量和变量之间的赋值是对同一个对象的引用, 变量指向一个对象或内存空间, 内存空间的内容可以修改</li><li>这里需要注意的是, 一些简单的对象, 比如较小的整型对象, Python采用对象重用的方法.<br>举例: a=2, b=2, 不会分配两次内存, a和b同时指向一个对象</li></ol><h3 id=\"变量命名\"><a href=\"#变量命名\" class=\"headerlink\" title=\"变量命名\"></a>变量命名</h3><ol><li>变量命名规则: 数字+字母+下划线, 不可以数字开头, 区分大小写. 单独的下划线是表示上一次运算的结果</li><li>变量名不可以是,关键词:<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> keyword</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(keyword.kwlist)</span><br><span class=\"line\">[<span class=\"string\">'False'</span>, <span class=\"string\">'None'</span>, <span class=\"string\">'True'</span>, <span class=\"string\">'and'</span>, <span class=\"string\">'as'</span>, <span class=\"string\">'assert'</span>, <span class=\"string\">'async'</span>, <span class=\"string\">'await'</span>, <span class=\"string\">'break'</span>, <span class=\"string\">'class'</span>, <span class=\"string\">'continue'</span>, <span class=\"string\">'def'</span>, <span class=\"string\">'del'</span>, <span class=\"string\">'elif'</span>, <span class=\"string\">'else'</span>, <span class=\"string\">'except'</span>, <span class=\"string\">'finally'</span>, <span class=\"string\">'for'</span>, <span class=\"string\">'from'</span>, <span class=\"string\">'global'</span>, <span class=\"string\">'if'</span>, <span class=\"string\">'import'</span>, <span class=\"string\">'in'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'lambda'</span>, <span class=\"string\">'nonlocal'</span>, <span class=\"string\">'not'</span>, <span class=\"string\">'or'</span>, <span class=\"string\">'pass'</span>, <span class=\"string\">'raise'</span>, <span class=\"string\">'return'</span>, <span class=\"string\">'try'</span>, <span class=\"string\">'while'</span>, <span class=\"string\">'with'</span>, <span class=\"string\">'yield'</span>]</span><br></pre></td></tr></table></figure></li></ol><h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><p>分局部变量和全局变量</p><p>函数外就是全局变量, 如果要在函数中修改全局变量, 使用<code>global</code>语句声明它是全局变量</p><p>如果同一程序中, 全局变量和局部变量同名, 则, 在局部变量作用范围内, 全局变量失效</p><p>如果在内层函数要修改外层函数变量:</p><ul><li>使用global</li><li>使用nonlocal关键字, 在内层函数中使用nonlocal声明变量</li><li>nonlocal 适用于在局部函数中的局部函数，把最内层的局部 变量设置成外层局部可用，但是还不是全局的。并且nonlocal必须绑定一个局部变量,不然报错</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scope_test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_local</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        spam = <span class=\"string\">\"local spam\"</span>   <span class=\"comment\">#和外面的spam不一样</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_nonlocal</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span>  spam        <span class=\"comment\">#使用外层的spam变量</span></span><br><span class=\"line\">        spam = <span class=\"string\">\"nonlocal spam\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_global</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">global</span> spam</span><br><span class=\"line\">        spam = <span class=\"string\">\"global spam\"</span></span><br><span class=\"line\">    spam = <span class=\"string\">\"test spam\"</span></span><br><span class=\"line\">    do_local()</span><br><span class=\"line\">    print(<span class=\"string\">\"After local assignmane:\"</span>, spam)</span><br><span class=\"line\">    do_nonlocal()</span><br><span class=\"line\">    print(<span class=\"string\">\"After nonlocal assignment:\"</span>,spam)</span><br><span class=\"line\">    do_global()</span><br><span class=\"line\">    print(<span class=\"string\">\"After global assignment:\"</span>,spam)</span><br><span class=\"line\"></span><br><span class=\"line\">scope_test()</span><br><span class=\"line\">print(<span class=\"string\">\"In global scope:\"</span>,spam)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">After local assignmane: test spam</span><br><span class=\"line\">After <span class=\"keyword\">nonlocal</span> assignment: <span class=\"keyword\">nonlocal</span> spam</span><br><span class=\"line\">After <span class=\"keyword\">global</span> assignment: <span class=\"keyword\">nonlocal</span> spam</span><br><span class=\"line\">In <span class=\"keyword\">global</span> scope: <span class=\"keyword\">global</span> spam</span><br></pre></td></tr></table></figure><h2 id=\"1-2-数据类型\"><a href=\"#1-2-数据类型\" class=\"headerlink\" title=\"1.2 数据类型\"></a>1.2 数据类型</h2><h3 id=\"1-2-1-数值类型\"><a href=\"#1-2-1-数值类型\" class=\"headerlink\" title=\"1.2.1 数值类型\"></a>1.2.1 数值类型</h3><p>三种类型: 整型int, 浮点型float, 复数型complex</p><ol><li><p>整型数据:<br>整数, 不带小数点, 可以有正负号.<br>数据的值不固定长度, 只要内存允许, 可以<strong>任意长度</strong><br>四种表示:</p><ul><li>十进制</li><li>二进制, 0b或者0B开头</li><li>八进制, 0o或者0O开头</li><li>十六进制, 0x或者0X开头</li></ul></li><li><p>浮点类型:<br>两种表示:</p><ul><li>十进制小数: 数字+小数点, 小数点后面可以没有数字, 如: 3.23, 34.0, 0.0, 34.</li><li>指数形式: 科学计数法表示的, e或者E表示10为底的指数. 两部分比如同时出现, 指数必须整数. 如4e-5, 45e-6. 提供17位<strong>有效数字</strong>精度, <strong>不是17位小数!</strong></li><li>注意可能选择题, 1234567890123456789.0 + 1 - 1234567890123456789 = 0.0, 1234567890123456789.0 - 1234567890123456789 + 1 = 1.0, 前者因为+1之后超过精度, 用科学计数法表示, +1 被忽略了, 所以结果为0.</li></ul></li><li><p>复数类型:</p><ul><li>表示形式: a+bJ, a是实部, b是虚部, J是-1的平方根, 是虚数单位, 也可写成j, 注意不是数学上的i</li><li>用x.real和x.imag获得实部和虚部, 结果都是<strong>浮点型</strong></li></ul></li></ol><h3 id=\"1-2-2-字符串类型\"><a href=\"#1-2-2-字符串类型\" class=\"headerlink\" title=\"1.2.2 字符串类型\"></a>1.2.2 字符串类型</h3><ol><li>使用单引号, 双引号, 或者三引号定义标准字符串, 三引号的字符串可以多行</li><li>使用下表访问字符串中的字符</li><li>字符串中字符不可改变, 只能重新赋值</li><li>使用转义字符控制输出<br>注意\\0: 空字符, \\a:响铃, \\r: 回车, 表示对当前行重叠输出, 只回车不换行</li><li>字符串前面加r表示原始字符串, 不转义</li><li><strong>eval()函数</strong>: 把字符串内容当作python语句执行, eval(‘1+1’), 结果为2</li><li><strong>len()函数</strong>: 返回长度</li></ol><h3 id=\"1-2-3-布尔类型\"><a href=\"#1-2-3-布尔类型\" class=\"headerlink\" title=\"1.2.3 布尔类型\"></a>1.2.3 布尔类型</h3><ol><li>True和False, 注意开头大写</li><li>实际上分别用整型值<strong>1和0</strong>参与运算</li></ol><h3 id=\"1-2-4-复合数据类型\"><a href=\"#1-2-4-复合数据类型\" class=\"headerlink\" title=\"1.2.4 复合数据类型\"></a>1.2.4 复合数据类型</h3><ol><li>包含多个相关联的数据元素,因此称为复合数据类型.</li><li>列表, 元组和字符串是又顺序的, 称为序列.<br>字典和集合是无顺序的.</li><li>列表:<ul><li>中括号, 逗号分隔, 类型可不同</li><li>可以嵌套</li><li>列表元素可以改变</li></ul></li><li>元组:<ul><li>1,2,3 这样省略括号的默认为<strong>元组</strong></li><li>小括号, 逗号分隔, 类型可不同</li><li>元组元素不可修改</li><li>() 表示空元组</li><li><strong>(9, )</strong>只有一个元素, 要用逗号结尾</li><li>(9)表示整数9</li></ul></li><li>字典:<ul><li>大括号, 逗号分隔</li><li>关键字: 值, 关键字必须不可变类型且互不相同</li><li>{} 空字典</li></ul></li><li>集合:<ul><li>无序, 不重复</li><li>大括号或者set()函数创建</li><li>set() 空集合</li></ul></li></ol><h2 id=\"1-3常用模块和函数\"><a href=\"#1-3常用模块和函数\" class=\"headerlink\" title=\"1.3常用模块和函数\"></a>1.3常用模块和函数</h2><p>三种导包<br></p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\">math.sqrt(<span class=\"number\">2</span>)</span><br><span class=\"line\">====</span><br><span class=\"line\"><span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> sqrt</span><br><span class=\"line\">sqrt(<span class=\"number\">2</span>)</span><br><span class=\"line\">===</span><br><span class=\"line\"><span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sqrt(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure><p></p><h3 id=\"1-3-1-math模块\"><a href=\"#1-3-1-math模块\" class=\"headerlink\" title=\"1.3.1 math模块\"></a>1.3.1 math模块</h3><p>常量: e, pi<br>fabs(), sqrt(), pow(x, y), exp(x), ceil(x), floor(x), fmod(y, x)<br>sin(x), cos(x), tan(x)…</p><h3 id=\"1-3-2-cmath模块\"><a href=\"#1-3-2-cmath模块\" class=\"headerlink\" title=\"1.3.2 cmath模块\"></a>1.3.2 cmath模块</h3><p>相对math支持复数运算<br>polar(x): 复数笛卡儿坐标换为极坐标<br>rect(r,p): 复数极坐标换为笛卡儿坐</p><h3 id=\"1-3-3-random模块\"><a href=\"#1-3-3-random模块\" class=\"headerlink\" title=\"1.3.3 random模块\"></a>1.3.3 random模块</h3><ul><li>seed(x)随机数种子, 种子相同, 随机数相同, 默认种子是时间</li><li>choice([0,1,2])随机挑选一个</li><li>sample(seq, k): 从序列中挑k个</li><li>shuffle(seq): 随机排序</li><li>random(): [0, 1)内实数</li><li>randint(a, b): [a, b]内整数</li><li>uniform(a,b): [a,b]内实数</li></ul><h3 id=\"1-3-4-time模块\"><a href=\"#1-3-4-time模块\" class=\"headerlink\" title=\"1.3.4 time模块\"></a>1.3.4 time模块</h3><ul><li>time(): 返回时间戳</li><li>localtime(secs): 接收一个时间戳, 返回时间元组</li><li>asctime([]): 接收一个时间元组, 返回一个日期时间字符串</li><li>asctime(localtime(time())), 可以这样用</li><li>ctime(time())和上面的结果相同</li></ul><h3 id=\"1-3-5-calendar模块\"><a href=\"#1-3-5-calendar模块\" class=\"headerlink\" title=\"1.3.5 calendar模块\"></a>1.3.5 calendar模块</h3><ul><li>提供日历相关功能</li><li>calendar.isleap(), 这个函数可以用来判断是否闰年</li></ul><h3 id=\"1-3-6-内置函数\"><a href=\"#1-3-6-内置函数\" class=\"headerlink\" title=\"1.3.6 内置函数\"></a>1.3.6 <strong>内置函数</strong></h3><ul><li>range([start,]end[,step]): 开始和步长可省, 默认开始0, 步长1, [start, end),不包括end哦! 如果要使用step, 需要写start. range()函数返回的还是可迭代对象</li><li>range()可以和list()或者tuple()结合: list(range(5)), tuple(range(5))</li></ul><ul><li>ord(): 将字符转化为相应编码值</li><li>chr(): 将整数转化为相应unicode字符</li></ul><ul><li>repr(object): 返回一个对象的string格式, <a href=\"https://www.runoob.com/python/python-func-repr.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">菜鸟教程</a></li><li>str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式</li><li>iter(可迭代对象): 用于产生一个可迭代对象的迭代器, 可用next(it)得到迭代器下一个元素</li></ul><ul><li>abs()</li><li>pow(x,y[,z]): x^y%z</li><li>round(x[,n]): 这个函数尽量不要用! 不是严格的四舍五入, 和浮点数精度有关, 具体可以参考<a href=\"https://www.runoob.com/w3cnote/python-round-func-note.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Python 中关于 round 函数的小坑</a>浮点数x, n为精确到小数点后的位数,可省默认保留整数, 结果仍浮点型</li><li>divmod(x, y): 结果为(商,余数), divmod(7,4)==(1,3)</li></ul><h2 id=\"1-4-基本运算\"><a href=\"#1-4-基本运算\" class=\"headerlink\" title=\"1.4 基本运算\"></a>1.4 基本运算</h2><h3 id=\"1-4-1-算术运算\"><a href=\"#1-4-1-算术运算\" class=\"headerlink\" title=\"1.4.1 算术运算\"></a>1.4.1 算术运算</h3><p>+, -, *, /(返回浮点数), //(整除), %, **(乘方)<br>这里注意下//这个运算:</p><ol><li>如果是正数, 那就是去掉小数部分, <strong>关键是负数, 需要向绝对值更大的方向进位</strong>.<br>举例: 4//3 == 1, -4//3 == -2, -7//3 == -3, -8//3 == -3</li><li>如果a//b, a或b是浮点数, 那结果也是浮点型, 只有<strong>两个都是整型</strong>, 结果才是整型<br>举例: 4//3 == 1, 4.1//3 == 1.0</li></ol><p>注意取模运算的结果,只有<strong>两个都是整型</strong>才是整型, 例: 5%3 == 2, 5%3.0 == 2.0</p><h3 id=\"1-4-2-计算误差\"><a href=\"#1-4-2-计算误差\" class=\"headerlink\" title=\"1.4.2 计算误差\"></a>1.4.2 计算误差</h3><p>浮点数有效位有效, 17位, 所以肯定有误差.<br>因此, 比较符点数的时候, == 运算符要小心使用, 应该判断是否约等于<br>举例: abs(2.2-1.2-1)&lt;1e-6, 取一个很小的误差就好</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">2.2</span><span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1.2000000000000002</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">2.2</span><span class=\"number\">-1</span><span class=\"number\">-1.2</span></span><br><span class=\"line\"><span class=\"number\">2.220446049250313e-16</span></span><br></pre></td></tr></table></figure><h3 id=\"1-4-3-数据类型转换\"><a href=\"#1-4-3-数据类型转换\" class=\"headerlink\" title=\"1.4.3 数据类型转换\"></a>1.4.3 数据类型转换</h3><p>整型+浮点型, 会自动将整型转换为浮点型<br><strong>强制转换:</strong></p><ul><li>int(x)</li><li>float(x)</li><li>complex(x), 将x转换为复数, 实部为x, 虚部为0</li><li>complex(x, y), x为实部, y为虚部</li></ul><h3 id=\"1-4-4-位运算\"><a href=\"#1-4-4-位运算\" class=\"headerlink\" title=\"1.4.4 位运算\"></a>1.4.4 位运算</h3><ul><li>&amp;: 按位与, 全1为1, |: 按位或, 有1为1, ^: 按位异或,不一样为1, ~: 按位取反, &lt;&lt;: 左移, 低位补0, &gt;&gt;: 右移,高位补0</li></ul><h2 id=\"1-5-输入与输出\"><a href=\"#1-5-输入与输出\" class=\"headerlink\" title=\"1.5 输入与输出\"></a>1.5 输入与输出</h2><h3 id=\"1-5-1-标准输入\"><a href=\"#1-5-1-标准输入\" class=\"headerlink\" title=\"1.5.1 标准输入\"></a>1.5.1 标准输入</h3><p>格式:</p><ul><li>input([提示字符串])</li></ul><p>提示字符串可选, input读入一行, 并返回一个字符串.<br>如果需要数值数据, 需要使用类型将字符串转化成数值<br>可以给多变量赋值, 使用eval(input())</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 读整数</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x=int(input())</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读多个变量</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x,y=eval(input())</span><br><span class=\"line\"><span class=\"number\">1</span>,<span class=\"number\">2</span></span><br><span class=\"line\">&gt;&gt; x</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\"># 相当于x,y=(3,4)</span></span><br></pre></td></tr></table></figure><h3 id=\"1-5-2-标准输出\"><a href=\"#1-5-2-标准输出\" class=\"headerlink\" title=\"1.5.2 标准输出\"></a>1.5.2 标准输出</h3><p>格式:</p><ul><li>print([输出项1,输出项2,..输出项n][,seq=分隔符][,end=结束符])</li></ul><p>seq默认空格, end默认回车换行<br>没有输出项则输出空行. print()从左到右输出每个项</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"number\">10</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"number\">10</span> <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"number\">10</span>, <span class=\"number\">20</span>, seq=<span class=\"string\">','</span>)</span><br><span class=\"line\"><span class=\"number\">10</span>,<span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"number\">10</span>, <span class=\"number\">20</span>, seq=<span class=\"string\">','</span>,end=<span class=\"string\">'*'</span>)</span><br><span class=\"line\"><span class=\"number\">10</span>,<span class=\"number\">20</span>*</span><br><span class=\"line\"><span class=\"comment\">#并且没换行</span></span><br></pre></td></tr></table></figure><h3 id=\"1-5-3-格式化输出\"><a href=\"#1-5-3-格式化输出\" class=\"headerlink\" title=\"1.5.3 格式化输出\"></a>1.5.3 格式化输出</h3><p>三种格式化输出方式:</p><ul><li>用%</li><li>用format()内置函数</li><li>用字符串的format方法</li></ul><h4 id=\"1-5-3-1-格式化运算符\"><a href=\"#1-5-3-1-格式化运算符\" class=\"headerlink\" title=\"1.5.3.1 格式化运算符%\"></a>1.5.3.1 格式化运算符%</h4><p>格式化字符串%(输出项1,输出项2…输出项n)</p><p>%的运算结果是字符串</p><p>格式符:</p><ul><li>%% 百分号, %c 字符, %s 字符串, %d 带符号整数, %o 八进制, %x/X, %e/E 科学记数法, %f/F 浮点数, %g/G 根据值大小选%e还是%f</li><li>不管什么类型,都可以用%s</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'Values are %s, %s, %s'</span>%(<span class=\"number\">1</span>,<span class=\"number\">2.3</span>,[<span class=\"string\">'one'</span>,<span class=\"string\">'two'</span>,<span class=\"string\">'three'</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 表示总长度为6, 小数部分2位, 输出不足用0补齐, 小数点也占一位</span></span><br><span class=\"line\"><span class=\"comment\"># 0可以用-, +代替, -左对齐, +表在正数前加上+号,默认不加</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'%06.2f'</span>%<span class=\"number\">1.234</span></span><br><span class=\"line\"><span class=\"string\">'001.24'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用字典输出时特殊用法, 这时候值由键确定</span></span><br><span class=\"line\"><span class=\"comment\"># '%(key)06.1f'%&#123;'key':value&#125;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'%(name)s:%(score)06.1f'</span>%&#123;<span class=\"string\">'score'</span>:<span class=\"number\">9.5</span>,<span class=\"string\">'name'</span>:<span class=\"string\">'Lucy'</span>&#125;</span><br><span class=\"line\"><span class=\"string\">'Lucy:0009.5'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># %*.*f 运行中确定的</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'%0*.*f'</span>%(<span class=\"number\">6</span>,<span class=\"number\">2</span>,<span class=\"number\">2.345</span>)</span><br><span class=\"line\"><span class=\"string\">'002.35'</span></span><br></pre></td></tr></table></figure><h4 id=\"1-5-3-2-format-内置函数\"><a href=\"#1-5-3-2-format-内置函数\" class=\"headerlink\" title=\"1.5.3.2 format()内置函数\"></a>1.5.3.2 format()内置函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">format(输出项[,格式字符串])</span><br></pre></td></tr></table></figure><p>省略格式符等价与str()函数</p><p>格式符:</p><ul><li>d, b(二进制), o, x, X</li><li>f, F, e, E, g, G</li><li>c(整数为编码的字符)</li><li>%(输出百分号)</li><li>&lt;(左对齐), &gt;(右对齐), ^(居中对齐), =(填充字符位于符号和数字之间), +(表正号)</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(format(<span class=\"number\">65</span>,<span class=\"string\">'c'</span>),format(<span class=\"number\">3.145</span>,<span class=\"string\">'f'</span>))</span><br><span class=\"line\">A <span class=\"number\">3.145000</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(format(<span class=\"number\">3.145</span>,<span class=\"string\">'6.2f'</span>),format(<span class=\"number\">3.145</span>,<span class=\"string\">'05.3'</span>))</span><br><span class=\"line\">  <span class=\"number\">3.15</span> <span class=\"number\">03.15</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(format(<span class=\"number\">3.145</span>,<span class=\"string\">'0=+10'</span>),format(<span class=\"string\">'test'</span>,<span class=\"string\">'&gt;20'</span>))</span><br><span class=\"line\">+<span class=\"number\">00003.145</span>                 test</span><br></pre></td></tr></table></figure><h4 id=\"1-5-3-3-字符串的format-方法\"><a href=\"#1-5-3-3-字符串的format-方法\" class=\"headerlink\" title=\"1.5.3.3 字符串的format()方法\"></a>1.5.3.3 字符串的format()方法</h4><p>属于字符串的类方法, 尽量用字符串的format()方法</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### </span></span><br><span class=\"line\"><span class=\"string\">'格式化字符串'</span>.format(输出项<span class=\"number\">1</span>, 输出项<span class=\"number\">2</span>, 输出项<span class=\"number\">3.</span>..输出项n)</span><br><span class=\"line\"></span><br><span class=\"line\">格式字符串格式:</span><br><span class=\"line\">&#123;[序号或者键]: 格式说明符&#125; 冒号不能丢</span><br><span class=\"line\"></span><br><span class=\"line\">格式化字符中, 普通字符原样输出, 格式说明符对应输出项</span><br><span class=\"line\"></span><br><span class=\"line\">序号从<span class=\"number\">0</span>开始! 如果全部省略就按照顺序输出</span><br><span class=\"line\"><span class=\"comment\">### </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 省略</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'i am &#123;&#125;, &#123;&#125;'</span>.format(<span class=\"string\">'Brenden'</span>,<span class=\"string\">'Welcome!'</span>))</span><br><span class=\"line\">i am Brenden, Welcome!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 序号</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'first:&#123;1&#125;, second:&#123;0&#125;, third:&#123;2&#125;'</span>.format(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>))</span><br><span class=\"line\">first:<span class=\"number\">2</span>, second:<span class=\"number\">1</span>, third:<span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 混用序号和键</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'hello, i am &#123;name&#125;, &#123;0&#125;'</span>.format(<span class=\"string\">'Welcome'</span>,name=<span class=\"string\">\"xiaoming\"</span>))</span><br><span class=\"line\">hello, i am xiaoming, Welcome</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结合格式符</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'&#123;0:*^15&#125;'</span>.format(<span class=\"number\">12345678</span>))</span><br><span class=\"line\">***<span class=\"number\">12345678</span>****</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'&#123;0:&lt;15&#125;'</span>.format(<span class=\"number\">12345678</span>))</span><br><span class=\"line\"><span class=\"number\">12345678</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'&#123;0:&gt;15&#125;'</span>.format(<span class=\"number\">12345678</span>))</span><br><span class=\"line\">       <span class=\"number\">12345678</span></span><br></pre></td></tr></table></figure><h2 id=\"1-6-缩进和注释\"><a href=\"#1-6-缩进和注释\" class=\"headerlink\" title=\"1.6 缩进和注释\"></a>1.6 缩进和注释</h2><h3 id=\"1-6-1-缩进\"><a href=\"#1-6-1-缩进\" class=\"headerlink\" title=\"1.6.1 缩进\"></a>1.6.1 缩进</h3><p>我认为, Python相对其他语言, 缩进真的是一个很坑的点, 同一程序中最好是一样的缩进, 否则经常出现缩进错误<br>一般是四个空格或者一个TAB</p><h3 id=\"1-6-2-注释\"><a href=\"#1-6-2-注释\" class=\"headerlink\" title=\"1.6.2 注释\"></a>1.6.2 注释</h3><p>如果注释里面有中文,记得要在开头使用<code>#coding=utf-8</code>或者<code>#coding=gbk</code></p><ul><li>单行注释: #开头, #后的就是注释</li><li>多行注释: 三个单引号或者双引号, <strong>多行注释不可以使用反斜杠续行!!</strong></li></ul><h2 id=\"1-7赋值语句\"><a href=\"#1-7赋值语句\" class=\"headerlink\" title=\"1.7赋值语句\"></a>1.7赋值语句</h2><h3 id=\"1-7-1-一般格式\"><a href=\"#1-7-1-一般格式\" class=\"headerlink\" title=\"1.7.1 一般格式\"></a>1.7.1 一般格式</h3><p>变量=表达式</p><h3 id=\"1-7-2-复合赋值语句\"><a href=\"#1-7-2-复合赋值语句\" class=\"headerlink\" title=\"1.7.2 复合赋值语句\"></a>1.7.2 复合赋值语句</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+=, -=, *=, /=, //=, **=, &lt;&lt;=, &gt;&gt;=, &amp;=, |=, ^=</span><br></pre></td></tr></table></figure><p><strong>注意!</strong> <code>x*y+5==x*(y+5)</code></p><h3 id=\"1-7-3-多变量赋值\"><a href=\"#1-7-3-多变量赋值\" class=\"headerlink\" title=\"1.7.3 多变量赋值\"></a>1.7.3 多变量赋值</h3><ol><li>链式赋值<ul><li>变量1=变量2=变量…..=变量n=表达式</li><li>a=b=10 等价于 a=10;b=10</li><li>要注意的是, 上例, a和b同时指向一个整型对象10</li></ul></li><li>同步赋值<ul><li>变量1,变量2,变量3…=表达式1,表达式2…表达式n</li><li>a,b,c=1,2,3</li><li>注意同步赋值不是单一赋值语句的先后执行!!!</li></ul></li></ol><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; x,x=2,-50 </span><br><span class=\"line\"># x结果为-50</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; x=-11</span><br><span class=\"line\">&gt;&gt;&gt; x,y=12,x</span><br><span class=\"line\"># 此时x=12, 但是y=-11 !!!要小心使用</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; a,b=1,2</span><br><span class=\"line\">&gt;&gt;&gt; a,b=b,a</span><br><span class=\"line\"># 此时a, b分别为2, 1</span><br><span class=\"line\"># 可以用a,b=b,a省略一个中间变量</span><br></pre></td></tr></table></figure><h2 id=\"1-8-条件的描述\"><a href=\"#1-8-条件的描述\" class=\"headerlink\" title=\"1.8 条件的描述\"></a>1.8 条件的描述</h2><h3 id=\"1-8-1-关系运算符\"><a href=\"#1-8-1-关系运算符\" class=\"headerlink\" title=\"1.8.1 关系运算符\"></a>1.8.1 关系运算符</h3><p>优先级小于算术运算符, 就是先算算术运算符, 再比较<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;, &lt;=, &gt;, &gt;=, ==, !=</span><br></pre></td></tr></table></figure><p></p><h3 id=\"1-8-2-逻辑运算\"><a href=\"#1-8-2-逻辑运算\" class=\"headerlink\" title=\"1.8.2 逻辑运算\"></a>1.8.2 逻辑运算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">and(与), or(或), not(非)</span><br></pre></td></tr></table></figure><p>优先级:</p><ul><li>not &gt; and &gt; or</li></ul><p>逻辑与: 前面的False就不算后面的<br>逻辑或: 前面的True就不算后面的</p><h3 id=\"1-8-3-成员测试\"><a href=\"#1-8-3-成员测试\" class=\"headerlink\" title=\"1.8.3 成员测试\"></a>1.8.3 成员测试</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">in: 在序列中查找, 返回True或者False</span><br><span class=\"line\">not in: 么找到返回True</span><br><span class=\"line\">is: 测试两个变量是否, 指向同一个变量</span><br></pre></td></tr></table></figure><blockquote class=\"blockquote-center\"><p><strong>end CH1</strong></p></blockquote><h1 id=\"CH2-Python程序结构\"><a href=\"#CH2-Python程序结构\" class=\"headerlink\" title=\"CH2. Python程序结构\"></a>CH2. Python程序结构</h1><h2 id=\"2-1-算法及其描述\"><a href=\"#2-1-算法及其描述\" class=\"headerlink\" title=\"2.1 算法及其描述\"></a>2.1 算法及其描述</h2><p>算法+数据结构=程序, 计算机解决问题的方法和步骤就是算法<br>算法描述:</p><ol><li>传统流程图</li><li>结构化流程图:<ul><li>程序的三种基本结构: 顺序结构, 选择结构, 循环结构</li><li>结构化流程图(N-S图): 顺序结构, 选择结构, 当型循环结构, 直到型循环结构, 各单元顺序执行</li></ul></li></ol><h2 id=\"2-2-顺序结构\"><a href=\"#2-2-顺序结构\" class=\"headerlink\" title=\"2.2 顺序结构\"></a>2.2 顺序结构</h2><p>简单的按照出现顺序执行</p><h2 id=\"2-3-选择结构\"><a href=\"#2-3-选择结构\" class=\"headerlink\" title=\"2.3 选择结构\"></a>2.3 选择结构</h2><h3 id=\"2-3-1-if-elif-else\"><a href=\"#2-3-1-if-elif-else\" class=\"headerlink\" title=\"2.3.1 if-elif-else\"></a>2.3.1 if-elif-else</h3><p>要注意的是, if的表达式可以使任意的, 比如 if ‘B’:<br>嵌套的时候根据对齐来配对</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 单分支</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ...:</span><br><span class=\"line\">  表达式</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 双分支</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ...:</span><br><span class=\"line\">  语句</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多分支</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ...:</span><br><span class=\"line\">  ...</span><br><span class=\"line\"><span class=\"keyword\">elif</span> ...:</span><br><span class=\"line\">  ...</span><br><span class=\"line\"><span class=\"keyword\">elif</span> ...:</span><br><span class=\"line\">  ...</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure><h3 id=\"2-3-2-条件运算\"><a href=\"#2-3-2-条件运算\" class=\"headerlink\" title=\"2.3.2 条件运算\"></a>2.3.2 条件运算</h3><p><strong>可以作为一个运算量, 而不是一个单独的语句</strong></p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表达式<span class=\"number\">1</span> <span class=\"keyword\">if</span> 表达式 <span class=\"keyword\">else</span> 表达式<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z= x <span class=\"keyword\">if</span> x&gt;y <span class=\"keyword\">else</span> y</span><br><span class=\"line\"><span class=\"comment\"># 其中z=后面的就是一个条件运算</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>i=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'a'</span> <span class=\"keyword\">if</span> i <span class=\"keyword\">else</span> <span class=\"string\">'A'</span></span><br><span class=\"line\"><span class=\"string\">'A'</span></span><br></pre></td></tr></table></figure><h2 id=\"2-4-循环结构\"><a href=\"#2-4-循环结构\" class=\"headerlink\" title=\"2.4 循环结构\"></a>2.4 循环结构</h2><h3 id=\"2-4-1-while\"><a href=\"#2-4-1-while\" class=\"headerlink\" title=\"2.4.1 while\"></a>2.4.1 while</h3><p>while和if有一个相同的地方就是, 如果循环体只哟一个语句, 可以写在一行</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> ...:</span><br><span class=\"line\">  ....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以结合else语句</span></span><br><span class=\"line\"><span class=\"comment\"># 但是只可以在while部分正常退出的时候才执行else部分</span></span><br><span class=\"line\"><span class=\"comment\"># 如果是break退出的, 不执行else部分</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ...:</span><br><span class=\"line\">  ....</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  ....</span><br></pre></td></tr></table></figure><h3 id=\"2-4-2-for\"><a href=\"#2-4-2-for\" class=\"headerlink\" title=\"2.4.2 for\"></a>2.4.2 for</h3><p>可结合range()函数, 看1.3.6部分</p><blockquote><p>range([start,]end[,step]): 开始和步长可省, 默认开始0, 步长1, [start, end),不包括end哦! 如果要使用step, 需要写start. range()返回可迭代对象<br>for循环中会自动调用iter()函数,和next()函数获得range里的元素</p></blockquote><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这个序列可以是: 字符串, 元组, 列表...</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> 变量 <span class=\"keyword\">in</span> 序列:</span><br><span class=\"line\">  语句块</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以用else语句</span></span><br><span class=\"line\"><span class=\"comment\"># 没碰到break就可以执行</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> 变量 <span class=\"keyword\">in</span> 序列:</span><br><span class=\"line\">  语句块</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  ....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结合range函数</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>  print(i, end=<span class=\"string\">','</span>)</span><br><span class=\"line\"><span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>):</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>  print(i, end=<span class=\"string\">','</span>)</span><br><span class=\"line\"><span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span></span><br></pre></td></tr></table></figure><h2 id=\"2-5-循环控制语句\"><a href=\"#2-5-循环控制语句\" class=\"headerlink\" title=\"2.5 循环控制语句\"></a>2.5 循环控制语句</h2><p>有<code>break</code>和<code>pass</code>和<code>continue</code>这三个</p><p>pass语句代表空语句,空操作, 相当于占位符</p><blockquote class=\"blockquote-center\"><p><strong>end CH2</strong></p></blockquote><h1 id=\"CH3-字符串和正则\"><a href=\"#CH3-字符串和正则\" class=\"headerlink\" title=\"CH3. 字符串和正则\"></a>CH3. 字符串和正则</h1><h2 id=\"3-1-字符串\"><a href=\"#3-1-字符串\" class=\"headerlink\" title=\"3.1 字符串\"></a>3.1 字符串</h2><p>关于编码的两个函数</p><ul><li>默认unicode编码, encode: 编码为, decode: 解码为unicode</li><li>s.encode(‘utf-8’)或者s.encode(‘gbk’)</li><li>s.decode(‘utf-8’)或者s.decode(‘gbk’)</li></ul><h3 id=\"索引和分片\"><a href=\"#索引和分片\" class=\"headerlink\" title=\"索引和分片\"></a>索引和分片</h3><p>索引分为正向和反向</p><div class=\"table-container\"><table><thead><tr><th style=\"text-align:center\">H</th><th style=\"text-align:center\">e</th><th style=\"text-align:center\">l</th><th style=\"text-align:center\">l</th><th style=\"text-align:center\">o</th></tr></thead><tbody><tr><td style=\"text-align:center\">s[0]</td><td style=\"text-align:center\">s[1]</td><td style=\"text-align:center\">s[2]</td><td style=\"text-align:center\">s[3]</td><td style=\"text-align:center\">s[4]</td></tr><tr><td style=\"text-align:center\">s[-5]</td><td style=\"text-align:center\">s[-4]</td><td style=\"text-align:center\">s[-3]</td><td style=\"text-align:center\">s[-2]</td><td style=\"text-align:center\">s[-1]</td></tr></tbody></table></div><p>分片使用中括号和如下格式:</p><ul><li>s[i:j:k]</li><li>i: 开始位置下标, j: 结束位置下标, 不包括j位置的字符, k: 步长</li><li>i,j,k都可以省略, i默认0或-1, j默认到最后一个字符, k默认1</li><li>一定要注意, 不管k是正还是负, 都不包括j位置的字符</li><li>i和j都可以超过字符串的长度</li></ul><p>示例:</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=<span class=\"string\">'hello'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[<span class=\"number\">0</span>:<span class=\"number\">4</span>:<span class=\"number\">1</span>])</span><br><span class=\"line\">hell</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[<span class=\"number\">0</span>:<span class=\"number\">5</span>:<span class=\"number\">2</span>])</span><br><span class=\"line\">hlo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[<span class=\"number\">-1</span>:<span class=\"number\">-5</span>:<span class=\"number\">-1</span>])</span><br><span class=\"line\">olle</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[<span class=\"number\">-1</span>:<span class=\"number\">-6</span>:<span class=\"number\">-1</span>])</span><br><span class=\"line\">olleh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[<span class=\"number\">0</span>:len(s)])</span><br><span class=\"line\">hello</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[-len(s):<span class=\"number\">-1</span>])</span><br><span class=\"line\">hell</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 都省了</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[:])</span><br><span class=\"line\">hello</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[::<span class=\"number\">2</span>])</span><br><span class=\"line\">hlo</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[::<span class=\"number\">-1</span>])</span><br><span class=\"line\">olleh</span><br><span class=\"line\"><span class=\"comment\"># 省略了步长</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[:<span class=\"number\">-1</span>])</span><br><span class=\"line\">hell</span><br></pre></td></tr></table></figure><h3 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h3><p>使用<code>+</code>连接, 如果不是字符串类型, 使用str()函数或者repr()函数转换成字符串</p><p>字符串不可用下标修改, 所以可以用连接操作改某个字符</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=<span class=\"string\">'abcd'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=s[<span class=\"number\">0</span>]+<span class=\"number\">9</span>+s[<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</span><br><span class=\"line\"><span class=\"string\">'a9cd'</span></span><br></pre></td></tr></table></figure><p>可以使用<code>*</code>进行重复连接, n*s或者s*n<br>可以使用+=或者*=这样的操作</p><p>如果是连加操作, +的效率很低, 可以使用s.join()函数代替, s是分隔符</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'-'</span>.join([<span class=\"string\">'Python'</span>,<span class=\"string\">'and'</span>,<span class=\"string\">'Program'</span>])</span><br><span class=\"line\"><span class=\"string\">'Python-and-Program'</span></span><br></pre></td></tr></table></figure><h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><ul><li>单子符就直接比较ASCII码</li><li>相同长度从左到右比较ASCII</li><li>不同长度补全空格再从左到右比较ASCII</li></ul><h3 id=\"字符串成员关系\"><a href=\"#字符串成员关系\" class=\"headerlink\" title=\"字符串成员关系\"></a>字符串成员关系</h3><p>用<code>in</code>和<code>not in</code>: 字符串1 [not] in 字符串2<br>返回True或者False</p><h3 id=\"字符串常用方法\"><a href=\"#字符串常用方法\" class=\"headerlink\" title=\"字符串常用方法\"></a>字符串常用方法</h3><p>字符串是一个类, 有许多类方法.这里只记常用的</p><h4 id=\"大小写和对齐\"><a href=\"#大小写和对齐\" class=\"headerlink\" title=\"大小写和对齐\"></a>大小写和对齐</h4><ul><li>s.upper()/lower()</li><li>s.ljust(width, [fillchar]): 输出width长度, 左对齐, 不足部分fillchar补齐, 默认空格</li><li>s.rjust()/center(): 参数同上, 右对齐和居中</li></ul><h4 id=\"字符串搜索\"><a href=\"#字符串搜索\" class=\"headerlink\" title=\"字符串搜索\"></a>字符串搜索</h4><ul><li>s.find(sub,[start,[end]]): 返回sub的第一个字符编号, 没有返回-1</li><li>s.index(sub,[start,[end]]): 和find相同, 不过没有时,返回一个错误</li><li>s.rfind(sub,[start,[end]]): 从后往前找sub,第一个字符编号,没有返回-1</li><li>s.rindex(sub,[start,[end]])</li><li>s.count(substr,[start,[end]]): 返回出现次数</li><li>s.startswith(prefix,[start,[end]])</li><li>s.endswith(suffix,[start,[end]])</li></ul><h4 id=\"字符串替换\"><a href=\"#字符串替换\" class=\"headerlink\" title=\"字符串替换\"></a>字符串替换</h4><ul><li>s.replace(oldstr,newstr,[count]): old替换为new</li><li>s.strip([chars]): 默认去前后空格, s前后的chars中的字符去掉</li><li>s.lstrip([chars])/rstrip()</li><li>s.expandtabs([tabsize]): s中tab替换为空格, tabsize为空格的数量, 默认8个</li></ul><h4 id=\"字符串拆分\"><a href=\"#字符串拆分\" class=\"headerlink\" title=\"字符串拆分\"></a>字符串拆分</h4><ul><li>s.split([sep,[maxsplit]]): sep:分隔符,默认空格, 按sep把s拆成一个列表, maxsplit:拆分次数,默认-1无限制</li><li>s.rsplit([sep,[maxsplit]]): 从右侧拆</li><li>s.splitlines([keepends]): 按行拆成列表, keepends为true: 保留每行分隔符</li><li>s.partition(sub): 拆成三个元素的元组(sub左, sub, sub右), 如果没sub, 返回(s, ‘’, ‘’)</li><li>s.rpartition(sub): 从右边找sub</li></ul><h4 id=\"字符串连接-1\"><a href=\"#字符串连接-1\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h4><ul><li>s.join(seq): seq为序列, s为分隔符<br>通常和list(s)结合使用, 修改string某个字符</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=<span class=\"string\">'abcd'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=list(s)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">0</span>]=<span class=\"string\">'t'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=<span class=\"string\">\"\"</span>.join(s)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</span><br><span class=\"line\"><span class=\"string\">'tbcd'</span></span><br></pre></td></tr></table></figure><h4 id=\"字符串类型判断\"><a href=\"#字符串类型判断\" class=\"headerlink\" title=\"字符串类型判断\"></a>字符串类型判断</h4><ul><li>s.isalnum(): 字母和数字, 至少一个字符</li><li>s.isalpha(): 全字母,至少一个字符</li><li>s.isdigit(): 全数字,至少一个字符</li><li>s.isspace(): 全空格,至少一个字符</li><li>s.islower()/isupper()/istitle()</li></ul><h3 id=\"字节类型bytes\"><a href=\"#字节类型bytes\" class=\"headerlink\" title=\"字节类型bytes\"></a>字节类型bytes</h3><p>bytes和string不一样, 可以用string.encode()方法和bytes.decode()方法进行两者转换.<br>bytes可以使用bytearray(by)的方式将bytes转换为bytearray对象<br>bytes对象不可修改, bytearray可修改</p><h2 id=\"3-2-正则表达式\"><a href=\"#3-2-正则表达式\" class=\"headerlink\" title=\"3.2 正则表达式\"></a>3.2 正则表达式</h2><p>太多了, 附上<a href=\"https://www.runoob.com/python/python-reg-expressions.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">菜鸟教程</a></p><blockquote class=\"blockquote-center\"><p><strong>end CH3</strong></p></blockquote><h1 id=\"CH4-复合数据类型\"><a href=\"#CH4-复合数据类型\" class=\"headerlink\" title=\"CH4. 复合数据类型\"></a>CH4. 复合数据类型</h1><h2 id=\"4-1-序列\"><a href=\"#4-1-序列\" class=\"headerlink\" title=\"4.1 序列\"></a>4.1 序列</h2><p>序列包括<strong>字符串, 列表, 元组</strong>, 按照位置编号存取</p><h3 id=\"4-1-1-通用操作\"><a href=\"#4-1-1-通用操作\" class=\"headerlink\" title=\"4.1.1 通用操作\"></a>4.1.1 通用操作</h3><ul><li>索引, 用下标访问, num[0], 支持反向索引, 从-1开始</li><li>分片, 注意不改变原序列, 而是产生一个新序列, 下面是常用分片用法</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>]</span><br><span class=\"line\"><span class=\"comment\"># 常见用法</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[<span class=\"number\">3</span>:<span class=\"number\">6</span>]</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以从末尾计数, 负数索引, 效果相同</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[<span class=\"number\">7</span>:<span class=\"number\">10</span>]</span><br><span class=\"line\">[<span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[<span class=\"number\">-3</span>:]</span><br><span class=\"line\">[<span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 省略部分下标</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[:<span class=\"number\">3</span>]</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[:]</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置步长</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[:len(num):<span class=\"number\">2</span>]</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开始索引可以超过列表长度, 视作从最后一个开始</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[<span class=\"number\">11</span>:<span class=\"number\">0</span>:<span class=\"number\">-1</span>]</span><br><span class=\"line\">[<span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[<span class=\"number\">8</span>:<span class=\"number\">0</span>:<span class=\"number\">-1</span>]</span><br><span class=\"line\">[<span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果步长为负数, 开始索引必须大于终止索引</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[<span class=\"number\">0</span>:<span class=\"number\">10</span>:<span class=\"number\">-1</span>]</span><br><span class=\"line\">[]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从id可以看出分片是新序列, 和赋值不一样</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y=x[:]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(x),id(y)</span><br><span class=\"line\">(<span class=\"number\">140158585788768</span>, <span class=\"number\">140158585103696</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z=x</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(x),id(z)</span><br><span class=\"line\">(<span class=\"number\">140158585788768</span>, <span class=\"number\">140158585788768</span>)</span><br></pre></td></tr></table></figure><ul><li>同类型序列可用+直接相加</li><li>可以用*进行乘法, 生成新序列, n&lt;1会返回一个空列表</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=[<span class=\"keyword\">None</span>]*<span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</span><br><span class=\"line\">[<span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>]</span><br></pre></td></tr></table></figure><ul><li>字符串部分介绍过, 可以直接比较, 同样适用于列表和元组, 但是列表和元组不可以比较</li><li>用in和notin判断成员资格</li><li>常用函数: len(), max(), min(), sum():要求元素必须为数值</li><li>常用函数: s.count(x), s.index(x)</li><li>enumerate(seq): 接收可迭代对象, 返回enumerate对象, 由每个元素的索引和值组成(索引, 值)</li><li>zip(seq1,seq2..seqn)</li><li>sorted(iterable, key=None, reverse=False): 返回排序后的列表, 返回的是副本,不改变源. reverse=False升序, reverse=True降序</li><li>reversed(iterable): 逆序排列, 返回新的对象</li><li>all(seq): seq元素都是True则返回True</li><li>any(seq): seq任一为True则返回True</li><li>序列拆分: 变量个数不一致时, 要用*, *只能有1个</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a,b,c=x</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a,b,c</span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a,*b=x</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a,b</span><br><span class=\"line\">(<span class=\"number\">1</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>*a,b=x</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a,b</span><br><span class=\"line\">([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure><h3 id=\"4-1-2-列表专用操作\"><a href=\"#4-1-2-列表专用操作\" class=\"headerlink\" title=\"4.1.2 列表专用操作\"></a>4.1.2 列表专用操作</h3><ul><li>列表可修改, 可元素赋值</li><li>del seq[index]/ del seq : 删除某元素或对象</li><li>分片赋值: 可以做到增加, 删除, 修改</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name=list(<span class=\"string\">'Perl'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name[<span class=\"number\">2</span>:]=list(<span class=\"string\">'ar'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name</span><br><span class=\"line\">[<span class=\"string\">'P'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'r'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改并增加, 后面那部分可以比前面的长</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name[<span class=\"number\">1</span>:]=list(<span class=\"string\">'ython'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name</span><br><span class=\"line\">[<span class=\"string\">'P'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'t'</span>, <span class=\"string\">'h'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'n'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以插入序列</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name=[<span class=\"number\">1</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name[<span class=\"number\">1</span>:<span class=\"number\">1</span>]=[<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除部分元素</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name[<span class=\"number\">1</span>:<span class=\"number\">3</span>]=[]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果步长不等于1, 那么前后数量必须相同</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name[:<span class=\"number\">4</span>:<span class=\"number\">2</span>]=[<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">\"&lt;stdin&gt;\"</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">ValueError: attempt to assign sequence of size <span class=\"number\">2</span> to extended slice of size <span class=\"number\">1</span></span><br></pre></td></tr></table></figure><ul><li>列表解析, 表达式可以任意, for循环可嵌套, if可选</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)]</span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[ord(x) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"string\">'python'</span>]</span><br><span class=\"line\">[<span class=\"number\">112</span>, <span class=\"number\">121</span>, <span class=\"number\">116</span>, <span class=\"number\">104</span>, <span class=\"number\">111</span>, <span class=\"number\">110</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[(x,y) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>) <span class=\"keyword\">if</span> x%<span class=\"number\">2</span>==<span class=\"number\">0</span> <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>) <span class=\"keyword\">if</span> y%<span class=\"number\">2</span>==<span class=\"number\">1</span>]</span><br><span class=\"line\">[(<span class=\"number\">0</span>, <span class=\"number\">1</span>), (<span class=\"number\">0</span>, <span class=\"number\">3</span>), (<span class=\"number\">2</span>, <span class=\"number\">1</span>), (<span class=\"number\">2</span>, <span class=\"number\">3</span>), (<span class=\"number\">4</span>, <span class=\"number\">1</span>), (<span class=\"number\">4</span>, <span class=\"number\">3</span>)]</span><br></pre></td></tr></table></figure><ul><li>以下方法都是在源列表上操作, 会修改原列表<ol><li>s.append(x): 末尾添加单个元素</li><li>s.extend(seq): 在s末尾添加seq所有元素</li><li>s.sort(reverse=False, key=None) 和 sorted(seq)这个函数功能一样, 但是sorted是返回副本</li><li>s.reverse(): 同reversed(seq)</li><li>s.pop([index]): 删除并返回index位置的元素, 默认最后一个, 超范围报错</li><li>s.insert(index,x): index处插入x, index大于列表长度,则插在最后</li><li>s.remove(x): 如果有多个, 只删除第一个</li></ol></li></ul><h3 id=\"4-1-3-元组和列表\"><a href=\"#4-1-3-元组和列表\" class=\"headerlink\" title=\"4.1.3 元组和列表\"></a>4.1.3 元组和列表</h3><p>都是有序序列, 常可替换</p><p><strong>区别:</strong></p><ol><li>元组不可变</li><li>元组小括号,列表中括号</li><li>元组可以在字典中作为key</li></ol><p>元组不可变, 但是可以用元组创建新元组<br>如果元组内元素为可变的, 如列表或字符串, 则可以修改<br>使用 list()和tuple()函数相互转换</p><h2 id=\"4-2-字典和集合\"><a href=\"#4-2-字典和集合\" class=\"headerlink\" title=\"4.2 字典和集合\"></a>4.2 字典和集合</h2><p>字典主要是元素的检索, 插入和删除.<br>集合主要考虑集合间的并, 交和差操作.</p><h3 id=\"4-2-1-字典\"><a href=\"#4-2-1-字典\" class=\"headerlink\" title=\"4.2.1 字典\"></a>4.2.1 字典</h3><p>注意点:</p><ul><li>关键是是不可变的, 如果元组里有可变类型比如列表, 就不可以作为key. python对key进行哈希, 根据计算结果决定存储地址, 所以可以用hash()函数判断是否可以作为key</li><li>字典是可变类型, 可以在原处增长或者缩短, 无需生成副本.</li><li>字典是异构的, 可以抱含任何类型数据: 元素可以是字典,列表,元组, 支持任意层次嵌套.</li><li>{}和dict()是空字典</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d1=dict()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d1</span><br><span class=\"line\">&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># dict参数可以是列表和元组</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d2=dict(([<span class=\"string\">'x'</span>,<span class=\"number\">1</span>],[<span class=\"string\">'y'</span>,<span class=\"number\">2</span>]))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d2</span><br><span class=\"line\">&#123;<span class=\"string\">'x'</span>: <span class=\"number\">1</span>, <span class=\"string\">'y'</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d2=dict([[<span class=\"string\">'x'</span>,<span class=\"number\">1</span>],[<span class=\"string\">'y'</span>,<span class=\"number\">2</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d2</span><br><span class=\"line\">&#123;<span class=\"string\">'x'</span>: <span class=\"number\">1</span>, <span class=\"string\">'y'</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以直接指定key和val</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d3=dict(name=<span class=\"string\">'allen'</span>,age=<span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d3</span><br><span class=\"line\">&#123;<span class=\"string\">'name'</span>: <span class=\"string\">'allen'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">15</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>更新和添加: 字典的更新直接用dict[key]=new_val就可以, 如果没有就直接增加一个新元素</li><li>删除: del 字典名[key] 或者 del 字典名</li><li>判断key是否存在: key in / not in dict</li><li>len(dict)</li><li>只支持==和！=</li><li>list(dict)返回key</li></ul><p>常用方法：</p><ul><li>fromkeys(序列[,值])</li><li>keys(), values(), items()</li><li>d.copy(), d.clear(), d.pop(key), d.popitem()</li><li>d.get(key[,value]): 返回key对应的val值, 若没有, 则返回value</li><li>d.setdefault(key,[value]): 存在则返回值, 不存在则插入key:value, value默认none</li><li>d2.update(d1): d1合并到d2, d1不变</li><li>has_key(key): 存在key返回true, 用in和not in就可以</li></ul><h3 id=\"4-2-2-集合\"><a href=\"#4-2-2-集合\" class=\"headerlink\" title=\"4.2.2 集合\"></a>4.2.2 集合</h3><h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><ol><li>空集合是set()</li><li>用大括号</li><li>字符串,列表, 元组都可以转set</li><li>set()创建可变集合, frozenset()创建不可变集合</li><li>可变集合的元素只能是数值, 字符串, 元组这些不可修改的, 可修改的列表,字典和可变集合都不可作为元素</li></ol><h4 id=\"集合的运算\"><a href=\"#集合的运算\" class=\"headerlink\" title=\"集合的运算\"></a>集合的运算</h4><ul><li>并： |, |=, s1.union(s2…sn)</li><li>交： &amp; , s1.intersection(s2…sn)</li><li>差： -, s1.difference(s2…sn)</li><li>对称差： ^, s1.symmetric_difference(s2…sn)</li><li>==</li><li>！=</li><li>s1\\&lt;s2: s1是s2真子集,</li><li>s1\\&lt;=s2: s1是s2子集, s1.issubset(s2)</li><li>s1>s2: 超集</li><li>s1>=s2: 相当于s1.issuperset(s2)</li><li>s.copy()</li></ul><h4 id=\"适用于可变集合的方法\"><a href=\"#适用于可变集合的方法\" class=\"headerlink\" title=\"适用于可变集合的方法\"></a>适用于可变集合的方法</h4><ul><li>s.add(x)</li><li>s.remove(x): 不存在会报错; s.discard(x): 不存在不报错</li><li>s.pop(): 删除任意一个元素并返回</li><li>s.clear()</li></ul><ul><li>s.update(s1,s2…): s=s|s1|s2…sn</li><li>s.intersection_update(s1,s2..sn): s=s&amp;s1&amp;s2..&amp;sn</li><li>s.difference_update(s1,s2..s2): s=s-s1-s2..-sn</li><li>s.symmetric_difference_update(s1): s=s^s1</li></ul><blockquote class=\"blockquote-center\"><p><strong>end CH4</strong></p></blockquote><h1 id=\"CH5-函数\"><a href=\"#CH5-函数\" class=\"headerlink\" title=\"CH5. 函数\"></a>CH5. 函数</h1><p>和其他的语言一样, 函数先定义再使用</p><h2 id=\"5-1-参数\"><a href=\"#5-1-参数\" class=\"headerlink\" title=\"5.1 参数\"></a>5.1 参数</h2><p>参数传递的方式是”值传递”</p><p><strong>要注意的是:</strong></p><ul><li>形参重新赋值重新分配对象, 指向别的对象, 不会改变实参</li><li>如果仅修改形参内容, 比如列表, 字典这样的可修改对象, 则会影响实参</li></ul><h3 id=\"参数类型\"><a href=\"#参数类型\" class=\"headerlink\" title=\"参数类型\"></a>参数类型</h3><ul><li>位置参数: 参数按照位置对应</li><li>关键字参数: 形参名=值</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mykey</span><span class=\"params\">(x,y)</span>:</span></span><br><span class=\"line\">  print(x, y)</span><br><span class=\"line\">mykey(y=<span class=\"number\">10</span>, x=<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure><ul><li>默认参数: 形参=默认值, 必须在参数列表右边, 在可变长度参数之前</li><li>可变长度参数: 参数数量不固定时, 针对元组和字典两种. 其他所有类型参数都必须在可变长度参数之前</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 元组一个*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myvarl</span><span class=\"params\">(*t)</span>:</span></span><br><span class=\"line\">  print(t)</span><br><span class=\"line\">myvarl(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 字典两个*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myvarl</span><span class=\"params\">(**t)</span>:</span></span><br><span class=\"line\">  print(t)</span><br><span class=\"line\">myvarl(<span class=\"string\">'y'</span>=<span class=\"number\">1</span>,<span class=\"string\">'x'</span>=<span class=\"number\">2</span>,<span class=\"string\">'z'</span>=<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure><h2 id=\"5-2-匿名函数\"><a href=\"#5-2-匿名函数\" class=\"headerlink\" title=\"5.2 匿名函数\"></a>5.2 匿名函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 参数也可以使用默认值, 返回值是表达式结果</span></span><br><span class=\"line\"><span class=\"keyword\">lambda</span> [参数<span class=\"number\">1</span>[,参数<span class=\"number\">2</span>,...,参数n]]: 表达式</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例如</span></span><br><span class=\"line\"><span class=\"keyword\">lambda</span> x,y: x+y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f=<span class=\"keyword\">lambda</span> x,y: x+y</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f(<span class=\"number\">5</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把匿名函数作为普通函数返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> x,y:x+y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 匿名函数作为序列或者字典元素</span></span><br><span class=\"line\">列表名=[匿名<span class=\"number\">1</span>, 匿名<span class=\"number\">2</span>,...匿名n]</span><br><span class=\"line\"><span class=\"comment\"># 调用</span></span><br><span class=\"line\">列表名[index](参数)</span><br></pre></td></tr></table></figure><h2 id=\"5-3-装饰器\"><a href=\"#5-3-装饰器\" class=\"headerlink\" title=\"5.3 装饰器\"></a>5.3 装饰器</h2><p>这里只记录一些注意点, 比较全面的看书上或者<a href=\"https://www.runoob.com/w3cnote/python-func-decorators.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Python 函数装饰器|菜鸟教程</a>, 这个讲的很全</p><ul><li>概念: 装饰器是用来包装函数的函数, 用来为已经存在的函数添加额外功能</li><li>返回对象: 装饰器输入是被装饰的函数对象, 返回新的函数对象.</li><li>调用: 使用@调用装饰器</li><li>调用的时候,本质上, 是将对象名重新指向一个新返回的函数, 达到修改函数的目的</li><li>返回: 装饰器最里面那层, 要返回被装饰的函数</li><li>在装饰器中,返回值, 例如 return func, func后面没有(), 加上()表示调用.</li><li>外层里层函数关系: 最外面的那层函数返回值, 是里面一层函数的函数名</li><li>多重装饰器: 执行顺序是从下往上, 最后执行被装饰函数内容</li></ul><h2 id=\"5-4-name\"><a href=\"#5-4-name\" class=\"headerlink\" title=\"5.4 __name__\"></a>5.4 __name__</h2><p>主动调用__name__值为__main__, 被导包时值为模块名<br>把一个程序文件既当作模块, 有可以主动调用时, 程序入口前加if:</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">  test()</span><br></pre></td></tr></table></figure><blockquote class=\"blockquote-center\"><p><strong>end CH5</strong></p></blockquote><h1 id=\"CH6-类\"><a href=\"#CH6-类\" class=\"headerlink\" title=\"CH6. 类\"></a>CH6. 类</h1><h2 id=\"6-1-属性\"><a href=\"#6-1-属性\" class=\"headerlink\" title=\"6.1 属性\"></a>6.1 属性</h2><div class=\"table-container\"><table><thead><tr><th style=\"text-align:left\"></th><th style=\"text-align:left\">格式</th><th style=\"text-align:left\">访问控制</th><th style=\"text-align:left\">添加</th><th style=\"text-align:left\">修改</th><th style=\"text-align:left\">作用域</th></tr></thead><tbody><tr><td style=\"text-align:left\">私有属性</td><td style=\"text-align:left\">类里函数外, 以__开头的属性</td><td style=\"text-align:left\">只能通过类方法中使用self.__name使用,类外无法直接访问</td><td style=\"text-align:left\">只能在类里面添加</td><td style=\"text-align:left\">在类方法里用self修改, 不影响其他对象</td><td style=\"text-align:left\">单个</td></tr><tr><td style=\"text-align:left\">类属性</td><td style=\"text-align:left\">直接在类里函数外定义的非私有属性,所有对象公有</td><td style=\"text-align:left\">类外通过类名和实例对象(不推荐)调用</td><td style=\"text-align:left\">类外可以通过类名.类属性添加</td><td style=\"text-align:left\">类外:类名修改,类里:类方法</td><td style=\"text-align:left\">所有</td></tr><tr><td style=\"text-align:left\">实例属性</td><td style=\"text-align:left\">在__init__里面定义或者通过实例对象引用定义</td><td style=\"text-align:left\">类外只有实例对象可以访问,类里面可以在类方法中调用</td><td style=\"text-align:left\">类里面在init方法中添加,类外使用实例对象.实例属性添加</td><td style=\"text-align:left\">用self修改或实例对象.实例属性修改</td><td style=\"text-align:left\">单个</td></tr></tbody></table></div><p>注意点:</p><ul><li>千万不要尝试实例对象创建类属性, 会自动创建一个同名实例属性,并屏蔽掉类属性</li><li>不可以用实例对象直接修改类属性, 要用类方法修改</li><li>使用del 删除实例属性和实例对象</li></ul><h2 id=\"6-2-方法\"><a href=\"#6-2-方法\" class=\"headerlink\" title=\"6.2 方法\"></a>6.2 方法</h2><div class=\"table-container\"><table><thead><tr><th style=\"text-align:left\"></th><th style=\"text-align:left\">特征</th><th style=\"text-align:left\">调用</th><th style=\"text-align:left\">和属性关系</th></tr></thead><tbody><tr><td style=\"text-align:left\">构造方法</td><td style=\"text-align:left\">__init__(self)</td><td style=\"text-align:left\">生成对象自动调用</td><td style=\"text-align:left\">里面用self定义的都是实例属性</td></tr><tr><td style=\"text-align:left\">析构方法</td><td style=\"text-align:left\">__del__(self)</td><td style=\"text-align:left\">释放对象自动调用</td><td style=\"text-align:left\">可以在里面进行释放资源的操作</td></tr><tr><td style=\"text-align:left\">类方法</td><td style=\"text-align:left\">@classmethod修饰器,第一个参数为cls</td><td style=\"text-align:left\">实例对象和类对象访问</td><td style=\"text-align:left\">引用的是类属性</td></tr><tr><td style=\"text-align:left\">实例方法</td><td style=\"text-align:left\">第一个参数为self</td><td style=\"text-align:left\">只能实例对象调用</td><td style=\"text-align:left\">实例属性优先级高于类属性,实例方法中实例属性会屏蔽类属性</td></tr><tr><td style=\"text-align:left\">静态方法</td><td style=\"text-align:left\">@staticmethod修饰器,无需多定义参数</td><td style=\"text-align:left\">类名和实例对象都可以访问</td><td style=\"text-align:left\">不绑定类或者实例, 引用类属性需要使用类名引用</td></tr></tbody></table></div><p>注意点:</p><ul><li>静态方法和实例方法不同的是, 静态方法不会自动绑定到类上, 类方法会自动绑定. 静态方法不需要引用类或者实例</li><li>静态方法很像我们在类外定义的函数，只不过静态方法可以通过类或者实例来调用而已。</li><li>实例方法中引用属性, 若存在同名类属性和实例属性, 则引用实例属性, 若无实例属性, 则引用类属性</li><li>实例方法中修改属性, 若存在同名类属性和实例属性, 则修改实例属性, 若无实例属性, 则创建新实例属性</li></ul><h2 id=\"6-3-继承\"><a href=\"#6-3-继承\" class=\"headerlink\" title=\"6.3 继承\"></a>6.3 继承</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 可以多重继承</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 子类名<span class=\"params\">(父类名<span class=\"number\">1</span>,父类名<span class=\"number\">2</span>,..)</span>:</span></span><br><span class=\"line\">  类体</span><br></pre></td></tr></table></figure><p>注:</p><ul><li>如果子类中没有重新定义构造方法, 会执行第一个父类的构造方法</li><li>使用内置方法issubclass(Child, Parent)判断一个类是否是另一个类的子孙类, 返回True或者False</li><li>小心使用多重继承, 能不用就不用, 可以用组合</li><li>多重继承函数的搜索顺序是广度优先, 从左到右找, 没有就下一个</li><li>super(Child,self).__init__()相当于Parent.__init__(self)</li><li>子类继承父类所有属性和方法, 如果没有覆盖掉, 则调用父类方法</li><li>可以使用父类名Parent.fun(self)或者super(Child,self).fun()来调用父类方法, 但是一定要传self</li></ul><p>对于init函数:</p><ul><li>如果子类没有定义自己的初始化函数，父类的初始化函数会被默认调用；但是如果要实例化子类的对象，则只能传入父类的初始化函数对应的参数，否则会出错。</li><li>如果子类定义了自己的初始化函数，而在子类中没有显示调用父类的初始化函数，则父类的属性不会被初始化</li><li>如果子类定义了自己的初始化函数，在子类中显示调用父类，子类和父类的属性都会被初始化</li></ul><p>详细的看下面这几个链接:<br><a href=\"http://blog.csdn.net/brucewong0516/article/details/79114977\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">python中的类，对象，方法，属性初认识（一）</a><br><a href=\"http://blog.csdn.net/brucewong0516/article/details/79118703\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">详解类class的属性：类数据属性、实例数据属性、特殊的类属性、属性隐藏（二）</a><br><a href=\"http://blog.csdn.net/brucewong0516/article/details/79119551\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">详解类class的方法：实例方法、类方法、静态方法（三）</a><br><a href=\"http://blog.csdn.net/brucewong0516/article/details/79120841\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">详解类class的访问控制：单下划线与双下划线（四）</a><br><a href=\"https://blog.csdn.net/brucewong0516/article/details/79121179\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">详解类class的继承、<strong>init</strong>初始化、super方法</a></p><h1 id=\"CH7-文件操作\"><a href=\"#CH7-文件操作\" class=\"headerlink\" title=\"CH7. 文件操作\"></a>CH7. 文件操作</h1><p>具体的可看<a href=\"https://www.runoob.com/python/python-files-io.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Python 文件I/O | 菜鸟教程</a>和<a href=\"https://blog.csdn.net/m0_38059843/article/details/78240835\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">python 文件操作，最全的一个 | CSDN</a></p><h1 id=\"CH8-注意点\"><a href=\"#CH8-注意点\" class=\"headerlink\" title=\"CH8. 注意点\"></a>CH8. 注意点</h1><ol><li>整除是//不是/, 看1.4.1</li><li>判断在不在用in</li><li>正则的使用</li><li>$是匹配结尾,如果是一行里面的不要用$符号,匹配所有单词只需要<code>[a-zA-Z]+</code>就可以</li><li>read()没有参数就是读全部</li><li>write()写字符串的时候可以用字符串.format()方法格式化输出到文件</li><li>open()之后要记得close()</li><li>dict.items()之后要使用list()转换一下才可以用</li><li>没有返回值的函数说明是要在序列内部修改, 注意不要修改引用, 只改内容</li><li>文件操作要记得使用try-except</li><li><strong>大量的数据</strong>统计要最好用字典,字典使用哈希会很快</li></ol><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>系统的复习一下Python的知识点, 做一些笔记</p></div>","more":"<h1 id=\"CH1-Python语言基础\"><a href=\"#CH1-Python语言基础\" class=\"headerlink\" title=\"CH1. Python语言基础\"></a>CH1. Python语言基础</h1><h2 id=\"1-1-常量与变量\"><a href=\"#1-1-常量与变量\" class=\"headerlink\" title=\"1.1 常量与变量\"></a>1.1 常量与变量</h2><h3 id=\"概念和注意点\"><a href=\"#概念和注意点\" class=\"headerlink\" title=\"概念和注意点\"></a>概念和注意点</h3><ol><li>内存是以字节为单位的一片连续的存储空间, 变量名是内存单元的名称, 变量值是变量所对应的内存单元的内容, 变量地址是变量对应内存单元的地址.</li><li>动态类型语言, 确定变量类型是在变量赋值的时候, <strong>每次赋值</strong>都可能改变类型</li><li>是基于值的内存管理方式, 不同的值分配不同的空间.<br>因此, 变量值改变时, 改变的是变量的指向关系, 使得变量指向另一个内存空间.<br>在C语言中是改变变量内存空间的内容, 变量对应的内存空间是固定的.<br>使用<strong> id()函数 </strong>可以查看对象的内存地址.</li><li>python中的变量是对一个对象的引用, 变量和变量之间的赋值是对同一个对象的引用, 变量指向一个对象或内存空间, 内存空间的内容可以修改</li><li>这里需要注意的是, 一些简单的对象, 比如较小的整型对象, Python采用对象重用的方法.<br>举例: a=2, b=2, 不会分配两次内存, a和b同时指向一个对象</li></ol><h3 id=\"变量命名\"><a href=\"#变量命名\" class=\"headerlink\" title=\"变量命名\"></a>变量命名</h3><ol><li>变量命名规则: 数字+字母+下划线, 不可以数字开头, 区分大小写. 单独的下划线是表示上一次运算的结果</li><li>变量名不可以是,关键词:<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> keyword</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(keyword.kwlist)</span><br><span class=\"line\">[<span class=\"string\">'False'</span>, <span class=\"string\">'None'</span>, <span class=\"string\">'True'</span>, <span class=\"string\">'and'</span>, <span class=\"string\">'as'</span>, <span class=\"string\">'assert'</span>, <span class=\"string\">'async'</span>, <span class=\"string\">'await'</span>, <span class=\"string\">'break'</span>, <span class=\"string\">'class'</span>, <span class=\"string\">'continue'</span>, <span class=\"string\">'def'</span>, <span class=\"string\">'del'</span>, <span class=\"string\">'elif'</span>, <span class=\"string\">'else'</span>, <span class=\"string\">'except'</span>, <span class=\"string\">'finally'</span>, <span class=\"string\">'for'</span>, <span class=\"string\">'from'</span>, <span class=\"string\">'global'</span>, <span class=\"string\">'if'</span>, <span class=\"string\">'import'</span>, <span class=\"string\">'in'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'lambda'</span>, <span class=\"string\">'nonlocal'</span>, <span class=\"string\">'not'</span>, <span class=\"string\">'or'</span>, <span class=\"string\">'pass'</span>, <span class=\"string\">'raise'</span>, <span class=\"string\">'return'</span>, <span class=\"string\">'try'</span>, <span class=\"string\">'while'</span>, <span class=\"string\">'with'</span>, <span class=\"string\">'yield'</span>]</span><br></pre></td></tr></table></figure></li></ol><h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><p>分局部变量和全局变量</p><p>函数外就是全局变量, 如果要在函数中修改全局变量, 使用<code>global</code>语句声明它是全局变量</p><p>如果同一程序中, 全局变量和局部变量同名, 则, 在局部变量作用范围内, 全局变量失效</p><p>如果在内层函数要修改外层函数变量:</p><ul><li>使用global</li><li>使用nonlocal关键字, 在内层函数中使用nonlocal声明变量</li><li>nonlocal 适用于在局部函数中的局部函数，把最内层的局部 变量设置成外层局部可用，但是还不是全局的。并且nonlocal必须绑定一个局部变量,不然报错</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scope_test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_local</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        spam = <span class=\"string\">\"local spam\"</span>   <span class=\"comment\">#和外面的spam不一样</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_nonlocal</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span>  spam        <span class=\"comment\">#使用外层的spam变量</span></span><br><span class=\"line\">        spam = <span class=\"string\">\"nonlocal spam\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_global</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">global</span> spam</span><br><span class=\"line\">        spam = <span class=\"string\">\"global spam\"</span></span><br><span class=\"line\">    spam = <span class=\"string\">\"test spam\"</span></span><br><span class=\"line\">    do_local()</span><br><span class=\"line\">    print(<span class=\"string\">\"After local assignmane:\"</span>, spam)</span><br><span class=\"line\">    do_nonlocal()</span><br><span class=\"line\">    print(<span class=\"string\">\"After nonlocal assignment:\"</span>,spam)</span><br><span class=\"line\">    do_global()</span><br><span class=\"line\">    print(<span class=\"string\">\"After global assignment:\"</span>,spam)</span><br><span class=\"line\"></span><br><span class=\"line\">scope_test()</span><br><span class=\"line\">print(<span class=\"string\">\"In global scope:\"</span>,spam)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\">After local assignmane: test spam</span><br><span class=\"line\">After <span class=\"keyword\">nonlocal</span> assignment: <span class=\"keyword\">nonlocal</span> spam</span><br><span class=\"line\">After <span class=\"keyword\">global</span> assignment: <span class=\"keyword\">nonlocal</span> spam</span><br><span class=\"line\">In <span class=\"keyword\">global</span> scope: <span class=\"keyword\">global</span> spam</span><br></pre></td></tr></table></figure><h2 id=\"1-2-数据类型\"><a href=\"#1-2-数据类型\" class=\"headerlink\" title=\"1.2 数据类型\"></a>1.2 数据类型</h2><h3 id=\"1-2-1-数值类型\"><a href=\"#1-2-1-数值类型\" class=\"headerlink\" title=\"1.2.1 数值类型\"></a>1.2.1 数值类型</h3><p>三种类型: 整型int, 浮点型float, 复数型complex</p><ol><li><p>整型数据:<br>整数, 不带小数点, 可以有正负号.<br>数据的值不固定长度, 只要内存允许, 可以<strong>任意长度</strong><br>四种表示:</p><ul><li>十进制</li><li>二进制, 0b或者0B开头</li><li>八进制, 0o或者0O开头</li><li>十六进制, 0x或者0X开头</li></ul></li><li><p>浮点类型:<br>两种表示:</p><ul><li>十进制小数: 数字+小数点, 小数点后面可以没有数字, 如: 3.23, 34.0, 0.0, 34.</li><li>指数形式: 科学计数法表示的, e或者E表示10为底的指数. 两部分比如同时出现, 指数必须整数. 如4e-5, 45e-6. 提供17位<strong>有效数字</strong>精度, <strong>不是17位小数!</strong></li><li>注意可能选择题, 1234567890123456789.0 + 1 - 1234567890123456789 = 0.0, 1234567890123456789.0 - 1234567890123456789 + 1 = 1.0, 前者因为+1之后超过精度, 用科学计数法表示, +1 被忽略了, 所以结果为0.</li></ul></li><li><p>复数类型:</p><ul><li>表示形式: a+bJ, a是实部, b是虚部, J是-1的平方根, 是虚数单位, 也可写成j, 注意不是数学上的i</li><li>用x.real和x.imag获得实部和虚部, 结果都是<strong>浮点型</strong></li></ul></li></ol><h3 id=\"1-2-2-字符串类型\"><a href=\"#1-2-2-字符串类型\" class=\"headerlink\" title=\"1.2.2 字符串类型\"></a>1.2.2 字符串类型</h3><ol><li>使用单引号, 双引号, 或者三引号定义标准字符串, 三引号的字符串可以多行</li><li>使用下表访问字符串中的字符</li><li>字符串中字符不可改变, 只能重新赋值</li><li>使用转义字符控制输出<br>注意\\0: 空字符, \\a:响铃, \\r: 回车, 表示对当前行重叠输出, 只回车不换行</li><li>字符串前面加r表示原始字符串, 不转义</li><li><strong>eval()函数</strong>: 把字符串内容当作python语句执行, eval(‘1+1’), 结果为2</li><li><strong>len()函数</strong>: 返回长度</li></ol><h3 id=\"1-2-3-布尔类型\"><a href=\"#1-2-3-布尔类型\" class=\"headerlink\" title=\"1.2.3 布尔类型\"></a>1.2.3 布尔类型</h3><ol><li>True和False, 注意开头大写</li><li>实际上分别用整型值<strong>1和0</strong>参与运算</li></ol><h3 id=\"1-2-4-复合数据类型\"><a href=\"#1-2-4-复合数据类型\" class=\"headerlink\" title=\"1.2.4 复合数据类型\"></a>1.2.4 复合数据类型</h3><ol><li>包含多个相关联的数据元素,因此称为复合数据类型.</li><li>列表, 元组和字符串是又顺序的, 称为序列.<br>字典和集合是无顺序的.</li><li>列表:<ul><li>中括号, 逗号分隔, 类型可不同</li><li>可以嵌套</li><li>列表元素可以改变</li></ul></li><li>元组:<ul><li>1,2,3 这样省略括号的默认为<strong>元组</strong></li><li>小括号, 逗号分隔, 类型可不同</li><li>元组元素不可修改</li><li>() 表示空元组</li><li><strong>(9, )</strong>只有一个元素, 要用逗号结尾</li><li>(9)表示整数9</li></ul></li><li>字典:<ul><li>大括号, 逗号分隔</li><li>关键字: 值, 关键字必须不可变类型且互不相同</li><li>{} 空字典</li></ul></li><li>集合:<ul><li>无序, 不重复</li><li>大括号或者set()函数创建</li><li>set() 空集合</li></ul></li></ol><h2 id=\"1-3常用模块和函数\"><a href=\"#1-3常用模块和函数\" class=\"headerlink\" title=\"1.3常用模块和函数\"></a>1.3常用模块和函数</h2><p>三种导包<br></p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\">math.sqrt(<span class=\"number\">2</span>)</span><br><span class=\"line\">====</span><br><span class=\"line\"><span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> sqrt</span><br><span class=\"line\">sqrt(<span class=\"number\">2</span>)</span><br><span class=\"line\">===</span><br><span class=\"line\"><span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sqrt(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure><p></p><h3 id=\"1-3-1-math模块\"><a href=\"#1-3-1-math模块\" class=\"headerlink\" title=\"1.3.1 math模块\"></a>1.3.1 math模块</h3><p>常量: e, pi<br>fabs(), sqrt(), pow(x, y), exp(x), ceil(x), floor(x), fmod(y, x)<br>sin(x), cos(x), tan(x)…</p><h3 id=\"1-3-2-cmath模块\"><a href=\"#1-3-2-cmath模块\" class=\"headerlink\" title=\"1.3.2 cmath模块\"></a>1.3.2 cmath模块</h3><p>相对math支持复数运算<br>polar(x): 复数笛卡儿坐标换为极坐标<br>rect(r,p): 复数极坐标换为笛卡儿坐</p><h3 id=\"1-3-3-random模块\"><a href=\"#1-3-3-random模块\" class=\"headerlink\" title=\"1.3.3 random模块\"></a>1.3.3 random模块</h3><ul><li>seed(x)随机数种子, 种子相同, 随机数相同, 默认种子是时间</li><li>choice([0,1,2])随机挑选一个</li><li>sample(seq, k): 从序列中挑k个</li><li>shuffle(seq): 随机排序</li><li>random(): [0, 1)内实数</li><li>randint(a, b): [a, b]内整数</li><li>uniform(a,b): [a,b]内实数</li></ul><h3 id=\"1-3-4-time模块\"><a href=\"#1-3-4-time模块\" class=\"headerlink\" title=\"1.3.4 time模块\"></a>1.3.4 time模块</h3><ul><li>time(): 返回时间戳</li><li>localtime(secs): 接收一个时间戳, 返回时间元组</li><li>asctime([]): 接收一个时间元组, 返回一个日期时间字符串</li><li>asctime(localtime(time())), 可以这样用</li><li>ctime(time())和上面的结果相同</li></ul><h3 id=\"1-3-5-calendar模块\"><a href=\"#1-3-5-calendar模块\" class=\"headerlink\" title=\"1.3.5 calendar模块\"></a>1.3.5 calendar模块</h3><ul><li>提供日历相关功能</li><li>calendar.isleap(), 这个函数可以用来判断是否闰年</li></ul><h3 id=\"1-3-6-内置函数\"><a href=\"#1-3-6-内置函数\" class=\"headerlink\" title=\"1.3.6 内置函数\"></a>1.3.6 <strong>内置函数</strong></h3><ul><li>range([start,]end[,step]): 开始和步长可省, 默认开始0, 步长1, [start, end),不包括end哦! 如果要使用step, 需要写start. range()函数返回的还是可迭代对象</li><li>range()可以和list()或者tuple()结合: list(range(5)), tuple(range(5))</li></ul><ul><li>ord(): 将字符转化为相应编码值</li><li>chr(): 将整数转化为相应unicode字符</li></ul><ul><li>repr(object): 返回一个对象的string格式, <a href=\"https://www.runoob.com/python/python-func-repr.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">菜鸟教程</a></li><li>str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式</li><li>iter(可迭代对象): 用于产生一个可迭代对象的迭代器, 可用next(it)得到迭代器下一个元素</li></ul><ul><li>abs()</li><li>pow(x,y[,z]): x^y%z</li><li>round(x[,n]): 这个函数尽量不要用! 不是严格的四舍五入, 和浮点数精度有关, 具体可以参考<a href=\"https://www.runoob.com/w3cnote/python-round-func-note.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Python 中关于 round 函数的小坑</a>浮点数x, n为精确到小数点后的位数,可省默认保留整数, 结果仍浮点型</li><li>divmod(x, y): 结果为(商,余数), divmod(7,4)==(1,3)</li></ul><h2 id=\"1-4-基本运算\"><a href=\"#1-4-基本运算\" class=\"headerlink\" title=\"1.4 基本运算\"></a>1.4 基本运算</h2><h3 id=\"1-4-1-算术运算\"><a href=\"#1-4-1-算术运算\" class=\"headerlink\" title=\"1.4.1 算术运算\"></a>1.4.1 算术运算</h3><p>+, -, *, /(返回浮点数), //(整除), %, **(乘方)<br>这里注意下//这个运算:</p><ol><li>如果是正数, 那就是去掉小数部分, <strong>关键是负数, 需要向绝对值更大的方向进位</strong>.<br>举例: 4//3 == 1, -4//3 == -2, -7//3 == -3, -8//3 == -3</li><li>如果a//b, a或b是浮点数, 那结果也是浮点型, 只有<strong>两个都是整型</strong>, 结果才是整型<br>举例: 4//3 == 1, 4.1//3 == 1.0</li></ol><p>注意取模运算的结果,只有<strong>两个都是整型</strong>才是整型, 例: 5%3 == 2, 5%3.0 == 2.0</p><h3 id=\"1-4-2-计算误差\"><a href=\"#1-4-2-计算误差\" class=\"headerlink\" title=\"1.4.2 计算误差\"></a>1.4.2 计算误差</h3><p>浮点数有效位有效, 17位, 所以肯定有误差.<br>因此, 比较符点数的时候, == 运算符要小心使用, 应该判断是否约等于<br>举例: abs(2.2-1.2-1)&lt;1e-6, 取一个很小的误差就好</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">2.2</span><span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1.2000000000000002</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">2.2</span><span class=\"number\">-1</span><span class=\"number\">-1.2</span></span><br><span class=\"line\"><span class=\"number\">2.220446049250313e-16</span></span><br></pre></td></tr></table></figure><h3 id=\"1-4-3-数据类型转换\"><a href=\"#1-4-3-数据类型转换\" class=\"headerlink\" title=\"1.4.3 数据类型转换\"></a>1.4.3 数据类型转换</h3><p>整型+浮点型, 会自动将整型转换为浮点型<br><strong>强制转换:</strong></p><ul><li>int(x)</li><li>float(x)</li><li>complex(x), 将x转换为复数, 实部为x, 虚部为0</li><li>complex(x, y), x为实部, y为虚部</li></ul><h3 id=\"1-4-4-位运算\"><a href=\"#1-4-4-位运算\" class=\"headerlink\" title=\"1.4.4 位运算\"></a>1.4.4 位运算</h3><ul><li>&amp;: 按位与, 全1为1, |: 按位或, 有1为1, ^: 按位异或,不一样为1, ~: 按位取反, &lt;&lt;: 左移, 低位补0, &gt;&gt;: 右移,高位补0</li></ul><h2 id=\"1-5-输入与输出\"><a href=\"#1-5-输入与输出\" class=\"headerlink\" title=\"1.5 输入与输出\"></a>1.5 输入与输出</h2><h3 id=\"1-5-1-标准输入\"><a href=\"#1-5-1-标准输入\" class=\"headerlink\" title=\"1.5.1 标准输入\"></a>1.5.1 标准输入</h3><p>格式:</p><ul><li>input([提示字符串])</li></ul><p>提示字符串可选, input读入一行, 并返回一个字符串.<br>如果需要数值数据, 需要使用类型将字符串转化成数值<br>可以给多变量赋值, 使用eval(input())</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 读整数</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x=int(input())</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读多个变量</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x,y=eval(input())</span><br><span class=\"line\"><span class=\"number\">1</span>,<span class=\"number\">2</span></span><br><span class=\"line\">&gt;&gt; x</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\"># 相当于x,y=(3,4)</span></span><br></pre></td></tr></table></figure><h3 id=\"1-5-2-标准输出\"><a href=\"#1-5-2-标准输出\" class=\"headerlink\" title=\"1.5.2 标准输出\"></a>1.5.2 标准输出</h3><p>格式:</p><ul><li>print([输出项1,输出项2,..输出项n][,seq=分隔符][,end=结束符])</li></ul><p>seq默认空格, end默认回车换行<br>没有输出项则输出空行. print()从左到右输出每个项</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"number\">10</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"number\">10</span> <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"number\">10</span>, <span class=\"number\">20</span>, seq=<span class=\"string\">','</span>)</span><br><span class=\"line\"><span class=\"number\">10</span>,<span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"number\">10</span>, <span class=\"number\">20</span>, seq=<span class=\"string\">','</span>,end=<span class=\"string\">'*'</span>)</span><br><span class=\"line\"><span class=\"number\">10</span>,<span class=\"number\">20</span>*</span><br><span class=\"line\"><span class=\"comment\">#并且没换行</span></span><br></pre></td></tr></table></figure><h3 id=\"1-5-3-格式化输出\"><a href=\"#1-5-3-格式化输出\" class=\"headerlink\" title=\"1.5.3 格式化输出\"></a>1.5.3 格式化输出</h3><p>三种格式化输出方式:</p><ul><li>用%</li><li>用format()内置函数</li><li>用字符串的format方法</li></ul><h4 id=\"1-5-3-1-格式化运算符\"><a href=\"#1-5-3-1-格式化运算符\" class=\"headerlink\" title=\"1.5.3.1 格式化运算符%\"></a>1.5.3.1 格式化运算符%</h4><p>格式化字符串%(输出项1,输出项2…输出项n)</p><p>%的运算结果是字符串</p><p>格式符:</p><ul><li>%% 百分号, %c 字符, %s 字符串, %d 带符号整数, %o 八进制, %x/X, %e/E 科学记数法, %f/F 浮点数, %g/G 根据值大小选%e还是%f</li><li>不管什么类型,都可以用%s</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'Values are %s, %s, %s'</span>%(<span class=\"number\">1</span>,<span class=\"number\">2.3</span>,[<span class=\"string\">'one'</span>,<span class=\"string\">'two'</span>,<span class=\"string\">'three'</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 表示总长度为6, 小数部分2位, 输出不足用0补齐, 小数点也占一位</span></span><br><span class=\"line\"><span class=\"comment\"># 0可以用-, +代替, -左对齐, +表在正数前加上+号,默认不加</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'%06.2f'</span>%<span class=\"number\">1.234</span></span><br><span class=\"line\"><span class=\"string\">'001.24'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用字典输出时特殊用法, 这时候值由键确定</span></span><br><span class=\"line\"><span class=\"comment\"># '%(key)06.1f'%&#123;'key':value&#125;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'%(name)s:%(score)06.1f'</span>%&#123;<span class=\"string\">'score'</span>:<span class=\"number\">9.5</span>,<span class=\"string\">'name'</span>:<span class=\"string\">'Lucy'</span>&#125;</span><br><span class=\"line\"><span class=\"string\">'Lucy:0009.5'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># %*.*f 运行中确定的</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'%0*.*f'</span>%(<span class=\"number\">6</span>,<span class=\"number\">2</span>,<span class=\"number\">2.345</span>)</span><br><span class=\"line\"><span class=\"string\">'002.35'</span></span><br></pre></td></tr></table></figure><h4 id=\"1-5-3-2-format-内置函数\"><a href=\"#1-5-3-2-format-内置函数\" class=\"headerlink\" title=\"1.5.3.2 format()内置函数\"></a>1.5.3.2 format()内置函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">format(输出项[,格式字符串])</span><br></pre></td></tr></table></figure><p>省略格式符等价与str()函数</p><p>格式符:</p><ul><li>d, b(二进制), o, x, X</li><li>f, F, e, E, g, G</li><li>c(整数为编码的字符)</li><li>%(输出百分号)</li><li>&lt;(左对齐), &gt;(右对齐), ^(居中对齐), =(填充字符位于符号和数字之间), +(表正号)</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(format(<span class=\"number\">65</span>,<span class=\"string\">'c'</span>),format(<span class=\"number\">3.145</span>,<span class=\"string\">'f'</span>))</span><br><span class=\"line\">A <span class=\"number\">3.145000</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(format(<span class=\"number\">3.145</span>,<span class=\"string\">'6.2f'</span>),format(<span class=\"number\">3.145</span>,<span class=\"string\">'05.3'</span>))</span><br><span class=\"line\">  <span class=\"number\">3.15</span> <span class=\"number\">03.15</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(format(<span class=\"number\">3.145</span>,<span class=\"string\">'0=+10'</span>),format(<span class=\"string\">'test'</span>,<span class=\"string\">'&gt;20'</span>))</span><br><span class=\"line\">+<span class=\"number\">00003.145</span>                 test</span><br></pre></td></tr></table></figure><h4 id=\"1-5-3-3-字符串的format-方法\"><a href=\"#1-5-3-3-字符串的format-方法\" class=\"headerlink\" title=\"1.5.3.3 字符串的format()方法\"></a>1.5.3.3 字符串的format()方法</h4><p>属于字符串的类方法, 尽量用字符串的format()方法</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### </span></span><br><span class=\"line\"><span class=\"string\">'格式化字符串'</span>.format(输出项<span class=\"number\">1</span>, 输出项<span class=\"number\">2</span>, 输出项<span class=\"number\">3.</span>..输出项n)</span><br><span class=\"line\"></span><br><span class=\"line\">格式字符串格式:</span><br><span class=\"line\">&#123;[序号或者键]: 格式说明符&#125; 冒号不能丢</span><br><span class=\"line\"></span><br><span class=\"line\">格式化字符中, 普通字符原样输出, 格式说明符对应输出项</span><br><span class=\"line\"></span><br><span class=\"line\">序号从<span class=\"number\">0</span>开始! 如果全部省略就按照顺序输出</span><br><span class=\"line\"><span class=\"comment\">### </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 省略</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'i am &#123;&#125;, &#123;&#125;'</span>.format(<span class=\"string\">'Brenden'</span>,<span class=\"string\">'Welcome!'</span>))</span><br><span class=\"line\">i am Brenden, Welcome!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 序号</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'first:&#123;1&#125;, second:&#123;0&#125;, third:&#123;2&#125;'</span>.format(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>))</span><br><span class=\"line\">first:<span class=\"number\">2</span>, second:<span class=\"number\">1</span>, third:<span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 混用序号和键</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'hello, i am &#123;name&#125;, &#123;0&#125;'</span>.format(<span class=\"string\">'Welcome'</span>,name=<span class=\"string\">\"xiaoming\"</span>))</span><br><span class=\"line\">hello, i am xiaoming, Welcome</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结合格式符</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'&#123;0:*^15&#125;'</span>.format(<span class=\"number\">12345678</span>))</span><br><span class=\"line\">***<span class=\"number\">12345678</span>****</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'&#123;0:&lt;15&#125;'</span>.format(<span class=\"number\">12345678</span>))</span><br><span class=\"line\"><span class=\"number\">12345678</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(<span class=\"string\">'&#123;0:&gt;15&#125;'</span>.format(<span class=\"number\">12345678</span>))</span><br><span class=\"line\">       <span class=\"number\">12345678</span></span><br></pre></td></tr></table></figure><h2 id=\"1-6-缩进和注释\"><a href=\"#1-6-缩进和注释\" class=\"headerlink\" title=\"1.6 缩进和注释\"></a>1.6 缩进和注释</h2><h3 id=\"1-6-1-缩进\"><a href=\"#1-6-1-缩进\" class=\"headerlink\" title=\"1.6.1 缩进\"></a>1.6.1 缩进</h3><p>我认为, Python相对其他语言, 缩进真的是一个很坑的点, 同一程序中最好是一样的缩进, 否则经常出现缩进错误<br>一般是四个空格或者一个TAB</p><h3 id=\"1-6-2-注释\"><a href=\"#1-6-2-注释\" class=\"headerlink\" title=\"1.6.2 注释\"></a>1.6.2 注释</h3><p>如果注释里面有中文,记得要在开头使用<code>#coding=utf-8</code>或者<code>#coding=gbk</code></p><ul><li>单行注释: #开头, #后的就是注释</li><li>多行注释: 三个单引号或者双引号, <strong>多行注释不可以使用反斜杠续行!!</strong></li></ul><h2 id=\"1-7赋值语句\"><a href=\"#1-7赋值语句\" class=\"headerlink\" title=\"1.7赋值语句\"></a>1.7赋值语句</h2><h3 id=\"1-7-1-一般格式\"><a href=\"#1-7-1-一般格式\" class=\"headerlink\" title=\"1.7.1 一般格式\"></a>1.7.1 一般格式</h3><p>变量=表达式</p><h3 id=\"1-7-2-复合赋值语句\"><a href=\"#1-7-2-复合赋值语句\" class=\"headerlink\" title=\"1.7.2 复合赋值语句\"></a>1.7.2 复合赋值语句</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+=, -=, *=, /=, //=, **=, &lt;&lt;=, &gt;&gt;=, &amp;=, |=, ^=</span><br></pre></td></tr></table></figure><p><strong>注意!</strong> <code>x*y+5==x*(y+5)</code></p><h3 id=\"1-7-3-多变量赋值\"><a href=\"#1-7-3-多变量赋值\" class=\"headerlink\" title=\"1.7.3 多变量赋值\"></a>1.7.3 多变量赋值</h3><ol><li>链式赋值<ul><li>变量1=变量2=变量…..=变量n=表达式</li><li>a=b=10 等价于 a=10;b=10</li><li>要注意的是, 上例, a和b同时指向一个整型对象10</li></ul></li><li>同步赋值<ul><li>变量1,变量2,变量3…=表达式1,表达式2…表达式n</li><li>a,b,c=1,2,3</li><li>注意同步赋值不是单一赋值语句的先后执行!!!</li></ul></li></ol><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; x,x=2,-50 </span><br><span class=\"line\"># x结果为-50</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; x=-11</span><br><span class=\"line\">&gt;&gt;&gt; x,y=12,x</span><br><span class=\"line\"># 此时x=12, 但是y=-11 !!!要小心使用</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; a,b=1,2</span><br><span class=\"line\">&gt;&gt;&gt; a,b=b,a</span><br><span class=\"line\"># 此时a, b分别为2, 1</span><br><span class=\"line\"># 可以用a,b=b,a省略一个中间变量</span><br></pre></td></tr></table></figure><h2 id=\"1-8-条件的描述\"><a href=\"#1-8-条件的描述\" class=\"headerlink\" title=\"1.8 条件的描述\"></a>1.8 条件的描述</h2><h3 id=\"1-8-1-关系运算符\"><a href=\"#1-8-1-关系运算符\" class=\"headerlink\" title=\"1.8.1 关系运算符\"></a>1.8.1 关系运算符</h3><p>优先级小于算术运算符, 就是先算算术运算符, 再比较<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;, &lt;=, &gt;, &gt;=, ==, !=</span><br></pre></td></tr></table></figure><p></p><h3 id=\"1-8-2-逻辑运算\"><a href=\"#1-8-2-逻辑运算\" class=\"headerlink\" title=\"1.8.2 逻辑运算\"></a>1.8.2 逻辑运算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">and(与), or(或), not(非)</span><br></pre></td></tr></table></figure><p>优先级:</p><ul><li>not &gt; and &gt; or</li></ul><p>逻辑与: 前面的False就不算后面的<br>逻辑或: 前面的True就不算后面的</p><h3 id=\"1-8-3-成员测试\"><a href=\"#1-8-3-成员测试\" class=\"headerlink\" title=\"1.8.3 成员测试\"></a>1.8.3 成员测试</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">in: 在序列中查找, 返回True或者False</span><br><span class=\"line\">not in: 么找到返回True</span><br><span class=\"line\">is: 测试两个变量是否, 指向同一个变量</span><br></pre></td></tr></table></figure><blockquote class=\"blockquote-center\"><p><strong>end CH1</strong></p></blockquote><h1 id=\"CH2-Python程序结构\"><a href=\"#CH2-Python程序结构\" class=\"headerlink\" title=\"CH2. Python程序结构\"></a>CH2. Python程序结构</h1><h2 id=\"2-1-算法及其描述\"><a href=\"#2-1-算法及其描述\" class=\"headerlink\" title=\"2.1 算法及其描述\"></a>2.1 算法及其描述</h2><p>算法+数据结构=程序, 计算机解决问题的方法和步骤就是算法<br>算法描述:</p><ol><li>传统流程图</li><li>结构化流程图:<ul><li>程序的三种基本结构: 顺序结构, 选择结构, 循环结构</li><li>结构化流程图(N-S图): 顺序结构, 选择结构, 当型循环结构, 直到型循环结构, 各单元顺序执行</li></ul></li></ol><h2 id=\"2-2-顺序结构\"><a href=\"#2-2-顺序结构\" class=\"headerlink\" title=\"2.2 顺序结构\"></a>2.2 顺序结构</h2><p>简单的按照出现顺序执行</p><h2 id=\"2-3-选择结构\"><a href=\"#2-3-选择结构\" class=\"headerlink\" title=\"2.3 选择结构\"></a>2.3 选择结构</h2><h3 id=\"2-3-1-if-elif-else\"><a href=\"#2-3-1-if-elif-else\" class=\"headerlink\" title=\"2.3.1 if-elif-else\"></a>2.3.1 if-elif-else</h3><p>要注意的是, if的表达式可以使任意的, 比如 if ‘B’:<br>嵌套的时候根据对齐来配对</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 单分支</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ...:</span><br><span class=\"line\">  表达式</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 双分支</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ...:</span><br><span class=\"line\">  语句</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多分支</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ...:</span><br><span class=\"line\">  ...</span><br><span class=\"line\"><span class=\"keyword\">elif</span> ...:</span><br><span class=\"line\">  ...</span><br><span class=\"line\"><span class=\"keyword\">elif</span> ...:</span><br><span class=\"line\">  ...</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure><h3 id=\"2-3-2-条件运算\"><a href=\"#2-3-2-条件运算\" class=\"headerlink\" title=\"2.3.2 条件运算\"></a>2.3.2 条件运算</h3><p><strong>可以作为一个运算量, 而不是一个单独的语句</strong></p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表达式<span class=\"number\">1</span> <span class=\"keyword\">if</span> 表达式 <span class=\"keyword\">else</span> 表达式<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z= x <span class=\"keyword\">if</span> x&gt;y <span class=\"keyword\">else</span> y</span><br><span class=\"line\"><span class=\"comment\"># 其中z=后面的就是一个条件运算</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>i=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'a'</span> <span class=\"keyword\">if</span> i <span class=\"keyword\">else</span> <span class=\"string\">'A'</span></span><br><span class=\"line\"><span class=\"string\">'A'</span></span><br></pre></td></tr></table></figure><h2 id=\"2-4-循环结构\"><a href=\"#2-4-循环结构\" class=\"headerlink\" title=\"2.4 循环结构\"></a>2.4 循环结构</h2><h3 id=\"2-4-1-while\"><a href=\"#2-4-1-while\" class=\"headerlink\" title=\"2.4.1 while\"></a>2.4.1 while</h3><p>while和if有一个相同的地方就是, 如果循环体只哟一个语句, 可以写在一行</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> ...:</span><br><span class=\"line\">  ....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以结合else语句</span></span><br><span class=\"line\"><span class=\"comment\"># 但是只可以在while部分正常退出的时候才执行else部分</span></span><br><span class=\"line\"><span class=\"comment\"># 如果是break退出的, 不执行else部分</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ...:</span><br><span class=\"line\">  ....</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  ....</span><br></pre></td></tr></table></figure><h3 id=\"2-4-2-for\"><a href=\"#2-4-2-for\" class=\"headerlink\" title=\"2.4.2 for\"></a>2.4.2 for</h3><p>可结合range()函数, 看1.3.6部分</p><blockquote><p>range([start,]end[,step]): 开始和步长可省, 默认开始0, 步长1, [start, end),不包括end哦! 如果要使用step, 需要写start. range()返回可迭代对象<br>for循环中会自动调用iter()函数,和next()函数获得range里的元素</p></blockquote><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这个序列可以是: 字符串, 元组, 列表...</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> 变量 <span class=\"keyword\">in</span> 序列:</span><br><span class=\"line\">  语句块</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以用else语句</span></span><br><span class=\"line\"><span class=\"comment\"># 没碰到break就可以执行</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> 变量 <span class=\"keyword\">in</span> 序列:</span><br><span class=\"line\">  语句块</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  ....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结合range函数</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>  print(i, end=<span class=\"string\">','</span>)</span><br><span class=\"line\"><span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>):</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>  print(i, end=<span class=\"string\">','</span>)</span><br><span class=\"line\"><span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span></span><br></pre></td></tr></table></figure><h2 id=\"2-5-循环控制语句\"><a href=\"#2-5-循环控制语句\" class=\"headerlink\" title=\"2.5 循环控制语句\"></a>2.5 循环控制语句</h2><p>有<code>break</code>和<code>pass</code>和<code>continue</code>这三个</p><p>pass语句代表空语句,空操作, 相当于占位符</p><blockquote class=\"blockquote-center\"><p><strong>end CH2</strong></p></blockquote><h1 id=\"CH3-字符串和正则\"><a href=\"#CH3-字符串和正则\" class=\"headerlink\" title=\"CH3. 字符串和正则\"></a>CH3. 字符串和正则</h1><h2 id=\"3-1-字符串\"><a href=\"#3-1-字符串\" class=\"headerlink\" title=\"3.1 字符串\"></a>3.1 字符串</h2><p>关于编码的两个函数</p><ul><li>默认unicode编码, encode: 编码为, decode: 解码为unicode</li><li>s.encode(‘utf-8’)或者s.encode(‘gbk’)</li><li>s.decode(‘utf-8’)或者s.decode(‘gbk’)</li></ul><h3 id=\"索引和分片\"><a href=\"#索引和分片\" class=\"headerlink\" title=\"索引和分片\"></a>索引和分片</h3><p>索引分为正向和反向</p><div class=\"table-container\"><table><thead><tr><th style=\"text-align:center\">H</th><th style=\"text-align:center\">e</th><th style=\"text-align:center\">l</th><th style=\"text-align:center\">l</th><th style=\"text-align:center\">o</th></tr></thead><tbody><tr><td style=\"text-align:center\">s[0]</td><td style=\"text-align:center\">s[1]</td><td style=\"text-align:center\">s[2]</td><td style=\"text-align:center\">s[3]</td><td style=\"text-align:center\">s[4]</td></tr><tr><td style=\"text-align:center\">s[-5]</td><td style=\"text-align:center\">s[-4]</td><td style=\"text-align:center\">s[-3]</td><td style=\"text-align:center\">s[-2]</td><td style=\"text-align:center\">s[-1]</td></tr></tbody></table></div><p>分片使用中括号和如下格式:</p><ul><li>s[i:j:k]</li><li>i: 开始位置下标, j: 结束位置下标, 不包括j位置的字符, k: 步长</li><li>i,j,k都可以省略, i默认0或-1, j默认到最后一个字符, k默认1</li><li>一定要注意, 不管k是正还是负, 都不包括j位置的字符</li><li>i和j都可以超过字符串的长度</li></ul><p>示例:</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=<span class=\"string\">'hello'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[<span class=\"number\">0</span>:<span class=\"number\">4</span>:<span class=\"number\">1</span>])</span><br><span class=\"line\">hell</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[<span class=\"number\">0</span>:<span class=\"number\">5</span>:<span class=\"number\">2</span>])</span><br><span class=\"line\">hlo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[<span class=\"number\">-1</span>:<span class=\"number\">-5</span>:<span class=\"number\">-1</span>])</span><br><span class=\"line\">olle</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[<span class=\"number\">-1</span>:<span class=\"number\">-6</span>:<span class=\"number\">-1</span>])</span><br><span class=\"line\">olleh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[<span class=\"number\">0</span>:len(s)])</span><br><span class=\"line\">hello</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[-len(s):<span class=\"number\">-1</span>])</span><br><span class=\"line\">hell</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 都省了</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[:])</span><br><span class=\"line\">hello</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[::<span class=\"number\">2</span>])</span><br><span class=\"line\">hlo</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[::<span class=\"number\">-1</span>])</span><br><span class=\"line\">olleh</span><br><span class=\"line\"><span class=\"comment\"># 省略了步长</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s[:<span class=\"number\">-1</span>])</span><br><span class=\"line\">hell</span><br></pre></td></tr></table></figure><h3 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h3><p>使用<code>+</code>连接, 如果不是字符串类型, 使用str()函数或者repr()函数转换成字符串</p><p>字符串不可用下标修改, 所以可以用连接操作改某个字符</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=<span class=\"string\">'abcd'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=s[<span class=\"number\">0</span>]+<span class=\"number\">9</span>+s[<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</span><br><span class=\"line\"><span class=\"string\">'a9cd'</span></span><br></pre></td></tr></table></figure><p>可以使用<code>*</code>进行重复连接, n*s或者s*n<br>可以使用+=或者*=这样的操作</p><p>如果是连加操作, +的效率很低, 可以使用s.join()函数代替, s是分隔符</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'-'</span>.join([<span class=\"string\">'Python'</span>,<span class=\"string\">'and'</span>,<span class=\"string\">'Program'</span>])</span><br><span class=\"line\"><span class=\"string\">'Python-and-Program'</span></span><br></pre></td></tr></table></figure><h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><ul><li>单子符就直接比较ASCII码</li><li>相同长度从左到右比较ASCII</li><li>不同长度补全空格再从左到右比较ASCII</li></ul><h3 id=\"字符串成员关系\"><a href=\"#字符串成员关系\" class=\"headerlink\" title=\"字符串成员关系\"></a>字符串成员关系</h3><p>用<code>in</code>和<code>not in</code>: 字符串1 [not] in 字符串2<br>返回True或者False</p><h3 id=\"字符串常用方法\"><a href=\"#字符串常用方法\" class=\"headerlink\" title=\"字符串常用方法\"></a>字符串常用方法</h3><p>字符串是一个类, 有许多类方法.这里只记常用的</p><h4 id=\"大小写和对齐\"><a href=\"#大小写和对齐\" class=\"headerlink\" title=\"大小写和对齐\"></a>大小写和对齐</h4><ul><li>s.upper()/lower()</li><li>s.ljust(width, [fillchar]): 输出width长度, 左对齐, 不足部分fillchar补齐, 默认空格</li><li>s.rjust()/center(): 参数同上, 右对齐和居中</li></ul><h4 id=\"字符串搜索\"><a href=\"#字符串搜索\" class=\"headerlink\" title=\"字符串搜索\"></a>字符串搜索</h4><ul><li>s.find(sub,[start,[end]]): 返回sub的第一个字符编号, 没有返回-1</li><li>s.index(sub,[start,[end]]): 和find相同, 不过没有时,返回一个错误</li><li>s.rfind(sub,[start,[end]]): 从后往前找sub,第一个字符编号,没有返回-1</li><li>s.rindex(sub,[start,[end]])</li><li>s.count(substr,[start,[end]]): 返回出现次数</li><li>s.startswith(prefix,[start,[end]])</li><li>s.endswith(suffix,[start,[end]])</li></ul><h4 id=\"字符串替换\"><a href=\"#字符串替换\" class=\"headerlink\" title=\"字符串替换\"></a>字符串替换</h4><ul><li>s.replace(oldstr,newstr,[count]): old替换为new</li><li>s.strip([chars]): 默认去前后空格, s前后的chars中的字符去掉</li><li>s.lstrip([chars])/rstrip()</li><li>s.expandtabs([tabsize]): s中tab替换为空格, tabsize为空格的数量, 默认8个</li></ul><h4 id=\"字符串拆分\"><a href=\"#字符串拆分\" class=\"headerlink\" title=\"字符串拆分\"></a>字符串拆分</h4><ul><li>s.split([sep,[maxsplit]]): sep:分隔符,默认空格, 按sep把s拆成一个列表, maxsplit:拆分次数,默认-1无限制</li><li>s.rsplit([sep,[maxsplit]]): 从右侧拆</li><li>s.splitlines([keepends]): 按行拆成列表, keepends为true: 保留每行分隔符</li><li>s.partition(sub): 拆成三个元素的元组(sub左, sub, sub右), 如果没sub, 返回(s, ‘’, ‘’)</li><li>s.rpartition(sub): 从右边找sub</li></ul><h4 id=\"字符串连接-1\"><a href=\"#字符串连接-1\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h4><ul><li>s.join(seq): seq为序列, s为分隔符<br>通常和list(s)结合使用, 修改string某个字符</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=<span class=\"string\">'abcd'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=list(s)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">0</span>]=<span class=\"string\">'t'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=<span class=\"string\">\"\"</span>.join(s)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</span><br><span class=\"line\"><span class=\"string\">'tbcd'</span></span><br></pre></td></tr></table></figure><h4 id=\"字符串类型判断\"><a href=\"#字符串类型判断\" class=\"headerlink\" title=\"字符串类型判断\"></a>字符串类型判断</h4><ul><li>s.isalnum(): 字母和数字, 至少一个字符</li><li>s.isalpha(): 全字母,至少一个字符</li><li>s.isdigit(): 全数字,至少一个字符</li><li>s.isspace(): 全空格,至少一个字符</li><li>s.islower()/isupper()/istitle()</li></ul><h3 id=\"字节类型bytes\"><a href=\"#字节类型bytes\" class=\"headerlink\" title=\"字节类型bytes\"></a>字节类型bytes</h3><p>bytes和string不一样, 可以用string.encode()方法和bytes.decode()方法进行两者转换.<br>bytes可以使用bytearray(by)的方式将bytes转换为bytearray对象<br>bytes对象不可修改, bytearray可修改</p><h2 id=\"3-2-正则表达式\"><a href=\"#3-2-正则表达式\" class=\"headerlink\" title=\"3.2 正则表达式\"></a>3.2 正则表达式</h2><p>太多了, 附上<a href=\"https://www.runoob.com/python/python-reg-expressions.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">菜鸟教程</a></p><blockquote class=\"blockquote-center\"><p><strong>end CH3</strong></p></blockquote><h1 id=\"CH4-复合数据类型\"><a href=\"#CH4-复合数据类型\" class=\"headerlink\" title=\"CH4. 复合数据类型\"></a>CH4. 复合数据类型</h1><h2 id=\"4-1-序列\"><a href=\"#4-1-序列\" class=\"headerlink\" title=\"4.1 序列\"></a>4.1 序列</h2><p>序列包括<strong>字符串, 列表, 元组</strong>, 按照位置编号存取</p><h3 id=\"4-1-1-通用操作\"><a href=\"#4-1-1-通用操作\" class=\"headerlink\" title=\"4.1.1 通用操作\"></a>4.1.1 通用操作</h3><ul><li>索引, 用下标访问, num[0], 支持反向索引, 从-1开始</li><li>分片, 注意不改变原序列, 而是产生一个新序列, 下面是常用分片用法</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>]</span><br><span class=\"line\"><span class=\"comment\"># 常见用法</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[<span class=\"number\">3</span>:<span class=\"number\">6</span>]</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以从末尾计数, 负数索引, 效果相同</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[<span class=\"number\">7</span>:<span class=\"number\">10</span>]</span><br><span class=\"line\">[<span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[<span class=\"number\">-3</span>:]</span><br><span class=\"line\">[<span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 省略部分下标</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[:<span class=\"number\">3</span>]</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[:]</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置步长</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[:len(num):<span class=\"number\">2</span>]</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开始索引可以超过列表长度, 视作从最后一个开始</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[<span class=\"number\">11</span>:<span class=\"number\">0</span>:<span class=\"number\">-1</span>]</span><br><span class=\"line\">[<span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[<span class=\"number\">8</span>:<span class=\"number\">0</span>:<span class=\"number\">-1</span>]</span><br><span class=\"line\">[<span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果步长为负数, 开始索引必须大于终止索引</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>num[<span class=\"number\">0</span>:<span class=\"number\">10</span>:<span class=\"number\">-1</span>]</span><br><span class=\"line\">[]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从id可以看出分片是新序列, 和赋值不一样</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y=x[:]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(x),id(y)</span><br><span class=\"line\">(<span class=\"number\">140158585788768</span>, <span class=\"number\">140158585103696</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z=x</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(x),id(z)</span><br><span class=\"line\">(<span class=\"number\">140158585788768</span>, <span class=\"number\">140158585788768</span>)</span><br></pre></td></tr></table></figure><ul><li>同类型序列可用+直接相加</li><li>可以用*进行乘法, 生成新序列, n&lt;1会返回一个空列表</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s=[<span class=\"keyword\">None</span>]*<span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</span><br><span class=\"line\">[<span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>]</span><br></pre></td></tr></table></figure><ul><li>字符串部分介绍过, 可以直接比较, 同样适用于列表和元组, 但是列表和元组不可以比较</li><li>用in和notin判断成员资格</li><li>常用函数: len(), max(), min(), sum():要求元素必须为数值</li><li>常用函数: s.count(x), s.index(x)</li><li>enumerate(seq): 接收可迭代对象, 返回enumerate对象, 由每个元素的索引和值组成(索引, 值)</li><li>zip(seq1,seq2..seqn)</li><li>sorted(iterable, key=None, reverse=False): 返回排序后的列表, 返回的是副本,不改变源. reverse=False升序, reverse=True降序</li><li>reversed(iterable): 逆序排列, 返回新的对象</li><li>all(seq): seq元素都是True则返回True</li><li>any(seq): seq任一为True则返回True</li><li>序列拆分: 变量个数不一致时, 要用*, *只能有1个</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a,b,c=x</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a,b,c</span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a,*b=x</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a,b</span><br><span class=\"line\">(<span class=\"number\">1</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>*a,b=x</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a,b</span><br><span class=\"line\">([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure><h3 id=\"4-1-2-列表专用操作\"><a href=\"#4-1-2-列表专用操作\" class=\"headerlink\" title=\"4.1.2 列表专用操作\"></a>4.1.2 列表专用操作</h3><ul><li>列表可修改, 可元素赋值</li><li>del seq[index]/ del seq : 删除某元素或对象</li><li>分片赋值: 可以做到增加, 删除, 修改</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name=list(<span class=\"string\">'Perl'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name[<span class=\"number\">2</span>:]=list(<span class=\"string\">'ar'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name</span><br><span class=\"line\">[<span class=\"string\">'P'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'r'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改并增加, 后面那部分可以比前面的长</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name[<span class=\"number\">1</span>:]=list(<span class=\"string\">'ython'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name</span><br><span class=\"line\">[<span class=\"string\">'P'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'t'</span>, <span class=\"string\">'h'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'n'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以插入序列</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name=[<span class=\"number\">1</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name[<span class=\"number\">1</span>:<span class=\"number\">1</span>]=[<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除部分元素</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name[<span class=\"number\">1</span>:<span class=\"number\">3</span>]=[]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果步长不等于1, 那么前后数量必须相同</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name[:<span class=\"number\">4</span>:<span class=\"number\">2</span>]=[<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">\"&lt;stdin&gt;\"</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">ValueError: attempt to assign sequence of size <span class=\"number\">2</span> to extended slice of size <span class=\"number\">1</span></span><br></pre></td></tr></table></figure><ul><li>列表解析, 表达式可以任意, for循环可嵌套, if可选</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)]</span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[ord(x) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"string\">'python'</span>]</span><br><span class=\"line\">[<span class=\"number\">112</span>, <span class=\"number\">121</span>, <span class=\"number\">116</span>, <span class=\"number\">104</span>, <span class=\"number\">111</span>, <span class=\"number\">110</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[(x,y) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>) <span class=\"keyword\">if</span> x%<span class=\"number\">2</span>==<span class=\"number\">0</span> <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>) <span class=\"keyword\">if</span> y%<span class=\"number\">2</span>==<span class=\"number\">1</span>]</span><br><span class=\"line\">[(<span class=\"number\">0</span>, <span class=\"number\">1</span>), (<span class=\"number\">0</span>, <span class=\"number\">3</span>), (<span class=\"number\">2</span>, <span class=\"number\">1</span>), (<span class=\"number\">2</span>, <span class=\"number\">3</span>), (<span class=\"number\">4</span>, <span class=\"number\">1</span>), (<span class=\"number\">4</span>, <span class=\"number\">3</span>)]</span><br></pre></td></tr></table></figure><ul><li>以下方法都是在源列表上操作, 会修改原列表<ol><li>s.append(x): 末尾添加单个元素</li><li>s.extend(seq): 在s末尾添加seq所有元素</li><li>s.sort(reverse=False, key=None) 和 sorted(seq)这个函数功能一样, 但是sorted是返回副本</li><li>s.reverse(): 同reversed(seq)</li><li>s.pop([index]): 删除并返回index位置的元素, 默认最后一个, 超范围报错</li><li>s.insert(index,x): index处插入x, index大于列表长度,则插在最后</li><li>s.remove(x): 如果有多个, 只删除第一个</li></ol></li></ul><h3 id=\"4-1-3-元组和列表\"><a href=\"#4-1-3-元组和列表\" class=\"headerlink\" title=\"4.1.3 元组和列表\"></a>4.1.3 元组和列表</h3><p>都是有序序列, 常可替换</p><p><strong>区别:</strong></p><ol><li>元组不可变</li><li>元组小括号,列表中括号</li><li>元组可以在字典中作为key</li></ol><p>元组不可变, 但是可以用元组创建新元组<br>如果元组内元素为可变的, 如列表或字符串, 则可以修改<br>使用 list()和tuple()函数相互转换</p><h2 id=\"4-2-字典和集合\"><a href=\"#4-2-字典和集合\" class=\"headerlink\" title=\"4.2 字典和集合\"></a>4.2 字典和集合</h2><p>字典主要是元素的检索, 插入和删除.<br>集合主要考虑集合间的并, 交和差操作.</p><h3 id=\"4-2-1-字典\"><a href=\"#4-2-1-字典\" class=\"headerlink\" title=\"4.2.1 字典\"></a>4.2.1 字典</h3><p>注意点:</p><ul><li>关键是是不可变的, 如果元组里有可变类型比如列表, 就不可以作为key. python对key进行哈希, 根据计算结果决定存储地址, 所以可以用hash()函数判断是否可以作为key</li><li>字典是可变类型, 可以在原处增长或者缩短, 无需生成副本.</li><li>字典是异构的, 可以抱含任何类型数据: 元素可以是字典,列表,元组, 支持任意层次嵌套.</li><li>{}和dict()是空字典</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d1=dict()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d1</span><br><span class=\"line\">&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># dict参数可以是列表和元组</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d2=dict(([<span class=\"string\">'x'</span>,<span class=\"number\">1</span>],[<span class=\"string\">'y'</span>,<span class=\"number\">2</span>]))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d2</span><br><span class=\"line\">&#123;<span class=\"string\">'x'</span>: <span class=\"number\">1</span>, <span class=\"string\">'y'</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d2=dict([[<span class=\"string\">'x'</span>,<span class=\"number\">1</span>],[<span class=\"string\">'y'</span>,<span class=\"number\">2</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d2</span><br><span class=\"line\">&#123;<span class=\"string\">'x'</span>: <span class=\"number\">1</span>, <span class=\"string\">'y'</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以直接指定key和val</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d3=dict(name=<span class=\"string\">'allen'</span>,age=<span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d3</span><br><span class=\"line\">&#123;<span class=\"string\">'name'</span>: <span class=\"string\">'allen'</span>, <span class=\"string\">'age'</span>: <span class=\"number\">15</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>更新和添加: 字典的更新直接用dict[key]=new_val就可以, 如果没有就直接增加一个新元素</li><li>删除: del 字典名[key] 或者 del 字典名</li><li>判断key是否存在: key in / not in dict</li><li>len(dict)</li><li>只支持==和！=</li><li>list(dict)返回key</li></ul><p>常用方法：</p><ul><li>fromkeys(序列[,值])</li><li>keys(), values(), items()</li><li>d.copy(), d.clear(), d.pop(key), d.popitem()</li><li>d.get(key[,value]): 返回key对应的val值, 若没有, 则返回value</li><li>d.setdefault(key,[value]): 存在则返回值, 不存在则插入key:value, value默认none</li><li>d2.update(d1): d1合并到d2, d1不变</li><li>has_key(key): 存在key返回true, 用in和not in就可以</li></ul><h3 id=\"4-2-2-集合\"><a href=\"#4-2-2-集合\" class=\"headerlink\" title=\"4.2.2 集合\"></a>4.2.2 集合</h3><h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><ol><li>空集合是set()</li><li>用大括号</li><li>字符串,列表, 元组都可以转set</li><li>set()创建可变集合, frozenset()创建不可变集合</li><li>可变集合的元素只能是数值, 字符串, 元组这些不可修改的, 可修改的列表,字典和可变集合都不可作为元素</li></ol><h4 id=\"集合的运算\"><a href=\"#集合的运算\" class=\"headerlink\" title=\"集合的运算\"></a>集合的运算</h4><ul><li>并： |, |=, s1.union(s2…sn)</li><li>交： &amp; , s1.intersection(s2…sn)</li><li>差： -, s1.difference(s2…sn)</li><li>对称差： ^, s1.symmetric_difference(s2…sn)</li><li>==</li><li>！=</li><li>s1\\&lt;s2: s1是s2真子集,</li><li>s1\\&lt;=s2: s1是s2子集, s1.issubset(s2)</li><li>s1>s2: 超集</li><li>s1>=s2: 相当于s1.issuperset(s2)</li><li>s.copy()</li></ul><h4 id=\"适用于可变集合的方法\"><a href=\"#适用于可变集合的方法\" class=\"headerlink\" title=\"适用于可变集合的方法\"></a>适用于可变集合的方法</h4><ul><li>s.add(x)</li><li>s.remove(x): 不存在会报错; s.discard(x): 不存在不报错</li><li>s.pop(): 删除任意一个元素并返回</li><li>s.clear()</li></ul><ul><li>s.update(s1,s2…): s=s|s1|s2…sn</li><li>s.intersection_update(s1,s2..sn): s=s&amp;s1&amp;s2..&amp;sn</li><li>s.difference_update(s1,s2..s2): s=s-s1-s2..-sn</li><li>s.symmetric_difference_update(s1): s=s^s1</li></ul><blockquote class=\"blockquote-center\"><p><strong>end CH4</strong></p></blockquote><h1 id=\"CH5-函数\"><a href=\"#CH5-函数\" class=\"headerlink\" title=\"CH5. 函数\"></a>CH5. 函数</h1><p>和其他的语言一样, 函数先定义再使用</p><h2 id=\"5-1-参数\"><a href=\"#5-1-参数\" class=\"headerlink\" title=\"5.1 参数\"></a>5.1 参数</h2><p>参数传递的方式是”值传递”</p><p><strong>要注意的是:</strong></p><ul><li>形参重新赋值重新分配对象, 指向别的对象, 不会改变实参</li><li>如果仅修改形参内容, 比如列表, 字典这样的可修改对象, 则会影响实参</li></ul><h3 id=\"参数类型\"><a href=\"#参数类型\" class=\"headerlink\" title=\"参数类型\"></a>参数类型</h3><ul><li>位置参数: 参数按照位置对应</li><li>关键字参数: 形参名=值</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mykey</span><span class=\"params\">(x,y)</span>:</span></span><br><span class=\"line\">  print(x, y)</span><br><span class=\"line\">mykey(y=<span class=\"number\">10</span>, x=<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure><ul><li>默认参数: 形参=默认值, 必须在参数列表右边, 在可变长度参数之前</li><li>可变长度参数: 参数数量不固定时, 针对元组和字典两种. 其他所有类型参数都必须在可变长度参数之前</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 元组一个*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myvarl</span><span class=\"params\">(*t)</span>:</span></span><br><span class=\"line\">  print(t)</span><br><span class=\"line\">myvarl(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 字典两个*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myvarl</span><span class=\"params\">(**t)</span>:</span></span><br><span class=\"line\">  print(t)</span><br><span class=\"line\">myvarl(<span class=\"string\">'y'</span>=<span class=\"number\">1</span>,<span class=\"string\">'x'</span>=<span class=\"number\">2</span>,<span class=\"string\">'z'</span>=<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure><h2 id=\"5-2-匿名函数\"><a href=\"#5-2-匿名函数\" class=\"headerlink\" title=\"5.2 匿名函数\"></a>5.2 匿名函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 参数也可以使用默认值, 返回值是表达式结果</span></span><br><span class=\"line\"><span class=\"keyword\">lambda</span> [参数<span class=\"number\">1</span>[,参数<span class=\"number\">2</span>,...,参数n]]: 表达式</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例如</span></span><br><span class=\"line\"><span class=\"keyword\">lambda</span> x,y: x+y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f=<span class=\"keyword\">lambda</span> x,y: x+y</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f(<span class=\"number\">5</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把匿名函数作为普通函数返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> x,y:x+y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 匿名函数作为序列或者字典元素</span></span><br><span class=\"line\">列表名=[匿名<span class=\"number\">1</span>, 匿名<span class=\"number\">2</span>,...匿名n]</span><br><span class=\"line\"><span class=\"comment\"># 调用</span></span><br><span class=\"line\">列表名[index](参数)</span><br></pre></td></tr></table></figure><h2 id=\"5-3-装饰器\"><a href=\"#5-3-装饰器\" class=\"headerlink\" title=\"5.3 装饰器\"></a>5.3 装饰器</h2><p>这里只记录一些注意点, 比较全面的看书上或者<a href=\"https://www.runoob.com/w3cnote/python-func-decorators.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Python 函数装饰器|菜鸟教程</a>, 这个讲的很全</p><ul><li>概念: 装饰器是用来包装函数的函数, 用来为已经存在的函数添加额外功能</li><li>返回对象: 装饰器输入是被装饰的函数对象, 返回新的函数对象.</li><li>调用: 使用@调用装饰器</li><li>调用的时候,本质上, 是将对象名重新指向一个新返回的函数, 达到修改函数的目的</li><li>返回: 装饰器最里面那层, 要返回被装饰的函数</li><li>在装饰器中,返回值, 例如 return func, func后面没有(), 加上()表示调用.</li><li>外层里层函数关系: 最外面的那层函数返回值, 是里面一层函数的函数名</li><li>多重装饰器: 执行顺序是从下往上, 最后执行被装饰函数内容</li></ul><h2 id=\"5-4-name\"><a href=\"#5-4-name\" class=\"headerlink\" title=\"5.4 __name__\"></a>5.4 __name__</h2><p>主动调用__name__值为__main__, 被导包时值为模块名<br>把一个程序文件既当作模块, 有可以主动调用时, 程序入口前加if:</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">  <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">  test()</span><br></pre></td></tr></table></figure><blockquote class=\"blockquote-center\"><p><strong>end CH5</strong></p></blockquote><h1 id=\"CH6-类\"><a href=\"#CH6-类\" class=\"headerlink\" title=\"CH6. 类\"></a>CH6. 类</h1><h2 id=\"6-1-属性\"><a href=\"#6-1-属性\" class=\"headerlink\" title=\"6.1 属性\"></a>6.1 属性</h2><div class=\"table-container\"><table><thead><tr><th style=\"text-align:left\"></th><th style=\"text-align:left\">格式</th><th style=\"text-align:left\">访问控制</th><th style=\"text-align:left\">添加</th><th style=\"text-align:left\">修改</th><th style=\"text-align:left\">作用域</th></tr></thead><tbody><tr><td style=\"text-align:left\">私有属性</td><td style=\"text-align:left\">类里函数外, 以__开头的属性</td><td style=\"text-align:left\">只能通过类方法中使用self.__name使用,类外无法直接访问</td><td style=\"text-align:left\">只能在类里面添加</td><td style=\"text-align:left\">在类方法里用self修改, 不影响其他对象</td><td style=\"text-align:left\">单个</td></tr><tr><td style=\"text-align:left\">类属性</td><td style=\"text-align:left\">直接在类里函数外定义的非私有属性,所有对象公有</td><td style=\"text-align:left\">类外通过类名和实例对象(不推荐)调用</td><td style=\"text-align:left\">类外可以通过类名.类属性添加</td><td style=\"text-align:left\">类外:类名修改,类里:类方法</td><td style=\"text-align:left\">所有</td></tr><tr><td style=\"text-align:left\">实例属性</td><td style=\"text-align:left\">在__init__里面定义或者通过实例对象引用定义</td><td style=\"text-align:left\">类外只有实例对象可以访问,类里面可以在类方法中调用</td><td style=\"text-align:left\">类里面在init方法中添加,类外使用实例对象.实例属性添加</td><td style=\"text-align:left\">用self修改或实例对象.实例属性修改</td><td style=\"text-align:left\">单个</td></tr></tbody></table></div><p>注意点:</p><ul><li>千万不要尝试实例对象创建类属性, 会自动创建一个同名实例属性,并屏蔽掉类属性</li><li>不可以用实例对象直接修改类属性, 要用类方法修改</li><li>使用del 删除实例属性和实例对象</li></ul><h2 id=\"6-2-方法\"><a href=\"#6-2-方法\" class=\"headerlink\" title=\"6.2 方法\"></a>6.2 方法</h2><div class=\"table-container\"><table><thead><tr><th style=\"text-align:left\"></th><th style=\"text-align:left\">特征</th><th style=\"text-align:left\">调用</th><th style=\"text-align:left\">和属性关系</th></tr></thead><tbody><tr><td style=\"text-align:left\">构造方法</td><td style=\"text-align:left\">__init__(self)</td><td style=\"text-align:left\">生成对象自动调用</td><td style=\"text-align:left\">里面用self定义的都是实例属性</td></tr><tr><td style=\"text-align:left\">析构方法</td><td style=\"text-align:left\">__del__(self)</td><td style=\"text-align:left\">释放对象自动调用</td><td style=\"text-align:left\">可以在里面进行释放资源的操作</td></tr><tr><td style=\"text-align:left\">类方法</td><td style=\"text-align:left\">@classmethod修饰器,第一个参数为cls</td><td style=\"text-align:left\">实例对象和类对象访问</td><td style=\"text-align:left\">引用的是类属性</td></tr><tr><td style=\"text-align:left\">实例方法</td><td style=\"text-align:left\">第一个参数为self</td><td style=\"text-align:left\">只能实例对象调用</td><td style=\"text-align:left\">实例属性优先级高于类属性,实例方法中实例属性会屏蔽类属性</td></tr><tr><td style=\"text-align:left\">静态方法</td><td style=\"text-align:left\">@staticmethod修饰器,无需多定义参数</td><td style=\"text-align:left\">类名和实例对象都可以访问</td><td style=\"text-align:left\">不绑定类或者实例, 引用类属性需要使用类名引用</td></tr></tbody></table></div><p>注意点:</p><ul><li>静态方法和实例方法不同的是, 静态方法不会自动绑定到类上, 类方法会自动绑定. 静态方法不需要引用类或者实例</li><li>静态方法很像我们在类外定义的函数，只不过静态方法可以通过类或者实例来调用而已。</li><li>实例方法中引用属性, 若存在同名类属性和实例属性, 则引用实例属性, 若无实例属性, 则引用类属性</li><li>实例方法中修改属性, 若存在同名类属性和实例属性, 则修改实例属性, 若无实例属性, 则创建新实例属性</li></ul><h2 id=\"6-3-继承\"><a href=\"#6-3-继承\" class=\"headerlink\" title=\"6.3 继承\"></a>6.3 继承</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 可以多重继承</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 子类名<span class=\"params\">(父类名<span class=\"number\">1</span>,父类名<span class=\"number\">2</span>,..)</span>:</span></span><br><span class=\"line\">  类体</span><br></pre></td></tr></table></figure><p>注:</p><ul><li>如果子类中没有重新定义构造方法, 会执行第一个父类的构造方法</li><li>使用内置方法issubclass(Child, Parent)判断一个类是否是另一个类的子孙类, 返回True或者False</li><li>小心使用多重继承, 能不用就不用, 可以用组合</li><li>多重继承函数的搜索顺序是广度优先, 从左到右找, 没有就下一个</li><li>super(Child,self).__init__()相当于Parent.__init__(self)</li><li>子类继承父类所有属性和方法, 如果没有覆盖掉, 则调用父类方法</li><li>可以使用父类名Parent.fun(self)或者super(Child,self).fun()来调用父类方法, 但是一定要传self</li></ul><p>对于init函数:</p><ul><li>如果子类没有定义自己的初始化函数，父类的初始化函数会被默认调用；但是如果要实例化子类的对象，则只能传入父类的初始化函数对应的参数，否则会出错。</li><li>如果子类定义了自己的初始化函数，而在子类中没有显示调用父类的初始化函数，则父类的属性不会被初始化</li><li>如果子类定义了自己的初始化函数，在子类中显示调用父类，子类和父类的属性都会被初始化</li></ul><p>详细的看下面这几个链接:<br><a href=\"http://blog.csdn.net/brucewong0516/article/details/79114977\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">python中的类，对象，方法，属性初认识（一）</a><br><a href=\"http://blog.csdn.net/brucewong0516/article/details/79118703\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">详解类class的属性：类数据属性、实例数据属性、特殊的类属性、属性隐藏（二）</a><br><a href=\"http://blog.csdn.net/brucewong0516/article/details/79119551\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">详解类class的方法：实例方法、类方法、静态方法（三）</a><br><a href=\"http://blog.csdn.net/brucewong0516/article/details/79120841\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">详解类class的访问控制：单下划线与双下划线（四）</a><br><a href=\"https://blog.csdn.net/brucewong0516/article/details/79121179\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">详解类class的继承、<strong>init</strong>初始化、super方法</a></p><h1 id=\"CH7-文件操作\"><a href=\"#CH7-文件操作\" class=\"headerlink\" title=\"CH7. 文件操作\"></a>CH7. 文件操作</h1><p>具体的可看<a href=\"https://www.runoob.com/python/python-files-io.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Python 文件I/O | 菜鸟教程</a>和<a href=\"https://blog.csdn.net/m0_38059843/article/details/78240835\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">python 文件操作，最全的一个 | CSDN</a></p><h1 id=\"CH8-注意点\"><a href=\"#CH8-注意点\" class=\"headerlink\" title=\"CH8. 注意点\"></a>CH8. 注意点</h1><ol><li>整除是//不是/, 看1.4.1</li><li>判断在不在用in</li><li>正则的使用</li><li>$是匹配结尾,如果是一行里面的不要用$符号,匹配所有单词只需要<code>[a-zA-Z]+</code>就可以</li><li>read()没有参数就是读全部</li><li>write()写字符串的时候可以用字符串.format()方法格式化输出到文件</li><li>open()之后要记得close()</li><li>dict.items()之后要使用list()转换一下才可以用</li><li>没有返回值的函数说明是要在序列内部修改, 注意不要修改引用, 只改内容</li><li>文件操作要记得使用try-except</li><li><strong>大量的数据</strong>统计要最好用字典,字典使用哈希会很快</li></ol><!-- rebuild by neat -->"},{"title":"SpaceVim中自定义Markdown相关快捷键","comments":1,"mathjax":false,"date":"2019-03-18T15:14:48.000Z","urlname":"spacevim-custom-keybind","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n  SpaceVim对Markdown的注释居然是html版本的，预览的时候还是可以显示，百度了才知道用[[//]]:#()的方法，就想着弄了快捷键，又是挖坑踩坑...\n  <!--more-->\n# Markdown注释方法\n\n## html标签 \n注意：需要在前面空一行\n```\n<div style='display: none'>\n哈哈我是注释，不会在浏览器中显示。\n我也是注释。\n</div>\n```\n\n## html注释\n```\n<!--哈哈我是注释，不会在浏览器中显示。-->\n\n<!--\n哈哈我是多段\n注释，\n不会在浏览器中显示。\n-->\n```\n\n## 利用Markdown原理\n利用markdown的解析原理来实现注释的。一般有的markdown解析器不支持上面的注释方法，这个时候就可以用此方法。\n\n```\n[comment]: <> (哈哈我是注释，不会在浏览器中显示。)\n[comment]: <> (哈哈我是注释，不会在浏览器中显示。)\n[comment]: <> (哈哈我是注释，不会在浏览器中显示。)\n[//]: <> (哈哈我是注释，不会在浏览器中显示。)\n[//]: # (哈哈我是注释，不会在浏览器中显示。)\n```\n\n其中，这种方法最稳定，适用性最强：\n```\n[//]: # (哈哈我是注释，不会在浏览器中显示。)\n```\n\n还看到这种最可爱，超级无敌萌的：\n```\n[^_^]: # (哈哈我是注释，不会在浏览器中显示。)\n```\n\n# SpaceVim中自定义快捷键\n**下面是[SpaceVim官网](https://spacevim.org/cn)的说明**\n> 启动函数   \n> 由于 toml 配置的局限性，SpaceVim 提供了两种启动函数 bootstrap_before 和 bootstrap_after，在该函数内可以使用 Vim script。 \n> 可通过 ~/.SpaceVim.d/init.toml 的 [options] 片段中的这两个选项 bootstrap_before 和 bootstrap_after 来指定函数名称，例如：\n> \n> [options]  \n> 　　bootstrap_before = \"myspacevim#before\"  \n>  　　bootstrap_after  = \"myspacevim#after\"  \n> 启动函数文件应放置在 Vim &runtimepath 的 autoload 文件夹内。例如：\n> \n> 文件名：~/.SpaceVim.d/autoload/myspacevim.vim\n> \n> function! myspacevim#before() abort  \n> 　　let g:neomake_enabled_c_makers = ['clang']  \n> 　　nnoremap jk <esc>  \n> endfunction\n> \n> function! myspacevim#after() abort  \n> 　　iunmap jk  \n> endfunction\n> 函数 bootstrap_before 将在读取用户配置后执行，而函数 bootstrap_after 将在 VimEnter autocmd 之后执行。\n> \n> 如果你需要添加自定义以 SPC 为前缀的快捷键，你需要使用 bootstrap function，在其中加入：\n> \n> function! myspacevim#before() abort  \n> 　　call SpaceVim#custom#SPCGroupName(['G'], '+TestGroup')  \n> 　　call SpaceVim#custom#SPC('nore', ['G', 't'], 'echom 1', 'echomessage 1', 1)  \n> endfunction\n\n# vim中定义快捷键相关说明\n\n## autocmd\n- autocmd是一个十分强大的命令，在.vimrc中配置以后在用vim创建文件的时候就会自动执行一些命令\n\n## 键盘映射\n具体参照[Vim中的键映射](https://www.cnblogs.com/softwaretesting/archive/2011/09/28/2194515.html)\n\n\n使用map命令，可以将键盘上的某个按键与Vim的命令绑定起来。例如使用以下命令，可以通过F5键将单词用花括号括起来：   \n\n　　:map <F5> i{e<Esc>a}<Esc>  \n\n其中：i{将插入字符{，然后使用Esc退回到命令状态；接着用e移到单词结尾，a}增加字符}，最后退至命令状态。\n\n在执行以上命令之后，光标定位在一个单词上（例如amount），按下F5键，这时字符就会变成{amount}的形式。   \n\n## 不同模式下的键盘映射\n使用下表中不同形式的map命令，可以针对特定的模式设置键盘映射：\n\n\n| Command  | Normal   | Visual    |Operator Pending |   插入模式  |命令行模式     |\n| \t:---:  |\t:---:   |\t:---:     |\t:---:           |\t:---:       |\t:---:         |\n|   命令 \t | 常规模式 |可视化模式 |运算符模式       |\tInsert Only | Command Line  |\n| :map\t   |     y\t  |      y    |       \ty       |             |               |    \n| :nmap\t   | y        |           |                 |             |               | \n| :vmap\t \t |          |       y   |                 |             |               |           \n| :omap\t \t |          |           |        y        |             |               |  \n| :map!\t \t |          |           |                 |       \ty\t  |     y         |         \n| :imap\t \t |          |           |                 |    \ty       |               |       \n| :cmap\t \t |          |           |                 |             |     \ty       |   \n\n# SpaceVim中进行自定义SPC开头的键映射\n下面是将SPC-v-c定义为Markdown文本中行注释，SPC-v-u对Markdown进行行取消注释，SPC-v-p进行Markdown文件样式预览.\n\n**~/.SpaceVim.d/autoload/myspacevim.vim**\n\n```\nfunction! myspacevim#before() abort\n　　set wrap\n\n    \"v开头为自定义快捷键\n　　call SpaceVim#custom#SPCGroupName(['v'], '+Personal Key Bindings')\n\n    \"使用v-p进行markdown网页预览\n　　autocmd BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn} call SpaceVim#custom#SPC('nore', ['v', 'p'], ':!google-chrome-stable \"%:p\"', 'Markdown-Previews',1)\n\n    \"对markdown进行行注释，在行首插入[//]:#(,在行尾插入右括号),命令是'I[//]:#(<Esc>A)<Esc>',注意这里的<Esc>要用Ctrl-Esc来完成 \n　　call SpaceVim#custom#SPC('nore', ['v', 'c'], 'I[//]:#(<Esc>A)<Esc>', 'Markdown-comment one line', 0)\n\n    \"对markdown取消行注释,在行首删除[//]:#(,在行尾删除右括号)\n　　call SpaceVim#custom#SPC('nore', ['v', 'u'], '07x$x', 'Markdown-uncomment one line', 0)\nendfunction\n\n```\n\n---------------\n---------------\n\n其实...我就想弄两个快捷键...\n","source":"_posts/SpaceVim中自定义Markdown相关快捷键.md","raw":"---\ntitle: SpaceVim中自定义Markdown相关快捷键\ncomments: true\nmathjax: false\ndate: 2019-03-18 23:14:48\ntags: [SpaceVim,Markdown, Notes]\ncategories: Notes\nurlname: spacevim-custom-keybind\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n  SpaceVim对Markdown的注释居然是html版本的，预览的时候还是可以显示，百度了才知道用[[//]]:#()的方法，就想着弄了快捷键，又是挖坑踩坑...\n  <!--more-->\n# Markdown注释方法\n\n## html标签 \n注意：需要在前面空一行\n```\n<div style='display: none'>\n哈哈我是注释，不会在浏览器中显示。\n我也是注释。\n</div>\n```\n\n## html注释\n```\n<!--哈哈我是注释，不会在浏览器中显示。-->\n\n<!--\n哈哈我是多段\n注释，\n不会在浏览器中显示。\n-->\n```\n\n## 利用Markdown原理\n利用markdown的解析原理来实现注释的。一般有的markdown解析器不支持上面的注释方法，这个时候就可以用此方法。\n\n```\n[comment]: <> (哈哈我是注释，不会在浏览器中显示。)\n[comment]: <> (哈哈我是注释，不会在浏览器中显示。)\n[comment]: <> (哈哈我是注释，不会在浏览器中显示。)\n[//]: <> (哈哈我是注释，不会在浏览器中显示。)\n[//]: # (哈哈我是注释，不会在浏览器中显示。)\n```\n\n其中，这种方法最稳定，适用性最强：\n```\n[//]: # (哈哈我是注释，不会在浏览器中显示。)\n```\n\n还看到这种最可爱，超级无敌萌的：\n```\n[^_^]: # (哈哈我是注释，不会在浏览器中显示。)\n```\n\n# SpaceVim中自定义快捷键\n**下面是[SpaceVim官网](https://spacevim.org/cn)的说明**\n> 启动函数   \n> 由于 toml 配置的局限性，SpaceVim 提供了两种启动函数 bootstrap_before 和 bootstrap_after，在该函数内可以使用 Vim script。 \n> 可通过 ~/.SpaceVim.d/init.toml 的 [options] 片段中的这两个选项 bootstrap_before 和 bootstrap_after 来指定函数名称，例如：\n> \n> [options]  \n> 　　bootstrap_before = \"myspacevim#before\"  \n>  　　bootstrap_after  = \"myspacevim#after\"  \n> 启动函数文件应放置在 Vim &runtimepath 的 autoload 文件夹内。例如：\n> \n> 文件名：~/.SpaceVim.d/autoload/myspacevim.vim\n> \n> function! myspacevim#before() abort  \n> 　　let g:neomake_enabled_c_makers = ['clang']  \n> 　　nnoremap jk <esc>  \n> endfunction\n> \n> function! myspacevim#after() abort  \n> 　　iunmap jk  \n> endfunction\n> 函数 bootstrap_before 将在读取用户配置后执行，而函数 bootstrap_after 将在 VimEnter autocmd 之后执行。\n> \n> 如果你需要添加自定义以 SPC 为前缀的快捷键，你需要使用 bootstrap function，在其中加入：\n> \n> function! myspacevim#before() abort  \n> 　　call SpaceVim#custom#SPCGroupName(['G'], '+TestGroup')  \n> 　　call SpaceVim#custom#SPC('nore', ['G', 't'], 'echom 1', 'echomessage 1', 1)  \n> endfunction\n\n# vim中定义快捷键相关说明\n\n## autocmd\n- autocmd是一个十分强大的命令，在.vimrc中配置以后在用vim创建文件的时候就会自动执行一些命令\n\n## 键盘映射\n具体参照[Vim中的键映射](https://www.cnblogs.com/softwaretesting/archive/2011/09/28/2194515.html)\n\n\n使用map命令，可以将键盘上的某个按键与Vim的命令绑定起来。例如使用以下命令，可以通过F5键将单词用花括号括起来：   \n\n　　:map <F5> i{e<Esc>a}<Esc>  \n\n其中：i{将插入字符{，然后使用Esc退回到命令状态；接着用e移到单词结尾，a}增加字符}，最后退至命令状态。\n\n在执行以上命令之后，光标定位在一个单词上（例如amount），按下F5键，这时字符就会变成{amount}的形式。   \n\n## 不同模式下的键盘映射\n使用下表中不同形式的map命令，可以针对特定的模式设置键盘映射：\n\n\n| Command  | Normal   | Visual    |Operator Pending |   插入模式  |命令行模式     |\n| \t:---:  |\t:---:   |\t:---:     |\t:---:           |\t:---:       |\t:---:         |\n|   命令 \t | 常规模式 |可视化模式 |运算符模式       |\tInsert Only | Command Line  |\n| :map\t   |     y\t  |      y    |       \ty       |             |               |    \n| :nmap\t   | y        |           |                 |             |               | \n| :vmap\t \t |          |       y   |                 |             |               |           \n| :omap\t \t |          |           |        y        |             |               |  \n| :map!\t \t |          |           |                 |       \ty\t  |     y         |         \n| :imap\t \t |          |           |                 |    \ty       |               |       \n| :cmap\t \t |          |           |                 |             |     \ty       |   \n\n# SpaceVim中进行自定义SPC开头的键映射\n下面是将SPC-v-c定义为Markdown文本中行注释，SPC-v-u对Markdown进行行取消注释，SPC-v-p进行Markdown文件样式预览.\n\n**~/.SpaceVim.d/autoload/myspacevim.vim**\n\n```\nfunction! myspacevim#before() abort\n　　set wrap\n\n    \"v开头为自定义快捷键\n　　call SpaceVim#custom#SPCGroupName(['v'], '+Personal Key Bindings')\n\n    \"使用v-p进行markdown网页预览\n　　autocmd BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn} call SpaceVim#custom#SPC('nore', ['v', 'p'], ':!google-chrome-stable \"%:p\"', 'Markdown-Previews',1)\n\n    \"对markdown进行行注释，在行首插入[//]:#(,在行尾插入右括号),命令是'I[//]:#(<Esc>A)<Esc>',注意这里的<Esc>要用Ctrl-Esc来完成 \n　　call SpaceVim#custom#SPC('nore', ['v', 'c'], 'I[//]:#(<Esc>A)<Esc>', 'Markdown-comment one line', 0)\n\n    \"对markdown取消行注释,在行首删除[//]:#(,在行尾删除右括号)\n　　call SpaceVim#custom#SPC('nore', ['v', 'u'], '07x$x', 'Markdown-uncomment one line', 0)\nendfunction\n\n```\n\n---------------\n---------------\n\n其实...我就想弄两个快捷键...\n","slug":"SpaceVim中自定义Markdown相关快捷键","published":1,"updated":"2019-07-25T18:33:56.003Z","layout":"post","photos":[],"link":"","_id":"ck2424lly0031lksbxk4sbnof","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><p>SpaceVim对Markdown的注释居然是html版本的，预览的时候还是可以显示，百度了才知道用[[//]]:#()的方法，就想着弄了快捷键，又是挖坑踩坑…<br><a id=\"more\"></a></p><h1 id=\"Markdown注释方法\"><a href=\"#Markdown注释方法\" class=\"headerlink\" title=\"Markdown注释方法\"></a>Markdown注释方法</h1><h2 id=\"html标签\"><a href=\"#html标签\" class=\"headerlink\" title=\"html标签\"></a>html标签</h2><p>注意：需要在前面空一行<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&apos;display: none&apos;&gt;</span><br><span class=\"line\">哈哈我是注释，不会在浏览器中显示。</span><br><span class=\"line\">我也是注释。</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"html注释\"><a href=\"#html注释\" class=\"headerlink\" title=\"html注释\"></a>html注释</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--哈哈我是注释，不会在浏览器中显示。--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--</span><br><span class=\"line\">哈哈我是多段</span><br><span class=\"line\">注释，</span><br><span class=\"line\">不会在浏览器中显示。</span><br><span class=\"line\">--&gt;</span><br></pre></td></tr></table></figure><h2 id=\"利用Markdown原理\"><a href=\"#利用Markdown原理\" class=\"headerlink\" title=\"利用Markdown原理\"></a>利用Markdown原理</h2><p>利用markdown的解析原理来实现注释的。一般有的markdown解析器不支持上面的注释方法，这个时候就可以用此方法。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class=\"line\">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class=\"line\">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class=\"line\">[//]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class=\"line\">[//]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure><p>其中，这种方法最稳定，适用性最强：<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[//]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure><p></p><p>还看到这种最可爱，超级无敌萌的：<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[^_^]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure><p></p><h1 id=\"SpaceVim中自定义快捷键\"><a href=\"#SpaceVim中自定义快捷键\" class=\"headerlink\" title=\"SpaceVim中自定义快捷键\"></a>SpaceVim中自定义快捷键</h1><p><strong>下面是<a href=\"https://spacevim.org/cn\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">SpaceVim官网</a>的说明</strong></p><blockquote><p>启动函数<br>由于 toml 配置的局限性，SpaceVim 提供了两种启动函数 bootstrap_before 和 bootstrap_after，在该函数内可以使用 Vim script。<br>可通过 ~/.SpaceVim.d/init.toml 的 [options] 片段中的这两个选项 bootstrap_before 和 bootstrap_after 来指定函数名称，例如：</p><p>[options]<br>bootstrap_before = “myspacevim#before”<br>bootstrap_after = “myspacevim#after”<br>启动函数文件应放置在 Vim &amp;runtimepath 的 autoload 文件夹内。例如：</p><p>文件名：~/.SpaceVim.d/autoload/myspacevim.vim</p><p>function! myspacevim#before() abort<br>let g:neomake_enabled_c_makers = [‘clang’]<br>nnoremap jk<esc><br>endfunction</esc></p><p>function! myspacevim#after() abort<br>iunmap jk<br>endfunction<br>函数 bootstrap_before 将在读取用户配置后执行，而函数 bootstrap_after 将在 VimEnter autocmd 之后执行。</p><p>如果你需要添加自定义以 SPC 为前缀的快捷键，你需要使用 bootstrap function，在其中加入：</p><p>function! myspacevim#before() abort<br>call SpaceVim#custom#SPCGroupName([‘G’], ‘+TestGroup’)<br>call SpaceVim#custom#SPC(‘nore’, [‘G’, ‘t’], ‘echom 1’, ‘echomessage 1’, 1)<br>endfunction</p></blockquote><h1 id=\"vim中定义快捷键相关说明\"><a href=\"#vim中定义快捷键相关说明\" class=\"headerlink\" title=\"vim中定义快捷键相关说明\"></a>vim中定义快捷键相关说明</h1><h2 id=\"autocmd\"><a href=\"#autocmd\" class=\"headerlink\" title=\"autocmd\"></a>autocmd</h2><ul><li>autocmd是一个十分强大的命令，在.vimrc中配置以后在用vim创建文件的时候就会自动执行一些命令</li></ul><h2 id=\"键盘映射\"><a href=\"#键盘映射\" class=\"headerlink\" title=\"键盘映射\"></a>键盘映射</h2><p>具体参照<a href=\"https://www.cnblogs.com/softwaretesting/archive/2011/09/28/2194515.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Vim中的键映射</a></p><p>使用map命令，可以将键盘上的某个按键与Vim的命令绑定起来。例如使用以下命令，可以通过F5键将单词用花括号括起来：</p><p>:map<f5>i{e<esc>a}<esc></esc></esc></f5></p><p>其中：i{将插入字符{，然后使用Esc退回到命令状态；接着用e移到单词结尾，a}增加字符}，最后退至命令状态。</p><p>在执行以上命令之后，光标定位在一个单词上（例如amount），按下F5键，这时字符就会变成{amount}的形式。</p><h2 id=\"不同模式下的键盘映射\"><a href=\"#不同模式下的键盘映射\" class=\"headerlink\" title=\"不同模式下的键盘映射\"></a>不同模式下的键盘映射</h2><p>使用下表中不同形式的map命令，可以针对特定的模式设置键盘映射：</p><div class=\"table-container\"><table><thead><tr><th style=\"text-align:center\">Command</th><th style=\"text-align:center\">Normal</th><th style=\"text-align:center\">Visual</th><th style=\"text-align:center\">Operator Pending</th><th style=\"text-align:center\">插入模式</th><th style=\"text-align:center\">命令行模式</th></tr></thead><tbody><tr><td style=\"text-align:center\">命令</td><td style=\"text-align:center\">常规模式</td><td style=\"text-align:center\">可视化模式</td><td style=\"text-align:center\">运算符模式</td><td style=\"text-align:center\">Insert Only</td><td style=\"text-align:center\">Command Line</td></tr><tr><td style=\"text-align:center\">:map</td><td style=\"text-align:center\">y</td><td style=\"text-align:center\">y</td><td style=\"text-align:center\">y</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td></tr><tr><td style=\"text-align:center\">:nmap</td><td style=\"text-align:center\">y</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td></tr><tr><td style=\"text-align:center\">:vmap</td><td style=\"text-align:center\"></td><td style=\"text-align:center\">y</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td></tr><tr><td style=\"text-align:center\">:omap</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\">y</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td></tr><tr><td style=\"text-align:center\">:map!</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\">y</td><td style=\"text-align:center\">y</td></tr><tr><td style=\"text-align:center\">:imap</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\">y</td><td style=\"text-align:center\"></td></tr><tr><td style=\"text-align:center\">:cmap</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\">y</td></tr></tbody></table></div><h1 id=\"SpaceVim中进行自定义SPC开头的键映射\"><a href=\"#SpaceVim中进行自定义SPC开头的键映射\" class=\"headerlink\" title=\"SpaceVim中进行自定义SPC开头的键映射\"></a>SpaceVim中进行自定义SPC开头的键映射</h1><p>下面是将SPC-v-c定义为Markdown文本中行注释，SPC-v-u对Markdown进行行取消注释，SPC-v-p进行Markdown文件样式预览.</p><p><strong>~/.SpaceVim.d/autoload/myspacevim.vim</strong></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function! myspacevim#before() abort</span><br><span class=\"line\">　　set wrap</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;v开头为自定义快捷键</span><br><span class=\"line\">　　call SpaceVim#custom#SPCGroupName([&apos;v&apos;], &apos;+Personal Key Bindings&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;使用v-p进行markdown网页预览</span><br><span class=\"line\">　　autocmd BufRead,BufNewFile *.&#123;md,mdown,mkd,mkdn,markdown,mdwn&#125; call SpaceVim#custom#SPC(&apos;nore&apos;, [&apos;v&apos;, &apos;p&apos;], &apos;:!google-chrome-stable &quot;%:p&quot;&apos;, &apos;Markdown-Previews&apos;,1)</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;对markdown进行行注释，在行首插入[//]:#(,在行尾插入右括号),命令是&apos;I[//]:#(&lt;Esc&gt;A)&lt;Esc&gt;&apos;,注意这里的&lt;Esc&gt;要用Ctrl-Esc来完成 </span><br><span class=\"line\">　　call SpaceVim#custom#SPC(&apos;nore&apos;, [&apos;v&apos;, &apos;c&apos;], &apos;I[//]:#(&lt;Esc&gt;A)&lt;Esc&gt;&apos;, &apos;Markdown-comment one line&apos;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;对markdown取消行注释,在行首删除[//]:#(,在行尾删除右括号)</span><br><span class=\"line\">　　call SpaceVim#custom#SPC(&apos;nore&apos;, [&apos;v&apos;, &apos;u&apos;], &apos;07x$x&apos;, &apos;Markdown-uncomment one line&apos;, 0)</span><br><span class=\"line\">endfunction</span><br></pre></td></tr></table></figure><h2 id=\"———————\"><a href=\"#———————\" class=\"headerlink\" title=\"———————-\"></a>———————-</h2><p>其实…我就想弄两个快捷键…</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><p>SpaceVim对Markdown的注释居然是html版本的，预览的时候还是可以显示，百度了才知道用[[//]]:#()的方法，就想着弄了快捷键，又是挖坑踩坑…<br>","more":"</p><h1 id=\"Markdown注释方法\"><a href=\"#Markdown注释方法\" class=\"headerlink\" title=\"Markdown注释方法\"></a>Markdown注释方法</h1><h2 id=\"html标签\"><a href=\"#html标签\" class=\"headerlink\" title=\"html标签\"></a>html标签</h2><p>注意：需要在前面空一行<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&apos;display: none&apos;&gt;</span><br><span class=\"line\">哈哈我是注释，不会在浏览器中显示。</span><br><span class=\"line\">我也是注释。</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"html注释\"><a href=\"#html注释\" class=\"headerlink\" title=\"html注释\"></a>html注释</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--哈哈我是注释，不会在浏览器中显示。--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--</span><br><span class=\"line\">哈哈我是多段</span><br><span class=\"line\">注释，</span><br><span class=\"line\">不会在浏览器中显示。</span><br><span class=\"line\">--&gt;</span><br></pre></td></tr></table></figure><h2 id=\"利用Markdown原理\"><a href=\"#利用Markdown原理\" class=\"headerlink\" title=\"利用Markdown原理\"></a>利用Markdown原理</h2><p>利用markdown的解析原理来实现注释的。一般有的markdown解析器不支持上面的注释方法，这个时候就可以用此方法。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class=\"line\">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class=\"line\">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class=\"line\">[//]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class=\"line\">[//]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure><p>其中，这种方法最稳定，适用性最强：<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[//]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure><p></p><p>还看到这种最可爱，超级无敌萌的：<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[^_^]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure><p></p><h1 id=\"SpaceVim中自定义快捷键\"><a href=\"#SpaceVim中自定义快捷键\" class=\"headerlink\" title=\"SpaceVim中自定义快捷键\"></a>SpaceVim中自定义快捷键</h1><p><strong>下面是<a href=\"https://spacevim.org/cn\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">SpaceVim官网</a>的说明</strong></p><blockquote><p>启动函数<br>由于 toml 配置的局限性，SpaceVim 提供了两种启动函数 bootstrap_before 和 bootstrap_after，在该函数内可以使用 Vim script。<br>可通过 ~/.SpaceVim.d/init.toml 的 [options] 片段中的这两个选项 bootstrap_before 和 bootstrap_after 来指定函数名称，例如：</p><p>[options]<br>bootstrap_before = “myspacevim#before”<br>bootstrap_after = “myspacevim#after”<br>启动函数文件应放置在 Vim &amp;runtimepath 的 autoload 文件夹内。例如：</p><p>文件名：~/.SpaceVim.d/autoload/myspacevim.vim</p><p>function! myspacevim#before() abort<br>let g:neomake_enabled_c_makers = [‘clang’]<br>nnoremap jk<esc><br>endfunction</esc></p><p>function! myspacevim#after() abort<br>iunmap jk<br>endfunction<br>函数 bootstrap_before 将在读取用户配置后执行，而函数 bootstrap_after 将在 VimEnter autocmd 之后执行。</p><p>如果你需要添加自定义以 SPC 为前缀的快捷键，你需要使用 bootstrap function，在其中加入：</p><p>function! myspacevim#before() abort<br>call SpaceVim#custom#SPCGroupName([‘G’], ‘+TestGroup’)<br>call SpaceVim#custom#SPC(‘nore’, [‘G’, ‘t’], ‘echom 1’, ‘echomessage 1’, 1)<br>endfunction</p></blockquote><h1 id=\"vim中定义快捷键相关说明\"><a href=\"#vim中定义快捷键相关说明\" class=\"headerlink\" title=\"vim中定义快捷键相关说明\"></a>vim中定义快捷键相关说明</h1><h2 id=\"autocmd\"><a href=\"#autocmd\" class=\"headerlink\" title=\"autocmd\"></a>autocmd</h2><ul><li>autocmd是一个十分强大的命令，在.vimrc中配置以后在用vim创建文件的时候就会自动执行一些命令</li></ul><h2 id=\"键盘映射\"><a href=\"#键盘映射\" class=\"headerlink\" title=\"键盘映射\"></a>键盘映射</h2><p>具体参照<a href=\"https://www.cnblogs.com/softwaretesting/archive/2011/09/28/2194515.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Vim中的键映射</a></p><p>使用map命令，可以将键盘上的某个按键与Vim的命令绑定起来。例如使用以下命令，可以通过F5键将单词用花括号括起来：</p><p>:map<f5>i{e<esc>a}<esc></esc></esc></f5></p><p>其中：i{将插入字符{，然后使用Esc退回到命令状态；接着用e移到单词结尾，a}增加字符}，最后退至命令状态。</p><p>在执行以上命令之后，光标定位在一个单词上（例如amount），按下F5键，这时字符就会变成{amount}的形式。</p><h2 id=\"不同模式下的键盘映射\"><a href=\"#不同模式下的键盘映射\" class=\"headerlink\" title=\"不同模式下的键盘映射\"></a>不同模式下的键盘映射</h2><p>使用下表中不同形式的map命令，可以针对特定的模式设置键盘映射：</p><div class=\"table-container\"><table><thead><tr><th style=\"text-align:center\">Command</th><th style=\"text-align:center\">Normal</th><th style=\"text-align:center\">Visual</th><th style=\"text-align:center\">Operator Pending</th><th style=\"text-align:center\">插入模式</th><th style=\"text-align:center\">命令行模式</th></tr></thead><tbody><tr><td style=\"text-align:center\">命令</td><td style=\"text-align:center\">常规模式</td><td style=\"text-align:center\">可视化模式</td><td style=\"text-align:center\">运算符模式</td><td style=\"text-align:center\">Insert Only</td><td style=\"text-align:center\">Command Line</td></tr><tr><td style=\"text-align:center\">:map</td><td style=\"text-align:center\">y</td><td style=\"text-align:center\">y</td><td style=\"text-align:center\">y</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td></tr><tr><td style=\"text-align:center\">:nmap</td><td style=\"text-align:center\">y</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td></tr><tr><td style=\"text-align:center\">:vmap</td><td style=\"text-align:center\"></td><td style=\"text-align:center\">y</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td></tr><tr><td style=\"text-align:center\">:omap</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\">y</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td></tr><tr><td style=\"text-align:center\">:map!</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\">y</td><td style=\"text-align:center\">y</td></tr><tr><td style=\"text-align:center\">:imap</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\">y</td><td style=\"text-align:center\"></td></tr><tr><td style=\"text-align:center\">:cmap</td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\"></td><td style=\"text-align:center\">y</td></tr></tbody></table></div><h1 id=\"SpaceVim中进行自定义SPC开头的键映射\"><a href=\"#SpaceVim中进行自定义SPC开头的键映射\" class=\"headerlink\" title=\"SpaceVim中进行自定义SPC开头的键映射\"></a>SpaceVim中进行自定义SPC开头的键映射</h1><p>下面是将SPC-v-c定义为Markdown文本中行注释，SPC-v-u对Markdown进行行取消注释，SPC-v-p进行Markdown文件样式预览.</p><p><strong>~/.SpaceVim.d/autoload/myspacevim.vim</strong></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function! myspacevim#before() abort</span><br><span class=\"line\">　　set wrap</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;v开头为自定义快捷键</span><br><span class=\"line\">　　call SpaceVim#custom#SPCGroupName([&apos;v&apos;], &apos;+Personal Key Bindings&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;使用v-p进行markdown网页预览</span><br><span class=\"line\">　　autocmd BufRead,BufNewFile *.&#123;md,mdown,mkd,mkdn,markdown,mdwn&#125; call SpaceVim#custom#SPC(&apos;nore&apos;, [&apos;v&apos;, &apos;p&apos;], &apos;:!google-chrome-stable &quot;%:p&quot;&apos;, &apos;Markdown-Previews&apos;,1)</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;对markdown进行行注释，在行首插入[//]:#(,在行尾插入右括号),命令是&apos;I[//]:#(&lt;Esc&gt;A)&lt;Esc&gt;&apos;,注意这里的&lt;Esc&gt;要用Ctrl-Esc来完成 </span><br><span class=\"line\">　　call SpaceVim#custom#SPC(&apos;nore&apos;, [&apos;v&apos;, &apos;c&apos;], &apos;I[//]:#(&lt;Esc&gt;A)&lt;Esc&gt;&apos;, &apos;Markdown-comment one line&apos;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;对markdown取消行注释,在行首删除[//]:#(,在行尾删除右括号)</span><br><span class=\"line\">　　call SpaceVim#custom#SPC(&apos;nore&apos;, [&apos;v&apos;, &apos;u&apos;], &apos;07x$x&apos;, &apos;Markdown-uncomment one line&apos;, 0)</span><br><span class=\"line\">endfunction</span><br></pre></td></tr></table></figure><h2 id=\"———————\"><a href=\"#———————\" class=\"headerlink\" title=\"———————-\"></a>———————-</h2><p>其实…我就想弄两个快捷键…</p><!-- rebuild by neat -->"},{"title":"Hello World","date":"2017-08-01T06:04:32.000Z","urlname":"hello-world","_content":"\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).<!--more-->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2017-08-01 14:04:32\ncategories: Notes\nurlname: hello-world\n---\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).<!--more-->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2019-07-25T17:49:57.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2424llz0034lksb5x3gciw6","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><p>Welcome to <a href=\"https://hexo.io/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">GitHub</a>.<a id=\"more\"></a></p><h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/writing.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Writing</a></p><h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/server.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Server</a></p><h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/generating.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Generating</a></p><h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/deployment.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Deployment</a></p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><p>Welcome to <a href=\"https://hexo.io/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">GitHub</a>.","more":"</p><h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/writing.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Writing</a></p><h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/server.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Server</a></p><h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/generating.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Generating</a></p><h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/deployment.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Deployment</a></p><!-- rebuild by neat -->"},{"title":"动态规划套路详解","urlname":"dp-notes","comments":1,"mathjax":false,"date":"2019-06-18T06:38:35.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n在LeetCode的[322题题解](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)中看到一篇动态规划的详解，讲的很清楚，转载记录下\n\n转自：[LeetCode动态规划套路详解](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)\n{% endnote %}\n<!--more-->\n## 介绍&闲谈\n下面通过对斐波那契数列和这道凑零钱问题详解动态规划。如果只想看本题的答案，请直接翻到最后查看。\n\n动态规划算法似乎是一种很高深莫测的算法，你会在一些面试或算法书籍的高级技巧部分看到相关内容，什么状态转移方程，**重叠子问题**，最优子结构等高大上的词汇也可能让你望而却步。\n\n而且，当你去看用动态规划解决某个问题的代码时，你会觉得这样解决问题竟然如此巧妙，但却难以理解，你可能惊讶于人家是怎么想到这种解法的。\n\n实际上，动态规划是一种常见的「算法设计技巧」，并没有什么高深莫测，至于各种高大上的术语，那是吓唬别人用的，只要你亲自体验几把，这些名词的含义其实显而易见，再简单不过了。\n\n至于为什么最终的解法看起来如此精妙，是因为动态规划遵循一套固定的流程：    \n递归的暴力解法 -> 带备忘录的递归解法 -> 非递归的动态规划解法。\n\n这个过程是层层递进的解决问题的过程，你如果没有前面的铺垫，直接看最终的非递归动态规划解法，当然会觉得牛逼而不可及了。\n\n当然，见的多了，思考多了，是可以一步写出非递归的动态规划解法的。任何技巧都需要练习，我们先遵循这个流程走，算法设计也就这些套路，除此之外，真的没啥高深的。\n\n以下，先通过两个个比较简单的例子：斐波那契和凑零钱问题，揭开动态规划的神秘面纱，描述上述三个流程。后续还会写几篇文章探讨如何使用动态规划技巧解决比较复杂的经典问题。\n\n首先，第一个快被举烂了的例子，斐波那契数列。请读者不要嫌弃这个例子简单，因为简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙。后续，困难的例子有的是。\n## 步骤一、暴力的递归算法\n\n```C++\nint fib(int N) {\n    if (N == 1 || N == 2) return 1;\n    return fib(N - 1) + fib(N - 2);\n}\n```\n\n这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。\n\nPS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。\n{% asset_img 1.png %}\n\n这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。\n\n**递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。**\n\n子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。\n\n解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。\n\n所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。\n\n观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。\n\n这就是动态规划问题的第一个性质：**重叠子问题**。下面，我们想办法解决这个问题。\n\n## 步骤二、带备忘录的递归解法\n\n明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。\n\n一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。\n\n```C++\nint fib(int N) {\n    if (N < 1) return 0;\n    // 备忘录全初始化为 0\n    vector<int> memo(N + 1, 0);\n    return helper(memo, N);\n}\nint helper(vector<int>& memo, int n) {\n    if (n == 1 || n == 2) return 1;\n    if (memo[n] != 0) return memo[n];\n    // 未被计算过\n    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);\n    return memo[n];\n}\n```\n\n现在，画出递归树，你就知道「备忘录」到底做了什么。\n\n{% asset_img 2.png %}\n\n实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。\n\n递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。\n\n子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) ... f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。\n\n解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。\n\n所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。\n\n至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。\n\n啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。\n\n啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。\n\n## 步骤三、动态规划\n\n有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！\n\n```C++\nint fib(int N) {\n    vector<int> dp(N + 1, 0);\n    dp[1] = dp[2] = 1;\n    for (int i = 3; i <= N; i++)\n        dp[i] = dp[i - 1] + dp[i - 2];\n    return dp[N];\n}\n```\n\n{% asset_img 3.png %}\n\n画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。\n\n这里，引出「动态转移方程」这个名词，实际上就是描述问题结构的数学形式：\n\n{% asset_img 4.png %}\n\n为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。\n\n你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。\n\n**千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程**，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。\n\n这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：\n\n```C++\nint fib(int n) {\n    if (n < 2) return n;\n    int prev = 0, curr = 1;\n    for (int i = 0; i < n - 1; i++) {\n        int sum = prev + curr;\n        prev = curr;\n        curr = sum;\n    }\n    return curr;\n}\n```\n\n有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，以上旨在演示算法设计螺旋上升的过程。当问题中要求求一个最优解或在代码中看到循环和 max、min 等函数时，十有八九，需要动态规划大显身手。\n\n下面，看第二个例子，**凑零钱问题**，有了上面的详细铺垫，这个问题会很快解决。\n\n题目：给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。\n\n比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 11 = 5 + 5 + 1 。下面走流程。\n## CoinChange问题\n### 一、暴力解法\n\n首先是最困难的一步，写出状态转移方程，这个问题比较好写：\n\n{% asset_img 5.png %}]\n\n其实，这个方程就用到了「最优子结构」性质：**原问题的解由子问题的最优解构成**。即 f(11) 由 f(10), f(9), f(6) 的最优解转移而来。\n\n记住，**要符合「最优子结构」，子问题间必须互相独立**。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。\n\n比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高...... 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高...... 当然，最终就是你每门课都是满分，这就是最高的总成绩。\n\n得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。\n\n但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。\n\n回到凑零钱问题，显然子问题之间没有相互制约，而是互相独立的。所以这个状态转移方程是可以得到正确答案的。\n\n之后就没啥难点了，按照方程写暴力递归算法即可。\n\n```C++\nint coinChange(vector<int>& coins, int amount) {\n    if (amount == 0) return 0;\n    int ans = INT_MAX;\n    for (int coin : coins) {\n        // 金额不可达\n        if (amount - coin < 0) continue;\n        int subProb = coinChange(coins, amount - coin);\n        // 子问题无解\n        if (subProb == -1) continue;\n        ans = min(ans, subProb + 1);\n    }\n    return ans == INT_MAX ? -1 : ans;\n}\n```\n\n画出递归树：\n\n{% asset_img 6.png %}\n\n时间复杂度分析：子问题总数 x 每个子问题的时间。子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 $$ O(k\\*n^k) $$，指数级别。\n\n### 二、带备忘录的递归算法\n\n```C++\nint coinChange(vector<int>& coins, int amount) {\n    // 备忘录初始化为 -2\n    vector<int> memo(amount + 1, -2);\n    return helper(coins, amount, memo);\n}\n\nint helper(vector<int>& coins, int amount, vector<int>& memo) {\n    if (amount == 0) return 0;\n    if (memo[amount] != -2) return memo[amount];\n    int ans = INT_MAX;\n    for (int coin : coins) {\n        // 金额不可达\n        if (amount - coin < 0) continue;\n        int subProb = helper(coins, amount - coin, memo);\n        // 子问题无解\n        if (subProb == -1) continue;\n        ans = min(ans, subProb + 1);\n    }\n    // 记录本轮答案\n    memo[amount] = (ans == INT_MAX) ? -1 : ans;\n    return memo[amount];\n}\n```\n\n不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。\n\n### 三、动态规划\n\n```C++\nint coinChange(vector<int>& coins, int amount) {\n    vector<int> dp(amount + 1, amount + 1);\n    dp[0] = 0;\n    for (int i = 1; i <= amount; i++) {\n        for (int coin : coins)\n            if (coin <= i)\n                dp[i] = min(dp[i], dp[i - coin] + 1);\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n```\n\n{% asset_img 7.png %}\n\n## 最后总结\n\n如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。\n\n计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。**算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。**\n\n列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。\n\n备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？\n","source":"_posts/动态规划套路详解.md","raw":"---\ntitle: 动态规划套路详解\ntags:\n  - DP\n  - Learning\n  - Notes\n  - Reprint\ncategories:\n  - Notes\nurlname: dp-notes\ncomments: true\nmathjax: false\ndate: 2019-06-18 14:38:35\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n在LeetCode的[322题题解](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)中看到一篇动态规划的详解，讲的很清楚，转载记录下\n\n转自：[LeetCode动态规划套路详解](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)\n{% endnote %}\n<!--more-->\n## 介绍&闲谈\n下面通过对斐波那契数列和这道凑零钱问题详解动态规划。如果只想看本题的答案，请直接翻到最后查看。\n\n动态规划算法似乎是一种很高深莫测的算法，你会在一些面试或算法书籍的高级技巧部分看到相关内容，什么状态转移方程，**重叠子问题**，最优子结构等高大上的词汇也可能让你望而却步。\n\n而且，当你去看用动态规划解决某个问题的代码时，你会觉得这样解决问题竟然如此巧妙，但却难以理解，你可能惊讶于人家是怎么想到这种解法的。\n\n实际上，动态规划是一种常见的「算法设计技巧」，并没有什么高深莫测，至于各种高大上的术语，那是吓唬别人用的，只要你亲自体验几把，这些名词的含义其实显而易见，再简单不过了。\n\n至于为什么最终的解法看起来如此精妙，是因为动态规划遵循一套固定的流程：    \n递归的暴力解法 -> 带备忘录的递归解法 -> 非递归的动态规划解法。\n\n这个过程是层层递进的解决问题的过程，你如果没有前面的铺垫，直接看最终的非递归动态规划解法，当然会觉得牛逼而不可及了。\n\n当然，见的多了，思考多了，是可以一步写出非递归的动态规划解法的。任何技巧都需要练习，我们先遵循这个流程走，算法设计也就这些套路，除此之外，真的没啥高深的。\n\n以下，先通过两个个比较简单的例子：斐波那契和凑零钱问题，揭开动态规划的神秘面纱，描述上述三个流程。后续还会写几篇文章探讨如何使用动态规划技巧解决比较复杂的经典问题。\n\n首先，第一个快被举烂了的例子，斐波那契数列。请读者不要嫌弃这个例子简单，因为简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙。后续，困难的例子有的是。\n## 步骤一、暴力的递归算法\n\n```C++\nint fib(int N) {\n    if (N == 1 || N == 2) return 1;\n    return fib(N - 1) + fib(N - 2);\n}\n```\n\n这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。\n\nPS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。\n{% asset_img 1.png %}\n\n这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。\n\n**递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。**\n\n子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。\n\n解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。\n\n所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。\n\n观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。\n\n这就是动态规划问题的第一个性质：**重叠子问题**。下面，我们想办法解决这个问题。\n\n## 步骤二、带备忘录的递归解法\n\n明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。\n\n一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。\n\n```C++\nint fib(int N) {\n    if (N < 1) return 0;\n    // 备忘录全初始化为 0\n    vector<int> memo(N + 1, 0);\n    return helper(memo, N);\n}\nint helper(vector<int>& memo, int n) {\n    if (n == 1 || n == 2) return 1;\n    if (memo[n] != 0) return memo[n];\n    // 未被计算过\n    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);\n    return memo[n];\n}\n```\n\n现在，画出递归树，你就知道「备忘录」到底做了什么。\n\n{% asset_img 2.png %}\n\n实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。\n\n递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。\n\n子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) ... f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。\n\n解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。\n\n所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。\n\n至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。\n\n啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。\n\n啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。\n\n## 步骤三、动态规划\n\n有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！\n\n```C++\nint fib(int N) {\n    vector<int> dp(N + 1, 0);\n    dp[1] = dp[2] = 1;\n    for (int i = 3; i <= N; i++)\n        dp[i] = dp[i - 1] + dp[i - 2];\n    return dp[N];\n}\n```\n\n{% asset_img 3.png %}\n\n画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。\n\n这里，引出「动态转移方程」这个名词，实际上就是描述问题结构的数学形式：\n\n{% asset_img 4.png %}\n\n为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。\n\n你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。\n\n**千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程**，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。\n\n这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：\n\n```C++\nint fib(int n) {\n    if (n < 2) return n;\n    int prev = 0, curr = 1;\n    for (int i = 0; i < n - 1; i++) {\n        int sum = prev + curr;\n        prev = curr;\n        curr = sum;\n    }\n    return curr;\n}\n```\n\n有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，以上旨在演示算法设计螺旋上升的过程。当问题中要求求一个最优解或在代码中看到循环和 max、min 等函数时，十有八九，需要动态规划大显身手。\n\n下面，看第二个例子，**凑零钱问题**，有了上面的详细铺垫，这个问题会很快解决。\n\n题目：给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。\n\n比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 11 = 5 + 5 + 1 。下面走流程。\n## CoinChange问题\n### 一、暴力解法\n\n首先是最困难的一步，写出状态转移方程，这个问题比较好写：\n\n{% asset_img 5.png %}]\n\n其实，这个方程就用到了「最优子结构」性质：**原问题的解由子问题的最优解构成**。即 f(11) 由 f(10), f(9), f(6) 的最优解转移而来。\n\n记住，**要符合「最优子结构」，子问题间必须互相独立**。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。\n\n比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高...... 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高...... 当然，最终就是你每门课都是满分，这就是最高的总成绩。\n\n得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。\n\n但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。\n\n回到凑零钱问题，显然子问题之间没有相互制约，而是互相独立的。所以这个状态转移方程是可以得到正确答案的。\n\n之后就没啥难点了，按照方程写暴力递归算法即可。\n\n```C++\nint coinChange(vector<int>& coins, int amount) {\n    if (amount == 0) return 0;\n    int ans = INT_MAX;\n    for (int coin : coins) {\n        // 金额不可达\n        if (amount - coin < 0) continue;\n        int subProb = coinChange(coins, amount - coin);\n        // 子问题无解\n        if (subProb == -1) continue;\n        ans = min(ans, subProb + 1);\n    }\n    return ans == INT_MAX ? -1 : ans;\n}\n```\n\n画出递归树：\n\n{% asset_img 6.png %}\n\n时间复杂度分析：子问题总数 x 每个子问题的时间。子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 $$ O(k\\*n^k) $$，指数级别。\n\n### 二、带备忘录的递归算法\n\n```C++\nint coinChange(vector<int>& coins, int amount) {\n    // 备忘录初始化为 -2\n    vector<int> memo(amount + 1, -2);\n    return helper(coins, amount, memo);\n}\n\nint helper(vector<int>& coins, int amount, vector<int>& memo) {\n    if (amount == 0) return 0;\n    if (memo[amount] != -2) return memo[amount];\n    int ans = INT_MAX;\n    for (int coin : coins) {\n        // 金额不可达\n        if (amount - coin < 0) continue;\n        int subProb = helper(coins, amount - coin, memo);\n        // 子问题无解\n        if (subProb == -1) continue;\n        ans = min(ans, subProb + 1);\n    }\n    // 记录本轮答案\n    memo[amount] = (ans == INT_MAX) ? -1 : ans;\n    return memo[amount];\n}\n```\n\n不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。\n\n### 三、动态规划\n\n```C++\nint coinChange(vector<int>& coins, int amount) {\n    vector<int> dp(amount + 1, amount + 1);\n    dp[0] = 0;\n    for (int i = 1; i <= amount; i++) {\n        for (int coin : coins)\n            if (coin <= i)\n                dp[i] = min(dp[i], dp[i - coin] + 1);\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n```\n\n{% asset_img 7.png %}\n\n## 最后总结\n\n如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。\n\n计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。**算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。**\n\n列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。\n\n备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？\n","slug":"动态规划套路详解","published":1,"updated":"2019-07-25T18:34:30.506Z","layout":"post","photos":[],"link":"","_id":"ck2424lm10035lksbybhdcdcc","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在LeetCode的<a href=\"https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">322题题解</a>中看到一篇动态规划的详解，讲的很清楚，转载记录下</p><p>转自：<a href=\"https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">LeetCode动态规划套路详解</a></p></div><a id=\"more\"></a><h2 id=\"介绍-amp-闲谈\"><a href=\"#介绍-amp-闲谈\" class=\"headerlink\" title=\"介绍&amp;闲谈\"></a>介绍&amp;闲谈</h2><p>下面通过对斐波那契数列和这道凑零钱问题详解动态规划。如果只想看本题的答案，请直接翻到最后查看。</p><p>动态规划算法似乎是一种很高深莫测的算法，你会在一些面试或算法书籍的高级技巧部分看到相关内容，什么状态转移方程，<strong>重叠子问题</strong>，最优子结构等高大上的词汇也可能让你望而却步。</p><p>而且，当你去看用动态规划解决某个问题的代码时，你会觉得这样解决问题竟然如此巧妙，但却难以理解，你可能惊讶于人家是怎么想到这种解法的。</p><p>实际上，动态规划是一种常见的「算法设计技巧」，并没有什么高深莫测，至于各种高大上的术语，那是吓唬别人用的，只要你亲自体验几把，这些名词的含义其实显而易见，再简单不过了。</p><p>至于为什么最终的解法看起来如此精妙，是因为动态规划遵循一套固定的流程：<br>递归的暴力解法 -&gt; 带备忘录的递归解法 -&gt; 非递归的动态规划解法。</p><p>这个过程是层层递进的解决问题的过程，你如果没有前面的铺垫，直接看最终的非递归动态规划解法，当然会觉得牛逼而不可及了。</p><p>当然，见的多了，思考多了，是可以一步写出非递归的动态规划解法的。任何技巧都需要练习，我们先遵循这个流程走，算法设计也就这些套路，除此之外，真的没啥高深的。</p><p>以下，先通过两个个比较简单的例子：斐波那契和凑零钱问题，揭开动态规划的神秘面纱，描述上述三个流程。后续还会写几篇文章探讨如何使用动态规划技巧解决比较复杂的经典问题。</p><p>首先，第一个快被举烂了的例子，斐波那契数列。请读者不要嫌弃这个例子简单，因为简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙。后续，困难的例子有的是。</p><h2 id=\"步骤一、暴力的递归算法\"><a href=\"#步骤一、暴力的递归算法\" class=\"headerlink\" title=\"步骤一、暴力的递归算法\"></a>步骤一、暴力的递归算法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N == <span class=\"number\">1</span> || N == <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(N - <span class=\"number\">1</span>) + fib(N - <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。</p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。<br><img src=\"/Notes/2019-06-18-dp-notes/1.png\"></p><p>这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p><strong>递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。</strong></p><p>子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><h2 id=\"步骤二、带备忘录的递归解法\"><a href=\"#步骤二、带备忘录的递归解法\" class=\"headerlink\" title=\"步骤二、带备忘录的递归解法\"></a>步骤二、带备忘录的递归解法</h2><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 备忘录全初始化为 0</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; memo(N + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(memo, N);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; memo, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span> || n == <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo[n] != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> memo[n];</span><br><span class=\"line\">    <span class=\"comment\">// 未被计算过</span></span><br><span class=\"line\">    memo[n] = helper(memo, n - <span class=\"number\">1</span>) + helper(memo, n - <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memo[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p><img src=\"/Notes/2019-06-18-dp-notes/2.png\"><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p>递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。</p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) … f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><h2 id=\"步骤三、动态规划\"><a href=\"#步骤三、动态规划\" class=\"headerlink\" title=\"步骤三、动态规划\"></a>步骤三、动态规划</h2><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; dp(N + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>] = dp[<span class=\"number\">2</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= N; i++)</span><br><span class=\"line\">        dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[N];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><img src=\"/Notes/2019-06-18-dp-notes/3.png\"><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「动态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><img src=\"/Notes/2019-06-18-dp-notes/4.png\"><p>为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程</strong>，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prev = <span class=\"number\">0</span>, curr = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = prev + curr;</span><br><span class=\"line\">        prev = curr;</span><br><span class=\"line\">        curr = sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> curr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，以上旨在演示算法设计螺旋上升的过程。当问题中要求求一个最优解或在代码中看到循环和 max、min 等函数时，十有八九，需要动态规划大显身手。</p><p>下面，看第二个例子，<strong>凑零钱问题</strong>，有了上面的详细铺垫，这个问题会很快解决。</p><p>题目：给你 k 种面值的硬币，面值分别为 c1, c2 … ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。</p><p>比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 11 = 5 + 5 + 1 。下面走流程。</p><h2 id=\"CoinChange问题\"><a href=\"#CoinChange问题\" class=\"headerlink\" title=\"CoinChange问题\"></a>CoinChange问题</h2><h3 id=\"一、暴力解法\"><a href=\"#一、暴力解法\" class=\"headerlink\" title=\"一、暴力解法\"></a>一、暴力解法</h3><p>首先是最困难的一步，写出状态转移方程，这个问题比较好写：</p><img src=\"/Notes/2019-06-18-dp-notes/5.png\">] 其实，这个方程就用到了「最优子结构」性质：**原问题的解由子问题的最优解构成**。即 f(11) 由 f(10), f(9), f(6) 的最优解转移而来。 记住，**要符合「最优子结构」，子问题间必须互相独立**。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。 比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高...... 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高...... 当然，最终就是你每门课都是满分，这就是最高的总成绩。 得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。 但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。 回到凑零钱问题，显然子问题之间没有相互制约，而是互相独立的。所以这个状态转移方程是可以得到正确答案的。 之后就没啥难点了，按照方程写暴力递归算法即可。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">coinChange</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; coins, <span class=\"keyword\">int</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (amount == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> coin : coins) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 金额不可达</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (amount - coin &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> subProb = coinChange(coins, amount - coin);</span><br><span class=\"line\">        <span class=\"comment\">// 子问题无解</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subProb == <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        ans = min(ans, subProb + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans == INT_MAX ? <span class=\"number\">-1</span> : ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>画出递归树：</p><img src=\"/Notes/2019-06-18-dp-notes/6.png\"><p>时间复杂度分析：子问题总数 x 每个子问题的时间。子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为<script type=\"math/tex\">O(k\\*n^k)</script>，指数级别。</p><h3 id=\"二、带备忘录的递归算法\"><a href=\"#二、带备忘录的递归算法\" class=\"headerlink\" title=\"二、带备忘录的递归算法\"></a>二、带备忘录的递归算法</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">coinChange</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; coins, <span class=\"keyword\">int</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 备忘录初始化为 -2</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; memo(amount + <span class=\"number\">1</span>, <span class=\"number\">-2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(coins, amount, memo);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; coins, <span class=\"keyword\">int</span> amount, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; memo)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (amount == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo[amount] != <span class=\"number\">-2</span>) <span class=\"keyword\">return</span> memo[amount];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> coin : coins) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 金额不可达</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (amount - coin &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> subProb = helper(coins, amount - coin, memo);</span><br><span class=\"line\">        <span class=\"comment\">// 子问题无解</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subProb == <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        ans = min(ans, subProb + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 记录本轮答案</span></span><br><span class=\"line\">    memo[amount] = (ans == INT_MAX) ? <span class=\"number\">-1</span> : ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memo[amount];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p><h3 id=\"三、动态规划\"><a href=\"#三、动态规划\" class=\"headerlink\" title=\"三、动态规划\"></a>三、动态规划</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">coinChange</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; coins, <span class=\"keyword\">int</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; dp(amount + <span class=\"number\">1</span>, amount + <span class=\"number\">1</span>);</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= amount; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> coin : coins)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (coin &lt;= i)</span><br><span class=\"line\">                dp[i] = min(dp[i], dp[i - coin] + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[amount] &gt; amount ? <span class=\"number\">-1</span> : dp[amount];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><img src=\"/Notes/2019-06-18-dp-notes/7.png\"><h2 id=\"最后总结\"><a href=\"#最后总结\" class=\"headerlink\" title=\"最后总结\"></a>最后总结</h2><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。<strong>算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</strong></p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在LeetCode的<a href=\"https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">322题题解</a>中看到一篇动态规划的详解，讲的很清楚，转载记录下</p><p>转自：<a href=\"https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">LeetCode动态规划套路详解</a></p></div>","more":"<h2 id=\"介绍-amp-闲谈\"><a href=\"#介绍-amp-闲谈\" class=\"headerlink\" title=\"介绍&amp;闲谈\"></a>介绍&amp;闲谈</h2><p>下面通过对斐波那契数列和这道凑零钱问题详解动态规划。如果只想看本题的答案，请直接翻到最后查看。</p><p>动态规划算法似乎是一种很高深莫测的算法，你会在一些面试或算法书籍的高级技巧部分看到相关内容，什么状态转移方程，<strong>重叠子问题</strong>，最优子结构等高大上的词汇也可能让你望而却步。</p><p>而且，当你去看用动态规划解决某个问题的代码时，你会觉得这样解决问题竟然如此巧妙，但却难以理解，你可能惊讶于人家是怎么想到这种解法的。</p><p>实际上，动态规划是一种常见的「算法设计技巧」，并没有什么高深莫测，至于各种高大上的术语，那是吓唬别人用的，只要你亲自体验几把，这些名词的含义其实显而易见，再简单不过了。</p><p>至于为什么最终的解法看起来如此精妙，是因为动态规划遵循一套固定的流程：<br>递归的暴力解法 -&gt; 带备忘录的递归解法 -&gt; 非递归的动态规划解法。</p><p>这个过程是层层递进的解决问题的过程，你如果没有前面的铺垫，直接看最终的非递归动态规划解法，当然会觉得牛逼而不可及了。</p><p>当然，见的多了，思考多了，是可以一步写出非递归的动态规划解法的。任何技巧都需要练习，我们先遵循这个流程走，算法设计也就这些套路，除此之外，真的没啥高深的。</p><p>以下，先通过两个个比较简单的例子：斐波那契和凑零钱问题，揭开动态规划的神秘面纱，描述上述三个流程。后续还会写几篇文章探讨如何使用动态规划技巧解决比较复杂的经典问题。</p><p>首先，第一个快被举烂了的例子，斐波那契数列。请读者不要嫌弃这个例子简单，因为简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙。后续，困难的例子有的是。</p><h2 id=\"步骤一、暴力的递归算法\"><a href=\"#步骤一、暴力的递归算法\" class=\"headerlink\" title=\"步骤一、暴力的递归算法\"></a>步骤一、暴力的递归算法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N == <span class=\"number\">1</span> || N == <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(N - <span class=\"number\">1</span>) + fib(N - <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。</p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。<br><img src=\"/Notes/2019-06-18-dp-notes/1.png\"></p><p>这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p><strong>递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。</strong></p><p>子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><h2 id=\"步骤二、带备忘录的递归解法\"><a href=\"#步骤二、带备忘录的递归解法\" class=\"headerlink\" title=\"步骤二、带备忘录的递归解法\"></a>步骤二、带备忘录的递归解法</h2><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 备忘录全初始化为 0</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; memo(N + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(memo, N);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; memo, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span> || n == <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo[n] != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> memo[n];</span><br><span class=\"line\">    <span class=\"comment\">// 未被计算过</span></span><br><span class=\"line\">    memo[n] = helper(memo, n - <span class=\"number\">1</span>) + helper(memo, n - <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memo[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p><img src=\"/Notes/2019-06-18-dp-notes/2.png\"><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p>递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。</p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) … f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><h2 id=\"步骤三、动态规划\"><a href=\"#步骤三、动态规划\" class=\"headerlink\" title=\"步骤三、动态规划\"></a>步骤三、动态规划</h2><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; dp(N + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>] = dp[<span class=\"number\">2</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= N; i++)</span><br><span class=\"line\">        dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[N];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><img src=\"/Notes/2019-06-18-dp-notes/3.png\"><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「动态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><img src=\"/Notes/2019-06-18-dp-notes/4.png\"><p>为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程</strong>，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prev = <span class=\"number\">0</span>, curr = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = prev + curr;</span><br><span class=\"line\">        prev = curr;</span><br><span class=\"line\">        curr = sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> curr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，以上旨在演示算法设计螺旋上升的过程。当问题中要求求一个最优解或在代码中看到循环和 max、min 等函数时，十有八九，需要动态规划大显身手。</p><p>下面，看第二个例子，<strong>凑零钱问题</strong>，有了上面的详细铺垫，这个问题会很快解决。</p><p>题目：给你 k 种面值的硬币，面值分别为 c1, c2 … ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。</p><p>比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 11 = 5 + 5 + 1 。下面走流程。</p><h2 id=\"CoinChange问题\"><a href=\"#CoinChange问题\" class=\"headerlink\" title=\"CoinChange问题\"></a>CoinChange问题</h2><h3 id=\"一、暴力解法\"><a href=\"#一、暴力解法\" class=\"headerlink\" title=\"一、暴力解法\"></a>一、暴力解法</h3><p>首先是最困难的一步，写出状态转移方程，这个问题比较好写：</p><img src=\"/Notes/2019-06-18-dp-notes/5.png\">] 其实，这个方程就用到了「最优子结构」性质：**原问题的解由子问题的最优解构成**。即 f(11) 由 f(10), f(9), f(6) 的最优解转移而来。 记住，**要符合「最优子结构」，子问题间必须互相独立**。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。 比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高...... 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高...... 当然，最终就是你每门课都是满分，这就是最高的总成绩。 得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。 但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。 回到凑零钱问题，显然子问题之间没有相互制约，而是互相独立的。所以这个状态转移方程是可以得到正确答案的。 之后就没啥难点了，按照方程写暴力递归算法即可。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">coinChange</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; coins, <span class=\"keyword\">int</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (amount == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> coin : coins) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 金额不可达</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (amount - coin &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> subProb = coinChange(coins, amount - coin);</span><br><span class=\"line\">        <span class=\"comment\">// 子问题无解</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subProb == <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        ans = min(ans, subProb + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans == INT_MAX ? <span class=\"number\">-1</span> : ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>画出递归树：</p><img src=\"/Notes/2019-06-18-dp-notes/6.png\"><p>时间复杂度分析：子问题总数 x 每个子问题的时间。子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为<script type=\"math/tex\">O(k\\*n^k)</script>，指数级别。</p><h3 id=\"二、带备忘录的递归算法\"><a href=\"#二、带备忘录的递归算法\" class=\"headerlink\" title=\"二、带备忘录的递归算法\"></a>二、带备忘录的递归算法</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">coinChange</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; coins, <span class=\"keyword\">int</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 备忘录初始化为 -2</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; memo(amount + <span class=\"number\">1</span>, <span class=\"number\">-2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(coins, amount, memo);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; coins, <span class=\"keyword\">int</span> amount, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; memo)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (amount == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo[amount] != <span class=\"number\">-2</span>) <span class=\"keyword\">return</span> memo[amount];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> coin : coins) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 金额不可达</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (amount - coin &lt; <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> subProb = helper(coins, amount - coin, memo);</span><br><span class=\"line\">        <span class=\"comment\">// 子问题无解</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subProb == <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        ans = min(ans, subProb + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 记录本轮答案</span></span><br><span class=\"line\">    memo[amount] = (ans == INT_MAX) ? <span class=\"number\">-1</span> : ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memo[amount];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p><h3 id=\"三、动态规划\"><a href=\"#三、动态规划\" class=\"headerlink\" title=\"三、动态规划\"></a>三、动态规划</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">coinChange</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; coins, <span class=\"keyword\">int</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; dp(amount + <span class=\"number\">1</span>, amount + <span class=\"number\">1</span>);</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= amount; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> coin : coins)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (coin &lt;= i)</span><br><span class=\"line\">                dp[i] = min(dp[i], dp[i - coin] + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[amount] &gt; amount ? <span class=\"number\">-1</span> : dp[amount];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><img src=\"/Notes/2019-06-18-dp-notes/7.png\"><h2 id=\"最后总结\"><a href=\"#最后总结\" class=\"headerlink\" title=\"最后总结\"></a>最后总结</h2><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。<strong>算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</strong></p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p><!-- rebuild by neat -->"},{"title":"记2019南大计算机本科生开放日","urlname":"2019-nju-csopenday-note","comments":1,"mathjax":false,"date":"2019-07-12T10:29:34.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n# 前言\n[最近更新：2019.10.2]\n- 记录南大夏令营的全程，包括准备阶段和夏令营阶段以及夏令营之后。 \n\n- 记录一些保研的经验,注意点。写了很多给学弟学妹们的话，希望你们保研能够顺利，避免踩坑。\n- 记录自己整个保研过程的感受，以及一些想写下来的东西。\n\n{% endnote %}\n<!--MORE-->\n\n# 写在之前\n2019年7月12，恩，南大夏令营第一天，一天之内心情就像打翻的五味瓶。。。\n\n哎，写下来这些也是希望能给后面的学弟学妹点帮助，毕竟我也是看了很多以前别人写的博客才完全了解夏令营。\n\n# 申请夏令营和选拔\n## 初审\n南大入营选拔很看重绩点和排名，以及，学校，这些都是敲门砖。\n\n当你绩点专业前5%，学校起码是211，你就有戏了，非211和985的，应该非常非常少，当然，如果你有很多厉害的奖，专利，论文啥的，就没问题\n除了上面的敲门砖，竞赛、论文、获奖、专利、软著这些之类的，如果有比较厉害的，也会很有希望。\n\n## 复审\n不要以为收到第一封通知邮件就是入营了，那只是初审，复审还会刷掉点人。\n复审需要寄送材料，按照邮件要求寄送即可，不要作假就行\n\n2019年大概400左右人入营，南京市内100+，非南京市280+，大概只给100不到的优营名额，竞争还是很激烈的\n\n# 夏令营\n## 准备\n别想了，在你报名之前你就应该准备。\n\n事实证明，如果你觉得自己有希望保研，最好大三下开学就准备夏令营，在大三下期末考之前，你需要认真复习准备我下面要说的。等期末结束再认真复习，就晚了。。\n我就是，期末之前复习不多，期末之后确认入营了才认真起来，但是时间完全不够用。\n\n**准备分为机试和面试**\n 1. 机试\n- 你需要学大量的算法，ACM中等难度就可以\n- 刷大量的题，100道肯定不够的，可以刷[leetcode](https://leetcode.com/problemset/all/)上的中等难度题，也可以找上面的分类题目写。还可以刷[牛客网](https://www.nowcoder.com/ta/kaoyan)的考研复试题。事实证明，这两个网站都很有用\n- 刷完题要总结，可以用思维导图，我觉得挺好\n 2. 面试\n- 你需要复习数学相关，比如：概统、现代、离散\n- 专业相关，比如：操作系统、数据结构、计网、计组、数据库。如果时间充足，全都复习，时间不够，按我的写的顺序复习\n\n## 第一天机试\n第一天，算是最难受的了把。因为报道当天早上从学校出发的，所以要早起。但是，前一天晚上睡觉睡不着..不是我一个人，同行的四个人，都睡不着，一方面是无法避免的紧张，另一方面是，和自己生物钟不协调，睡太早\n\n所以尽量提前几天调好生物钟把，精神会好点\n\n上午11点左右到南大，路上本来想着再看看算法，但是因为晕车，困，没座位这些原因就没看。报道之后就直接去酒店登记入住了。酒店还是很棒的，毕竟四星级，条件很好。\n每天的午饭晚饭有餐券。不得不说！南大的伙食真的好，虽然，很贵....我看到一个女生，两个大荤加一个蔬菜，好像还有汤，26元..正常人均15把\n\n吃完饭就没多少时间了，因为着凉肚子难受，趴桌子趴了一会。复习也只能大概过一遍。所以尽量夏令营之前准备妥当。\n吃饭的时候听可靠消息说今年的题目比较难，当时心里就慌了，后面等机房开门的时候就一直看算法，心情沉重，\n\n### 机试\n要求下午1点半到，两点开始考试。\n一共两小时，三道题，每道题有10个测试用例，一个测试用例10分。满分也就是300分。\n\n以前好像看到说可以看到测试用例。但是！并没有，只能看到你第几个通过，第几个没通过，而且今年看不到总排名\n\n**第一题**\n\n大概意思是，给你一个不超过100位的数N，和一个不超过100的数字K，要求从数N中去掉K个数字，然后使得去掉K个数之后，N最小。\n\n**题解参考链接**：<https://blog.csdn.net/c20190413/article/details/77368590>   \n    \n   \n**第二题**\n\n大概意思是，有B个男孩，G个女孩，要求所有男孩女孩排成一队，连续的男孩个数不可以超过K个，问一共有多少种排法\n\n**思路参考：**\n\n分路递归，看当前为止是男孩还是女孩。\n\n所以第一路递归，当前是男孩，第二路递归，当前是女孩，然后继续递归遍历下一个位置。\n\n当然会有限制条件，不可以连续超过K个男孩，我在参数中记录当前位置，前面的男孩个数。\n\n如果女孩个数等于0，那后面全是男孩，要看剩下的男孩个数是否超过K，如果男孩个数为0，剩下全是女孩，返回1。\n\n如果前面男孩个数已经K个了，这个位置只能是女孩。\n\n大概这样。但是会超时，10个样例只通过了7个...后面也没想到怎么剪枝优化。\n\n**第三题**\n\n给出一个二叉树的前序遍历序列和后序遍历序列，序列是没有空节点#号的，只有字母，问通过这两个序列可以构造多少中不同的二叉树，因为树的样子不一样，遍历的序列是可能一样的。比如前序序列:ABC，后序序列CBA，就有4种不同的树\n\n推荐阅读：\n1. [二叉树遍历（已知前序和后序遍历，求中序遍历的可能的序列数）](https://blog.csdn.net/qq_37437983/article/details/79613947)\n1. [已知二叉树先序遍历和后序遍历序列，求可能的中序遍历序列及方案数，是np问题还是p问题？](https://www.zhihu.com/question/298250264)\n\n## 第二天面试\n### 面试\n虽说，南大夏令营的结果是综合了机试和面试，综合排名。但是！**实际情况是**，机试稳了，面试就走过场了。面试相对来说没那么重要，但是为了不留遗憾，还是需要认真对待的。机试完一晚上加上第二天上午的时间，足够准备了。\n\n这次的面试分两批，上下午。我是下午那批，所以有一个上午可以睡个好觉，吃个美滋滋的自助早餐，还能准备一会。\n\n**每个人面试大概十分钟，只有一个英文面试题，一定要好好练练口语，以便临场发挥**\n\n我这次面试比较轻松，没有太过刁难。上来先**自我介绍**，没说限制时间，基本上自己说完就好。\n\n然后因为我说了国家级大创，所以，下一个问题**问了大创项目**，做了啥，怎么样，细节。还有会从你的回答中，**延伸出去**，问一些技术方面的问题。\n\n大创这里三个老师都问了我问题，由易到难，中间还问了我通信如何实现高并发，如何处理请求，以及通过什么方式实现的通信，比如WIFI，蓝牙，我说了是WEBSOCKET。还问了更深的窄带物联网的通信。这里花的时间是比较多的。\n\n随后一个老师**英文提问**自己哪门课学的比较好，为什么，紧张状态下真的话都说不清，很乱，这也是我面试唯一一个败笔....不过还好的是说完就冷静下来，继续回答问题。\n\n自我介绍说想在大数据这方面继续深造，老师就问了**为什么，如何看待大数据**，一些理解把，**延伸出去**的问了如何看待大数据中的隐私问题，答完又问了解过隐私方面的协议，比如说XXX吗，确实没听过，就直说这个不是很了解。\n\n整个面试还是比较轻松的，我的面试没那么难。\n\n不过交流下来，差距还是挺大的，似乎只有我比较幸运，问的比较正常。其他的有很多挺难回答的问题，**因老师和自我介绍而异**把。\n\n**面试的原则是实事求是，不会就是不会，还有就是更偏向随机应变，而不是死背稿子。**\n\n在面试的时候一般都会很紧张，所以背的稿子几乎没啥用。甚至我的自我介绍都是临场发挥的，和稿子不大一样。\n\n**建议**是自我介绍好好写，记住大概要说的。然后基于自己的自我介绍，自己想可能会问啥问题，然后自己回答。\n\n### 联系导师签字\n面试完基本上就去找意向导师了，也有人第一天来就直接找了意向导师。\n\n每个老师只能签四个人，所以说，如果去晚了，可能会没名额。\n\n这个也挺难说，毕竟签了字，你也不一定能进南大，签了字，老师也不一定选你。\n\n**这里的建议是：**\n　　夏令营之前就了解好各个实验室的情况，起码有个大概了解。可以找本校的在南大读研的学长，让他给你说说情况，推荐下啥的。也可以避免踩雷。有了意向导师，在复审通过后就给老师发邮件，记得附上自己简历。\n\n南大的实验室，除了LAMDA，其他的实力上来说应该差不多，只是有的比价偏理论，有的比较偏项目，有的比较综合，自己看方向和综合情况选把。\n\n## 第三天\n机试面试结束，先让我玩一个晚上，享受四星级酒店的待遇再说吧～\n\n-----\n\n第三天并没有什么实质性的工作，主要就是听一个总结，然后见了导师，了解导师那边的情况，以及谈下自己来南大的可能性之类的，算是探探底。如果老师非常想要你，还是有可能会帮你的。\n\n# 一些保研注意点\n1. 机试：\n如果想去的学校有机试，一定一定要好好准备，提前准备，算法不是一星期两星期就能练好的。\n1. 报名：\n提前列个表，有哪些大概能去冲一冲的学校。学校要多，表要长，夏令营的时候一定要尽量多参加。到了预推免还没OFFER，那预推免报名更要多报名。\n1. 冲刺好学校：\n夏令营和预推免的时候，不要怕报名麻烦，报了就有希望，一定要多尝试。就算是北大软微，我现在都有点后悔没报名，因为有学校比我的差的，都能去试试。\n1. 后路：  \n永远不要太相信自己的实力，因为大部分学校面试占比很大，所以主观性很强。不管什么情况，一定要准备另一条后路。以及，最差情况的心理准备。甚至要做好本校资格拿不到，转战考研的准备。\n1. 联系导师：\n夏令营阶段：有些学校导师的权利比较大，更尊重导师意见。这样的话，最好提前联系导师，来回多发几封邮件。让他看到你的优势，他如果想要你，会去争取。\n预推免阶段：这时候，报了名，就得联系导师，不管能不能进复试。一方面是增加进复试以及拿到OFFER的几率，另一方面，你联系晚了，好导师就没名额了，都被预订了。\n1. 如果夏令营没有满意的OFFER：\n夏令营结束，到预推免，有很长的时间，这段时间要加油，补短板。中间会有本校的保研，更不能掉链子，拿不到本校资格就完蛋了。还有最重要的是，没有好OFFER，预推免一定要光撒网。但是时间有限，安排好时间的前提下，多尝试想去的学校。因为预推免门槛比夏令营低，会有机会，就算没成，也能给自己增加补录几率。\n\n其他的一些问题，相信你们自己都可以处理好。\n\n# 最后的话\n后面得知并没有被录，而是在替补队列。距离被录取，差了大概20-30分。机试一个样例10分，差2-3个样例这样。\n\n非常遗憾，但是心里还是感觉可以在9月被补录，因为南大夏令营最早，每年最后都会有很多人鸽。但是肯定不能把希望全放在南大上。所以后面参加了东南的预推免，以及9月报名的计算所的预推免。\n\n拿到计算所的OFFER后，其他的预推免就全部拒绝了，没什么必要参加了。南大这边也有想过一点，万一有补录，怎么办。也只能拒绝。\n\n到了28号0点，要填志愿了，这时候还没有打电话过来补录。想着应该不会补录了，只填了计算所一个志愿。\n\n没想到第二天早上9点，南大打电话过来问有名额，要不要去。但是这时候已经太晚了，南大老师也很着急，于是直接拒绝了。把时间留给别人，可能很多人都在等补录。\n\n现在想想心里还是很遗憾。整个保研过程，南大是我最想去的学校，也是准备时间最长的学校，计算所只是机缘巧合录了。从4月中旬，大概那时就开始准备南大的夏令营，虽然在期末之前准备的进度很慢，但是真的是花了很多时间练算法题。\n\n断断续续准备了大概两个月。没想到拿了一个替补。也没想到最后给了名额，但是却拒绝了。如果计算所没录，可能最好的结果就是补录南大把。当初录取差了一点，后面所有的准备都不一样了，结果而言，也是真的就差了一点。\n\n感慨还是很多，也想过如果当初，多练练常考题型，可能也不会有后面这么多曲折，这么多担心。做什么事情，还是需要全力以赴才能让自己不后悔。\n\n保研已经结束了，希望未来四年，能更加努力，要为自己加油！\n\n共勉！\n\n--------\n","source":"_posts/记2019南大计算机本科生开放日.md","raw":"---\ntitle: 记2019南大计算机本科生开放日\ntags:\n  - Nju\n  - SummerCamp\n  - Daily\ncategories:\n  - Daily\nurlname: 2019-nju-csopenday-note\ncomments: true\nmathjax: false\ndate: 2019-07-12 18:29:34\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n# 前言\n[最近更新：2019.10.2]\n- 记录南大夏令营的全程，包括准备阶段和夏令营阶段以及夏令营之后。 \n\n- 记录一些保研的经验,注意点。写了很多给学弟学妹们的话，希望你们保研能够顺利，避免踩坑。\n- 记录自己整个保研过程的感受，以及一些想写下来的东西。\n\n{% endnote %}\n<!--MORE-->\n\n# 写在之前\n2019年7月12，恩，南大夏令营第一天，一天之内心情就像打翻的五味瓶。。。\n\n哎，写下来这些也是希望能给后面的学弟学妹点帮助，毕竟我也是看了很多以前别人写的博客才完全了解夏令营。\n\n# 申请夏令营和选拔\n## 初审\n南大入营选拔很看重绩点和排名，以及，学校，这些都是敲门砖。\n\n当你绩点专业前5%，学校起码是211，你就有戏了，非211和985的，应该非常非常少，当然，如果你有很多厉害的奖，专利，论文啥的，就没问题\n除了上面的敲门砖，竞赛、论文、获奖、专利、软著这些之类的，如果有比较厉害的，也会很有希望。\n\n## 复审\n不要以为收到第一封通知邮件就是入营了，那只是初审，复审还会刷掉点人。\n复审需要寄送材料，按照邮件要求寄送即可，不要作假就行\n\n2019年大概400左右人入营，南京市内100+，非南京市280+，大概只给100不到的优营名额，竞争还是很激烈的\n\n# 夏令营\n## 准备\n别想了，在你报名之前你就应该准备。\n\n事实证明，如果你觉得自己有希望保研，最好大三下开学就准备夏令营，在大三下期末考之前，你需要认真复习准备我下面要说的。等期末结束再认真复习，就晚了。。\n我就是，期末之前复习不多，期末之后确认入营了才认真起来，但是时间完全不够用。\n\n**准备分为机试和面试**\n 1. 机试\n- 你需要学大量的算法，ACM中等难度就可以\n- 刷大量的题，100道肯定不够的，可以刷[leetcode](https://leetcode.com/problemset/all/)上的中等难度题，也可以找上面的分类题目写。还可以刷[牛客网](https://www.nowcoder.com/ta/kaoyan)的考研复试题。事实证明，这两个网站都很有用\n- 刷完题要总结，可以用思维导图，我觉得挺好\n 2. 面试\n- 你需要复习数学相关，比如：概统、现代、离散\n- 专业相关，比如：操作系统、数据结构、计网、计组、数据库。如果时间充足，全都复习，时间不够，按我的写的顺序复习\n\n## 第一天机试\n第一天，算是最难受的了把。因为报道当天早上从学校出发的，所以要早起。但是，前一天晚上睡觉睡不着..不是我一个人，同行的四个人，都睡不着，一方面是无法避免的紧张，另一方面是，和自己生物钟不协调，睡太早\n\n所以尽量提前几天调好生物钟把，精神会好点\n\n上午11点左右到南大，路上本来想着再看看算法，但是因为晕车，困，没座位这些原因就没看。报道之后就直接去酒店登记入住了。酒店还是很棒的，毕竟四星级，条件很好。\n每天的午饭晚饭有餐券。不得不说！南大的伙食真的好，虽然，很贵....我看到一个女生，两个大荤加一个蔬菜，好像还有汤，26元..正常人均15把\n\n吃完饭就没多少时间了，因为着凉肚子难受，趴桌子趴了一会。复习也只能大概过一遍。所以尽量夏令营之前准备妥当。\n吃饭的时候听可靠消息说今年的题目比较难，当时心里就慌了，后面等机房开门的时候就一直看算法，心情沉重，\n\n### 机试\n要求下午1点半到，两点开始考试。\n一共两小时，三道题，每道题有10个测试用例，一个测试用例10分。满分也就是300分。\n\n以前好像看到说可以看到测试用例。但是！并没有，只能看到你第几个通过，第几个没通过，而且今年看不到总排名\n\n**第一题**\n\n大概意思是，给你一个不超过100位的数N，和一个不超过100的数字K，要求从数N中去掉K个数字，然后使得去掉K个数之后，N最小。\n\n**题解参考链接**：<https://blog.csdn.net/c20190413/article/details/77368590>   \n    \n   \n**第二题**\n\n大概意思是，有B个男孩，G个女孩，要求所有男孩女孩排成一队，连续的男孩个数不可以超过K个，问一共有多少种排法\n\n**思路参考：**\n\n分路递归，看当前为止是男孩还是女孩。\n\n所以第一路递归，当前是男孩，第二路递归，当前是女孩，然后继续递归遍历下一个位置。\n\n当然会有限制条件，不可以连续超过K个男孩，我在参数中记录当前位置，前面的男孩个数。\n\n如果女孩个数等于0，那后面全是男孩，要看剩下的男孩个数是否超过K，如果男孩个数为0，剩下全是女孩，返回1。\n\n如果前面男孩个数已经K个了，这个位置只能是女孩。\n\n大概这样。但是会超时，10个样例只通过了7个...后面也没想到怎么剪枝优化。\n\n**第三题**\n\n给出一个二叉树的前序遍历序列和后序遍历序列，序列是没有空节点#号的，只有字母，问通过这两个序列可以构造多少中不同的二叉树，因为树的样子不一样，遍历的序列是可能一样的。比如前序序列:ABC，后序序列CBA，就有4种不同的树\n\n推荐阅读：\n1. [二叉树遍历（已知前序和后序遍历，求中序遍历的可能的序列数）](https://blog.csdn.net/qq_37437983/article/details/79613947)\n1. [已知二叉树先序遍历和后序遍历序列，求可能的中序遍历序列及方案数，是np问题还是p问题？](https://www.zhihu.com/question/298250264)\n\n## 第二天面试\n### 面试\n虽说，南大夏令营的结果是综合了机试和面试，综合排名。但是！**实际情况是**，机试稳了，面试就走过场了。面试相对来说没那么重要，但是为了不留遗憾，还是需要认真对待的。机试完一晚上加上第二天上午的时间，足够准备了。\n\n这次的面试分两批，上下午。我是下午那批，所以有一个上午可以睡个好觉，吃个美滋滋的自助早餐，还能准备一会。\n\n**每个人面试大概十分钟，只有一个英文面试题，一定要好好练练口语，以便临场发挥**\n\n我这次面试比较轻松，没有太过刁难。上来先**自我介绍**，没说限制时间，基本上自己说完就好。\n\n然后因为我说了国家级大创，所以，下一个问题**问了大创项目**，做了啥，怎么样，细节。还有会从你的回答中，**延伸出去**，问一些技术方面的问题。\n\n大创这里三个老师都问了我问题，由易到难，中间还问了我通信如何实现高并发，如何处理请求，以及通过什么方式实现的通信，比如WIFI，蓝牙，我说了是WEBSOCKET。还问了更深的窄带物联网的通信。这里花的时间是比较多的。\n\n随后一个老师**英文提问**自己哪门课学的比较好，为什么，紧张状态下真的话都说不清，很乱，这也是我面试唯一一个败笔....不过还好的是说完就冷静下来，继续回答问题。\n\n自我介绍说想在大数据这方面继续深造，老师就问了**为什么，如何看待大数据**，一些理解把，**延伸出去**的问了如何看待大数据中的隐私问题，答完又问了解过隐私方面的协议，比如说XXX吗，确实没听过，就直说这个不是很了解。\n\n整个面试还是比较轻松的，我的面试没那么难。\n\n不过交流下来，差距还是挺大的，似乎只有我比较幸运，问的比较正常。其他的有很多挺难回答的问题，**因老师和自我介绍而异**把。\n\n**面试的原则是实事求是，不会就是不会，还有就是更偏向随机应变，而不是死背稿子。**\n\n在面试的时候一般都会很紧张，所以背的稿子几乎没啥用。甚至我的自我介绍都是临场发挥的，和稿子不大一样。\n\n**建议**是自我介绍好好写，记住大概要说的。然后基于自己的自我介绍，自己想可能会问啥问题，然后自己回答。\n\n### 联系导师签字\n面试完基本上就去找意向导师了，也有人第一天来就直接找了意向导师。\n\n每个老师只能签四个人，所以说，如果去晚了，可能会没名额。\n\n这个也挺难说，毕竟签了字，你也不一定能进南大，签了字，老师也不一定选你。\n\n**这里的建议是：**\n　　夏令营之前就了解好各个实验室的情况，起码有个大概了解。可以找本校的在南大读研的学长，让他给你说说情况，推荐下啥的。也可以避免踩雷。有了意向导师，在复审通过后就给老师发邮件，记得附上自己简历。\n\n南大的实验室，除了LAMDA，其他的实力上来说应该差不多，只是有的比价偏理论，有的比较偏项目，有的比较综合，自己看方向和综合情况选把。\n\n## 第三天\n机试面试结束，先让我玩一个晚上，享受四星级酒店的待遇再说吧～\n\n-----\n\n第三天并没有什么实质性的工作，主要就是听一个总结，然后见了导师，了解导师那边的情况，以及谈下自己来南大的可能性之类的，算是探探底。如果老师非常想要你，还是有可能会帮你的。\n\n# 一些保研注意点\n1. 机试：\n如果想去的学校有机试，一定一定要好好准备，提前准备，算法不是一星期两星期就能练好的。\n1. 报名：\n提前列个表，有哪些大概能去冲一冲的学校。学校要多，表要长，夏令营的时候一定要尽量多参加。到了预推免还没OFFER，那预推免报名更要多报名。\n1. 冲刺好学校：\n夏令营和预推免的时候，不要怕报名麻烦，报了就有希望，一定要多尝试。就算是北大软微，我现在都有点后悔没报名，因为有学校比我的差的，都能去试试。\n1. 后路：  \n永远不要太相信自己的实力，因为大部分学校面试占比很大，所以主观性很强。不管什么情况，一定要准备另一条后路。以及，最差情况的心理准备。甚至要做好本校资格拿不到，转战考研的准备。\n1. 联系导师：\n夏令营阶段：有些学校导师的权利比较大，更尊重导师意见。这样的话，最好提前联系导师，来回多发几封邮件。让他看到你的优势，他如果想要你，会去争取。\n预推免阶段：这时候，报了名，就得联系导师，不管能不能进复试。一方面是增加进复试以及拿到OFFER的几率，另一方面，你联系晚了，好导师就没名额了，都被预订了。\n1. 如果夏令营没有满意的OFFER：\n夏令营结束，到预推免，有很长的时间，这段时间要加油，补短板。中间会有本校的保研，更不能掉链子，拿不到本校资格就完蛋了。还有最重要的是，没有好OFFER，预推免一定要光撒网。但是时间有限，安排好时间的前提下，多尝试想去的学校。因为预推免门槛比夏令营低，会有机会，就算没成，也能给自己增加补录几率。\n\n其他的一些问题，相信你们自己都可以处理好。\n\n# 最后的话\n后面得知并没有被录，而是在替补队列。距离被录取，差了大概20-30分。机试一个样例10分，差2-3个样例这样。\n\n非常遗憾，但是心里还是感觉可以在9月被补录，因为南大夏令营最早，每年最后都会有很多人鸽。但是肯定不能把希望全放在南大上。所以后面参加了东南的预推免，以及9月报名的计算所的预推免。\n\n拿到计算所的OFFER后，其他的预推免就全部拒绝了，没什么必要参加了。南大这边也有想过一点，万一有补录，怎么办。也只能拒绝。\n\n到了28号0点，要填志愿了，这时候还没有打电话过来补录。想着应该不会补录了，只填了计算所一个志愿。\n\n没想到第二天早上9点，南大打电话过来问有名额，要不要去。但是这时候已经太晚了，南大老师也很着急，于是直接拒绝了。把时间留给别人，可能很多人都在等补录。\n\n现在想想心里还是很遗憾。整个保研过程，南大是我最想去的学校，也是准备时间最长的学校，计算所只是机缘巧合录了。从4月中旬，大概那时就开始准备南大的夏令营，虽然在期末之前准备的进度很慢，但是真的是花了很多时间练算法题。\n\n断断续续准备了大概两个月。没想到拿了一个替补。也没想到最后给了名额，但是却拒绝了。如果计算所没录，可能最好的结果就是补录南大把。当初录取差了一点，后面所有的准备都不一样了，结果而言，也是真的就差了一点。\n\n感慨还是很多，也想过如果当初，多练练常考题型，可能也不会有后面这么多曲折，这么多担心。做什么事情，还是需要全力以赴才能让自己不后悔。\n\n保研已经结束了，希望未来四年，能更加努力，要为自己加油！\n\n共勉！\n\n--------\n","slug":"记2019南大计算机本科生开放日","published":1,"updated":"2019-10-02T17:46:10.633Z","layout":"post","photos":[],"link":"","_id":"ck2424lm80038lksb68wxm9cb","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>[最近更新：2019.10.2]</p><ul><li><p>记录南大夏令营的全程，包括准备阶段和夏令营阶段以及夏令营之后。</p></li><li><p>记录一些保研的经验,注意点。写了很多给学弟学妹们的话，希望你们保研能够顺利，避免踩坑。</p></li><li>记录自己整个保研过程的感受，以及一些想写下来的东西。</li></ul></div><h1 id=\"写在之前\"><a href=\"#写在之前\" class=\"headerlink\" title=\"写在之前\"></a>写在之前</h1><p>2019年7月12，恩，南大夏令营第一天，一天之内心情就像打翻的五味瓶。。。</p><p>哎，写下来这些也是希望能给后面的学弟学妹点帮助，毕竟我也是看了很多以前别人写的博客才完全了解夏令营。</p><h1 id=\"申请夏令营和选拔\"><a href=\"#申请夏令营和选拔\" class=\"headerlink\" title=\"申请夏令营和选拔\"></a>申请夏令营和选拔</h1><h2 id=\"初审\"><a href=\"#初审\" class=\"headerlink\" title=\"初审\"></a>初审</h2><p>南大入营选拔很看重绩点和排名，以及，学校，这些都是敲门砖。</p><p>当你绩点专业前5%，学校起码是211，你就有戏了，非211和985的，应该非常非常少，当然，如果你有很多厉害的奖，专利，论文啥的，就没问题<br>除了上面的敲门砖，竞赛、论文、获奖、专利、软著这些之类的，如果有比较厉害的，也会很有希望。</p><h2 id=\"复审\"><a href=\"#复审\" class=\"headerlink\" title=\"复审\"></a>复审</h2><p>不要以为收到第一封通知邮件就是入营了，那只是初审，复审还会刷掉点人。<br>复审需要寄送材料，按照邮件要求寄送即可，不要作假就行</p><p>2019年大概400左右人入营，南京市内100+，非南京市280+，大概只给100不到的优营名额，竞争还是很激烈的</p><h1 id=\"夏令营\"><a href=\"#夏令营\" class=\"headerlink\" title=\"夏令营\"></a>夏令营</h1><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>别想了，在你报名之前你就应该准备。</p><p>事实证明，如果你觉得自己有希望保研，最好大三下开学就准备夏令营，在大三下期末考之前，你需要认真复习准备我下面要说的。等期末结束再认真复习，就晚了。。<br>我就是，期末之前复习不多，期末之后确认入营了才认真起来，但是时间完全不够用。</p><p><strong>准备分为机试和面试</strong></p><ol><li>机试<ul><li>你需要学大量的算法，ACM中等难度就可以</li><li>刷大量的题，100道肯定不够的，可以刷<a href=\"https://leetcode.com/problemset/all/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">leetcode</a>上的中等难度题，也可以找上面的分类题目写。还可以刷<a href=\"https://www.nowcoder.com/ta/kaoyan\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">牛客网</a>的考研复试题。事实证明，这两个网站都很有用</li><li>刷完题要总结，可以用思维导图，我觉得挺好</li></ul></li><li>面试<ul><li>你需要复习数学相关，比如：概统、现代、离散</li><li>专业相关，比如：操作系统、数据结构、计网、计组、数据库。如果时间充足，全都复习，时间不够，按我的写的顺序复习</li></ul></li></ol><h2 id=\"第一天机试\"><a href=\"#第一天机试\" class=\"headerlink\" title=\"第一天机试\"></a>第一天机试</h2><p>第一天，算是最难受的了把。因为报道当天早上从学校出发的，所以要早起。但是，前一天晚上睡觉睡不着..不是我一个人，同行的四个人，都睡不着，一方面是无法避免的紧张，另一方面是，和自己生物钟不协调，睡太早</p><p>所以尽量提前几天调好生物钟把，精神会好点</p><p>上午11点左右到南大，路上本来想着再看看算法，但是因为晕车，困，没座位这些原因就没看。报道之后就直接去酒店登记入住了。酒店还是很棒的，毕竟四星级，条件很好。<br>每天的午饭晚饭有餐券。不得不说！南大的伙食真的好，虽然，很贵….我看到一个女生，两个大荤加一个蔬菜，好像还有汤，26元..正常人均15把</p><p>吃完饭就没多少时间了，因为着凉肚子难受，趴桌子趴了一会。复习也只能大概过一遍。所以尽量夏令营之前准备妥当。<br>吃饭的时候听可靠消息说今年的题目比较难，当时心里就慌了，后面等机房开门的时候就一直看算法，心情沉重，</p><h3 id=\"机试\"><a href=\"#机试\" class=\"headerlink\" title=\"机试\"></a>机试</h3><p>要求下午1点半到，两点开始考试。<br>一共两小时，三道题，每道题有10个测试用例，一个测试用例10分。满分也就是300分。</p><p>以前好像看到说可以看到测试用例。但是！并没有，只能看到你第几个通过，第几个没通过，而且今年看不到总排名</p><p><strong>第一题</strong></p><p>大概意思是，给你一个不超过100位的数N，和一个不超过100的数字K，要求从数N中去掉K个数字，然后使得去掉K个数之后，N最小。</p><p><strong>题解参考链接</strong>：<a href=\"https://blog.csdn.net/c20190413/article/details/77368590\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://blog.csdn.net/c20190413/article/details/77368590</a></p><p><strong>第二题</strong></p><p>大概意思是，有B个男孩，G个女孩，要求所有男孩女孩排成一队，连续的男孩个数不可以超过K个，问一共有多少种排法</p><p><strong>思路参考：</strong></p><p>分路递归，看当前为止是男孩还是女孩。</p><p>所以第一路递归，当前是男孩，第二路递归，当前是女孩，然后继续递归遍历下一个位置。</p><p>当然会有限制条件，不可以连续超过K个男孩，我在参数中记录当前位置，前面的男孩个数。</p><p>如果女孩个数等于0，那后面全是男孩，要看剩下的男孩个数是否超过K，如果男孩个数为0，剩下全是女孩，返回1。</p><p>如果前面男孩个数已经K个了，这个位置只能是女孩。</p><p>大概这样。但是会超时，10个样例只通过了7个…后面也没想到怎么剪枝优化。</p><p><strong>第三题</strong></p><p>给出一个二叉树的前序遍历序列和后序遍历序列，序列是没有空节点#号的，只有字母，问通过这两个序列可以构造多少中不同的二叉树，因为树的样子不一样，遍历的序列是可能一样的。比如前序序列:ABC，后序序列CBA，就有4种不同的树</p><p>推荐阅读：</p><ol><li><a href=\"https://blog.csdn.net/qq_37437983/article/details/79613947\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">二叉树遍历（已知前序和后序遍历，求中序遍历的可能的序列数）</a></li><li><a href=\"https://www.zhihu.com/question/298250264\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">已知二叉树先序遍历和后序遍历序列，求可能的中序遍历序列及方案数，是np问题还是p问题？</a></li></ol><h2 id=\"第二天面试\"><a href=\"#第二天面试\" class=\"headerlink\" title=\"第二天面试\"></a>第二天面试</h2><h3 id=\"面试\"><a href=\"#面试\" class=\"headerlink\" title=\"面试\"></a>面试</h3><p>虽说，南大夏令营的结果是综合了机试和面试，综合排名。但是！<strong>实际情况是</strong>，机试稳了，面试就走过场了。面试相对来说没那么重要，但是为了不留遗憾，还是需要认真对待的。机试完一晚上加上第二天上午的时间，足够准备了。</p><p>这次的面试分两批，上下午。我是下午那批，所以有一个上午可以睡个好觉，吃个美滋滋的自助早餐，还能准备一会。</p><p><strong>每个人面试大概十分钟，只有一个英文面试题，一定要好好练练口语，以便临场发挥</strong></p><p>我这次面试比较轻松，没有太过刁难。上来先<strong>自我介绍</strong>，没说限制时间，基本上自己说完就好。</p><p>然后因为我说了国家级大创，所以，下一个问题<strong>问了大创项目</strong>，做了啥，怎么样，细节。还有会从你的回答中，<strong>延伸出去</strong>，问一些技术方面的问题。</p><p>大创这里三个老师都问了我问题，由易到难，中间还问了我通信如何实现高并发，如何处理请求，以及通过什么方式实现的通信，比如WIFI，蓝牙，我说了是WEBSOCKET。还问了更深的窄带物联网的通信。这里花的时间是比较多的。</p><p>随后一个老师<strong>英文提问</strong>自己哪门课学的比较好，为什么，紧张状态下真的话都说不清，很乱，这也是我面试唯一一个败笔….不过还好的是说完就冷静下来，继续回答问题。</p><p>自我介绍说想在大数据这方面继续深造，老师就问了<strong>为什么，如何看待大数据</strong>，一些理解把，<strong>延伸出去</strong>的问了如何看待大数据中的隐私问题，答完又问了解过隐私方面的协议，比如说XXX吗，确实没听过，就直说这个不是很了解。</p><p>整个面试还是比较轻松的，我的面试没那么难。</p><p>不过交流下来，差距还是挺大的，似乎只有我比较幸运，问的比较正常。其他的有很多挺难回答的问题，<strong>因老师和自我介绍而异</strong>把。</p><p><strong>面试的原则是实事求是，不会就是不会，还有就是更偏向随机应变，而不是死背稿子。</strong></p><p>在面试的时候一般都会很紧张，所以背的稿子几乎没啥用。甚至我的自我介绍都是临场发挥的，和稿子不大一样。</p><p><strong>建议</strong>是自我介绍好好写，记住大概要说的。然后基于自己的自我介绍，自己想可能会问啥问题，然后自己回答。</p><h3 id=\"联系导师签字\"><a href=\"#联系导师签字\" class=\"headerlink\" title=\"联系导师签字\"></a>联系导师签字</h3><p>面试完基本上就去找意向导师了，也有人第一天来就直接找了意向导师。</p><p>每个老师只能签四个人，所以说，如果去晚了，可能会没名额。</p><p>这个也挺难说，毕竟签了字，你也不一定能进南大，签了字，老师也不一定选你。</p><p><strong>这里的建议是：</strong><br>夏令营之前就了解好各个实验室的情况，起码有个大概了解。可以找本校的在南大读研的学长，让他给你说说情况，推荐下啥的。也可以避免踩雷。有了意向导师，在复审通过后就给老师发邮件，记得附上自己简历。</p><p>南大的实验室，除了LAMDA，其他的实力上来说应该差不多，只是有的比价偏理论，有的比较偏项目，有的比较综合，自己看方向和综合情况选把。</p><h2 id=\"第三天\"><a href=\"#第三天\" class=\"headerlink\" title=\"第三天\"></a>第三天</h2><p>机试面试结束，先让我玩一个晚上，享受四星级酒店的待遇再说吧～</p><hr><p>第三天并没有什么实质性的工作，主要就是听一个总结，然后见了导师，了解导师那边的情况，以及谈下自己来南大的可能性之类的，算是探探底。如果老师非常想要你，还是有可能会帮你的。</p><h1 id=\"一些保研注意点\"><a href=\"#一些保研注意点\" class=\"headerlink\" title=\"一些保研注意点\"></a>一些保研注意点</h1><ol><li>机试：<br>如果想去的学校有机试，一定一定要好好准备，提前准备，算法不是一星期两星期就能练好的。</li><li>报名：<br>提前列个表，有哪些大概能去冲一冲的学校。学校要多，表要长，夏令营的时候一定要尽量多参加。到了预推免还没OFFER，那预推免报名更要多报名。</li><li>冲刺好学校：<br>夏令营和预推免的时候，不要怕报名麻烦，报了就有希望，一定要多尝试。就算是北大软微，我现在都有点后悔没报名，因为有学校比我的差的，都能去试试。</li><li>后路：<br>永远不要太相信自己的实力，因为大部分学校面试占比很大，所以主观性很强。不管什么情况，一定要准备另一条后路。以及，最差情况的心理准备。甚至要做好本校资格拿不到，转战考研的准备。</li><li>联系导师：<br>夏令营阶段：有些学校导师的权利比较大，更尊重导师意见。这样的话，最好提前联系导师，来回多发几封邮件。让他看到你的优势，他如果想要你，会去争取。<br>预推免阶段：这时候，报了名，就得联系导师，不管能不能进复试。一方面是增加进复试以及拿到OFFER的几率，另一方面，你联系晚了，好导师就没名额了，都被预订了。</li><li>如果夏令营没有满意的OFFER：<br>夏令营结束，到预推免，有很长的时间，这段时间要加油，补短板。中间会有本校的保研，更不能掉链子，拿不到本校资格就完蛋了。还有最重要的是，没有好OFFER，预推免一定要光撒网。但是时间有限，安排好时间的前提下，多尝试想去的学校。因为预推免门槛比夏令营低，会有机会，就算没成，也能给自己增加补录几率。</li></ol><p>其他的一些问题，相信你们自己都可以处理好。</p><h1 id=\"最后的话\"><a href=\"#最后的话\" class=\"headerlink\" title=\"最后的话\"></a>最后的话</h1><p>后面得知并没有被录，而是在替补队列。距离被录取，差了大概20-30分。机试一个样例10分，差2-3个样例这样。</p><p>非常遗憾，但是心里还是感觉可以在9月被补录，因为南大夏令营最早，每年最后都会有很多人鸽。但是肯定不能把希望全放在南大上。所以后面参加了东南的预推免，以及9月报名的计算所的预推免。</p><p>拿到计算所的OFFER后，其他的预推免就全部拒绝了，没什么必要参加了。南大这边也有想过一点，万一有补录，怎么办。也只能拒绝。</p><p>到了28号0点，要填志愿了，这时候还没有打电话过来补录。想着应该不会补录了，只填了计算所一个志愿。</p><p>没想到第二天早上9点，南大打电话过来问有名额，要不要去。但是这时候已经太晚了，南大老师也很着急，于是直接拒绝了。把时间留给别人，可能很多人都在等补录。</p><p>现在想想心里还是很遗憾。整个保研过程，南大是我最想去的学校，也是准备时间最长的学校，计算所只是机缘巧合录了。从4月中旬，大概那时就开始准备南大的夏令营，虽然在期末之前准备的进度很慢，但是真的是花了很多时间练算法题。</p><p>断断续续准备了大概两个月。没想到拿了一个替补。也没想到最后给了名额，但是却拒绝了。如果计算所没录，可能最好的结果就是补录南大把。当初录取差了一点，后面所有的准备都不一样了，结果而言，也是真的就差了一点。</p><p>感慨还是很多，也想过如果当初，多练练常考题型，可能也不会有后面这么多曲折，这么多担心。做什么事情，还是需要全力以赴才能让自己不后悔。</p><p>保研已经结束了，希望未来四年，能更加努力，要为自己加油！</p><p>共勉！</p><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"","more":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>[最近更新：2019.10.2]</p><ul><li><p>记录南大夏令营的全程，包括准备阶段和夏令营阶段以及夏令营之后。</p></li><li><p>记录一些保研的经验,注意点。写了很多给学弟学妹们的话，希望你们保研能够顺利，避免踩坑。</p></li><li>记录自己整个保研过程的感受，以及一些想写下来的东西。</li></ul></div><h1 id=\"写在之前\"><a href=\"#写在之前\" class=\"headerlink\" title=\"写在之前\"></a>写在之前</h1><p>2019年7月12，恩，南大夏令营第一天，一天之内心情就像打翻的五味瓶。。。</p><p>哎，写下来这些也是希望能给后面的学弟学妹点帮助，毕竟我也是看了很多以前别人写的博客才完全了解夏令营。</p><h1 id=\"申请夏令营和选拔\"><a href=\"#申请夏令营和选拔\" class=\"headerlink\" title=\"申请夏令营和选拔\"></a>申请夏令营和选拔</h1><h2 id=\"初审\"><a href=\"#初审\" class=\"headerlink\" title=\"初审\"></a>初审</h2><p>南大入营选拔很看重绩点和排名，以及，学校，这些都是敲门砖。</p><p>当你绩点专业前5%，学校起码是211，你就有戏了，非211和985的，应该非常非常少，当然，如果你有很多厉害的奖，专利，论文啥的，就没问题<br>除了上面的敲门砖，竞赛、论文、获奖、专利、软著这些之类的，如果有比较厉害的，也会很有希望。</p><h2 id=\"复审\"><a href=\"#复审\" class=\"headerlink\" title=\"复审\"></a>复审</h2><p>不要以为收到第一封通知邮件就是入营了，那只是初审，复审还会刷掉点人。<br>复审需要寄送材料，按照邮件要求寄送即可，不要作假就行</p><p>2019年大概400左右人入营，南京市内100+，非南京市280+，大概只给100不到的优营名额，竞争还是很激烈的</p><h1 id=\"夏令营\"><a href=\"#夏令营\" class=\"headerlink\" title=\"夏令营\"></a>夏令营</h1><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>别想了，在你报名之前你就应该准备。</p><p>事实证明，如果你觉得自己有希望保研，最好大三下开学就准备夏令营，在大三下期末考之前，你需要认真复习准备我下面要说的。等期末结束再认真复习，就晚了。。<br>我就是，期末之前复习不多，期末之后确认入营了才认真起来，但是时间完全不够用。</p><p><strong>准备分为机试和面试</strong></p><ol><li>机试<ul><li>你需要学大量的算法，ACM中等难度就可以</li><li>刷大量的题，100道肯定不够的，可以刷<a href=\"https://leetcode.com/problemset/all/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">leetcode</a>上的中等难度题，也可以找上面的分类题目写。还可以刷<a href=\"https://www.nowcoder.com/ta/kaoyan\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">牛客网</a>的考研复试题。事实证明，这两个网站都很有用</li><li>刷完题要总结，可以用思维导图，我觉得挺好</li></ul></li><li>面试<ul><li>你需要复习数学相关，比如：概统、现代、离散</li><li>专业相关，比如：操作系统、数据结构、计网、计组、数据库。如果时间充足，全都复习，时间不够，按我的写的顺序复习</li></ul></li></ol><h2 id=\"第一天机试\"><a href=\"#第一天机试\" class=\"headerlink\" title=\"第一天机试\"></a>第一天机试</h2><p>第一天，算是最难受的了把。因为报道当天早上从学校出发的，所以要早起。但是，前一天晚上睡觉睡不着..不是我一个人，同行的四个人，都睡不着，一方面是无法避免的紧张，另一方面是，和自己生物钟不协调，睡太早</p><p>所以尽量提前几天调好生物钟把，精神会好点</p><p>上午11点左右到南大，路上本来想着再看看算法，但是因为晕车，困，没座位这些原因就没看。报道之后就直接去酒店登记入住了。酒店还是很棒的，毕竟四星级，条件很好。<br>每天的午饭晚饭有餐券。不得不说！南大的伙食真的好，虽然，很贵….我看到一个女生，两个大荤加一个蔬菜，好像还有汤，26元..正常人均15把</p><p>吃完饭就没多少时间了，因为着凉肚子难受，趴桌子趴了一会。复习也只能大概过一遍。所以尽量夏令营之前准备妥当。<br>吃饭的时候听可靠消息说今年的题目比较难，当时心里就慌了，后面等机房开门的时候就一直看算法，心情沉重，</p><h3 id=\"机试\"><a href=\"#机试\" class=\"headerlink\" title=\"机试\"></a>机试</h3><p>要求下午1点半到，两点开始考试。<br>一共两小时，三道题，每道题有10个测试用例，一个测试用例10分。满分也就是300分。</p><p>以前好像看到说可以看到测试用例。但是！并没有，只能看到你第几个通过，第几个没通过，而且今年看不到总排名</p><p><strong>第一题</strong></p><p>大概意思是，给你一个不超过100位的数N，和一个不超过100的数字K，要求从数N中去掉K个数字，然后使得去掉K个数之后，N最小。</p><p><strong>题解参考链接</strong>：<a href=\"https://blog.csdn.net/c20190413/article/details/77368590\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://blog.csdn.net/c20190413/article/details/77368590</a></p><p><strong>第二题</strong></p><p>大概意思是，有B个男孩，G个女孩，要求所有男孩女孩排成一队，连续的男孩个数不可以超过K个，问一共有多少种排法</p><p><strong>思路参考：</strong></p><p>分路递归，看当前为止是男孩还是女孩。</p><p>所以第一路递归，当前是男孩，第二路递归，当前是女孩，然后继续递归遍历下一个位置。</p><p>当然会有限制条件，不可以连续超过K个男孩，我在参数中记录当前位置，前面的男孩个数。</p><p>如果女孩个数等于0，那后面全是男孩，要看剩下的男孩个数是否超过K，如果男孩个数为0，剩下全是女孩，返回1。</p><p>如果前面男孩个数已经K个了，这个位置只能是女孩。</p><p>大概这样。但是会超时，10个样例只通过了7个…后面也没想到怎么剪枝优化。</p><p><strong>第三题</strong></p><p>给出一个二叉树的前序遍历序列和后序遍历序列，序列是没有空节点#号的，只有字母，问通过这两个序列可以构造多少中不同的二叉树，因为树的样子不一样，遍历的序列是可能一样的。比如前序序列:ABC，后序序列CBA，就有4种不同的树</p><p>推荐阅读：</p><ol><li><a href=\"https://blog.csdn.net/qq_37437983/article/details/79613947\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">二叉树遍历（已知前序和后序遍历，求中序遍历的可能的序列数）</a></li><li><a href=\"https://www.zhihu.com/question/298250264\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">已知二叉树先序遍历和后序遍历序列，求可能的中序遍历序列及方案数，是np问题还是p问题？</a></li></ol><h2 id=\"第二天面试\"><a href=\"#第二天面试\" class=\"headerlink\" title=\"第二天面试\"></a>第二天面试</h2><h3 id=\"面试\"><a href=\"#面试\" class=\"headerlink\" title=\"面试\"></a>面试</h3><p>虽说，南大夏令营的结果是综合了机试和面试，综合排名。但是！<strong>实际情况是</strong>，机试稳了，面试就走过场了。面试相对来说没那么重要，但是为了不留遗憾，还是需要认真对待的。机试完一晚上加上第二天上午的时间，足够准备了。</p><p>这次的面试分两批，上下午。我是下午那批，所以有一个上午可以睡个好觉，吃个美滋滋的自助早餐，还能准备一会。</p><p><strong>每个人面试大概十分钟，只有一个英文面试题，一定要好好练练口语，以便临场发挥</strong></p><p>我这次面试比较轻松，没有太过刁难。上来先<strong>自我介绍</strong>，没说限制时间，基本上自己说完就好。</p><p>然后因为我说了国家级大创，所以，下一个问题<strong>问了大创项目</strong>，做了啥，怎么样，细节。还有会从你的回答中，<strong>延伸出去</strong>，问一些技术方面的问题。</p><p>大创这里三个老师都问了我问题，由易到难，中间还问了我通信如何实现高并发，如何处理请求，以及通过什么方式实现的通信，比如WIFI，蓝牙，我说了是WEBSOCKET。还问了更深的窄带物联网的通信。这里花的时间是比较多的。</p><p>随后一个老师<strong>英文提问</strong>自己哪门课学的比较好，为什么，紧张状态下真的话都说不清，很乱，这也是我面试唯一一个败笔….不过还好的是说完就冷静下来，继续回答问题。</p><p>自我介绍说想在大数据这方面继续深造，老师就问了<strong>为什么，如何看待大数据</strong>，一些理解把，<strong>延伸出去</strong>的问了如何看待大数据中的隐私问题，答完又问了解过隐私方面的协议，比如说XXX吗，确实没听过，就直说这个不是很了解。</p><p>整个面试还是比较轻松的，我的面试没那么难。</p><p>不过交流下来，差距还是挺大的，似乎只有我比较幸运，问的比较正常。其他的有很多挺难回答的问题，<strong>因老师和自我介绍而异</strong>把。</p><p><strong>面试的原则是实事求是，不会就是不会，还有就是更偏向随机应变，而不是死背稿子。</strong></p><p>在面试的时候一般都会很紧张，所以背的稿子几乎没啥用。甚至我的自我介绍都是临场发挥的，和稿子不大一样。</p><p><strong>建议</strong>是自我介绍好好写，记住大概要说的。然后基于自己的自我介绍，自己想可能会问啥问题，然后自己回答。</p><h3 id=\"联系导师签字\"><a href=\"#联系导师签字\" class=\"headerlink\" title=\"联系导师签字\"></a>联系导师签字</h3><p>面试完基本上就去找意向导师了，也有人第一天来就直接找了意向导师。</p><p>每个老师只能签四个人，所以说，如果去晚了，可能会没名额。</p><p>这个也挺难说，毕竟签了字，你也不一定能进南大，签了字，老师也不一定选你。</p><p><strong>这里的建议是：</strong><br>夏令营之前就了解好各个实验室的情况，起码有个大概了解。可以找本校的在南大读研的学长，让他给你说说情况，推荐下啥的。也可以避免踩雷。有了意向导师，在复审通过后就给老师发邮件，记得附上自己简历。</p><p>南大的实验室，除了LAMDA，其他的实力上来说应该差不多，只是有的比价偏理论，有的比较偏项目，有的比较综合，自己看方向和综合情况选把。</p><h2 id=\"第三天\"><a href=\"#第三天\" class=\"headerlink\" title=\"第三天\"></a>第三天</h2><p>机试面试结束，先让我玩一个晚上，享受四星级酒店的待遇再说吧～</p><hr><p>第三天并没有什么实质性的工作，主要就是听一个总结，然后见了导师，了解导师那边的情况，以及谈下自己来南大的可能性之类的，算是探探底。如果老师非常想要你，还是有可能会帮你的。</p><h1 id=\"一些保研注意点\"><a href=\"#一些保研注意点\" class=\"headerlink\" title=\"一些保研注意点\"></a>一些保研注意点</h1><ol><li>机试：<br>如果想去的学校有机试，一定一定要好好准备，提前准备，算法不是一星期两星期就能练好的。</li><li>报名：<br>提前列个表，有哪些大概能去冲一冲的学校。学校要多，表要长，夏令营的时候一定要尽量多参加。到了预推免还没OFFER，那预推免报名更要多报名。</li><li>冲刺好学校：<br>夏令营和预推免的时候，不要怕报名麻烦，报了就有希望，一定要多尝试。就算是北大软微，我现在都有点后悔没报名，因为有学校比我的差的，都能去试试。</li><li>后路：<br>永远不要太相信自己的实力，因为大部分学校面试占比很大，所以主观性很强。不管什么情况，一定要准备另一条后路。以及，最差情况的心理准备。甚至要做好本校资格拿不到，转战考研的准备。</li><li>联系导师：<br>夏令营阶段：有些学校导师的权利比较大，更尊重导师意见。这样的话，最好提前联系导师，来回多发几封邮件。让他看到你的优势，他如果想要你，会去争取。<br>预推免阶段：这时候，报了名，就得联系导师，不管能不能进复试。一方面是增加进复试以及拿到OFFER的几率，另一方面，你联系晚了，好导师就没名额了，都被预订了。</li><li>如果夏令营没有满意的OFFER：<br>夏令营结束，到预推免，有很长的时间，这段时间要加油，补短板。中间会有本校的保研，更不能掉链子，拿不到本校资格就完蛋了。还有最重要的是，没有好OFFER，预推免一定要光撒网。但是时间有限，安排好时间的前提下，多尝试想去的学校。因为预推免门槛比夏令营低，会有机会，就算没成，也能给自己增加补录几率。</li></ol><p>其他的一些问题，相信你们自己都可以处理好。</p><h1 id=\"最后的话\"><a href=\"#最后的话\" class=\"headerlink\" title=\"最后的话\"></a>最后的话</h1><p>后面得知并没有被录，而是在替补队列。距离被录取，差了大概20-30分。机试一个样例10分，差2-3个样例这样。</p><p>非常遗憾，但是心里还是感觉可以在9月被补录，因为南大夏令营最早，每年最后都会有很多人鸽。但是肯定不能把希望全放在南大上。所以后面参加了东南的预推免，以及9月报名的计算所的预推免。</p><p>拿到计算所的OFFER后，其他的预推免就全部拒绝了，没什么必要参加了。南大这边也有想过一点，万一有补录，怎么办。也只能拒绝。</p><p>到了28号0点，要填志愿了，这时候还没有打电话过来补录。想着应该不会补录了，只填了计算所一个志愿。</p><p>没想到第二天早上9点，南大打电话过来问有名额，要不要去。但是这时候已经太晚了，南大老师也很着急，于是直接拒绝了。把时间留给别人，可能很多人都在等补录。</p><p>现在想想心里还是很遗憾。整个保研过程，南大是我最想去的学校，也是准备时间最长的学校，计算所只是机缘巧合录了。从4月中旬，大概那时就开始准备南大的夏令营，虽然在期末之前准备的进度很慢，但是真的是花了很多时间练算法题。</p><p>断断续续准备了大概两个月。没想到拿了一个替补。也没想到最后给了名额，但是却拒绝了。如果计算所没录，可能最好的结果就是补录南大把。当初录取差了一点，后面所有的准备都不一样了，结果而言，也是真的就差了一点。</p><p>感慨还是很多，也想过如果当初，多练练常考题型，可能也不会有后面这么多曲折，这么多担心。做什么事情，还是需要全力以赴才能让自己不后悔。</p><p>保研已经结束了，希望未来四年，能更加努力，要为自己加油！</p><p>共勉！</p><hr><!-- rebuild by neat -->"},{"title":"每个人都需要一个引路人","comments":1,"mathjax":false,"date":"2019-10-16T15:14:02.000Z","urlname":"everyone-need-a-life-coach","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n\n前一阵子回了趟高中，时隔两年再次进入当初的校园，有点兴奋又有点感慨。\n如今已经是准研究生，又仿佛到了大学刚开学那时候。\n回顾之前的生活，由心的感叹，真的每个人都需要一个人生的引路人。\n{% endnote %}\n<!--more-->\n\n## 重返高中\n\n### 高中的变化\n毕业之后，高中变了很多。在操场后面建了体育馆，而且学校后面那条小河，以及附近的荒地，都被归入学校的范围了。在原有的基础上扩建了很多。原本的正门变成了后门，新建了一个更气派的大门。\n\n在学校门口看着以前小小的高中变了模样，心里还是很开心的。想着要见到班主任了，突然又有点紧张。印象里上次见他应该是大一的时候，那时还能有几个同伴，现在大家都很忙，就只有自己一个人孤零零的回来。\n\n### 我的班主任\n原本还担心这么久不见，会没有话可谈，没想到能和他聊一上午。似乎是因为穿着的问题，班主任看起来更加像是中年男人了。印象里高中那会，他看起来还是挺年轻的。\n\n班主任和学生之间的话题，似乎永远都会围绕着学习和日常生活，少有打趣和玩笑。\n\n在他面前，我似乎还是当初那个说着“你让我把目标定为年级前几，我现在做到了。”的那个孩子，不管过了几年，还是他的学生。\n\n高中那时候只想着好好学习，没那么多烦心事。偶尔以为自己成绩不错骄傲一下，在其他同学面前像个爱炫耀的小公鸡。现在想想真的很轻松，也很快乐。\n\n班上的同学似乎对班主任都有点偏见，总说他不靠谱，没其他班主任好。但我感觉，从心底他们还是非常认可他的，说的话似乎都是在开玩笑。老师说，毕业之后，很多人都私下和他有联系，更让我确定是这样。\n\n和他聊了很多，说了自己目前的现状，说到了未来的发展，说到了曾经的我们，还有现在的学弟学妹们。看得出来，老师对我回去看望他很开心，对我现在的发展也很满意。以后再回去可能得等毕业了。时间过得很快，总感觉还想呆在学校，呆在我的高中生活里。\n\n### 给高中学弟学妹们的话\n最后临走，在他现在带的班级里和学弟学妹们讲了点话。是，他还是做班主任，但是带的学生，却不是第一届了。\n\n看着学弟学妹们稚嫩的样子，心里感慨更多了。想说很多，又不知道从何说起。\n\n简单的提了一下自己认为高中很重要的学习方法，又提醒他们不要早恋。听老班说，现在的学生没有以前质量高了，而且都不在乎学业，没什么目标。我想，可能只有到最后，他们才能明白，高中是最应该好好读书的时候。\n\n最后还是提醒他们说要目光放长远点，但是，我感觉，这时候的这些小雏鹰，不到最后是不会明白这个道理的。\n\n讲的比较乱，后来回去也挺后悔，应该早点准备这个讲话。很多我认为应该告诉他们的，还是没有想起来。\n\n### 回去后的感叹\n高中，一个呈上启下的阶段，真的很重要。我认为除了好好学习，埋头刷题，学习方面还需要自我总结，好的学习方法从来都是自己总结出来的，别人的，真的不一定适合。这些总结学习方法的能力，并不是只适用于高中，大学乃至未来的生活都会用到。直接的表现就是，别人感觉你比他聪明，其实只是学习能力的一个提升。\n\n除了学习，我认为心理素质和精神素质的培养也很重要，当然，这是在大学才发现的。必须在高中就培养出较好的心理承受能力，比较平稳的，最好是积极乐观的心态。如果在高中这方面忽视了，结果很可能是大学的时候，承受不住各种压力，各种挫折失败，一次次的让自己崩溃。如果乐观还好，悲观的话，那带来的可能就是灾难性的后果，被压力打败，对未来没有希望，对自己没有信心，那很可能就会有抑郁症。\n\n除了这方面，还有需要重视的是对未来自己发展的一个规划。简单说就是自己未来的职业。这个选择，可能决定未来的人生。高考填专业，一方面是要看自己感不感兴趣，另一方面，是这个专业是否有前景。\n\n我认为，感兴趣可能要占到0.7的权重，前景可能只占到0.3。从大学开始，更多的是兴趣驱动。\n\n你应该做的是，将自己非常感兴趣的，有点兴趣的，可能感兴趣的，所有方向都列出来，然后在这里面挑选最有前景又有兴趣的。\n\n人生最完美的，就是能够把自己的兴趣作为职业。而这个决定权，在高考填志愿那时候的你手中。\n\n如果你没有选择自己感兴趣的，而是热门专业。那你要做的就是，在大学四年里，尽量对这个方向培养出兴趣。实在不喜欢，那你在大二下学期前就应该找到自己真正喜欢的方向。否则除非你不读研，不然会很累。\n\n如果你在高中找到了自己兴趣所在，又能学有余力。那希望你能够利用课余时间自学一下那方面的基础知识。\n\n你高中学的基础，都是你大学比别人优秀的资本。\n\n我是多希望当初能这样给学弟学妹们讲讲啊，这样他们会少走很多弯路，会有一个长远的视角。不会像我这样，只有自己吃了亏，才意识到当初应该怎样怎样。\n\n## 大学三年\n....\n","source":"_posts/每个人都需要一个引路人.md","raw":"---\ntitle: 每个人都需要一个引路人\ntags:\n  - Daily\n  - Lift\ncategories:\n  - Daily\ncomments: true\nmathjax: false\ndate: 2019-10-16 23:14:02\nurlname: everyone-need-a-life-coach\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n\n前一阵子回了趟高中，时隔两年再次进入当初的校园，有点兴奋又有点感慨。\n如今已经是准研究生，又仿佛到了大学刚开学那时候。\n回顾之前的生活，由心的感叹，真的每个人都需要一个人生的引路人。\n{% endnote %}\n<!--more-->\n\n## 重返高中\n\n### 高中的变化\n毕业之后，高中变了很多。在操场后面建了体育馆，而且学校后面那条小河，以及附近的荒地，都被归入学校的范围了。在原有的基础上扩建了很多。原本的正门变成了后门，新建了一个更气派的大门。\n\n在学校门口看着以前小小的高中变了模样，心里还是很开心的。想着要见到班主任了，突然又有点紧张。印象里上次见他应该是大一的时候，那时还能有几个同伴，现在大家都很忙，就只有自己一个人孤零零的回来。\n\n### 我的班主任\n原本还担心这么久不见，会没有话可谈，没想到能和他聊一上午。似乎是因为穿着的问题，班主任看起来更加像是中年男人了。印象里高中那会，他看起来还是挺年轻的。\n\n班主任和学生之间的话题，似乎永远都会围绕着学习和日常生活，少有打趣和玩笑。\n\n在他面前，我似乎还是当初那个说着“你让我把目标定为年级前几，我现在做到了。”的那个孩子，不管过了几年，还是他的学生。\n\n高中那时候只想着好好学习，没那么多烦心事。偶尔以为自己成绩不错骄傲一下，在其他同学面前像个爱炫耀的小公鸡。现在想想真的很轻松，也很快乐。\n\n班上的同学似乎对班主任都有点偏见，总说他不靠谱，没其他班主任好。但我感觉，从心底他们还是非常认可他的，说的话似乎都是在开玩笑。老师说，毕业之后，很多人都私下和他有联系，更让我确定是这样。\n\n和他聊了很多，说了自己目前的现状，说到了未来的发展，说到了曾经的我们，还有现在的学弟学妹们。看得出来，老师对我回去看望他很开心，对我现在的发展也很满意。以后再回去可能得等毕业了。时间过得很快，总感觉还想呆在学校，呆在我的高中生活里。\n\n### 给高中学弟学妹们的话\n最后临走，在他现在带的班级里和学弟学妹们讲了点话。是，他还是做班主任，但是带的学生，却不是第一届了。\n\n看着学弟学妹们稚嫩的样子，心里感慨更多了。想说很多，又不知道从何说起。\n\n简单的提了一下自己认为高中很重要的学习方法，又提醒他们不要早恋。听老班说，现在的学生没有以前质量高了，而且都不在乎学业，没什么目标。我想，可能只有到最后，他们才能明白，高中是最应该好好读书的时候。\n\n最后还是提醒他们说要目光放长远点，但是，我感觉，这时候的这些小雏鹰，不到最后是不会明白这个道理的。\n\n讲的比较乱，后来回去也挺后悔，应该早点准备这个讲话。很多我认为应该告诉他们的，还是没有想起来。\n\n### 回去后的感叹\n高中，一个呈上启下的阶段，真的很重要。我认为除了好好学习，埋头刷题，学习方面还需要自我总结，好的学习方法从来都是自己总结出来的，别人的，真的不一定适合。这些总结学习方法的能力，并不是只适用于高中，大学乃至未来的生活都会用到。直接的表现就是，别人感觉你比他聪明，其实只是学习能力的一个提升。\n\n除了学习，我认为心理素质和精神素质的培养也很重要，当然，这是在大学才发现的。必须在高中就培养出较好的心理承受能力，比较平稳的，最好是积极乐观的心态。如果在高中这方面忽视了，结果很可能是大学的时候，承受不住各种压力，各种挫折失败，一次次的让自己崩溃。如果乐观还好，悲观的话，那带来的可能就是灾难性的后果，被压力打败，对未来没有希望，对自己没有信心，那很可能就会有抑郁症。\n\n除了这方面，还有需要重视的是对未来自己发展的一个规划。简单说就是自己未来的职业。这个选择，可能决定未来的人生。高考填专业，一方面是要看自己感不感兴趣，另一方面，是这个专业是否有前景。\n\n我认为，感兴趣可能要占到0.7的权重，前景可能只占到0.3。从大学开始，更多的是兴趣驱动。\n\n你应该做的是，将自己非常感兴趣的，有点兴趣的，可能感兴趣的，所有方向都列出来，然后在这里面挑选最有前景又有兴趣的。\n\n人生最完美的，就是能够把自己的兴趣作为职业。而这个决定权，在高考填志愿那时候的你手中。\n\n如果你没有选择自己感兴趣的，而是热门专业。那你要做的就是，在大学四年里，尽量对这个方向培养出兴趣。实在不喜欢，那你在大二下学期前就应该找到自己真正喜欢的方向。否则除非你不读研，不然会很累。\n\n如果你在高中找到了自己兴趣所在，又能学有余力。那希望你能够利用课余时间自学一下那方面的基础知识。\n\n你高中学的基础，都是你大学比别人优秀的资本。\n\n我是多希望当初能这样给学弟学妹们讲讲啊，这样他们会少走很多弯路，会有一个长远的视角。不会像我这样，只有自己吃了亏，才意识到当初应该怎样怎样。\n\n## 大学三年\n....\n","slug":"每个人都需要一个引路人","published":1,"updated":"2019-10-20T11:54:49.141Z","layout":"post","photos":[],"link":"","_id":"ck2424lme003blksbjgss5z17","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前一阵子回了趟高中，时隔两年再次进入当初的校园，有点兴奋又有点感慨。<br>如今已经是准研究生，又仿佛到了大学刚开学那时候。<br>回顾之前的生活，由心的感叹，真的每个人都需要一个人生的引路人。</p></div><a id=\"more\"></a><h2 id=\"重返高中\"><a href=\"#重返高中\" class=\"headerlink\" title=\"重返高中\"></a>重返高中</h2><h3 id=\"高中的变化\"><a href=\"#高中的变化\" class=\"headerlink\" title=\"高中的变化\"></a>高中的变化</h3><p>毕业之后，高中变了很多。在操场后面建了体育馆，而且学校后面那条小河，以及附近的荒地，都被归入学校的范围了。在原有的基础上扩建了很多。原本的正门变成了后门，新建了一个更气派的大门。</p><p>在学校门口看着以前小小的高中变了模样，心里还是很开心的。想着要见到班主任了，突然又有点紧张。印象里上次见他应该是大一的时候，那时还能有几个同伴，现在大家都很忙，就只有自己一个人孤零零的回来。</p><h3 id=\"我的班主任\"><a href=\"#我的班主任\" class=\"headerlink\" title=\"我的班主任\"></a>我的班主任</h3><p>原本还担心这么久不见，会没有话可谈，没想到能和他聊一上午。似乎是因为穿着的问题，班主任看起来更加像是中年男人了。印象里高中那会，他看起来还是挺年轻的。</p><p>班主任和学生之间的话题，似乎永远都会围绕着学习和日常生活，少有打趣和玩笑。</p><p>在他面前，我似乎还是当初那个说着“你让我把目标定为年级前几，我现在做到了。”的那个孩子，不管过了几年，还是他的学生。</p><p>高中那时候只想着好好学习，没那么多烦心事。偶尔以为自己成绩不错骄傲一下，在其他同学面前像个爱炫耀的小公鸡。现在想想真的很轻松，也很快乐。</p><p>班上的同学似乎对班主任都有点偏见，总说他不靠谱，没其他班主任好。但我感觉，从心底他们还是非常认可他的，说的话似乎都是在开玩笑。老师说，毕业之后，很多人都私下和他有联系，更让我确定是这样。</p><p>和他聊了很多，说了自己目前的现状，说到了未来的发展，说到了曾经的我们，还有现在的学弟学妹们。看得出来，老师对我回去看望他很开心，对我现在的发展也很满意。以后再回去可能得等毕业了。时间过得很快，总感觉还想呆在学校，呆在我的高中生活里。</p><h3 id=\"给高中学弟学妹们的话\"><a href=\"#给高中学弟学妹们的话\" class=\"headerlink\" title=\"给高中学弟学妹们的话\"></a>给高中学弟学妹们的话</h3><p>最后临走，在他现在带的班级里和学弟学妹们讲了点话。是，他还是做班主任，但是带的学生，却不是第一届了。</p><p>看着学弟学妹们稚嫩的样子，心里感慨更多了。想说很多，又不知道从何说起。</p><p>简单的提了一下自己认为高中很重要的学习方法，又提醒他们不要早恋。听老班说，现在的学生没有以前质量高了，而且都不在乎学业，没什么目标。我想，可能只有到最后，他们才能明白，高中是最应该好好读书的时候。</p><p>最后还是提醒他们说要目光放长远点，但是，我感觉，这时候的这些小雏鹰，不到最后是不会明白这个道理的。</p><p>讲的比较乱，后来回去也挺后悔，应该早点准备这个讲话。很多我认为应该告诉他们的，还是没有想起来。</p><h3 id=\"回去后的感叹\"><a href=\"#回去后的感叹\" class=\"headerlink\" title=\"回去后的感叹\"></a>回去后的感叹</h3><p>高中，一个呈上启下的阶段，真的很重要。我认为除了好好学习，埋头刷题，学习方面还需要自我总结，好的学习方法从来都是自己总结出来的，别人的，真的不一定适合。这些总结学习方法的能力，并不是只适用于高中，大学乃至未来的生活都会用到。直接的表现就是，别人感觉你比他聪明，其实只是学习能力的一个提升。</p><p>除了学习，我认为心理素质和精神素质的培养也很重要，当然，这是在大学才发现的。必须在高中就培养出较好的心理承受能力，比较平稳的，最好是积极乐观的心态。如果在高中这方面忽视了，结果很可能是大学的时候，承受不住各种压力，各种挫折失败，一次次的让自己崩溃。如果乐观还好，悲观的话，那带来的可能就是灾难性的后果，被压力打败，对未来没有希望，对自己没有信心，那很可能就会有抑郁症。</p><p>除了这方面，还有需要重视的是对未来自己发展的一个规划。简单说就是自己未来的职业。这个选择，可能决定未来的人生。高考填专业，一方面是要看自己感不感兴趣，另一方面，是这个专业是否有前景。</p><p>我认为，感兴趣可能要占到0.7的权重，前景可能只占到0.3。从大学开始，更多的是兴趣驱动。</p><p>你应该做的是，将自己非常感兴趣的，有点兴趣的，可能感兴趣的，所有方向都列出来，然后在这里面挑选最有前景又有兴趣的。</p><p>人生最完美的，就是能够把自己的兴趣作为职业。而这个决定权，在高考填志愿那时候的你手中。</p><p>如果你没有选择自己感兴趣的，而是热门专业。那你要做的就是，在大学四年里，尽量对这个方向培养出兴趣。实在不喜欢，那你在大二下学期前就应该找到自己真正喜欢的方向。否则除非你不读研，不然会很累。</p><p>如果你在高中找到了自己兴趣所在，又能学有余力。那希望你能够利用课余时间自学一下那方面的基础知识。</p><p>你高中学的基础，都是你大学比别人优秀的资本。</p><p>我是多希望当初能这样给学弟学妹们讲讲啊，这样他们会少走很多弯路，会有一个长远的视角。不会像我这样，只有自己吃了亏，才意识到当初应该怎样怎样。</p><h2 id=\"大学三年\"><a href=\"#大学三年\" class=\"headerlink\" title=\"大学三年\"></a>大学三年</h2><p>….</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前一阵子回了趟高中，时隔两年再次进入当初的校园，有点兴奋又有点感慨。<br>如今已经是准研究生，又仿佛到了大学刚开学那时候。<br>回顾之前的生活，由心的感叹，真的每个人都需要一个人生的引路人。</p></div>","more":"<h2 id=\"重返高中\"><a href=\"#重返高中\" class=\"headerlink\" title=\"重返高中\"></a>重返高中</h2><h3 id=\"高中的变化\"><a href=\"#高中的变化\" class=\"headerlink\" title=\"高中的变化\"></a>高中的变化</h3><p>毕业之后，高中变了很多。在操场后面建了体育馆，而且学校后面那条小河，以及附近的荒地，都被归入学校的范围了。在原有的基础上扩建了很多。原本的正门变成了后门，新建了一个更气派的大门。</p><p>在学校门口看着以前小小的高中变了模样，心里还是很开心的。想着要见到班主任了，突然又有点紧张。印象里上次见他应该是大一的时候，那时还能有几个同伴，现在大家都很忙，就只有自己一个人孤零零的回来。</p><h3 id=\"我的班主任\"><a href=\"#我的班主任\" class=\"headerlink\" title=\"我的班主任\"></a>我的班主任</h3><p>原本还担心这么久不见，会没有话可谈，没想到能和他聊一上午。似乎是因为穿着的问题，班主任看起来更加像是中年男人了。印象里高中那会，他看起来还是挺年轻的。</p><p>班主任和学生之间的话题，似乎永远都会围绕着学习和日常生活，少有打趣和玩笑。</p><p>在他面前，我似乎还是当初那个说着“你让我把目标定为年级前几，我现在做到了。”的那个孩子，不管过了几年，还是他的学生。</p><p>高中那时候只想着好好学习，没那么多烦心事。偶尔以为自己成绩不错骄傲一下，在其他同学面前像个爱炫耀的小公鸡。现在想想真的很轻松，也很快乐。</p><p>班上的同学似乎对班主任都有点偏见，总说他不靠谱，没其他班主任好。但我感觉，从心底他们还是非常认可他的，说的话似乎都是在开玩笑。老师说，毕业之后，很多人都私下和他有联系，更让我确定是这样。</p><p>和他聊了很多，说了自己目前的现状，说到了未来的发展，说到了曾经的我们，还有现在的学弟学妹们。看得出来，老师对我回去看望他很开心，对我现在的发展也很满意。以后再回去可能得等毕业了。时间过得很快，总感觉还想呆在学校，呆在我的高中生活里。</p><h3 id=\"给高中学弟学妹们的话\"><a href=\"#给高中学弟学妹们的话\" class=\"headerlink\" title=\"给高中学弟学妹们的话\"></a>给高中学弟学妹们的话</h3><p>最后临走，在他现在带的班级里和学弟学妹们讲了点话。是，他还是做班主任，但是带的学生，却不是第一届了。</p><p>看着学弟学妹们稚嫩的样子，心里感慨更多了。想说很多，又不知道从何说起。</p><p>简单的提了一下自己认为高中很重要的学习方法，又提醒他们不要早恋。听老班说，现在的学生没有以前质量高了，而且都不在乎学业，没什么目标。我想，可能只有到最后，他们才能明白，高中是最应该好好读书的时候。</p><p>最后还是提醒他们说要目光放长远点，但是，我感觉，这时候的这些小雏鹰，不到最后是不会明白这个道理的。</p><p>讲的比较乱，后来回去也挺后悔，应该早点准备这个讲话。很多我认为应该告诉他们的，还是没有想起来。</p><h3 id=\"回去后的感叹\"><a href=\"#回去后的感叹\" class=\"headerlink\" title=\"回去后的感叹\"></a>回去后的感叹</h3><p>高中，一个呈上启下的阶段，真的很重要。我认为除了好好学习，埋头刷题，学习方面还需要自我总结，好的学习方法从来都是自己总结出来的，别人的，真的不一定适合。这些总结学习方法的能力，并不是只适用于高中，大学乃至未来的生活都会用到。直接的表现就是，别人感觉你比他聪明，其实只是学习能力的一个提升。</p><p>除了学习，我认为心理素质和精神素质的培养也很重要，当然，这是在大学才发现的。必须在高中就培养出较好的心理承受能力，比较平稳的，最好是积极乐观的心态。如果在高中这方面忽视了，结果很可能是大学的时候，承受不住各种压力，各种挫折失败，一次次的让自己崩溃。如果乐观还好，悲观的话，那带来的可能就是灾难性的后果，被压力打败，对未来没有希望，对自己没有信心，那很可能就会有抑郁症。</p><p>除了这方面，还有需要重视的是对未来自己发展的一个规划。简单说就是自己未来的职业。这个选择，可能决定未来的人生。高考填专业，一方面是要看自己感不感兴趣，另一方面，是这个专业是否有前景。</p><p>我认为，感兴趣可能要占到0.7的权重，前景可能只占到0.3。从大学开始，更多的是兴趣驱动。</p><p>你应该做的是，将自己非常感兴趣的，有点兴趣的，可能感兴趣的，所有方向都列出来，然后在这里面挑选最有前景又有兴趣的。</p><p>人生最完美的，就是能够把自己的兴趣作为职业。而这个决定权，在高考填志愿那时候的你手中。</p><p>如果你没有选择自己感兴趣的，而是热门专业。那你要做的就是，在大学四年里，尽量对这个方向培养出兴趣。实在不喜欢，那你在大二下学期前就应该找到自己真正喜欢的方向。否则除非你不读研，不然会很累。</p><p>如果你在高中找到了自己兴趣所在，又能学有余力。那希望你能够利用课余时间自学一下那方面的基础知识。</p><p>你高中学的基础，都是你大学比别人优秀的资本。</p><p>我是多希望当初能这样给学弟学妹们讲讲啊，这样他们会少走很多弯路，会有一个长远的视角。不会像我这样，只有自己吃了亏，才意识到当初应该怎样怎样。</p><h2 id=\"大学三年\"><a href=\"#大学三年\" class=\"headerlink\" title=\"大学三年\"></a>大学三年</h2><p>….</p><!-- rebuild by neat -->"},{"title":"MNIST入门-手写数字识别问题集锦","comments":1,"mathjax":false,"date":"2019-04-17T18:12:37.000Z","urlname":"mnist-beginner-digitrecognization-problems","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n记录一下手写数字识别这个项目过程中遇到的问题，以及解决方法，还有一些图像处理方面的文章推荐\n{% endnote %}\n<!--more-->\n## canvas画笔位置有偏移\n- 使用`window.innerHeight || document.documentElement.clientHeight`语句获取视窗高度，同理获得宽度\n- 移动端获得视窗的高度和宽度后，根据高视窗的大小设置canvas大小，以及下方按钮文字等大小\n- PC端通过canvas的`mousedown、mousemove、mouseup`这三个事件绘图，画笔的起始点和新点用`event.clientX - canvas.offsetLeft`获取x，同理获取y,\n- 移动端用`touchstart、touchmove、touchend`这三个事件，画笔的起始点和终点都用`event.targetTouches[0].clientX - canvas.offsetLeft`获取x，`event.targetTouches[0].clientY - canvas.offsetTop`获取y\n\n## canvas用二次贝塞尔曲线绘图\n**PC端mousemove事件代码**\n\n```javascript\n//PC端鼠标移动\nfunction draw(event) {\n  if (onoff == true) {\n    //获取新点和中点\n    var newx = event.clientX - canvas.offsetLeft;\n    var newy = event.clientY - canvas.offsetTop;\n    midx = 0.5*(newx+oldx);\n    midy = 0.5*(newy+oldy);\n\n    //设置粗细和颜色\n    ctx.lineWidth = linew;\n    ctx.strokeStyle = linecolor;\n    ctx.lineCap = 'round';\n\n    //绘制二次贝塞尔\n    ctx.moveTo(oldx,oldy);\n    ctx.quadraticCurveTo( midx , midy , newx , newy );\n    ctx.stroke();\n\n    //转移新旧坐标\n    oldx = newx;\n    oldy = newy;\n  };\n}\n```\n\n**mobile端mousemove事件代码**\n\n```javascript\n//移动端手指移动\nfunction tMove(event){\n  //获取新点和中点\n  var touche = event.targetTouches[0];\n  var newx = touche.clientX - canvas.offsetLeft;\n  var newy = touche.clientY - canvas.offsetTop;\n  midx = 0.5*(newx+oldx);\n  midy = 0.5*(newy+oldy);\n\n  //设置粗细和颜色\n  ctx.lineWidth = linew;\n  ctx.strokeStyle = linecolor;\n  ctx.lineCap = 'round'\n\n  ctx.beginPath();\n  ctx.moveTo(oldx,oldy);\n  ctx.quadraticCurveTo(midx,midy,newx,newy);\n  ctx.stroke();\n\n  oldx = newx;\n  oldy = newy;\n}\n```\n\n## canvas的imageData像素级缩放\n想要获得canvas上的图像并且缩放到28\\*28，使用scale方法是不行的，必须获取所有的像素RGBA值，然后横向隔一段取一个点，竖向隔几行取一行，一共横向每行取28个像素点，竖向取28行\n\n代码如下：\n\n```javascript\n//缩放imageData,scale:倍数,返回:imageData\nfunction scaleImageData(imageData, scale) {\n  var scaled =\n      ctx.createImageData(imageData.width * scale, imageData.height * scale);\n  for (var row = 0; row < imageData.height; row++) {\n    for (var col = 0; col < imageData.width; col++) {\n      var sourcePixel = [\n        imageData.data[(row * imageData.width + col) * 4 + 0],\n        imageData.data[(row * imageData.width + col) * 4 + 1],\n        imageData.data[(row * imageData.width + col) * 4 + 2],\n        imageData.data[(row * imageData.width + col) * 4 + 3]\n      ];\n      for (var y = 0; y < scale; y++) {\n        var destRow = Math.floor(row * scale) + y;\n        for (var x = 0; x < scale; x++) {\n          var destCol = Math.floor(col * scale) + x;\n          for (var i = 0; i < 4; i++) {\n            scaled.data[(destRow * scaled.width + destCol) * 4 + i] = sourcePixel[i];\n          }\n        }\n      }\n    }\n  }\n//  alert(scaled.data.length);\n  return scaled;\n}\n```\n\n## 获取服务器的ip\n这里取巧了，直接从浏览器显示部分获取\n代码如下：\n\n```java\n//获取服务器ip，运行时urlPath为https://192.168.137.1:8000/\nfunction getRemoteIp(){\n  var urlPath = window.document.location.href;  //浏览器显示地址 http://10.15.5.83:5555/ISV/demo.aspx?a=1&b=2\n  // var docPath = window.document.location.pathname; //文件在服务器相对地址 /ISV/demo.aspx\n  // var index = urlPath.indexOf(docPath);\n  var serverPath = urlPath.substring(7, urlPath.length-1);//服务器ip 192.168.137.1\n  return serverPath;\n}\n```\n\n## UA检测\n因为要适配移动端和PC端，所以简单的UA检测还是必要的，这里没有做的很复杂   \n主要就是通过检测`navigator.platfowm`中的关键词来判断\n\n代码如下：\n\n```java\nvar ua = navigator.userAgent; \nvar system = {\n  win : false,\n  mac : false,\n  linux : false,\n  // mobile\n  iphone : false,\n  android : false,\n};\n\nvar p = navigator.platform;\nsystem.win = p.indexOf('Win') == 0;\nsystem.mac = p.indexOf('Mac') == 0;\nsystem.linux = p.indexOf('Linux') == 0;\nsystem.iphone = ua.indexOf('iPhone') > -1;\nsystem.android = ua.indexOf('Android') > -1\n\nif(system.win||system.mac){\n    ...\n} else if(system.android||system.iphone){\n    ...\n}\n```\n\n## python根据数组生成图片\ndtype一定要写的，不写生成错误\nimgData就是图片的RGBA数据数组，要转成np数组才可以用PIL的Image.fromarray()\n\n```python\narray = np.asarray(imgData, dtype=np.uint8)\nimage = Image.fromarray(array, 'RGBA') \nimage.save(outputImgPath + imgName +'.png')\n```\n\n## 将RGBA转换为RGB格式数组\n网上看了很多，有用PIL的，还有直接写算法转换的，用opencv的...很多  \n这里发现PIL的不好用，读出来还是RGBA的格式，而且没办法用函数在数组上转换\n\n最后解决办法是:\n- 从前端传过来的数据是字典类型，先获取values()\n- 将dict.vlues这个数组转换为ndarray数组\n- 转换完了,再把这个RGBA数组用 PIL 转换为图片\n- 用save()方法保存为临时图片\n- 用opencv读取临时图片的RGB通道的数据\n\n```java\n# 将图片数据转换为ndarray类型\nnpData = np.array(imageData,dtype=np.uint8).reshape(28,28,4)\n# 将RGBA格式数组转换为图片\nimage = Image.fromarray(npData, 'RGBA') \n# 保存临时图片\nimage.save('static/images/npimg.png')\n\n# 用opencv读取图片的RGB数据\nrgbImage = cv2.imread('static/images/npimg.png', cv2.IMREAD_COLOR) \n```\n\n## cv2.imread(path[, flags])\ncv2的imread函数的第二个参数这里说明下:\n> 如果不设置，读进来的是BGR格式的数据，值在0-255,flag一共有3个取值\n> cv2.IMREAD_COLOR : 读入彩色图片,任何与透明度相关通道的会被忽视,默认以这种方式读入.\n> cv2.IMREAD_GRAYSCALE : 以灰度图的形式读入图片\n> cv2.IMREAD_UNCHANGED : 保留读取图片原有的颜色通道.\n\n可以简单的用**-1,0,1**来分别表示这3个flag\n\n\n## Python图像处理\n### 图片的读写方式总结\n找到一个很全的博客，推荐一下：[Python各类图像库的图片读写方式总结](https://www.jb51.net/article/135307.htm)\n\n### opencv的基本操作\n推荐看看这篇文章：[点击跳转](https://www.jianshu.com/p/ed00179ede34)\n\n### tensorflow简单的图像处理\n推荐链接：[使用TensorFlow进行简单的图像处理](https://blog.csdn.net/jia20003/article/details/79118769)\n\n### PIL格式转换\n推荐链接：[Python图像处理库PIL中图像格式转换（一）](https://blog.csdn.net/icamera0/article/details/50843172)\n\n## 对图片灰度化\n如果只是灰度的话可以用PIL的convert函数，很方便，但是这里要用tensorflow，所以得用`tf.image_to_grayscale(imageData)`这个函数。注意事先要先将数据格式转换为`tf.float32`类型的\n\n```python\n# 将rgb图片转换为float32格式\nrgbImage = tf.image.convert_image_dtype(rgbImage, tf.float32)\n# 将图片灰度化得到(28,28,1)格式的tensor\nrgbImage = tf.image.rgb_to_grayscale(rgbImage\n```\n\n## 后端改变图片的背景和画笔颜色数据\n出于美观，前端并不是黑底白字，但是模型训练的是黑底白字的，虽然后面测试用了灰度数据，还是会不准确，所以在数据处理前，对imageData中的部分像素进行修改，将橙色变为黑色，黑色画笔变为白色\n\n```python\n# 将橙色的背景转换为黑色,将画笔的黑色转为白色\n# input: RGBA格式图片数据\n# output: 修改过的RGBA格式图片数据\ndef reveBlack(imageData):\n    for i in range(0,len(imageData),4):\n        # 如果画笔为白色\n        if imageData[i]==0 and imageData[i+1]==0 and imageData[i+2]==0:\n            imageData[i]=imageData[i+1]=imageData[i+2]=255\n        # 如果背景为橙色\n        if imageData[i]==255 and imageData[i+1]==165 and imageData[i+2]==0:\n            imageData[i]=imageData[i+1]=imageData[i+2]=0\n    return imageDat\n```\n\n## tensor和numpy数组转换\n### tensor转ndarray\n由于项目里面是模型恢复，所以没有初始化这步\n有两种方法：\n\n```python\n### 将tensor转换为ndarray\ninit = tf.initialize_all_variables()\nwith tf.Session() as sess:\n    sess.run(init)\n    # 第一种\n    ndName = tensorName1.eval(session=sess)\n    #第二种\n    ndName = sess.run(tensorName2)\n```\n\n\n## ndarray转tensor\n\n```python\n# 将ndarray转换为tensor\ntensorName =  tf.convert_to_tensor(ndName, dtype = tf.float32)\n```\n\n\n## 使用训练好的模型\n**参考链接：**[言初见的CSDN博客](https://blog.csdn.net/yanchujian88/article/details/80559936)\n\n训练用的算法是Lenet-5，下面的代码是部分调用模型代码，因为只有一张图片的数据，并不是用整个测试集，所以有些地方会有点不一样\n\n主要还是通过恢复模型，传入图片数据来获得预测结果\n\n注意点：\n1. x占位符的shape，要注意个train的一致，第一个shape要是1，因为只有一个图片\n2. 使用tf.argmax(y,1)函数获得最大预测的下标,这里就是结果了，因为是0-9正好对应了下标\n3. 输入的feed_dict测试数据必须是ndarray，不可以是tensor，因此要转换以下\n\n代码如下：\n\n```python\n# 定义输入格式(1,28,28,1)\nx = tf.placeholder(tf.float32, [1, \n                                mnist_inference.IMAGE_SIZE, \n                                mnist_inference.IMAGE_SIZE, \n                                mnist_inference.NUM_CHANNEL], \n                                name='x-input')\n#直接通过调用封装好的函数来计算前向传播的结果 \ny = mnist_inference.interence(x,None, None)\n\n#使用tf.argmax(y, 1)就可以得到输入样例的预测类别 \nprediction = tf.argmax(y, 1)\n\n# 通过变量重命名的方式来加载模型\n# 所有滑动平均的值组成的字典,处在/ExponentialMovingAverage下的值  \n# 为了方便加载时重命名滑动平均量，tf.train.ExponentialMovingAverage类  \n# 提供了variables_to_store函数来生成tf.train.Saver类所需要的变量  \n# 这些值要从模型中提取\nvariable_averages = tf.train.ExponentialMovingAverage(mnist_train.MOVING_AVERAGE_DECAY)\nvariable_to_restore = variable_averages.variables_to_restore()\nsaver = tf.train.Saver(variable_to_restore)\n\n# 用数据测试模型\nwith tf.Session() as sess: \n    # get_checkoutpoint_state()会通过checkoutpoint文件自动找到目录中最新模型的文件名\n    ckpt = tf.train.get_checkpoint_state(mnist_train.MODEL_PATH)\n    if ckpt and ckpt.model_checkpoint_path:\n        # 加载模型\n        saver.restore(sess, ckpt.model_checkpoint_path)\n\n        # 将tensor转换为np数组,这里也可以用np的reshape方法\n        rgbNpData = tf.reshape(rgbImage,[1,\n                                            mnist_inference.IMAGE_SIZE, \n                                            mnist_inference.IMAGE_SIZE, \n                                            mnist_inference.NUM_CHANNEL])\n        # 将tensor转换为ndarray\n        reshaped_data = rgbNpData.eval()\n        # 将输入的测试数据格式调整为一个四维矩阵\n        validate_feed = {x: reshaped_data}\n\n        # 获得预测的结果数组\n        predictionNum = sess.run(prediction, feed_dict = validate_feed)\n        print(\"Number is %d\" %(predictionNum[0]))\n\ntf.reset_default_graph()\n```\n\n## 报错：Error: the tensor's graph is different from the session's graph\n这是因为session里面的图和使用的图不一样导致的，刚开始不清楚，把参考的博客上面的那句： with tf.Graph().as_default() as g:写上去了，导致默认图被设置成了g，但是用的又是恢复的图，所以不一样了\n\n解决办法炒鸡简单...但是debug的过程里就一直没意识到就是了...就是把那句话去掉就行了哇\n\n## 报错：List of Tensors when single Tensor expected\n使用tf.constant()函数的时候可能会报这个错误\n\n看看这个函数的定义：\n> def constant(value, dtype=None, shape=None, name=\"Const\", verify_shape=False)\n> value: A constant value (or list) of output type dtype.\n> Returns: A Constant Tensor.\n\n问题也应该清楚了，constant要求输入的是list，用的时候如果传入了tensor类型的，当然就不可以了\n\n## 总结\n遇到的问题还是很多的，好几个bug都折磨了我几个小时，找不到bug在哪太艰难了，深深的感受到要学了点基础再来做项目，就说这个tensorflow，没有大致的学一遍，遇到问题完全就是无头苍蝇，不好排错\n\n一个项目学到的东西还是挺多的，实战真的很重要啊\n","source":"_posts/MachineLearning/MNIST入门-手写数字识别问题集锦.md","raw":"---\ntitle: MNIST入门-手写数字识别问题集锦\ncomments: true\nmathjax: false\ndate: 2019-04-18 02:12:37\ntags: [Daily, MNIST, Tensorflow, LeNet-5, Problems,ML]\ncategories: MachineLearning\nurlname: mnist-beginner-digitrecognization-problems\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n记录一下手写数字识别这个项目过程中遇到的问题，以及解决方法，还有一些图像处理方面的文章推荐\n{% endnote %}\n<!--more-->\n## canvas画笔位置有偏移\n- 使用`window.innerHeight || document.documentElement.clientHeight`语句获取视窗高度，同理获得宽度\n- 移动端获得视窗的高度和宽度后，根据高视窗的大小设置canvas大小，以及下方按钮文字等大小\n- PC端通过canvas的`mousedown、mousemove、mouseup`这三个事件绘图，画笔的起始点和新点用`event.clientX - canvas.offsetLeft`获取x，同理获取y,\n- 移动端用`touchstart、touchmove、touchend`这三个事件，画笔的起始点和终点都用`event.targetTouches[0].clientX - canvas.offsetLeft`获取x，`event.targetTouches[0].clientY - canvas.offsetTop`获取y\n\n## canvas用二次贝塞尔曲线绘图\n**PC端mousemove事件代码**\n\n```javascript\n//PC端鼠标移动\nfunction draw(event) {\n  if (onoff == true) {\n    //获取新点和中点\n    var newx = event.clientX - canvas.offsetLeft;\n    var newy = event.clientY - canvas.offsetTop;\n    midx = 0.5*(newx+oldx);\n    midy = 0.5*(newy+oldy);\n\n    //设置粗细和颜色\n    ctx.lineWidth = linew;\n    ctx.strokeStyle = linecolor;\n    ctx.lineCap = 'round';\n\n    //绘制二次贝塞尔\n    ctx.moveTo(oldx,oldy);\n    ctx.quadraticCurveTo( midx , midy , newx , newy );\n    ctx.stroke();\n\n    //转移新旧坐标\n    oldx = newx;\n    oldy = newy;\n  };\n}\n```\n\n**mobile端mousemove事件代码**\n\n```javascript\n//移动端手指移动\nfunction tMove(event){\n  //获取新点和中点\n  var touche = event.targetTouches[0];\n  var newx = touche.clientX - canvas.offsetLeft;\n  var newy = touche.clientY - canvas.offsetTop;\n  midx = 0.5*(newx+oldx);\n  midy = 0.5*(newy+oldy);\n\n  //设置粗细和颜色\n  ctx.lineWidth = linew;\n  ctx.strokeStyle = linecolor;\n  ctx.lineCap = 'round'\n\n  ctx.beginPath();\n  ctx.moveTo(oldx,oldy);\n  ctx.quadraticCurveTo(midx,midy,newx,newy);\n  ctx.stroke();\n\n  oldx = newx;\n  oldy = newy;\n}\n```\n\n## canvas的imageData像素级缩放\n想要获得canvas上的图像并且缩放到28\\*28，使用scale方法是不行的，必须获取所有的像素RGBA值，然后横向隔一段取一个点，竖向隔几行取一行，一共横向每行取28个像素点，竖向取28行\n\n代码如下：\n\n```javascript\n//缩放imageData,scale:倍数,返回:imageData\nfunction scaleImageData(imageData, scale) {\n  var scaled =\n      ctx.createImageData(imageData.width * scale, imageData.height * scale);\n  for (var row = 0; row < imageData.height; row++) {\n    for (var col = 0; col < imageData.width; col++) {\n      var sourcePixel = [\n        imageData.data[(row * imageData.width + col) * 4 + 0],\n        imageData.data[(row * imageData.width + col) * 4 + 1],\n        imageData.data[(row * imageData.width + col) * 4 + 2],\n        imageData.data[(row * imageData.width + col) * 4 + 3]\n      ];\n      for (var y = 0; y < scale; y++) {\n        var destRow = Math.floor(row * scale) + y;\n        for (var x = 0; x < scale; x++) {\n          var destCol = Math.floor(col * scale) + x;\n          for (var i = 0; i < 4; i++) {\n            scaled.data[(destRow * scaled.width + destCol) * 4 + i] = sourcePixel[i];\n          }\n        }\n      }\n    }\n  }\n//  alert(scaled.data.length);\n  return scaled;\n}\n```\n\n## 获取服务器的ip\n这里取巧了，直接从浏览器显示部分获取\n代码如下：\n\n```java\n//获取服务器ip，运行时urlPath为https://192.168.137.1:8000/\nfunction getRemoteIp(){\n  var urlPath = window.document.location.href;  //浏览器显示地址 http://10.15.5.83:5555/ISV/demo.aspx?a=1&b=2\n  // var docPath = window.document.location.pathname; //文件在服务器相对地址 /ISV/demo.aspx\n  // var index = urlPath.indexOf(docPath);\n  var serverPath = urlPath.substring(7, urlPath.length-1);//服务器ip 192.168.137.1\n  return serverPath;\n}\n```\n\n## UA检测\n因为要适配移动端和PC端，所以简单的UA检测还是必要的，这里没有做的很复杂   \n主要就是通过检测`navigator.platfowm`中的关键词来判断\n\n代码如下：\n\n```java\nvar ua = navigator.userAgent; \nvar system = {\n  win : false,\n  mac : false,\n  linux : false,\n  // mobile\n  iphone : false,\n  android : false,\n};\n\nvar p = navigator.platform;\nsystem.win = p.indexOf('Win') == 0;\nsystem.mac = p.indexOf('Mac') == 0;\nsystem.linux = p.indexOf('Linux') == 0;\nsystem.iphone = ua.indexOf('iPhone') > -1;\nsystem.android = ua.indexOf('Android') > -1\n\nif(system.win||system.mac){\n    ...\n} else if(system.android||system.iphone){\n    ...\n}\n```\n\n## python根据数组生成图片\ndtype一定要写的，不写生成错误\nimgData就是图片的RGBA数据数组，要转成np数组才可以用PIL的Image.fromarray()\n\n```python\narray = np.asarray(imgData, dtype=np.uint8)\nimage = Image.fromarray(array, 'RGBA') \nimage.save(outputImgPath + imgName +'.png')\n```\n\n## 将RGBA转换为RGB格式数组\n网上看了很多，有用PIL的，还有直接写算法转换的，用opencv的...很多  \n这里发现PIL的不好用，读出来还是RGBA的格式，而且没办法用函数在数组上转换\n\n最后解决办法是:\n- 从前端传过来的数据是字典类型，先获取values()\n- 将dict.vlues这个数组转换为ndarray数组\n- 转换完了,再把这个RGBA数组用 PIL 转换为图片\n- 用save()方法保存为临时图片\n- 用opencv读取临时图片的RGB通道的数据\n\n```java\n# 将图片数据转换为ndarray类型\nnpData = np.array(imageData,dtype=np.uint8).reshape(28,28,4)\n# 将RGBA格式数组转换为图片\nimage = Image.fromarray(npData, 'RGBA') \n# 保存临时图片\nimage.save('static/images/npimg.png')\n\n# 用opencv读取图片的RGB数据\nrgbImage = cv2.imread('static/images/npimg.png', cv2.IMREAD_COLOR) \n```\n\n## cv2.imread(path[, flags])\ncv2的imread函数的第二个参数这里说明下:\n> 如果不设置，读进来的是BGR格式的数据，值在0-255,flag一共有3个取值\n> cv2.IMREAD_COLOR : 读入彩色图片,任何与透明度相关通道的会被忽视,默认以这种方式读入.\n> cv2.IMREAD_GRAYSCALE : 以灰度图的形式读入图片\n> cv2.IMREAD_UNCHANGED : 保留读取图片原有的颜色通道.\n\n可以简单的用**-1,0,1**来分别表示这3个flag\n\n\n## Python图像处理\n### 图片的读写方式总结\n找到一个很全的博客，推荐一下：[Python各类图像库的图片读写方式总结](https://www.jb51.net/article/135307.htm)\n\n### opencv的基本操作\n推荐看看这篇文章：[点击跳转](https://www.jianshu.com/p/ed00179ede34)\n\n### tensorflow简单的图像处理\n推荐链接：[使用TensorFlow进行简单的图像处理](https://blog.csdn.net/jia20003/article/details/79118769)\n\n### PIL格式转换\n推荐链接：[Python图像处理库PIL中图像格式转换（一）](https://blog.csdn.net/icamera0/article/details/50843172)\n\n## 对图片灰度化\n如果只是灰度的话可以用PIL的convert函数，很方便，但是这里要用tensorflow，所以得用`tf.image_to_grayscale(imageData)`这个函数。注意事先要先将数据格式转换为`tf.float32`类型的\n\n```python\n# 将rgb图片转换为float32格式\nrgbImage = tf.image.convert_image_dtype(rgbImage, tf.float32)\n# 将图片灰度化得到(28,28,1)格式的tensor\nrgbImage = tf.image.rgb_to_grayscale(rgbImage\n```\n\n## 后端改变图片的背景和画笔颜色数据\n出于美观，前端并不是黑底白字，但是模型训练的是黑底白字的，虽然后面测试用了灰度数据，还是会不准确，所以在数据处理前，对imageData中的部分像素进行修改，将橙色变为黑色，黑色画笔变为白色\n\n```python\n# 将橙色的背景转换为黑色,将画笔的黑色转为白色\n# input: RGBA格式图片数据\n# output: 修改过的RGBA格式图片数据\ndef reveBlack(imageData):\n    for i in range(0,len(imageData),4):\n        # 如果画笔为白色\n        if imageData[i]==0 and imageData[i+1]==0 and imageData[i+2]==0:\n            imageData[i]=imageData[i+1]=imageData[i+2]=255\n        # 如果背景为橙色\n        if imageData[i]==255 and imageData[i+1]==165 and imageData[i+2]==0:\n            imageData[i]=imageData[i+1]=imageData[i+2]=0\n    return imageDat\n```\n\n## tensor和numpy数组转换\n### tensor转ndarray\n由于项目里面是模型恢复，所以没有初始化这步\n有两种方法：\n\n```python\n### 将tensor转换为ndarray\ninit = tf.initialize_all_variables()\nwith tf.Session() as sess:\n    sess.run(init)\n    # 第一种\n    ndName = tensorName1.eval(session=sess)\n    #第二种\n    ndName = sess.run(tensorName2)\n```\n\n\n## ndarray转tensor\n\n```python\n# 将ndarray转换为tensor\ntensorName =  tf.convert_to_tensor(ndName, dtype = tf.float32)\n```\n\n\n## 使用训练好的模型\n**参考链接：**[言初见的CSDN博客](https://blog.csdn.net/yanchujian88/article/details/80559936)\n\n训练用的算法是Lenet-5，下面的代码是部分调用模型代码，因为只有一张图片的数据，并不是用整个测试集，所以有些地方会有点不一样\n\n主要还是通过恢复模型，传入图片数据来获得预测结果\n\n注意点：\n1. x占位符的shape，要注意个train的一致，第一个shape要是1，因为只有一个图片\n2. 使用tf.argmax(y,1)函数获得最大预测的下标,这里就是结果了，因为是0-9正好对应了下标\n3. 输入的feed_dict测试数据必须是ndarray，不可以是tensor，因此要转换以下\n\n代码如下：\n\n```python\n# 定义输入格式(1,28,28,1)\nx = tf.placeholder(tf.float32, [1, \n                                mnist_inference.IMAGE_SIZE, \n                                mnist_inference.IMAGE_SIZE, \n                                mnist_inference.NUM_CHANNEL], \n                                name='x-input')\n#直接通过调用封装好的函数来计算前向传播的结果 \ny = mnist_inference.interence(x,None, None)\n\n#使用tf.argmax(y, 1)就可以得到输入样例的预测类别 \nprediction = tf.argmax(y, 1)\n\n# 通过变量重命名的方式来加载模型\n# 所有滑动平均的值组成的字典,处在/ExponentialMovingAverage下的值  \n# 为了方便加载时重命名滑动平均量，tf.train.ExponentialMovingAverage类  \n# 提供了variables_to_store函数来生成tf.train.Saver类所需要的变量  \n# 这些值要从模型中提取\nvariable_averages = tf.train.ExponentialMovingAverage(mnist_train.MOVING_AVERAGE_DECAY)\nvariable_to_restore = variable_averages.variables_to_restore()\nsaver = tf.train.Saver(variable_to_restore)\n\n# 用数据测试模型\nwith tf.Session() as sess: \n    # get_checkoutpoint_state()会通过checkoutpoint文件自动找到目录中最新模型的文件名\n    ckpt = tf.train.get_checkpoint_state(mnist_train.MODEL_PATH)\n    if ckpt and ckpt.model_checkpoint_path:\n        # 加载模型\n        saver.restore(sess, ckpt.model_checkpoint_path)\n\n        # 将tensor转换为np数组,这里也可以用np的reshape方法\n        rgbNpData = tf.reshape(rgbImage,[1,\n                                            mnist_inference.IMAGE_SIZE, \n                                            mnist_inference.IMAGE_SIZE, \n                                            mnist_inference.NUM_CHANNEL])\n        # 将tensor转换为ndarray\n        reshaped_data = rgbNpData.eval()\n        # 将输入的测试数据格式调整为一个四维矩阵\n        validate_feed = {x: reshaped_data}\n\n        # 获得预测的结果数组\n        predictionNum = sess.run(prediction, feed_dict = validate_feed)\n        print(\"Number is %d\" %(predictionNum[0]))\n\ntf.reset_default_graph()\n```\n\n## 报错：Error: the tensor's graph is different from the session's graph\n这是因为session里面的图和使用的图不一样导致的，刚开始不清楚，把参考的博客上面的那句： with tf.Graph().as_default() as g:写上去了，导致默认图被设置成了g，但是用的又是恢复的图，所以不一样了\n\n解决办法炒鸡简单...但是debug的过程里就一直没意识到就是了...就是把那句话去掉就行了哇\n\n## 报错：List of Tensors when single Tensor expected\n使用tf.constant()函数的时候可能会报这个错误\n\n看看这个函数的定义：\n> def constant(value, dtype=None, shape=None, name=\"Const\", verify_shape=False)\n> value: A constant value (or list) of output type dtype.\n> Returns: A Constant Tensor.\n\n问题也应该清楚了，constant要求输入的是list，用的时候如果传入了tensor类型的，当然就不可以了\n\n## 总结\n遇到的问题还是很多的，好几个bug都折磨了我几个小时，找不到bug在哪太艰难了，深深的感受到要学了点基础再来做项目，就说这个tensorflow，没有大致的学一遍，遇到问题完全就是无头苍蝇，不好排错\n\n一个项目学到的东西还是挺多的，实战真的很重要啊\n","slug":"MachineLearning/MNIST入门-手写数字识别问题集锦","published":1,"updated":"2019-07-25T18:32:38.343Z","layout":"post","photos":[],"link":"","_id":"ck2424lsc004tlksb721myvg9","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>记录一下手写数字识别这个项目过程中遇到的问题，以及解决方法，还有一些图像处理方面的文章推荐</p></div><a id=\"more\"></a><h2 id=\"canvas画笔位置有偏移\"><a href=\"#canvas画笔位置有偏移\" class=\"headerlink\" title=\"canvas画笔位置有偏移\"></a>canvas画笔位置有偏移</h2><ul><li>使用<code>window.innerHeight || document.documentElement.clientHeight</code>语句获取视窗高度，同理获得宽度</li><li>移动端获得视窗的高度和宽度后，根据高视窗的大小设置canvas大小，以及下方按钮文字等大小</li><li>PC端通过canvas的<code>mousedown、mousemove、mouseup</code>这三个事件绘图，画笔的起始点和新点用<code>event.clientX - canvas.offsetLeft</code>获取x，同理获取y,</li><li>移动端用<code>touchstart、touchmove、touchend</code>这三个事件，画笔的起始点和终点都用<code>event.targetTouches[0].clientX - canvas.offsetLeft</code>获取x，<code>event.targetTouches[0].clientY - canvas.offsetTop</code>获取y</li></ul><h2 id=\"canvas用二次贝塞尔曲线绘图\"><a href=\"#canvas用二次贝塞尔曲线绘图\" class=\"headerlink\" title=\"canvas用二次贝塞尔曲线绘图\"></a>canvas用二次贝塞尔曲线绘图</h2><p><strong>PC端mousemove事件代码</strong></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PC端鼠标移动</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (onoff == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取新点和中点</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> newx = event.clientX - canvas.offsetLeft;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newy = event.clientY - canvas.offsetTop;</span><br><span class=\"line\">    midx = <span class=\"number\">0.5</span>*(newx+oldx);</span><br><span class=\"line\">    midy = <span class=\"number\">0.5</span>*(newy+oldy);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置粗细和颜色</span></span><br><span class=\"line\">    ctx.lineWidth = linew;</span><br><span class=\"line\">    ctx.strokeStyle = linecolor;</span><br><span class=\"line\">    ctx.lineCap = <span class=\"string\">'round'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//绘制二次贝塞尔</span></span><br><span class=\"line\">    ctx.moveTo(oldx,oldy);</span><br><span class=\"line\">    ctx.quadraticCurveTo( midx , midy , newx , newy );</span><br><span class=\"line\">    ctx.stroke();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//转移新旧坐标</span></span><br><span class=\"line\">    oldx = newx;</span><br><span class=\"line\">    oldy = newy;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>mobile端mousemove事件代码</strong></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//移动端手指移动</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tMove</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//获取新点和中点</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> touche = event.targetTouches[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newx = touche.clientX - canvas.offsetLeft;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newy = touche.clientY - canvas.offsetTop;</span><br><span class=\"line\">  midx = <span class=\"number\">0.5</span>*(newx+oldx);</span><br><span class=\"line\">  midy = <span class=\"number\">0.5</span>*(newy+oldy);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//设置粗细和颜色</span></span><br><span class=\"line\">  ctx.lineWidth = linew;</span><br><span class=\"line\">  ctx.strokeStyle = linecolor;</span><br><span class=\"line\">  ctx.lineCap = <span class=\"string\">'round'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ctx.beginPath();</span><br><span class=\"line\">  ctx.moveTo(oldx,oldy);</span><br><span class=\"line\">  ctx.quadraticCurveTo(midx,midy,newx,newy);</span><br><span class=\"line\">  ctx.stroke();</span><br><span class=\"line\"></span><br><span class=\"line\">  oldx = newx;</span><br><span class=\"line\">  oldy = newy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"canvas的imageData像素级缩放\"><a href=\"#canvas的imageData像素级缩放\" class=\"headerlink\" title=\"canvas的imageData像素级缩放\"></a>canvas的imageData像素级缩放</h2><p>想要获得canvas上的图像并且缩放到28*28，使用scale方法是不行的，必须获取所有的像素RGBA值，然后横向隔一段取一个点，竖向隔几行取一行，一共横向每行取28个像素点，竖向取28行</p><p>代码如下：</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//缩放imageData,scale:倍数,返回:imageData</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scaleImageData</span>(<span class=\"params\">imageData, scale</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scaled =</span><br><span class=\"line\">      ctx.createImageData(imageData.width * scale, imageData.height * scale);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> row = <span class=\"number\">0</span>; row &lt; imageData.height; row++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> col = <span class=\"number\">0</span>; col &lt; imageData.width; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> sourcePixel = [</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">0</span>],</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">1</span>],</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">2</span>],</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">3</span>]</span><br><span class=\"line\">      ];</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> y = <span class=\"number\">0</span>; y &lt; scale; y++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> destRow = <span class=\"built_in\">Math</span>.floor(row * scale) + y;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x = <span class=\"number\">0</span>; x &lt; scale; x++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> destCol = <span class=\"built_in\">Math</span>.floor(col * scale) + x;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            scaled.data[(destRow * scaled.width + destCol) * <span class=\"number\">4</span> + i] = sourcePixel[i];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">//  alert(scaled.data.length);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> scaled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"获取服务器的ip\"><a href=\"#获取服务器的ip\" class=\"headerlink\" title=\"获取服务器的ip\"></a>获取服务器的ip</h2><p>这里取巧了，直接从浏览器显示部分获取<br>代码如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取服务器ip，运行时urlPath为https://192.168.137.1:8000/</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">getRemoteIp</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  var urlPath = window.document.location.href;  <span class=\"comment\">//浏览器显示地址 http://10.15.5.83:5555/ISV/demo.aspx?a=1&amp;b=2</span></span><br><span class=\"line\">  <span class=\"comment\">// var docPath = window.document.location.pathname; //文件在服务器相对地址 /ISV/demo.aspx</span></span><br><span class=\"line\">  <span class=\"comment\">// var index = urlPath.indexOf(docPath);</span></span><br><span class=\"line\">  var serverPath = urlPath.substring(<span class=\"number\">7</span>, urlPath.length-<span class=\"number\">1</span>);<span class=\"comment\">//服务器ip 192.168.137.1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> serverPath;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"UA检测\"><a href=\"#UA检测\" class=\"headerlink\" title=\"UA检测\"></a>UA检测</h2><p>因为要适配移动端和PC端，所以简单的UA检测还是必要的，这里没有做的很复杂<br>主要就是通过检测<code>navigator.platfowm</code>中的关键词来判断</p><p>代码如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ua = navigator.userAgent; </span><br><span class=\"line\">var system = &#123;</span><br><span class=\"line\">  win : <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  mac : <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  linux : <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">// mobile</span></span><br><span class=\"line\">  iphone : <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  android : <span class=\"keyword\">false</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p = navigator.platform;</span><br><span class=\"line\">system.win = p.indexOf(<span class=\"string\">'Win'</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">system.mac = p.indexOf(<span class=\"string\">'Mac'</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">system.linux = p.indexOf(<span class=\"string\">'Linux'</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">system.iphone = ua.indexOf(<span class=\"string\">'iPhone'</span>) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">system.android = ua.indexOf(<span class=\"string\">'Android'</span>) &gt; -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(system.win||system.mac)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(system.android||system.iphone)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"python根据数组生成图片\"><a href=\"#python根据数组生成图片\" class=\"headerlink\" title=\"python根据数组生成图片\"></a>python根据数组生成图片</h2><p>dtype一定要写的，不写生成错误<br>imgData就是图片的RGBA数据数组，要转成np数组才可以用PIL的Image.fromarray()</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array = np.asarray(imgData, dtype=np.uint8)</span><br><span class=\"line\">image = Image.fromarray(array, <span class=\"string\">'RGBA'</span>) </span><br><span class=\"line\">image.save(outputImgPath + imgName +<span class=\"string\">'.png'</span>)</span><br></pre></td></tr></table></figure><h2 id=\"将RGBA转换为RGB格式数组\"><a href=\"#将RGBA转换为RGB格式数组\" class=\"headerlink\" title=\"将RGBA转换为RGB格式数组\"></a>将RGBA转换为RGB格式数组</h2><p>网上看了很多，有用PIL的，还有直接写算法转换的，用opencv的…很多<br>这里发现PIL的不好用，读出来还是RGBA的格式，而且没办法用函数在数组上转换</p><p>最后解决办法是:</p><ul><li>从前端传过来的数据是字典类型，先获取values()</li><li>将dict.vlues这个数组转换为ndarray数组</li><li>转换完了,再把这个RGBA数组用 PIL 转换为图片</li><li>用save()方法保存为临时图片</li><li>用opencv读取临时图片的RGB通道的数据</li></ul><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 将图片数据转换为ndarray类型</span><br><span class=\"line\">npData = np.array(imageData,dtype=np.uint8).reshape(<span class=\"number\">28</span>,<span class=\"number\">28</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"># 将RGBA格式数组转换为图片</span><br><span class=\"line\">image = Image.fromarray(npData, <span class=\"string\">'RGBA'</span>) </span><br><span class=\"line\"># 保存临时图片</span><br><span class=\"line\">image.save(<span class=\"string\">'static/images/npimg.png'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"># 用opencv读取图片的RGB数据</span><br><span class=\"line\">rgbImage = cv2.imread(<span class=\"string\">'static/images/npimg.png'</span>, cv2.IMREAD_COLOR)</span><br></pre></td></tr></table></figure><h2 id=\"cv2-imread-path-flags\"><a href=\"#cv2-imread-path-flags\" class=\"headerlink\" title=\"cv2.imread(path[, flags])\"></a>cv2.imread(path[, flags])</h2><p>cv2的imread函数的第二个参数这里说明下:</p><blockquote><p>如果不设置，读进来的是BGR格式的数据，值在0-255,flag一共有3个取值<br>cv2.IMREAD_COLOR : 读入彩色图片,任何与透明度相关通道的会被忽视,默认以这种方式读入.<br>cv2.IMREAD_GRAYSCALE : 以灰度图的形式读入图片<br>cv2.IMREAD_UNCHANGED : 保留读取图片原有的颜色通道.</p></blockquote><p>可以简单的用<strong>-1,0,1</strong>来分别表示这3个flag</p><h2 id=\"Python图像处理\"><a href=\"#Python图像处理\" class=\"headerlink\" title=\"Python图像处理\"></a>Python图像处理</h2><h3 id=\"图片的读写方式总结\"><a href=\"#图片的读写方式总结\" class=\"headerlink\" title=\"图片的读写方式总结\"></a>图片的读写方式总结</h3><p>找到一个很全的博客，推荐一下：<a href=\"https://www.jb51.net/article/135307.htm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Python各类图像库的图片读写方式总结</a></p><h3 id=\"opencv的基本操作\"><a href=\"#opencv的基本操作\" class=\"headerlink\" title=\"opencv的基本操作\"></a>opencv的基本操作</h3><p>推荐看看这篇文章：<a href=\"https://www.jianshu.com/p/ed00179ede34\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">点击跳转</a></p><h3 id=\"tensorflow简单的图像处理\"><a href=\"#tensorflow简单的图像处理\" class=\"headerlink\" title=\"tensorflow简单的图像处理\"></a>tensorflow简单的图像处理</h3><p>推荐链接：<a href=\"https://blog.csdn.net/jia20003/article/details/79118769\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">使用TensorFlow进行简单的图像处理</a></p><h3 id=\"PIL格式转换\"><a href=\"#PIL格式转换\" class=\"headerlink\" title=\"PIL格式转换\"></a>PIL格式转换</h3><p>推荐链接：<a href=\"https://blog.csdn.net/icamera0/article/details/50843172\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Python图像处理库PIL中图像格式转换（一）</a></p><h2 id=\"对图片灰度化\"><a href=\"#对图片灰度化\" class=\"headerlink\" title=\"对图片灰度化\"></a>对图片灰度化</h2><p>如果只是灰度的话可以用PIL的convert函数，很方便，但是这里要用tensorflow，所以得用<code>tf.image_to_grayscale(imageData)</code>这个函数。注意事先要先将数据格式转换为<code>tf.float32</code>类型的</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将rgb图片转换为float32格式</span></span><br><span class=\"line\">rgbImage = tf.image.convert_image_dtype(rgbImage, tf.float32)</span><br><span class=\"line\"><span class=\"comment\"># 将图片灰度化得到(28,28,1)格式的tensor</span></span><br><span class=\"line\">rgbImage = tf.image.rgb_to_grayscale(rgbImage</span><br></pre></td></tr></table></figure><h2 id=\"后端改变图片的背景和画笔颜色数据\"><a href=\"#后端改变图片的背景和画笔颜色数据\" class=\"headerlink\" title=\"后端改变图片的背景和画笔颜色数据\"></a>后端改变图片的背景和画笔颜色数据</h2><p>出于美观，前端并不是黑底白字，但是模型训练的是黑底白字的，虽然后面测试用了灰度数据，还是会不准确，所以在数据处理前，对imageData中的部分像素进行修改，将橙色变为黑色，黑色画笔变为白色</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将橙色的背景转换为黑色,将画笔的黑色转为白色</span></span><br><span class=\"line\"><span class=\"comment\"># input: RGBA格式图片数据</span></span><br><span class=\"line\"><span class=\"comment\"># output: 修改过的RGBA格式图片数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reveBlack</span><span class=\"params\">(imageData)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,len(imageData),<span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 如果画笔为白色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> imageData[i]==<span class=\"number\">0</span> <span class=\"keyword\">and</span> imageData[i+<span class=\"number\">1</span>]==<span class=\"number\">0</span> <span class=\"keyword\">and</span> imageData[i+<span class=\"number\">2</span>]==<span class=\"number\">0</span>:</span><br><span class=\"line\">            imageData[i]=imageData[i+<span class=\"number\">1</span>]=imageData[i+<span class=\"number\">2</span>]=<span class=\"number\">255</span></span><br><span class=\"line\">        <span class=\"comment\"># 如果背景为橙色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> imageData[i]==<span class=\"number\">255</span> <span class=\"keyword\">and</span> imageData[i+<span class=\"number\">1</span>]==<span class=\"number\">165</span> <span class=\"keyword\">and</span> imageData[i+<span class=\"number\">2</span>]==<span class=\"number\">0</span>:</span><br><span class=\"line\">            imageData[i]=imageData[i+<span class=\"number\">1</span>]=imageData[i+<span class=\"number\">2</span>]=<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> imageDat</span><br></pre></td></tr></table></figure><h2 id=\"tensor和numpy数组转换\"><a href=\"#tensor和numpy数组转换\" class=\"headerlink\" title=\"tensor和numpy数组转换\"></a>tensor和numpy数组转换</h2><h3 id=\"tensor转ndarray\"><a href=\"#tensor转ndarray\" class=\"headerlink\" title=\"tensor转ndarray\"></a>tensor转ndarray</h3><p>由于项目里面是模型恢复，所以没有初始化这步<br>有两种方法：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 将tensor转换为ndarray</span></span><br><span class=\"line\">init = tf.initialize_all_variables()</span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess:</span><br><span class=\"line\">    sess.run(init)</span><br><span class=\"line\">    <span class=\"comment\"># 第一种</span></span><br><span class=\"line\">    ndName = tensorName1.eval(session=sess)</span><br><span class=\"line\">    <span class=\"comment\">#第二种</span></span><br><span class=\"line\">    ndName = sess.run(tensorName2)</span><br></pre></td></tr></table></figure><h2 id=\"ndarray转tensor\"><a href=\"#ndarray转tensor\" class=\"headerlink\" title=\"ndarray转tensor\"></a>ndarray转tensor</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将ndarray转换为tensor</span></span><br><span class=\"line\">tensorName =  tf.convert_to_tensor(ndName, dtype = tf.float32)</span><br></pre></td></tr></table></figure><h2 id=\"使用训练好的模型\"><a href=\"#使用训练好的模型\" class=\"headerlink\" title=\"使用训练好的模型\"></a>使用训练好的模型</h2><p><strong>参考链接：</strong><a href=\"https://blog.csdn.net/yanchujian88/article/details/80559936\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">言初见的CSDN博客</a></p><p>训练用的算法是Lenet-5，下面的代码是部分调用模型代码，因为只有一张图片的数据，并不是用整个测试集，所以有些地方会有点不一样</p><p>主要还是通过恢复模型，传入图片数据来获得预测结果</p><p>注意点：</p><ol><li>x占位符的shape，要注意个train的一致，第一个shape要是1，因为只有一个图片</li><li>使用tf.argmax(y,1)函数获得最大预测的下标,这里就是结果了，因为是0-9正好对应了下标</li><li>输入的feed_dict测试数据必须是ndarray，不可以是tensor，因此要转换以下</li></ol><p>代码如下：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义输入格式(1,28,28,1)</span></span><br><span class=\"line\">x = tf.placeholder(tf.float32, [<span class=\"number\">1</span>, </span><br><span class=\"line\">                                mnist_inference.IMAGE_SIZE, </span><br><span class=\"line\">                                mnist_inference.IMAGE_SIZE, </span><br><span class=\"line\">                                mnist_inference.NUM_CHANNEL], </span><br><span class=\"line\">                                name=<span class=\"string\">'x-input'</span>)</span><br><span class=\"line\"><span class=\"comment\">#直接通过调用封装好的函数来计算前向传播的结果 </span></span><br><span class=\"line\">y = mnist_inference.interence(x,<span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#使用tf.argmax(y, 1)就可以得到输入样例的预测类别 </span></span><br><span class=\"line\">prediction = tf.argmax(y, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过变量重命名的方式来加载模型</span></span><br><span class=\"line\"><span class=\"comment\"># 所有滑动平均的值组成的字典,处在/ExponentialMovingAverage下的值  </span></span><br><span class=\"line\"><span class=\"comment\"># 为了方便加载时重命名滑动平均量，tf.train.ExponentialMovingAverage类  </span></span><br><span class=\"line\"><span class=\"comment\"># 提供了variables_to_store函数来生成tf.train.Saver类所需要的变量  </span></span><br><span class=\"line\"><span class=\"comment\"># 这些值要从模型中提取</span></span><br><span class=\"line\">variable_averages = tf.train.ExponentialMovingAverage(mnist_train.MOVING_AVERAGE_DECAY)</span><br><span class=\"line\">variable_to_restore = variable_averages.variables_to_restore()</span><br><span class=\"line\">saver = tf.train.Saver(variable_to_restore)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用数据测试模型</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess: </span><br><span class=\"line\">    <span class=\"comment\"># get_checkoutpoint_state()会通过checkoutpoint文件自动找到目录中最新模型的文件名</span></span><br><span class=\"line\">    ckpt = tf.train.get_checkpoint_state(mnist_train.MODEL_PATH)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ckpt <span class=\"keyword\">and</span> ckpt.model_checkpoint_path:</span><br><span class=\"line\">        <span class=\"comment\"># 加载模型</span></span><br><span class=\"line\">        saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 将tensor转换为np数组,这里也可以用np的reshape方法</span></span><br><span class=\"line\">        rgbNpData = tf.reshape(rgbImage,[<span class=\"number\">1</span>,</span><br><span class=\"line\">                                            mnist_inference.IMAGE_SIZE, </span><br><span class=\"line\">                                            mnist_inference.IMAGE_SIZE, </span><br><span class=\"line\">                                            mnist_inference.NUM_CHANNEL])</span><br><span class=\"line\">        <span class=\"comment\"># 将tensor转换为ndarray</span></span><br><span class=\"line\">        reshaped_data = rgbNpData.eval()</span><br><span class=\"line\">        <span class=\"comment\"># 将输入的测试数据格式调整为一个四维矩阵</span></span><br><span class=\"line\">        validate_feed = &#123;x: reshaped_data&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获得预测的结果数组</span></span><br><span class=\"line\">        predictionNum = sess.run(prediction, feed_dict = validate_feed)</span><br><span class=\"line\">        print(<span class=\"string\">\"Number is %d\"</span> %(predictionNum[<span class=\"number\">0</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\">tf.reset_default_graph()</span><br></pre></td></tr></table></figure><h2 id=\"报错：Error-the-tensor’s-graph-is-different-from-the-session’s-graph\"><a href=\"#报错：Error-the-tensor’s-graph-is-different-from-the-session’s-graph\" class=\"headerlink\" title=\"报错：Error: the tensor’s graph is different from the session’s graph\"></a>报错：Error: the tensor’s graph is different from the session’s graph</h2><p>这是因为session里面的图和使用的图不一样导致的，刚开始不清楚，把参考的博客上面的那句： with tf.Graph().as_default() as g:写上去了，导致默认图被设置成了g，但是用的又是恢复的图，所以不一样了</p><p>解决办法炒鸡简单…但是debug的过程里就一直没意识到就是了…就是把那句话去掉就行了哇</p><h2 id=\"报错：List-of-Tensors-when-single-Tensor-expected\"><a href=\"#报错：List-of-Tensors-when-single-Tensor-expected\" class=\"headerlink\" title=\"报错：List of Tensors when single Tensor expected\"></a>报错：List of Tensors when single Tensor expected</h2><p>使用tf.constant()函数的时候可能会报这个错误</p><p>看看这个函数的定义：</p><blockquote><p>def constant(value, dtype=None, shape=None, name=”Const”, verify_shape=False)<br>value: A constant value (or list) of output type dtype.<br>Returns: A Constant Tensor.</p></blockquote><p>问题也应该清楚了，constant要求输入的是list，用的时候如果传入了tensor类型的，当然就不可以了</p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>遇到的问题还是很多的，好几个bug都折磨了我几个小时，找不到bug在哪太艰难了，深深的感受到要学了点基础再来做项目，就说这个tensorflow，没有大致的学一遍，遇到问题完全就是无头苍蝇，不好排错</p><p>一个项目学到的东西还是挺多的，实战真的很重要啊</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>记录一下手写数字识别这个项目过程中遇到的问题，以及解决方法，还有一些图像处理方面的文章推荐</p></div>","more":"<h2 id=\"canvas画笔位置有偏移\"><a href=\"#canvas画笔位置有偏移\" class=\"headerlink\" title=\"canvas画笔位置有偏移\"></a>canvas画笔位置有偏移</h2><ul><li>使用<code>window.innerHeight || document.documentElement.clientHeight</code>语句获取视窗高度，同理获得宽度</li><li>移动端获得视窗的高度和宽度后，根据高视窗的大小设置canvas大小，以及下方按钮文字等大小</li><li>PC端通过canvas的<code>mousedown、mousemove、mouseup</code>这三个事件绘图，画笔的起始点和新点用<code>event.clientX - canvas.offsetLeft</code>获取x，同理获取y,</li><li>移动端用<code>touchstart、touchmove、touchend</code>这三个事件，画笔的起始点和终点都用<code>event.targetTouches[0].clientX - canvas.offsetLeft</code>获取x，<code>event.targetTouches[0].clientY - canvas.offsetTop</code>获取y</li></ul><h2 id=\"canvas用二次贝塞尔曲线绘图\"><a href=\"#canvas用二次贝塞尔曲线绘图\" class=\"headerlink\" title=\"canvas用二次贝塞尔曲线绘图\"></a>canvas用二次贝塞尔曲线绘图</h2><p><strong>PC端mousemove事件代码</strong></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PC端鼠标移动</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (onoff == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取新点和中点</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> newx = event.clientX - canvas.offsetLeft;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newy = event.clientY - canvas.offsetTop;</span><br><span class=\"line\">    midx = <span class=\"number\">0.5</span>*(newx+oldx);</span><br><span class=\"line\">    midy = <span class=\"number\">0.5</span>*(newy+oldy);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置粗细和颜色</span></span><br><span class=\"line\">    ctx.lineWidth = linew;</span><br><span class=\"line\">    ctx.strokeStyle = linecolor;</span><br><span class=\"line\">    ctx.lineCap = <span class=\"string\">'round'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//绘制二次贝塞尔</span></span><br><span class=\"line\">    ctx.moveTo(oldx,oldy);</span><br><span class=\"line\">    ctx.quadraticCurveTo( midx , midy , newx , newy );</span><br><span class=\"line\">    ctx.stroke();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//转移新旧坐标</span></span><br><span class=\"line\">    oldx = newx;</span><br><span class=\"line\">    oldy = newy;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>mobile端mousemove事件代码</strong></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//移动端手指移动</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tMove</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//获取新点和中点</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> touche = event.targetTouches[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newx = touche.clientX - canvas.offsetLeft;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newy = touche.clientY - canvas.offsetTop;</span><br><span class=\"line\">  midx = <span class=\"number\">0.5</span>*(newx+oldx);</span><br><span class=\"line\">  midy = <span class=\"number\">0.5</span>*(newy+oldy);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//设置粗细和颜色</span></span><br><span class=\"line\">  ctx.lineWidth = linew;</span><br><span class=\"line\">  ctx.strokeStyle = linecolor;</span><br><span class=\"line\">  ctx.lineCap = <span class=\"string\">'round'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ctx.beginPath();</span><br><span class=\"line\">  ctx.moveTo(oldx,oldy);</span><br><span class=\"line\">  ctx.quadraticCurveTo(midx,midy,newx,newy);</span><br><span class=\"line\">  ctx.stroke();</span><br><span class=\"line\"></span><br><span class=\"line\">  oldx = newx;</span><br><span class=\"line\">  oldy = newy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"canvas的imageData像素级缩放\"><a href=\"#canvas的imageData像素级缩放\" class=\"headerlink\" title=\"canvas的imageData像素级缩放\"></a>canvas的imageData像素级缩放</h2><p>想要获得canvas上的图像并且缩放到28*28，使用scale方法是不行的，必须获取所有的像素RGBA值，然后横向隔一段取一个点，竖向隔几行取一行，一共横向每行取28个像素点，竖向取28行</p><p>代码如下：</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//缩放imageData,scale:倍数,返回:imageData</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scaleImageData</span>(<span class=\"params\">imageData, scale</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scaled =</span><br><span class=\"line\">      ctx.createImageData(imageData.width * scale, imageData.height * scale);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> row = <span class=\"number\">0</span>; row &lt; imageData.height; row++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> col = <span class=\"number\">0</span>; col &lt; imageData.width; col++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> sourcePixel = [</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">0</span>],</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">1</span>],</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">2</span>],</span><br><span class=\"line\">        imageData.data[(row * imageData.width + col) * <span class=\"number\">4</span> + <span class=\"number\">3</span>]</span><br><span class=\"line\">      ];</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> y = <span class=\"number\">0</span>; y &lt; scale; y++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> destRow = <span class=\"built_in\">Math</span>.floor(row * scale) + y;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x = <span class=\"number\">0</span>; x &lt; scale; x++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> destCol = <span class=\"built_in\">Math</span>.floor(col * scale) + x;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            scaled.data[(destRow * scaled.width + destCol) * <span class=\"number\">4</span> + i] = sourcePixel[i];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">//  alert(scaled.data.length);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> scaled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"获取服务器的ip\"><a href=\"#获取服务器的ip\" class=\"headerlink\" title=\"获取服务器的ip\"></a>获取服务器的ip</h2><p>这里取巧了，直接从浏览器显示部分获取<br>代码如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取服务器ip，运行时urlPath为https://192.168.137.1:8000/</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">getRemoteIp</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  var urlPath = window.document.location.href;  <span class=\"comment\">//浏览器显示地址 http://10.15.5.83:5555/ISV/demo.aspx?a=1&amp;b=2</span></span><br><span class=\"line\">  <span class=\"comment\">// var docPath = window.document.location.pathname; //文件在服务器相对地址 /ISV/demo.aspx</span></span><br><span class=\"line\">  <span class=\"comment\">// var index = urlPath.indexOf(docPath);</span></span><br><span class=\"line\">  var serverPath = urlPath.substring(<span class=\"number\">7</span>, urlPath.length-<span class=\"number\">1</span>);<span class=\"comment\">//服务器ip 192.168.137.1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> serverPath;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"UA检测\"><a href=\"#UA检测\" class=\"headerlink\" title=\"UA检测\"></a>UA检测</h2><p>因为要适配移动端和PC端，所以简单的UA检测还是必要的，这里没有做的很复杂<br>主要就是通过检测<code>navigator.platfowm</code>中的关键词来判断</p><p>代码如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ua = navigator.userAgent; </span><br><span class=\"line\">var system = &#123;</span><br><span class=\"line\">  win : <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  mac : <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  linux : <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">// mobile</span></span><br><span class=\"line\">  iphone : <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  android : <span class=\"keyword\">false</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p = navigator.platform;</span><br><span class=\"line\">system.win = p.indexOf(<span class=\"string\">'Win'</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">system.mac = p.indexOf(<span class=\"string\">'Mac'</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">system.linux = p.indexOf(<span class=\"string\">'Linux'</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">system.iphone = ua.indexOf(<span class=\"string\">'iPhone'</span>) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">system.android = ua.indexOf(<span class=\"string\">'Android'</span>) &gt; -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(system.win||system.mac)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(system.android||system.iphone)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"python根据数组生成图片\"><a href=\"#python根据数组生成图片\" class=\"headerlink\" title=\"python根据数组生成图片\"></a>python根据数组生成图片</h2><p>dtype一定要写的，不写生成错误<br>imgData就是图片的RGBA数据数组，要转成np数组才可以用PIL的Image.fromarray()</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array = np.asarray(imgData, dtype=np.uint8)</span><br><span class=\"line\">image = Image.fromarray(array, <span class=\"string\">'RGBA'</span>) </span><br><span class=\"line\">image.save(outputImgPath + imgName +<span class=\"string\">'.png'</span>)</span><br></pre></td></tr></table></figure><h2 id=\"将RGBA转换为RGB格式数组\"><a href=\"#将RGBA转换为RGB格式数组\" class=\"headerlink\" title=\"将RGBA转换为RGB格式数组\"></a>将RGBA转换为RGB格式数组</h2><p>网上看了很多，有用PIL的，还有直接写算法转换的，用opencv的…很多<br>这里发现PIL的不好用，读出来还是RGBA的格式，而且没办法用函数在数组上转换</p><p>最后解决办法是:</p><ul><li>从前端传过来的数据是字典类型，先获取values()</li><li>将dict.vlues这个数组转换为ndarray数组</li><li>转换完了,再把这个RGBA数组用 PIL 转换为图片</li><li>用save()方法保存为临时图片</li><li>用opencv读取临时图片的RGB通道的数据</li></ul><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 将图片数据转换为ndarray类型</span><br><span class=\"line\">npData = np.array(imageData,dtype=np.uint8).reshape(<span class=\"number\">28</span>,<span class=\"number\">28</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"># 将RGBA格式数组转换为图片</span><br><span class=\"line\">image = Image.fromarray(npData, <span class=\"string\">'RGBA'</span>) </span><br><span class=\"line\"># 保存临时图片</span><br><span class=\"line\">image.save(<span class=\"string\">'static/images/npimg.png'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"># 用opencv读取图片的RGB数据</span><br><span class=\"line\">rgbImage = cv2.imread(<span class=\"string\">'static/images/npimg.png'</span>, cv2.IMREAD_COLOR)</span><br></pre></td></tr></table></figure><h2 id=\"cv2-imread-path-flags\"><a href=\"#cv2-imread-path-flags\" class=\"headerlink\" title=\"cv2.imread(path[, flags])\"></a>cv2.imread(path[, flags])</h2><p>cv2的imread函数的第二个参数这里说明下:</p><blockquote><p>如果不设置，读进来的是BGR格式的数据，值在0-255,flag一共有3个取值<br>cv2.IMREAD_COLOR : 读入彩色图片,任何与透明度相关通道的会被忽视,默认以这种方式读入.<br>cv2.IMREAD_GRAYSCALE : 以灰度图的形式读入图片<br>cv2.IMREAD_UNCHANGED : 保留读取图片原有的颜色通道.</p></blockquote><p>可以简单的用<strong>-1,0,1</strong>来分别表示这3个flag</p><h2 id=\"Python图像处理\"><a href=\"#Python图像处理\" class=\"headerlink\" title=\"Python图像处理\"></a>Python图像处理</h2><h3 id=\"图片的读写方式总结\"><a href=\"#图片的读写方式总结\" class=\"headerlink\" title=\"图片的读写方式总结\"></a>图片的读写方式总结</h3><p>找到一个很全的博客，推荐一下：<a href=\"https://www.jb51.net/article/135307.htm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Python各类图像库的图片读写方式总结</a></p><h3 id=\"opencv的基本操作\"><a href=\"#opencv的基本操作\" class=\"headerlink\" title=\"opencv的基本操作\"></a>opencv的基本操作</h3><p>推荐看看这篇文章：<a href=\"https://www.jianshu.com/p/ed00179ede34\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">点击跳转</a></p><h3 id=\"tensorflow简单的图像处理\"><a href=\"#tensorflow简单的图像处理\" class=\"headerlink\" title=\"tensorflow简单的图像处理\"></a>tensorflow简单的图像处理</h3><p>推荐链接：<a href=\"https://blog.csdn.net/jia20003/article/details/79118769\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">使用TensorFlow进行简单的图像处理</a></p><h3 id=\"PIL格式转换\"><a href=\"#PIL格式转换\" class=\"headerlink\" title=\"PIL格式转换\"></a>PIL格式转换</h3><p>推荐链接：<a href=\"https://blog.csdn.net/icamera0/article/details/50843172\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Python图像处理库PIL中图像格式转换（一）</a></p><h2 id=\"对图片灰度化\"><a href=\"#对图片灰度化\" class=\"headerlink\" title=\"对图片灰度化\"></a>对图片灰度化</h2><p>如果只是灰度的话可以用PIL的convert函数，很方便，但是这里要用tensorflow，所以得用<code>tf.image_to_grayscale(imageData)</code>这个函数。注意事先要先将数据格式转换为<code>tf.float32</code>类型的</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将rgb图片转换为float32格式</span></span><br><span class=\"line\">rgbImage = tf.image.convert_image_dtype(rgbImage, tf.float32)</span><br><span class=\"line\"><span class=\"comment\"># 将图片灰度化得到(28,28,1)格式的tensor</span></span><br><span class=\"line\">rgbImage = tf.image.rgb_to_grayscale(rgbImage</span><br></pre></td></tr></table></figure><h2 id=\"后端改变图片的背景和画笔颜色数据\"><a href=\"#后端改变图片的背景和画笔颜色数据\" class=\"headerlink\" title=\"后端改变图片的背景和画笔颜色数据\"></a>后端改变图片的背景和画笔颜色数据</h2><p>出于美观，前端并不是黑底白字，但是模型训练的是黑底白字的，虽然后面测试用了灰度数据，还是会不准确，所以在数据处理前，对imageData中的部分像素进行修改，将橙色变为黑色，黑色画笔变为白色</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将橙色的背景转换为黑色,将画笔的黑色转为白色</span></span><br><span class=\"line\"><span class=\"comment\"># input: RGBA格式图片数据</span></span><br><span class=\"line\"><span class=\"comment\"># output: 修改过的RGBA格式图片数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reveBlack</span><span class=\"params\">(imageData)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,len(imageData),<span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 如果画笔为白色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> imageData[i]==<span class=\"number\">0</span> <span class=\"keyword\">and</span> imageData[i+<span class=\"number\">1</span>]==<span class=\"number\">0</span> <span class=\"keyword\">and</span> imageData[i+<span class=\"number\">2</span>]==<span class=\"number\">0</span>:</span><br><span class=\"line\">            imageData[i]=imageData[i+<span class=\"number\">1</span>]=imageData[i+<span class=\"number\">2</span>]=<span class=\"number\">255</span></span><br><span class=\"line\">        <span class=\"comment\"># 如果背景为橙色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> imageData[i]==<span class=\"number\">255</span> <span class=\"keyword\">and</span> imageData[i+<span class=\"number\">1</span>]==<span class=\"number\">165</span> <span class=\"keyword\">and</span> imageData[i+<span class=\"number\">2</span>]==<span class=\"number\">0</span>:</span><br><span class=\"line\">            imageData[i]=imageData[i+<span class=\"number\">1</span>]=imageData[i+<span class=\"number\">2</span>]=<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> imageDat</span><br></pre></td></tr></table></figure><h2 id=\"tensor和numpy数组转换\"><a href=\"#tensor和numpy数组转换\" class=\"headerlink\" title=\"tensor和numpy数组转换\"></a>tensor和numpy数组转换</h2><h3 id=\"tensor转ndarray\"><a href=\"#tensor转ndarray\" class=\"headerlink\" title=\"tensor转ndarray\"></a>tensor转ndarray</h3><p>由于项目里面是模型恢复，所以没有初始化这步<br>有两种方法：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 将tensor转换为ndarray</span></span><br><span class=\"line\">init = tf.initialize_all_variables()</span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess:</span><br><span class=\"line\">    sess.run(init)</span><br><span class=\"line\">    <span class=\"comment\"># 第一种</span></span><br><span class=\"line\">    ndName = tensorName1.eval(session=sess)</span><br><span class=\"line\">    <span class=\"comment\">#第二种</span></span><br><span class=\"line\">    ndName = sess.run(tensorName2)</span><br></pre></td></tr></table></figure><h2 id=\"ndarray转tensor\"><a href=\"#ndarray转tensor\" class=\"headerlink\" title=\"ndarray转tensor\"></a>ndarray转tensor</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将ndarray转换为tensor</span></span><br><span class=\"line\">tensorName =  tf.convert_to_tensor(ndName, dtype = tf.float32)</span><br></pre></td></tr></table></figure><h2 id=\"使用训练好的模型\"><a href=\"#使用训练好的模型\" class=\"headerlink\" title=\"使用训练好的模型\"></a>使用训练好的模型</h2><p><strong>参考链接：</strong><a href=\"https://blog.csdn.net/yanchujian88/article/details/80559936\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">言初见的CSDN博客</a></p><p>训练用的算法是Lenet-5，下面的代码是部分调用模型代码，因为只有一张图片的数据，并不是用整个测试集，所以有些地方会有点不一样</p><p>主要还是通过恢复模型，传入图片数据来获得预测结果</p><p>注意点：</p><ol><li>x占位符的shape，要注意个train的一致，第一个shape要是1，因为只有一个图片</li><li>使用tf.argmax(y,1)函数获得最大预测的下标,这里就是结果了，因为是0-9正好对应了下标</li><li>输入的feed_dict测试数据必须是ndarray，不可以是tensor，因此要转换以下</li></ol><p>代码如下：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义输入格式(1,28,28,1)</span></span><br><span class=\"line\">x = tf.placeholder(tf.float32, [<span class=\"number\">1</span>, </span><br><span class=\"line\">                                mnist_inference.IMAGE_SIZE, </span><br><span class=\"line\">                                mnist_inference.IMAGE_SIZE, </span><br><span class=\"line\">                                mnist_inference.NUM_CHANNEL], </span><br><span class=\"line\">                                name=<span class=\"string\">'x-input'</span>)</span><br><span class=\"line\"><span class=\"comment\">#直接通过调用封装好的函数来计算前向传播的结果 </span></span><br><span class=\"line\">y = mnist_inference.interence(x,<span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#使用tf.argmax(y, 1)就可以得到输入样例的预测类别 </span></span><br><span class=\"line\">prediction = tf.argmax(y, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过变量重命名的方式来加载模型</span></span><br><span class=\"line\"><span class=\"comment\"># 所有滑动平均的值组成的字典,处在/ExponentialMovingAverage下的值  </span></span><br><span class=\"line\"><span class=\"comment\"># 为了方便加载时重命名滑动平均量，tf.train.ExponentialMovingAverage类  </span></span><br><span class=\"line\"><span class=\"comment\"># 提供了variables_to_store函数来生成tf.train.Saver类所需要的变量  </span></span><br><span class=\"line\"><span class=\"comment\"># 这些值要从模型中提取</span></span><br><span class=\"line\">variable_averages = tf.train.ExponentialMovingAverage(mnist_train.MOVING_AVERAGE_DECAY)</span><br><span class=\"line\">variable_to_restore = variable_averages.variables_to_restore()</span><br><span class=\"line\">saver = tf.train.Saver(variable_to_restore)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用数据测试模型</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess: </span><br><span class=\"line\">    <span class=\"comment\"># get_checkoutpoint_state()会通过checkoutpoint文件自动找到目录中最新模型的文件名</span></span><br><span class=\"line\">    ckpt = tf.train.get_checkpoint_state(mnist_train.MODEL_PATH)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ckpt <span class=\"keyword\">and</span> ckpt.model_checkpoint_path:</span><br><span class=\"line\">        <span class=\"comment\"># 加载模型</span></span><br><span class=\"line\">        saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 将tensor转换为np数组,这里也可以用np的reshape方法</span></span><br><span class=\"line\">        rgbNpData = tf.reshape(rgbImage,[<span class=\"number\">1</span>,</span><br><span class=\"line\">                                            mnist_inference.IMAGE_SIZE, </span><br><span class=\"line\">                                            mnist_inference.IMAGE_SIZE, </span><br><span class=\"line\">                                            mnist_inference.NUM_CHANNEL])</span><br><span class=\"line\">        <span class=\"comment\"># 将tensor转换为ndarray</span></span><br><span class=\"line\">        reshaped_data = rgbNpData.eval()</span><br><span class=\"line\">        <span class=\"comment\"># 将输入的测试数据格式调整为一个四维矩阵</span></span><br><span class=\"line\">        validate_feed = &#123;x: reshaped_data&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获得预测的结果数组</span></span><br><span class=\"line\">        predictionNum = sess.run(prediction, feed_dict = validate_feed)</span><br><span class=\"line\">        print(<span class=\"string\">\"Number is %d\"</span> %(predictionNum[<span class=\"number\">0</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\">tf.reset_default_graph()</span><br></pre></td></tr></table></figure><h2 id=\"报错：Error-the-tensor’s-graph-is-different-from-the-session’s-graph\"><a href=\"#报错：Error-the-tensor’s-graph-is-different-from-the-session’s-graph\" class=\"headerlink\" title=\"报错：Error: the tensor’s graph is different from the session’s graph\"></a>报错：Error: the tensor’s graph is different from the session’s graph</h2><p>这是因为session里面的图和使用的图不一样导致的，刚开始不清楚，把参考的博客上面的那句： with tf.Graph().as_default() as g:写上去了，导致默认图被设置成了g，但是用的又是恢复的图，所以不一样了</p><p>解决办法炒鸡简单…但是debug的过程里就一直没意识到就是了…就是把那句话去掉就行了哇</p><h2 id=\"报错：List-of-Tensors-when-single-Tensor-expected\"><a href=\"#报错：List-of-Tensors-when-single-Tensor-expected\" class=\"headerlink\" title=\"报错：List of Tensors when single Tensor expected\"></a>报错：List of Tensors when single Tensor expected</h2><p>使用tf.constant()函数的时候可能会报这个错误</p><p>看看这个函数的定义：</p><blockquote><p>def constant(value, dtype=None, shape=None, name=”Const”, verify_shape=False)<br>value: A constant value (or list) of output type dtype.<br>Returns: A Constant Tensor.</p></blockquote><p>问题也应该清楚了，constant要求输入的是list，用的时候如果传入了tensor类型的，当然就不可以了</p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>遇到的问题还是很多的，好几个bug都折磨了我几个小时，找不到bug在哪太艰难了，深深的感受到要学了点基础再来做项目，就说这个tensorflow，没有大致的学一遍，遇到问题完全就是无头苍蝇，不好排错</p><p>一个项目学到的东西还是挺多的，实战真的很重要啊</p><!-- rebuild by neat -->"},{"title":"机器学习概念整理","comments":1,"mathjax":true,"date":"2018-10-13T13:57:53.000Z","urlname":"machinelearning-concepts","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n　　记录一些学习过程中遇到的基础概念，来源《机器学习导论》，《机器学习》——周志华，《白话大数据和机器学习》，《统计学习方法》——李航等，不是很全，等以后学习的深入待补充。<!--more-->\n\n# 数据和信息\n- 信息: 香农指出是\"信息是用来消除随机不定性的东西\",就是那些把我们不清楚的描述,\"信息是被消除的不确定性\"。\n- 算法: 简单理解为计算的方法和技巧，也可以是解决问题的办法\n- 信息量: 一种信息数量化度量的规则，I=log_2m(m中情况产生概率均等)\n- 先验概率: 事件按照常理，一般性规律发生的概率\n- 香农公式: $$ C = B * log_2(1+S/N) $$,B=2H,H为信道带宽,S为信号功率,N为噪声功率\n- 信息熵: 信息的杂乱程度的量化描述,H(x)=-sum_1^np(x_i)log_2P(x_i),i=1,2...\n- 熵: 混乱程度的描述，越有序，熵越低，反之越高 \n\n# 回归和聚类\n- 回归: 从大量的函数结果和自变量反推回函数表达式的过程就是回归 \n- 过拟合: 一般是拟合过程中模型描述的太复杂，一般参数繁多，计算逻辑多\n- 欠拟合: 一般是操作不当产生的误差e分布太散或者太大的情况\n \n\n# 无分类的概念\n\n\n","source":"_posts/MachineLearning/机器学习概念整理.md","raw":"---\ntitle: 机器学习概念整理\ncomments: true\nmathjax: true\ndate: 2018-10-13 21:57:53\ntags: MachineLearning\ncategories: MachineLearning\nurlname: machinelearning-concepts\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n　　记录一些学习过程中遇到的基础概念，来源《机器学习导论》，《机器学习》——周志华，《白话大数据和机器学习》，《统计学习方法》——李航等，不是很全，等以后学习的深入待补充。<!--more-->\n\n# 数据和信息\n- 信息: 香农指出是\"信息是用来消除随机不定性的东西\",就是那些把我们不清楚的描述,\"信息是被消除的不确定性\"。\n- 算法: 简单理解为计算的方法和技巧，也可以是解决问题的办法\n- 信息量: 一种信息数量化度量的规则，I=log_2m(m中情况产生概率均等)\n- 先验概率: 事件按照常理，一般性规律发生的概率\n- 香农公式: $$ C = B * log_2(1+S/N) $$,B=2H,H为信道带宽,S为信号功率,N为噪声功率\n- 信息熵: 信息的杂乱程度的量化描述,H(x)=-sum_1^np(x_i)log_2P(x_i),i=1,2...\n- 熵: 混乱程度的描述，越有序，熵越低，反之越高 \n\n# 回归和聚类\n- 回归: 从大量的函数结果和自变量反推回函数表达式的过程就是回归 \n- 过拟合: 一般是拟合过程中模型描述的太复杂，一般参数繁多，计算逻辑多\n- 欠拟合: 一般是操作不当产生的误差e分布太散或者太大的情况\n \n\n# 无分类的概念\n\n\n","slug":"MachineLearning/机器学习概念整理","published":1,"updated":"2019-07-25T18:37:32.350Z","layout":"post","photos":[],"link":"","_id":"ck2424lsd004ulksbhgxz59m1","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><p>记录一些学习过程中遇到的基础概念，来源《机器学习导论》，《机器学习》——周志华，《白话大数据和机器学习》，《统计学习方法》——李航等，不是很全，等以后学习的深入待补充。<a id=\"more\"></a></p><h1 id=\"数据和信息\"><a href=\"#数据和信息\" class=\"headerlink\" title=\"数据和信息\"></a>数据和信息</h1><ul><li>信息: 香农指出是”信息是用来消除随机不定性的东西”,就是那些把我们不清楚的描述,”信息是被消除的不确定性”。</li><li>算法: 简单理解为计算的方法和技巧，也可以是解决问题的办法</li><li>信息量: 一种信息数量化度量的规则，I=log_2m(m中情况产生概率均等)</li><li>先验概率: 事件按照常理，一般性规律发生的概率</li><li>香农公式:<script type=\"math/tex\">C = B * log_2(1+S/N)</script>,B=2H,H为信道带宽,S为信号功率,N为噪声功率</li><li>信息熵: 信息的杂乱程度的量化描述,H(x)=-sum_1^np(x_i)log_2P(x_i),i=1,2…</li><li>熵: 混乱程度的描述，越有序，熵越低，反之越高</li></ul><h1 id=\"回归和聚类\"><a href=\"#回归和聚类\" class=\"headerlink\" title=\"回归和聚类\"></a>回归和聚类</h1><ul><li>回归: 从大量的函数结果和自变量反推回函数表达式的过程就是回归</li><li>过拟合: 一般是拟合过程中模型描述的太复杂，一般参数繁多，计算逻辑多</li><li>欠拟合: 一般是操作不当产生的误差e分布太散或者太大的情况</li></ul><h1 id=\"无分类的概念\"><a href=\"#无分类的概念\" class=\"headerlink\" title=\"无分类的概念\"></a>无分类的概念</h1><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><p>记录一些学习过程中遇到的基础概念，来源《机器学习导论》，《机器学习》——周志华，《白话大数据和机器学习》，《统计学习方法》——李航等，不是很全，等以后学习的深入待补充。","more":"</p><h1 id=\"数据和信息\"><a href=\"#数据和信息\" class=\"headerlink\" title=\"数据和信息\"></a>数据和信息</h1><ul><li>信息: 香农指出是”信息是用来消除随机不定性的东西”,就是那些把我们不清楚的描述,”信息是被消除的不确定性”。</li><li>算法: 简单理解为计算的方法和技巧，也可以是解决问题的办法</li><li>信息量: 一种信息数量化度量的规则，I=log_2m(m中情况产生概率均等)</li><li>先验概率: 事件按照常理，一般性规律发生的概率</li><li>香农公式:<script type=\"math/tex\">C = B * log_2(1+S/N)</script>,B=2H,H为信道带宽,S为信号功率,N为噪声功率</li><li>信息熵: 信息的杂乱程度的量化描述,H(x)=-sum_1^np(x_i)log_2P(x_i),i=1,2…</li><li>熵: 混乱程度的描述，越有序，熵越低，反之越高</li></ul><h1 id=\"回归和聚类\"><a href=\"#回归和聚类\" class=\"headerlink\" title=\"回归和聚类\"></a>回归和聚类</h1><ul><li>回归: 从大量的函数结果和自变量反推回函数表达式的过程就是回归</li><li>过拟合: 一般是拟合过程中模型描述的太复杂，一般参数繁多，计算逻辑多</li><li>欠拟合: 一般是操作不当产生的误差e分布太散或者太大的情况</li></ul><h1 id=\"无分类的概念\"><a href=\"#无分类的概念\" class=\"headerlink\" title=\"无分类的概念\"></a>无分类的概念</h1><!-- rebuild by neat -->"},{"title":"聚类和K-Means算法","comments":1,"date":"2018-09-10T10:08:12.000Z","urlname":"machinelearning-cluster-k-means","mathjax":true,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n# 聚类\n## 聚类定义\n　　聚类(Clustering)，指的是一种学习方式（操作方式），即把物理或者抽象对象的集合分组为由彼此的对象组成的多个类的分析过程。<!--more--> \n\n{% note info %} 聚类属于无监督机器学习，简言之就是把特征形态相同的或者近似的划分在一个概念下，聚集为一组。\n\n聚类在实际的应用中中亦是非常广泛的，如：市场细分（Market segmentation）、社交圈分析（social network analysis）、集群计算（organize computing clusters）、天体数据分析（astronomical data analysis）等\n{% endnote %}\n\n## 聚类算法分类\n　　主要的聚类主要的聚类算法可以划分为如下几类：划分方法、层次方法、基于密度的方法、基于网格的方法以及基于模型的方法。\n\n　　每一类中都存在着得到广泛应用的算法，例如：划分方法中的k-means聚类算法、层次方法中的凝聚型层次聚类算法、基于模型方法中的神经网络聚类算法等\n\n　　但是上述的都是硬聚类，即每一个数据只能被归为一类，还有一种是模糊聚类。\n   　　模糊聚类通过隶属函数来确定每个数据隶属于各个簇的程度，而不是将一个数据对象硬性地归类到某一簇中。\n\n# 常用距离算法\n## 欧氏距离\n　　欧氏距离是最直观的距离度量方法，通常就是学过的两点间距离，可以用在多维。\n\n- 二维平面上点a(x1,y1)与b(x2,y2)间的欧氏距离:  \n$$ d_{12} = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2} $$\n- 三维空间点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离:\n$$ d{12} = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2} $$\n- 更高维的计算类似二维三维\n\n## 曼哈顿距离\n　　不再是两点间连线的那种，是类似九宫格的走法，只能直线和直角拐弯。又叫做“城市街区距离”。\n\n- 二维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离：\n$$ d_12 = |x_1-x_2|+|y_1-y_2| $$\n- 三维和其他维类似\n\n{% note info %}\n　　除了这两种还有余弦距离和切比雪夫距离等，这里不展开说。采用不同的距离度量方法对结果有很大的影响。\n{% endnote %}\n\n# k-means算法\n  思想大致是:\n- 1.　先随机选k个质心\n- 2.　对每个点计算其到各个质心的距离\n- 3.　选距离最近的，把这个点归为这个质心的一类，形成k个簇\n- 4.　然后对于每个簇，计算其中每个点到质心的平均距离\n- 5.　然后把这个作为这个簇的新的质心,进行第二步\n- 6.　直到簇不怎么发生变化或者达到了预设的最大迭代次数，停止\n  \n　主要函数如下:\n\n```C++\n//k-means聚类\nvector<Cluster> k_means(vector<vector<int> >trans,int k,int counts){\n  vector<Cluster> clusters(k);\n\n  const int row = trans.size();\n  const int col = trans[0].size();\n\n  //随机初始化聚类中心\n  srand((int)time(0));\n  for(int i=0;i<k;i++){\n    int center = rand()%trans.size();\n    clusters[i].center=trans[center]; \n  }\n\n  //迭代counts次\n  for(int cnt = 0;cnt<counts;cnt++){\n\n    //清空样本空间\n    for(int i=0;i<k;i++)\n      clusters[i].samples.clear();\n\n    //计算样本属于的簇\n    for(int i=0;i<row;i++){\n      int tmp_center = 0;\n      int minal = cal_distance(trans[i],clusters[tmp_center].center);\n\n      for(int j=1;j<k;j++){\n        int distance = cal_distance(trans[i],clusters[j].center);\n        if(distance<minal){\n          tmp_center = j;\n          minal = distance;\n        }\n      }\n\n      clusters[tmp_center].samples.push_back(i);\n    }\n\n    //重新计算簇中心\n    for(int i=0;i<k;i++){\n      int sum = 0;\n\n      for(int m=0;m<trans[0].size();m++){\n        for(int j=0;j<clusters[i].samples.size();j++){\n          //cout<<\"sum+=: \"<<trans[clusters[i].samples[j]][m];\n          sum+=trans[clusters[i].samples[j]][m];\n        }\n\n        clusters[i].center[m]=sum/clusters[i].samples.size();\n        sum=0;\n      }\n    }\n  }\n\n  return clusters;\n}\n```\n\n　用了C\\+\\+作为实现的代码，python的代码可以参考网上的，有很多。计算距离用的是欧式距离。数据可以自己构造尝试。\n\n----------------------------------------------\n","source":"_posts/MachineLearning/聚类和K-Means算法.md","raw":"---\ntitle: 聚类和K-Means算法\ncomments: true\ndate: 2018-09-10 18:08:12\ntags: [Python,MachineLearning,Clustering,K-Means,Learning]\ncategories: MachineLearning\nurlname: machinelearning-cluster-k-means\nmathjax: true\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n# 聚类\n## 聚类定义\n　　聚类(Clustering)，指的是一种学习方式（操作方式），即把物理或者抽象对象的集合分组为由彼此的对象组成的多个类的分析过程。<!--more--> \n\n{% note info %} 聚类属于无监督机器学习，简言之就是把特征形态相同的或者近似的划分在一个概念下，聚集为一组。\n\n聚类在实际的应用中中亦是非常广泛的，如：市场细分（Market segmentation）、社交圈分析（social network analysis）、集群计算（organize computing clusters）、天体数据分析（astronomical data analysis）等\n{% endnote %}\n\n## 聚类算法分类\n　　主要的聚类主要的聚类算法可以划分为如下几类：划分方法、层次方法、基于密度的方法、基于网格的方法以及基于模型的方法。\n\n　　每一类中都存在着得到广泛应用的算法，例如：划分方法中的k-means聚类算法、层次方法中的凝聚型层次聚类算法、基于模型方法中的神经网络聚类算法等\n\n　　但是上述的都是硬聚类，即每一个数据只能被归为一类，还有一种是模糊聚类。\n   　　模糊聚类通过隶属函数来确定每个数据隶属于各个簇的程度，而不是将一个数据对象硬性地归类到某一簇中。\n\n# 常用距离算法\n## 欧氏距离\n　　欧氏距离是最直观的距离度量方法，通常就是学过的两点间距离，可以用在多维。\n\n- 二维平面上点a(x1,y1)与b(x2,y2)间的欧氏距离:  \n$$ d_{12} = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2} $$\n- 三维空间点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离:\n$$ d{12} = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2} $$\n- 更高维的计算类似二维三维\n\n## 曼哈顿距离\n　　不再是两点间连线的那种，是类似九宫格的走法，只能直线和直角拐弯。又叫做“城市街区距离”。\n\n- 二维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离：\n$$ d_12 = |x_1-x_2|+|y_1-y_2| $$\n- 三维和其他维类似\n\n{% note info %}\n　　除了这两种还有余弦距离和切比雪夫距离等，这里不展开说。采用不同的距离度量方法对结果有很大的影响。\n{% endnote %}\n\n# k-means算法\n  思想大致是:\n- 1.　先随机选k个质心\n- 2.　对每个点计算其到各个质心的距离\n- 3.　选距离最近的，把这个点归为这个质心的一类，形成k个簇\n- 4.　然后对于每个簇，计算其中每个点到质心的平均距离\n- 5.　然后把这个作为这个簇的新的质心,进行第二步\n- 6.　直到簇不怎么发生变化或者达到了预设的最大迭代次数，停止\n  \n　主要函数如下:\n\n```C++\n//k-means聚类\nvector<Cluster> k_means(vector<vector<int> >trans,int k,int counts){\n  vector<Cluster> clusters(k);\n\n  const int row = trans.size();\n  const int col = trans[0].size();\n\n  //随机初始化聚类中心\n  srand((int)time(0));\n  for(int i=0;i<k;i++){\n    int center = rand()%trans.size();\n    clusters[i].center=trans[center]; \n  }\n\n  //迭代counts次\n  for(int cnt = 0;cnt<counts;cnt++){\n\n    //清空样本空间\n    for(int i=0;i<k;i++)\n      clusters[i].samples.clear();\n\n    //计算样本属于的簇\n    for(int i=0;i<row;i++){\n      int tmp_center = 0;\n      int minal = cal_distance(trans[i],clusters[tmp_center].center);\n\n      for(int j=1;j<k;j++){\n        int distance = cal_distance(trans[i],clusters[j].center);\n        if(distance<minal){\n          tmp_center = j;\n          minal = distance;\n        }\n      }\n\n      clusters[tmp_center].samples.push_back(i);\n    }\n\n    //重新计算簇中心\n    for(int i=0;i<k;i++){\n      int sum = 0;\n\n      for(int m=0;m<trans[0].size();m++){\n        for(int j=0;j<clusters[i].samples.size();j++){\n          //cout<<\"sum+=: \"<<trans[clusters[i].samples[j]][m];\n          sum+=trans[clusters[i].samples[j]][m];\n        }\n\n        clusters[i].center[m]=sum/clusters[i].samples.size();\n        sum=0;\n      }\n    }\n  }\n\n  return clusters;\n}\n```\n\n　用了C\\+\\+作为实现的代码，python的代码可以参考网上的，有很多。计算距离用的是欧式距离。数据可以自己构造尝试。\n\n----------------------------------------------\n","slug":"MachineLearning/聚类和K-Means算法","published":1,"updated":"2019-07-25T18:37:48.380Z","layout":"post","photos":[],"link":"","_id":"ck2424lsf004wlksbz384871l","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><p></p><meta name=\"referrer\" content=\"no-referrer\"><p></p><h1 id=\"聚类\"><a href=\"#聚类\" class=\"headerlink\" title=\"聚类\"></a>聚类</h1><h2 id=\"聚类定义\"><a href=\"#聚类定义\" class=\"headerlink\" title=\"聚类定义\"></a>聚类定义</h2><p>聚类(Clustering)，指的是一种学习方式（操作方式），即把物理或者抽象对象的集合分组为由彼此的对象组成的多个类的分析过程。<a id=\"more\"></a></p><div class=\"note info\"><p>聚类属于无监督机器学习，简言之就是把特征形态相同的或者近似的划分在一个概念下，聚集为一组。</p><p>聚类在实际的应用中中亦是非常广泛的，如：市场细分（Market segmentation）、社交圈分析（social network analysis）、集群计算（organize computing clusters）、天体数据分析（astronomical data analysis）等</p></div><h2 id=\"聚类算法分类\"><a href=\"#聚类算法分类\" class=\"headerlink\" title=\"聚类算法分类\"></a>聚类算法分类</h2><p>主要的聚类主要的聚类算法可以划分为如下几类：划分方法、层次方法、基于密度的方法、基于网格的方法以及基于模型的方法。</p><p>每一类中都存在着得到广泛应用的算法，例如：划分方法中的k-means聚类算法、层次方法中的凝聚型层次聚类算法、基于模型方法中的神经网络聚类算法等</p><p>但是上述的都是硬聚类，即每一个数据只能被归为一类，还有一种是模糊聚类。<br>模糊聚类通过隶属函数来确定每个数据隶属于各个簇的程度，而不是将一个数据对象硬性地归类到某一簇中。</p><h1 id=\"常用距离算法\"><a href=\"#常用距离算法\" class=\"headerlink\" title=\"常用距离算法\"></a>常用距离算法</h1><h2 id=\"欧氏距离\"><a href=\"#欧氏距离\" class=\"headerlink\" title=\"欧氏距离\"></a>欧氏距离</h2><p>欧氏距离是最直观的距离度量方法，通常就是学过的两点间距离，可以用在多维。</p><ul><li>二维平面上点a(x1,y1)与b(x2,y2)间的欧氏距离:<script type=\"math/tex;mode=display\">d_{12} = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}</script></li><li>三维空间点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离:<script type=\"math/tex;mode=display\">d{12} = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}</script></li><li>更高维的计算类似二维三维</li></ul><h2 id=\"曼哈顿距离\"><a href=\"#曼哈顿距离\" class=\"headerlink\" title=\"曼哈顿距离\"></a>曼哈顿距离</h2><p>不再是两点间连线的那种，是类似九宫格的走法，只能直线和直角拐弯。又叫做“城市街区距离”。</p><ul><li>二维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离：<script type=\"math/tex;mode=display\">d_12 = |x_1-x_2|+|y_1-y_2|</script></li><li>三维和其他维类似</li></ul><div class=\"note info\"><p>除了这两种还有余弦距离和切比雪夫距离等，这里不展开说。采用不同的距离度量方法对结果有很大的影响。</p></div><h1 id=\"k-means算法\"><a href=\"#k-means算法\" class=\"headerlink\" title=\"k-means算法\"></a>k-means算法</h1><p>思想大致是:</p><ul><li>1.　先随机选k个质心</li><li>2.　对每个点计算其到各个质心的距离</li><li>3.　选距离最近的，把这个点归为这个质心的一类，形成k个簇</li><li>4.　然后对于每个簇，计算其中每个点到质心的平均距离</li><li>5.　然后把这个作为这个簇的新的质心,进行第二步</li><li>6.　直到簇不怎么发生变化或者达到了预设的最大迭代次数，停止</li></ul><p>主要函数如下:</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//k-means聚类</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Cluster&gt; k_means(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt;trans,<span class=\"keyword\">int</span> k,<span class=\"keyword\">int</span> counts)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;Cluster&gt; clusters(k);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> row = trans.size();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> col = trans[<span class=\"number\">0</span>].size();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//随机初始化聚类中心</span></span><br><span class=\"line\">  srand((<span class=\"keyword\">int</span>)time(<span class=\"number\">0</span>));</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> center = rand()%trans.size();</span><br><span class=\"line\">    clusters[i].center=trans[center]; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//迭代counts次</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;cnt&lt;counts;cnt++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//清空样本空间</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)</span><br><span class=\"line\">      clusters[i].samples.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//计算样本属于的簇</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;row;i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> tmp_center = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> minal = cal_distance(trans[i],clusters[tmp_center].center);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;k;j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> distance = cal_distance(trans[i],clusters[j].center);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(distance&lt;minal)&#123;</span><br><span class=\"line\">          tmp_center = j;</span><br><span class=\"line\">          minal = distance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      clusters[tmp_center].samples.push_back(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//重新计算簇中心</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> m=<span class=\"number\">0</span>;m&lt;trans[<span class=\"number\">0</span>].size();m++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;clusters[i].samples.size();j++)&#123;</span><br><span class=\"line\">          <span class=\"comment\">//cout&lt;&lt;\"sum+=: \"&lt;&lt;trans[clusters[i].samples[j]][m];</span></span><br><span class=\"line\">          sum+=trans[clusters[i].samples[j]][m];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        clusters[i].center[m]=sum/clusters[i].samples.size();</span><br><span class=\"line\">        sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> clusters;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>用了C++作为实现的代码，python的代码可以参考网上的，有很多。计算距离用的是欧式距离。数据可以自己构造尝试。</p><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><p></p><meta name=\"referrer\" content=\"no-referrer\"><p></p><h1 id=\"聚类\"><a href=\"#聚类\" class=\"headerlink\" title=\"聚类\"></a>聚类</h1><h2 id=\"聚类定义\"><a href=\"#聚类定义\" class=\"headerlink\" title=\"聚类定义\"></a>聚类定义</h2><p>聚类(Clustering)，指的是一种学习方式（操作方式），即把物理或者抽象对象的集合分组为由彼此的对象组成的多个类的分析过程。","more":"</p><div class=\"note info\"><p>聚类属于无监督机器学习，简言之就是把特征形态相同的或者近似的划分在一个概念下，聚集为一组。</p><p>聚类在实际的应用中中亦是非常广泛的，如：市场细分（Market segmentation）、社交圈分析（social network analysis）、集群计算（organize computing clusters）、天体数据分析（astronomical data analysis）等</p></div><h2 id=\"聚类算法分类\"><a href=\"#聚类算法分类\" class=\"headerlink\" title=\"聚类算法分类\"></a>聚类算法分类</h2><p>主要的聚类主要的聚类算法可以划分为如下几类：划分方法、层次方法、基于密度的方法、基于网格的方法以及基于模型的方法。</p><p>每一类中都存在着得到广泛应用的算法，例如：划分方法中的k-means聚类算法、层次方法中的凝聚型层次聚类算法、基于模型方法中的神经网络聚类算法等</p><p>但是上述的都是硬聚类，即每一个数据只能被归为一类，还有一种是模糊聚类。<br>模糊聚类通过隶属函数来确定每个数据隶属于各个簇的程度，而不是将一个数据对象硬性地归类到某一簇中。</p><h1 id=\"常用距离算法\"><a href=\"#常用距离算法\" class=\"headerlink\" title=\"常用距离算法\"></a>常用距离算法</h1><h2 id=\"欧氏距离\"><a href=\"#欧氏距离\" class=\"headerlink\" title=\"欧氏距离\"></a>欧氏距离</h2><p>欧氏距离是最直观的距离度量方法，通常就是学过的两点间距离，可以用在多维。</p><ul><li>二维平面上点a(x1,y1)与b(x2,y2)间的欧氏距离:<script type=\"math/tex;mode=display\">d_{12} = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}</script></li><li>三维空间点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离:<script type=\"math/tex;mode=display\">d{12} = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}</script></li><li>更高维的计算类似二维三维</li></ul><h2 id=\"曼哈顿距离\"><a href=\"#曼哈顿距离\" class=\"headerlink\" title=\"曼哈顿距离\"></a>曼哈顿距离</h2><p>不再是两点间连线的那种，是类似九宫格的走法，只能直线和直角拐弯。又叫做“城市街区距离”。</p><ul><li>二维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离：<script type=\"math/tex;mode=display\">d_12 = |x_1-x_2|+|y_1-y_2|</script></li><li>三维和其他维类似</li></ul><div class=\"note info\"><p>除了这两种还有余弦距离和切比雪夫距离等，这里不展开说。采用不同的距离度量方法对结果有很大的影响。</p></div><h1 id=\"k-means算法\"><a href=\"#k-means算法\" class=\"headerlink\" title=\"k-means算法\"></a>k-means算法</h1><p>思想大致是:</p><ul><li>1.　先随机选k个质心</li><li>2.　对每个点计算其到各个质心的距离</li><li>3.　选距离最近的，把这个点归为这个质心的一类，形成k个簇</li><li>4.　然后对于每个簇，计算其中每个点到质心的平均距离</li><li>5.　然后把这个作为这个簇的新的质心,进行第二步</li><li>6.　直到簇不怎么发生变化或者达到了预设的最大迭代次数，停止</li></ul><p>主要函数如下:</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//k-means聚类</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Cluster&gt; k_means(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt;trans,<span class=\"keyword\">int</span> k,<span class=\"keyword\">int</span> counts)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;Cluster&gt; clusters(k);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> row = trans.size();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> col = trans[<span class=\"number\">0</span>].size();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//随机初始化聚类中心</span></span><br><span class=\"line\">  srand((<span class=\"keyword\">int</span>)time(<span class=\"number\">0</span>));</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> center = rand()%trans.size();</span><br><span class=\"line\">    clusters[i].center=trans[center]; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//迭代counts次</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;cnt&lt;counts;cnt++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//清空样本空间</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)</span><br><span class=\"line\">      clusters[i].samples.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//计算样本属于的簇</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;row;i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> tmp_center = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> minal = cal_distance(trans[i],clusters[tmp_center].center);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;k;j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> distance = cal_distance(trans[i],clusters[j].center);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(distance&lt;minal)&#123;</span><br><span class=\"line\">          tmp_center = j;</span><br><span class=\"line\">          minal = distance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      clusters[tmp_center].samples.push_back(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//重新计算簇中心</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> m=<span class=\"number\">0</span>;m&lt;trans[<span class=\"number\">0</span>].size();m++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;clusters[i].samples.size();j++)&#123;</span><br><span class=\"line\">          <span class=\"comment\">//cout&lt;&lt;\"sum+=: \"&lt;&lt;trans[clusters[i].samples[j]][m];</span></span><br><span class=\"line\">          sum+=trans[clusters[i].samples[j]][m];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        clusters[i].center[m]=sum/clusters[i].samples.size();</span><br><span class=\"line\">        sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> clusters;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>用了C++作为实现的代码，python的代码可以参考网上的，有很多。计算距离用的是欧式距离。数据可以自己构造尝试。</p><hr><!-- rebuild by neat -->"},{"title":"MNIST入门-手写数字识别","comments":1,"mathjax":false,"date":"2019-04-02T02:11:01.000Z","urlname":"mnist-beginner-digitrecognization","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n**Target**  \n将训练一个机器学习模型用于预测图片里面的数字.  \n\n理解TensorFlow工作流程和机器学习的基本概念\n\n和官网不同的是只记录关键点\n{% endnote %}\n<!--more-->\n**关键词**\n\n[MNIST](http://yann.lecun.com/exdb/mnist/)\n[TensorFlow](http://www.tensorfly.cn/tfdoc/tutorials/mnist_beginners.html)\n[Softmax Regression](https://blog.csdn.net/google19890102/article/details/41594889)\n\n## 数据集\n- 数据集被分成两部分：60000行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）\n- 把这些图片设为“xs”，把这些标签设为“ys”\n  - 训练数据集的图片是 mnist.train.images ，训练数据集的标签是 mnist.train.labels\n- mnist.train.images 是一个形状为 [60000, 784] 的张量，第一个维度数字索引图片，第二个维度数字索引每张图片中的像素点\n  - 向量值表某个像素的强度值，值介于0和1之间\n- mnist.train.labels 是一个 [60000, 10] 的数字矩阵\n  - 标签数据是\"one-hot vectors\"\n  - 10维，只有一个维度非0\n  - 标签0将表示成([1,0,0,0,0,0,0,0,0,0,0])\n\n## Softmax\nsoftmax模型可以用来给不同的对象分配概率。即使在之后，我们训练更加精细的模型时，最后一步也需要用softmax来分配概率。\n\n### 第一步\n- 对数据进行加权求和，在手写数字识别的例子里就是丢每个像素值加权求和\n- 在每个像素值求和的后面加上一个偏置量$$ b_i $$，这是由于输入会有一些干扰量\n\n可以得到输入图片 x ，[784]的向量，它代表的是数字 i 的证据可以表示:\n$$ evidence_i = \\sum_jW_{i,j}x_j+b_i $$\n其中$$ W_i $$维度是[784,10]，代表权重，$$ b_i $$维度是[10]代表是数字i类的偏置量，j代表图片x的像素索引用于求和\n\n### 第二步\n再使用softmax函数将evidence转换成概率y\n$$ y=softmax(evidence) $$\nsoftmax函数可以看成是激励函数(activation)，把线性函数输出转换成想要的格式:关于10个数字的概率分布。\n$$ softmax(x) = normalize(exp(x)) $$\n$$ softmax(x)_i = {exp(x_i) \\over \\sum_jexp(x_j)} $$\n{% note %}\n即：把输入值当成幂指数求值，再正则化这些结果值\n{% endnote %}\n\n结合上面的evidence可以知道，evidence越大，正则化后的结果更大，就是权重更大。\n{% asset_img sof1.png %}\n进一步写成:\n$$ y = softmax(W_x + b) $$\n\n## 实现模型\n\n\n","source":"_posts/MachineLearning/MNIST入门-手写数字识别.md","raw":"---\ntitle: MNIST入门-手写数字识别\ncomments: true\nmathjax: false\ndate: 2019-04-02 10:11:01\ntags: [TensorFlow, ML, MNIST]\ncategories: MachineLearning\nurlname: mnist-beginner-digitrecognization\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n**Target**  \n将训练一个机器学习模型用于预测图片里面的数字.  \n\n理解TensorFlow工作流程和机器学习的基本概念\n\n和官网不同的是只记录关键点\n{% endnote %}\n<!--more-->\n**关键词**\n\n[MNIST](http://yann.lecun.com/exdb/mnist/)\n[TensorFlow](http://www.tensorfly.cn/tfdoc/tutorials/mnist_beginners.html)\n[Softmax Regression](https://blog.csdn.net/google19890102/article/details/41594889)\n\n## 数据集\n- 数据集被分成两部分：60000行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）\n- 把这些图片设为“xs”，把这些标签设为“ys”\n  - 训练数据集的图片是 mnist.train.images ，训练数据集的标签是 mnist.train.labels\n- mnist.train.images 是一个形状为 [60000, 784] 的张量，第一个维度数字索引图片，第二个维度数字索引每张图片中的像素点\n  - 向量值表某个像素的强度值，值介于0和1之间\n- mnist.train.labels 是一个 [60000, 10] 的数字矩阵\n  - 标签数据是\"one-hot vectors\"\n  - 10维，只有一个维度非0\n  - 标签0将表示成([1,0,0,0,0,0,0,0,0,0,0])\n\n## Softmax\nsoftmax模型可以用来给不同的对象分配概率。即使在之后，我们训练更加精细的模型时，最后一步也需要用softmax来分配概率。\n\n### 第一步\n- 对数据进行加权求和，在手写数字识别的例子里就是丢每个像素值加权求和\n- 在每个像素值求和的后面加上一个偏置量$$ b_i $$，这是由于输入会有一些干扰量\n\n可以得到输入图片 x ，[784]的向量，它代表的是数字 i 的证据可以表示:\n$$ evidence_i = \\sum_jW_{i,j}x_j+b_i $$\n其中$$ W_i $$维度是[784,10]，代表权重，$$ b_i $$维度是[10]代表是数字i类的偏置量，j代表图片x的像素索引用于求和\n\n### 第二步\n再使用softmax函数将evidence转换成概率y\n$$ y=softmax(evidence) $$\nsoftmax函数可以看成是激励函数(activation)，把线性函数输出转换成想要的格式:关于10个数字的概率分布。\n$$ softmax(x) = normalize(exp(x)) $$\n$$ softmax(x)_i = {exp(x_i) \\over \\sum_jexp(x_j)} $$\n{% note %}\n即：把输入值当成幂指数求值，再正则化这些结果值\n{% endnote %}\n\n结合上面的evidence可以知道，evidence越大，正则化后的结果更大，就是权重更大。\n{% asset_img sof1.png %}\n进一步写成:\n$$ y = softmax(W_x + b) $$\n\n## 实现模型\n\n\n","slug":"MachineLearning/MNIST入门-手写数字识别","published":1,"updated":"2019-07-25T18:32:13.366Z","layout":"post","photos":[],"link":"","_id":"ck2424lsk004ylksbwzg6mp8j","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p><strong>Target</strong><br>将训练一个机器学习模型用于预测图片里面的数字.</p><p>理解TensorFlow工作流程和机器学习的基本概念</p><p>和官网不同的是只记录关键点</p></div><a id=\"more\"></a><p><strong>关键词</strong></p><p><a href=\"http://yann.lecun.com/exdb/mnist/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MNIST</a><br><a href=\"http://www.tensorfly.cn/tfdoc/tutorials/mnist_beginners.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">TensorFlow</a><br><a href=\"https://blog.csdn.net/google19890102/article/details/41594889\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Softmax Regression</a></p><h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><ul><li>数据集被分成两部分：60000行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）</li><li>把这些图片设为“xs”，把这些标签设为“ys”<ul><li>训练数据集的图片是 mnist.train.images ，训练数据集的标签是 mnist.train.labels</li></ul></li><li>mnist.train.images 是一个形状为 [60000, 784] 的张量，第一个维度数字索引图片，第二个维度数字索引每张图片中的像素点<ul><li>向量值表某个像素的强度值，值介于0和1之间</li></ul></li><li>mnist.train.labels 是一个 [60000, 10] 的数字矩阵<ul><li>标签数据是”one-hot vectors”</li><li>10维，只有一个维度非0</li><li>标签0将表示成([1,0,0,0,0,0,0,0,0,0,0])</li></ul></li></ul><h2 id=\"Softmax\"><a href=\"#Softmax\" class=\"headerlink\" title=\"Softmax\"></a>Softmax</h2><p>softmax模型可以用来给不同的对象分配概率。即使在之后，我们训练更加精细的模型时，最后一步也需要用softmax来分配概率。</p><h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><ul><li>对数据进行加权求和，在手写数字识别的例子里就是丢每个像素值加权求和</li><li>在每个像素值求和的后面加上一个偏置量<script type=\"math/tex\">b_i</script>，这是由于输入会有一些干扰量</li></ul><p>可以得到输入图片 x ，[784]的向量，它代表的是数字 i 的证据可以表示:</p><script type=\"math/tex;mode=display\">evidence_i = \\sum_jW_{i,j}x_j+b_i</script><p>其中<script type=\"math/tex\">W_i</script>维度是[784,10]，代表权重，<script type=\"math/tex\">b_i</script>维度是[10]代表是数字i类的偏置量，j代表图片x的像素索引用于求和</p><h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>再使用softmax函数将evidence转换成概率y</p><script type=\"math/tex;mode=display\">y=softmax(evidence)</script><p>softmax函数可以看成是激励函数(activation)，把线性函数输出转换成想要的格式:关于10个数字的概率分布。</p><script type=\"math/tex;mode=display\">softmax(x) = normalize(exp(x))</script><script type=\"math/tex;mode=display\">softmax(x)_i = {exp(x_i) \\over \\sum_jexp(x_j)}</script><div class=\"note\"><p>即：把输入值当成幂指数求值，再正则化这些结果值</p></div><p>结合上面的evidence可以知道，evidence越大，正则化后的结果更大，就是权重更大。<br><img src=\"/MachineLearning/2019-04-02-mnist-beginner-digitrecognization/sof1.png\"><br>进一步写成:</p><script type=\"math/tex;mode=display\">y = softmax(W_x + b)</script><h2 id=\"实现模型\"><a href=\"#实现模型\" class=\"headerlink\" title=\"实现模型\"></a>实现模型</h2><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p><strong>Target</strong><br>将训练一个机器学习模型用于预测图片里面的数字.</p><p>理解TensorFlow工作流程和机器学习的基本概念</p><p>和官网不同的是只记录关键点</p></div>","more":"<p><strong>关键词</strong></p><p><a href=\"http://yann.lecun.com/exdb/mnist/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MNIST</a><br><a href=\"http://www.tensorfly.cn/tfdoc/tutorials/mnist_beginners.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">TensorFlow</a><br><a href=\"https://blog.csdn.net/google19890102/article/details/41594889\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Softmax Regression</a></p><h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><ul><li>数据集被分成两部分：60000行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）</li><li>把这些图片设为“xs”，把这些标签设为“ys”<ul><li>训练数据集的图片是 mnist.train.images ，训练数据集的标签是 mnist.train.labels</li></ul></li><li>mnist.train.images 是一个形状为 [60000, 784] 的张量，第一个维度数字索引图片，第二个维度数字索引每张图片中的像素点<ul><li>向量值表某个像素的强度值，值介于0和1之间</li></ul></li><li>mnist.train.labels 是一个 [60000, 10] 的数字矩阵<ul><li>标签数据是”one-hot vectors”</li><li>10维，只有一个维度非0</li><li>标签0将表示成([1,0,0,0,0,0,0,0,0,0,0])</li></ul></li></ul><h2 id=\"Softmax\"><a href=\"#Softmax\" class=\"headerlink\" title=\"Softmax\"></a>Softmax</h2><p>softmax模型可以用来给不同的对象分配概率。即使在之后，我们训练更加精细的模型时，最后一步也需要用softmax来分配概率。</p><h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><ul><li>对数据进行加权求和，在手写数字识别的例子里就是丢每个像素值加权求和</li><li>在每个像素值求和的后面加上一个偏置量<script type=\"math/tex\">b_i</script>，这是由于输入会有一些干扰量</li></ul><p>可以得到输入图片 x ，[784]的向量，它代表的是数字 i 的证据可以表示:</p><script type=\"math/tex;mode=display\">evidence_i = \\sum_jW_{i,j}x_j+b_i</script><p>其中<script type=\"math/tex\">W_i</script>维度是[784,10]，代表权重，<script type=\"math/tex\">b_i</script>维度是[10]代表是数字i类的偏置量，j代表图片x的像素索引用于求和</p><h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>再使用softmax函数将evidence转换成概率y</p><script type=\"math/tex;mode=display\">y=softmax(evidence)</script><p>softmax函数可以看成是激励函数(activation)，把线性函数输出转换成想要的格式:关于10个数字的概率分布。</p><script type=\"math/tex;mode=display\">softmax(x) = normalize(exp(x))</script><script type=\"math/tex;mode=display\">softmax(x)_i = {exp(x_i) \\over \\sum_jexp(x_j)}</script><div class=\"note\"><p>即：把输入值当成幂指数求值，再正则化这些结果值</p></div><p>结合上面的evidence可以知道，evidence越大，正则化后的结果更大，就是权重更大。<br><img src=\"/MachineLearning/2019-04-02-mnist-beginner-digitrecognization/sof1.png\"><br>进一步写成:</p><script type=\"math/tex;mode=display\">y = softmax(W_x + b)</script><h2 id=\"实现模型\"><a href=\"#实现模型\" class=\"headerlink\" title=\"实现模型\"></a>实现模型</h2><!-- rebuild by neat -->"},{"title":"凸函数、凸集和凸优化","comments":1,"mathjax":true,"date":"2019-10-20T13:38:40.000Z","urlname":"convex-function-set-optimization","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n记录凸函数、凸集和凸优化的一些问题。\n在SVM中要用到。\n{% endnote %}\n<!--more-->\n## 凸函数\n### 定义\n用简单的一元函数$$ f(x) $$来说，如果对于任意$$ t \\in [0,1] $$均满足：$$ f(tx_1+(1−t)x_2) \\le tf(x_1)+(1−t)f(x_2)，则称f(x)为凸函数(convex function)\n\n如果对于任意tϵ(0,1)均满足：$$ f(tx_1+(1−t)x_2) \\lt tf(x_1)+(1−t)f(x_2)，则称f(x)为严格凸函数(convex function) $$\n\n直观上理解，凸函数的隔线在曲线下方。\n{% asset_img tuhanshu.png 割线在曲线上方 %}\n\n上述可以推广到多元函数。\n\n如果优化函数是凸函数，那么，局部最小就是全局最小，不会陷入局部最优里。\nSVM的目标函数$$ ||\\omega||^2 $$就是一个凸函数\n\n### 判断凸函数\n- 一元函数：求二阶导数的符号来判断，如果非负，就是凸函数\n- 多元函数：通过Hessian矩阵的正定性判断，如果Hessian矩阵是半正定矩阵，那就是凸函数\n\n### 凸函数性质\n凸函数满足Jensen不等式：\n\n如果 f 是凸函数，X是随机变量，那么$$ \\theta_1,…,\\theta_k \\ge 0，\\theta_1 + … + \\theta_k = 1$$,$$ f(\\theta_1x_1+ … + \\theta_kx_k) \\le \\theta_1f(x_1)+ … + \\theta_kf(x_k)$$\n\n如果把$$ \\theta $$看成是$$ x_k $$的概率，那么就可以理解成下面的一般式子：\n$$f(E(X)) \\le E(f(X))$$\n\n## 凸集\n### 定义\n如果集合 C 为凸集，那么对于任意的 $$ x1,x2 in C 与0 \\le \\theta \\le 1都有 \\theta x_1+(1−\\theta)x_2 in C $$，与仿射集的区别在于仿射集并没有$$ \\theta \\ge 0 $$的要求，例如一条线段是凸集，而一条直线是仿射集。\n\n扩展到多维的情况，如果有 $$ \\theta_1 + \\theta_2 +...+ \\theta_k = 1, \\theta_i \\gt 0 $$，则称具有$$ \\theta_1x_1 + \\theta_2x_2 +...+ \\theta_kx_k $$形式的点为 $$ x_1,x_2....x_k $$的凸组合。\n\n称由集合$$ C \\subset R^n $$中点的所有凸组合所组成的集合为C的凸包：\n$$ conv C = { \\theta_1x_1 +...+ \\theta_kx_k | x_1,..,x_k in C, \\theta_1+\\theta_2+...+\\theta_k=1, \\theta_i \\ge 0}$$\n\n与仿射包同样，凸包也是包含 C 的最小的凸集，在一般情况下，设$$ C \\subset R^n $$ 是凸集，x 是随机变量，并且$$ x in C $$的概率为1，那么 $$ E x \\in C $$\n\n### 重要的凸集\n任意的仿射集和子空间都是凸集，一些比较简单的例如空集 $$ \\emptyset $$ ，单点集{x0}，全空间$$ R^n $$ ，直线/射线/线段都是凸的。\n\n还有一些比较重要的凸集如下：\n1. 超平面$$  {x|a^Tx = b} $$和半空间$$ {x|a^Tx \\le b}$$\n1. Euclid球 $$B(x_c,r)={x| ||x−x_c||_2 \\le r}$$\n1. 椭球$$ \\xi ={x|(x−x_c)^T P^(−1) (x−x_c) \\le 1}\n1. 范数球 $${x| ||x−x_c|| \\le r}，其中 ||⋅|| 是$$ R^n $$中的范数\n1. 范数锥 $$C={(x,t)| ||x|| \\le t} \\subset R^(n+1)$$\n1. 多面体 $$P={x|a^T_j \\le b_j, j=1,...,m, c^T_j x = d_j,j=1,...,p}$$，即为有限个半空间和超平面的交集，单纯形也为凸集，是一种特殊的多面体半正定锥 $$S^n_+={X \\subset R^{n∗n}|X=X^T,X \\ge 0}$$，即为半正定对称矩阵的集合_\n\n## 凸优化问题\n在优化问题中，凸优化问题由于具有优良的性质（局部最优解即是全局最优解），受到广泛研究。\n主要作用是，将有约束条件的转换成无约束条件的。\n\n对于一个含约束的优化问题：\n$$ \n\\left\\{\n\\begin{array}{c}\nmin_x  f(x) \\\\\ns.t. x in C\n\\end{array}\n\\right.\n$$\n其中，f(x) 为一个凸函数，变量x 的可行域C 是一个凸集，那么这个优化问题称为一个凸优化问题。\n将上面的约束条件的形式更加明确一点，一个凸优化问题可以写成：\n\n$$ \n\\left\\{\n\\begin{array}{c}\nmin_x  f(x) \\\\\ns.t.  & g_i(x) \\le 0 \\\\\n& h_i(x) = 0\n\\end{array}\n\\right.\n$$\n\n其中，f(x) 当然仍然为一个凸函数，但对约束条件有一定要求：$$ g_i(x) $$ 是凸函数；$$ h_i(x) $$为仿射函数。这样的要求当然是为了保证可行域是一个凸集。\n\n不等式约束中$$ g_i(x) $$为凸函数，而凸函数的水平截集$${x|g_i(x) \\le \\alpha}是一个凸集(凸函数的性质)，这就使得不等式约束保证了可行域为凸集；\n对于等式约束$$ h_i(x)=0 $$可以写成：\n$$ \n\\left\\{\n\\begin{array}{c}\nh_i(x) \\le 0 \\\\\nh_i(x) \\ge 0\n\\end{array}\n\\right.\n$$\n\n要使得满足条件的x 组成的集合为凸集，就要求$$ h_i(x) $$ 既是一个凸函数，又是一个凹函数，这样hi(x)便只能是仿射函数了。\n\n以上便是凸优化问题的一般形式。常见的线性规划、二次规划、二次约束二次规划等优化问题都是凸优化问题。\n","source":"_posts/MachineLearning/凸函数、凸集和凸优化.md","raw":"---\ntitle: 凸函数、凸集和凸优化\ntags:\n  - 凸函数\n  - 凸集\n  - 凸优化\n  - SVM\ncategories:\n  - MachineLearning\ncomments: true\nmathjax: true\ndate: 2019-10-20 21:38:40\nurlname: convex-function-set-optimization\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n记录凸函数、凸集和凸优化的一些问题。\n在SVM中要用到。\n{% endnote %}\n<!--more-->\n## 凸函数\n### 定义\n用简单的一元函数$$ f(x) $$来说，如果对于任意$$ t \\in [0,1] $$均满足：$$ f(tx_1+(1−t)x_2) \\le tf(x_1)+(1−t)f(x_2)，则称f(x)为凸函数(convex function)\n\n如果对于任意tϵ(0,1)均满足：$$ f(tx_1+(1−t)x_2) \\lt tf(x_1)+(1−t)f(x_2)，则称f(x)为严格凸函数(convex function) $$\n\n直观上理解，凸函数的隔线在曲线下方。\n{% asset_img tuhanshu.png 割线在曲线上方 %}\n\n上述可以推广到多元函数。\n\n如果优化函数是凸函数，那么，局部最小就是全局最小，不会陷入局部最优里。\nSVM的目标函数$$ ||\\omega||^2 $$就是一个凸函数\n\n### 判断凸函数\n- 一元函数：求二阶导数的符号来判断，如果非负，就是凸函数\n- 多元函数：通过Hessian矩阵的正定性判断，如果Hessian矩阵是半正定矩阵，那就是凸函数\n\n### 凸函数性质\n凸函数满足Jensen不等式：\n\n如果 f 是凸函数，X是随机变量，那么$$ \\theta_1,…,\\theta_k \\ge 0，\\theta_1 + … + \\theta_k = 1$$,$$ f(\\theta_1x_1+ … + \\theta_kx_k) \\le \\theta_1f(x_1)+ … + \\theta_kf(x_k)$$\n\n如果把$$ \\theta $$看成是$$ x_k $$的概率，那么就可以理解成下面的一般式子：\n$$f(E(X)) \\le E(f(X))$$\n\n## 凸集\n### 定义\n如果集合 C 为凸集，那么对于任意的 $$ x1,x2 in C 与0 \\le \\theta \\le 1都有 \\theta x_1+(1−\\theta)x_2 in C $$，与仿射集的区别在于仿射集并没有$$ \\theta \\ge 0 $$的要求，例如一条线段是凸集，而一条直线是仿射集。\n\n扩展到多维的情况，如果有 $$ \\theta_1 + \\theta_2 +...+ \\theta_k = 1, \\theta_i \\gt 0 $$，则称具有$$ \\theta_1x_1 + \\theta_2x_2 +...+ \\theta_kx_k $$形式的点为 $$ x_1,x_2....x_k $$的凸组合。\n\n称由集合$$ C \\subset R^n $$中点的所有凸组合所组成的集合为C的凸包：\n$$ conv C = { \\theta_1x_1 +...+ \\theta_kx_k | x_1,..,x_k in C, \\theta_1+\\theta_2+...+\\theta_k=1, \\theta_i \\ge 0}$$\n\n与仿射包同样，凸包也是包含 C 的最小的凸集，在一般情况下，设$$ C \\subset R^n $$ 是凸集，x 是随机变量，并且$$ x in C $$的概率为1，那么 $$ E x \\in C $$\n\n### 重要的凸集\n任意的仿射集和子空间都是凸集，一些比较简单的例如空集 $$ \\emptyset $$ ，单点集{x0}，全空间$$ R^n $$ ，直线/射线/线段都是凸的。\n\n还有一些比较重要的凸集如下：\n1. 超平面$$  {x|a^Tx = b} $$和半空间$$ {x|a^Tx \\le b}$$\n1. Euclid球 $$B(x_c,r)={x| ||x−x_c||_2 \\le r}$$\n1. 椭球$$ \\xi ={x|(x−x_c)^T P^(−1) (x−x_c) \\le 1}\n1. 范数球 $${x| ||x−x_c|| \\le r}，其中 ||⋅|| 是$$ R^n $$中的范数\n1. 范数锥 $$C={(x,t)| ||x|| \\le t} \\subset R^(n+1)$$\n1. 多面体 $$P={x|a^T_j \\le b_j, j=1,...,m, c^T_j x = d_j,j=1,...,p}$$，即为有限个半空间和超平面的交集，单纯形也为凸集，是一种特殊的多面体半正定锥 $$S^n_+={X \\subset R^{n∗n}|X=X^T,X \\ge 0}$$，即为半正定对称矩阵的集合_\n\n## 凸优化问题\n在优化问题中，凸优化问题由于具有优良的性质（局部最优解即是全局最优解），受到广泛研究。\n主要作用是，将有约束条件的转换成无约束条件的。\n\n对于一个含约束的优化问题：\n$$ \n\\left\\{\n\\begin{array}{c}\nmin_x  f(x) \\\\\ns.t. x in C\n\\end{array}\n\\right.\n$$\n其中，f(x) 为一个凸函数，变量x 的可行域C 是一个凸集，那么这个优化问题称为一个凸优化问题。\n将上面的约束条件的形式更加明确一点，一个凸优化问题可以写成：\n\n$$ \n\\left\\{\n\\begin{array}{c}\nmin_x  f(x) \\\\\ns.t.  & g_i(x) \\le 0 \\\\\n& h_i(x) = 0\n\\end{array}\n\\right.\n$$\n\n其中，f(x) 当然仍然为一个凸函数，但对约束条件有一定要求：$$ g_i(x) $$ 是凸函数；$$ h_i(x) $$为仿射函数。这样的要求当然是为了保证可行域是一个凸集。\n\n不等式约束中$$ g_i(x) $$为凸函数，而凸函数的水平截集$${x|g_i(x) \\le \\alpha}是一个凸集(凸函数的性质)，这就使得不等式约束保证了可行域为凸集；\n对于等式约束$$ h_i(x)=0 $$可以写成：\n$$ \n\\left\\{\n\\begin{array}{c}\nh_i(x) \\le 0 \\\\\nh_i(x) \\ge 0\n\\end{array}\n\\right.\n$$\n\n要使得满足条件的x 组成的集合为凸集，就要求$$ h_i(x) $$ 既是一个凸函数，又是一个凹函数，这样hi(x)便只能是仿射函数了。\n\n以上便是凸优化问题的一般形式。常见的线性规划、二次规划、二次约束二次规划等优化问题都是凸优化问题。\n","slug":"MachineLearning/凸函数、凸集和凸优化","published":1,"updated":"2019-10-20T14:40:17.377Z","layout":"post","photos":[],"link":"","_id":"ck2424lsp0050lksbcbx1wje8","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>记录凸函数、凸集和凸优化的一些问题。<br>在SVM中要用到。</p></div><a id=\"more\"></a><h2 id=\"凸函数\"><a href=\"#凸函数\" class=\"headerlink\" title=\"凸函数\"></a>凸函数</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>用简单的一元函数<script type=\"math/tex\">f(x)</script>来说，如果对于任意<script type=\"math/tex\">t \\in [0,1]</script>均满足：$$ f(tx_1+(1−t)x_2) \\le tf(x_1)+(1−t)f(x_2)，则称f(x)为凸函数(convex function)</p><p>如果对于任意tϵ(0,1)均满足：<script type=\"math/tex\">f(tx_1+(1−t)x_2) \\lt tf(x_1)+(1−t)f(x_2)，则称f(x)为严格凸函数(convex function)</script></p><p>直观上理解，凸函数的隔线在曲线下方。<br></p><p>上述可以推广到多元函数。</p><p>如果优化函数是凸函数，那么，局部最小就是全局最小，不会陷入局部最优里。<br>SVM的目标函数<script type=\"math/tex\">||\\omega||^2</script>就是一个凸函数</p><h3 id=\"判断凸函数\"><a href=\"#判断凸函数\" class=\"headerlink\" title=\"判断凸函数\"></a>判断凸函数</h3><ul><li>一元函数：求二阶导数的符号来判断，如果非负，就是凸函数</li><li>多元函数：通过Hessian矩阵的正定性判断，如果Hessian矩阵是半正定矩阵，那就是凸函数</li></ul><h3 id=\"凸函数性质\"><a href=\"#凸函数性质\" class=\"headerlink\" title=\"凸函数性质\"></a>凸函数性质</h3><p>凸函数满足Jensen不等式：</p><p>如果 f 是凸函数，X是随机变量，那么<script type=\"math/tex\">\\theta_1,…,\\theta_k \\ge 0，\\theta_1 + … + \\theta_k = 1</script>,<script type=\"math/tex\">f(\\theta_1x_1+ … + \\theta_kx_k) \\le \\theta_1f(x_1)+ … + \\theta_kf(x_k)</script></p><p>如果把<script type=\"math/tex\">\\theta</script>看成是<script type=\"math/tex\">x_k</script>的概率，那么就可以理解成下面的一般式子：</p><script type=\"math/tex;mode=display\">f(E(X)) \\le E(f(X))</script><h2 id=\"凸集\"><a href=\"#凸集\" class=\"headerlink\" title=\"凸集\"></a>凸集</h2><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>如果集合 C 为凸集，那么对于任意的<script type=\"math/tex\">x1,x2 in C 与0 \\le \\theta \\le 1都有 \\theta x_1+(1−\\theta)x_2 in C</script>，与仿射集的区别在于仿射集并没有<script type=\"math/tex\">\\theta \\ge 0</script>的要求，例如一条线段是凸集，而一条直线是仿射集。</p><p>扩展到多维的情况，如果有<script type=\"math/tex\">\\theta_1 + \\theta_2 +...+ \\theta_k = 1, \\theta_i \\gt 0</script>，则称具有<script type=\"math/tex\">\\theta_1x_1 + \\theta_2x_2 +...+ \\theta_kx_k</script>形式的点为<script type=\"math/tex\">x_1,x_2....x_k</script>的凸组合。</p><p>称由集合<script type=\"math/tex\">C \\subset R^n</script>中点的所有凸组合所组成的集合为C的凸包：</p><script type=\"math/tex;mode=display\">conv C = { \\theta_1x_1 +...+ \\theta_kx_k | x_1,..,x_k in C, \\theta_1+\\theta_2+...+\\theta_k=1, \\theta_i \\ge 0}</script><p>与仿射包同样，凸包也是包含 C 的最小的凸集，在一般情况下，设<script type=\"math/tex\">C \\subset R^n</script>是凸集，x 是随机变量，并且<script type=\"math/tex\">x in C</script>的概率为1，那么<script type=\"math/tex\">E x \\in C</script></p><h3 id=\"重要的凸集\"><a href=\"#重要的凸集\" class=\"headerlink\" title=\"重要的凸集\"></a>重要的凸集</h3><p>任意的仿射集和子空间都是凸集，一些比较简单的例如空集<script type=\"math/tex\">\\emptyset</script>，单点集{x0}，全空间<script type=\"math/tex\">R^n</script>，直线/射线/线段都是凸的。</p><p>还有一些比较重要的凸集如下：</p><ol><li>超平面<script type=\"math/tex\">{x|a^Tx = b}</script>和半空间<script type=\"math/tex\">{x|a^Tx \\le b}</script></li><li>Euclid球<script type=\"math/tex\">B(x_c,r)={x| ||x−x_c||_2 \\le r}</script></li><li>椭球$$ \\xi ={x|(x−x_c)^T P^(−1) (x−x_c) \\le 1}</li><li>范数球<script type=\"math/tex\">{x| ||x−x_c|| \\le r}，其中 ||⋅|| 是</script>R^n $$中的范数</li><li>范数锥<script type=\"math/tex\">C={(x,t)| ||x|| \\le t} \\subset R^(n+1)</script></li><li>多面体<script type=\"math/tex\">P={x|a^T_j \\le b_j, j=1,...,m, c^T_j x = d_j,j=1,...,p}</script>，即为有限个半空间和超平面的交集，单纯形也为凸集，是一种特殊的多面体半正定锥<script type=\"math/tex\">S^n_+={X \\subset R^{n∗n}|X=X^T,X \\ge 0}</script>，即为半正定对称矩阵的集合_</li></ol><h2 id=\"凸优化问题\"><a href=\"#凸优化问题\" class=\"headerlink\" title=\"凸优化问题\"></a>凸优化问题</h2><p>在优化问题中，凸优化问题由于具有优良的性质（局部最优解即是全局最优解），受到广泛研究。<br>主要作用是，将有约束条件的转换成无约束条件的。</p><p>对于一个含约束的优化问题：</p><script type=\"math/tex;mode=display\">\\left\\{\n\\begin{array}{c}\nmin_x  f(x) \\\\\ns.t. x in C\n\\end{array}\n\\right.</script><p>其中，f(x) 为一个凸函数，变量x 的可行域C 是一个凸集，那么这个优化问题称为一个凸优化问题。<br>将上面的约束条件的形式更加明确一点，一个凸优化问题可以写成：</p><script type=\"math/tex;mode=display\">\\left\\{\n\\begin{array}{c}\nmin_x  f(x) \\\\\ns.t.  & g_i(x) \\le 0 \\\\\n& h_i(x) = 0\n\\end{array}\n\\right.</script><p>其中，f(x) 当然仍然为一个凸函数，但对约束条件有一定要求：<script type=\"math/tex\">g_i(x)</script>是凸函数；<script type=\"math/tex\">h_i(x)</script>为仿射函数。这样的要求当然是为了保证可行域是一个凸集。</p><p>不等式约束中<script type=\"math/tex\">g_i(x)</script>为凸函数，而凸函数的水平截集<script type=\"math/tex\">{x|g_i(x) \\le \\alpha}是一个凸集(凸函数的性质)，这就使得不等式约束保证了可行域为凸集；\n对于等式约束</script>h_i(x)=0 $$可以写成：</p><script type=\"math/tex;mode=display\">\\left\\{\n\\begin{array}{c}\nh_i(x) \\le 0 \\\\\nh_i(x) \\ge 0\n\\end{array}\n\\right.</script><p>要使得满足条件的x 组成的集合为凸集，就要求<script type=\"math/tex\">h_i(x)</script>既是一个凸函数，又是一个凹函数，这样hi(x)便只能是仿射函数了。</p><p>以上便是凸优化问题的一般形式。常见的线性规划、二次规划、二次约束二次规划等优化问题都是凸优化问题。</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>记录凸函数、凸集和凸优化的一些问题。<br>在SVM中要用到。</p></div>","more":"<h2 id=\"凸函数\"><a href=\"#凸函数\" class=\"headerlink\" title=\"凸函数\"></a>凸函数</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>用简单的一元函数<script type=\"math/tex\">f(x)</script>来说，如果对于任意<script type=\"math/tex\">t \\in [0,1]</script>均满足：$$ f(tx_1+(1−t)x_2) \\le tf(x_1)+(1−t)f(x_2)，则称f(x)为凸函数(convex function)</p><p>如果对于任意tϵ(0,1)均满足：<script type=\"math/tex\">f(tx_1+(1−t)x_2) \\lt tf(x_1)+(1−t)f(x_2)，则称f(x)为严格凸函数(convex function)</script></p><p>直观上理解，凸函数的隔线在曲线下方。<br></p><p>上述可以推广到多元函数。</p><p>如果优化函数是凸函数，那么，局部最小就是全局最小，不会陷入局部最优里。<br>SVM的目标函数<script type=\"math/tex\">||\\omega||^2</script>就是一个凸函数</p><h3 id=\"判断凸函数\"><a href=\"#判断凸函数\" class=\"headerlink\" title=\"判断凸函数\"></a>判断凸函数</h3><ul><li>一元函数：求二阶导数的符号来判断，如果非负，就是凸函数</li><li>多元函数：通过Hessian矩阵的正定性判断，如果Hessian矩阵是半正定矩阵，那就是凸函数</li></ul><h3 id=\"凸函数性质\"><a href=\"#凸函数性质\" class=\"headerlink\" title=\"凸函数性质\"></a>凸函数性质</h3><p>凸函数满足Jensen不等式：</p><p>如果 f 是凸函数，X是随机变量，那么<script type=\"math/tex\">\\theta_1,…,\\theta_k \\ge 0，\\theta_1 + … + \\theta_k = 1</script>,<script type=\"math/tex\">f(\\theta_1x_1+ … + \\theta_kx_k) \\le \\theta_1f(x_1)+ … + \\theta_kf(x_k)</script></p><p>如果把<script type=\"math/tex\">\\theta</script>看成是<script type=\"math/tex\">x_k</script>的概率，那么就可以理解成下面的一般式子：</p><script type=\"math/tex;mode=display\">f(E(X)) \\le E(f(X))</script><h2 id=\"凸集\"><a href=\"#凸集\" class=\"headerlink\" title=\"凸集\"></a>凸集</h2><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>如果集合 C 为凸集，那么对于任意的<script type=\"math/tex\">x1,x2 in C 与0 \\le \\theta \\le 1都有 \\theta x_1+(1−\\theta)x_2 in C</script>，与仿射集的区别在于仿射集并没有<script type=\"math/tex\">\\theta \\ge 0</script>的要求，例如一条线段是凸集，而一条直线是仿射集。</p><p>扩展到多维的情况，如果有<script type=\"math/tex\">\\theta_1 + \\theta_2 +...+ \\theta_k = 1, \\theta_i \\gt 0</script>，则称具有<script type=\"math/tex\">\\theta_1x_1 + \\theta_2x_2 +...+ \\theta_kx_k</script>形式的点为<script type=\"math/tex\">x_1,x_2....x_k</script>的凸组合。</p><p>称由集合<script type=\"math/tex\">C \\subset R^n</script>中点的所有凸组合所组成的集合为C的凸包：</p><script type=\"math/tex;mode=display\">conv C = { \\theta_1x_1 +...+ \\theta_kx_k | x_1,..,x_k in C, \\theta_1+\\theta_2+...+\\theta_k=1, \\theta_i \\ge 0}</script><p>与仿射包同样，凸包也是包含 C 的最小的凸集，在一般情况下，设<script type=\"math/tex\">C \\subset R^n</script>是凸集，x 是随机变量，并且<script type=\"math/tex\">x in C</script>的概率为1，那么<script type=\"math/tex\">E x \\in C</script></p><h3 id=\"重要的凸集\"><a href=\"#重要的凸集\" class=\"headerlink\" title=\"重要的凸集\"></a>重要的凸集</h3><p>任意的仿射集和子空间都是凸集，一些比较简单的例如空集<script type=\"math/tex\">\\emptyset</script>，单点集{x0}，全空间<script type=\"math/tex\">R^n</script>，直线/射线/线段都是凸的。</p><p>还有一些比较重要的凸集如下：</p><ol><li>超平面<script type=\"math/tex\">{x|a^Tx = b}</script>和半空间<script type=\"math/tex\">{x|a^Tx \\le b}</script></li><li>Euclid球<script type=\"math/tex\">B(x_c,r)={x| ||x−x_c||_2 \\le r}</script></li><li>椭球$$ \\xi ={x|(x−x_c)^T P^(−1) (x−x_c) \\le 1}</li><li>范数球<script type=\"math/tex\">{x| ||x−x_c|| \\le r}，其中 ||⋅|| 是</script>R^n $$中的范数</li><li>范数锥<script type=\"math/tex\">C={(x,t)| ||x|| \\le t} \\subset R^(n+1)</script></li><li>多面体<script type=\"math/tex\">P={x|a^T_j \\le b_j, j=1,...,m, c^T_j x = d_j,j=1,...,p}</script>，即为有限个半空间和超平面的交集，单纯形也为凸集，是一种特殊的多面体半正定锥<script type=\"math/tex\">S^n_+={X \\subset R^{n∗n}|X=X^T,X \\ge 0}</script>，即为半正定对称矩阵的集合_</li></ol><h2 id=\"凸优化问题\"><a href=\"#凸优化问题\" class=\"headerlink\" title=\"凸优化问题\"></a>凸优化问题</h2><p>在优化问题中，凸优化问题由于具有优良的性质（局部最优解即是全局最优解），受到广泛研究。<br>主要作用是，将有约束条件的转换成无约束条件的。</p><p>对于一个含约束的优化问题：</p><script type=\"math/tex;mode=display\">\\left\\{\n\\begin{array}{c}\nmin_x  f(x) \\\\\ns.t. x in C\n\\end{array}\n\\right.</script><p>其中，f(x) 为一个凸函数，变量x 的可行域C 是一个凸集，那么这个优化问题称为一个凸优化问题。<br>将上面的约束条件的形式更加明确一点，一个凸优化问题可以写成：</p><script type=\"math/tex;mode=display\">\\left\\{\n\\begin{array}{c}\nmin_x  f(x) \\\\\ns.t.  & g_i(x) \\le 0 \\\\\n& h_i(x) = 0\n\\end{array}\n\\right.</script><p>其中，f(x) 当然仍然为一个凸函数，但对约束条件有一定要求：<script type=\"math/tex\">g_i(x)</script>是凸函数；<script type=\"math/tex\">h_i(x)</script>为仿射函数。这样的要求当然是为了保证可行域是一个凸集。</p><p>不等式约束中<script type=\"math/tex\">g_i(x)</script>为凸函数，而凸函数的水平截集<script type=\"math/tex\">{x|g_i(x) \\le \\alpha}是一个凸集(凸函数的性质)，这就使得不等式约束保证了可行域为凸集；\n对于等式约束</script>h_i(x)=0 $$可以写成：</p><script type=\"math/tex;mode=display\">\\left\\{\n\\begin{array}{c}\nh_i(x) \\le 0 \\\\\nh_i(x) \\ge 0\n\\end{array}\n\\right.</script><p>要使得满足条件的x 组成的集合为凸集，就要求<script type=\"math/tex\">h_i(x)</script>既是一个凸函数，又是一个凹函数，这样hi(x)便只能是仿射函数了。</p><p>以上便是凸优化问题的一般形式。常见的线性规划、二次规划、二次约束二次规划等优化问题都是凸优化问题。</p><!-- rebuild by neat -->"},{"title":"超平面、函数间隔和几何间隔","comments":1,"mathjax":true,"date":"2019-10-20T12:24:35.000Z","urlname":"hyperplane-functionalmargin-geometricmargin","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n关于超平面、函数间隔以及几何间隔的理解。\n这些在SVM中要用到。\n{% endnote %}\n<!--more-->\n\n## 超平面\n### 定义\n1. 超平面是指n维线性空间中维度为n-1的子空间。它可以把线性空间分割成不相交的两部分。比如二维空间中，一条直线是一维的，它把平面分成了两块；三维空间中，一个平面是二维的，它把空间分成了两块。\n2. 法向量是指垂直于超平面的向量\n\n### 法向量和超平面公式\n假设在$$R^3$$空间内，那么法向量和平面总是垂直的。如下图：\n{% asset_img faxianglaing.png 三维空间中法向量和平面横截面  %}\n\n$$ x(x_1', x_2, x_3) $$\n$$ x(x_1, x_2, x_3)，x'(x_1', x_2', x_3')，w(w_1, w_2, w_3) $$\n\n不难看出，$$x - x'$$和法向量垂直，于是：\n$$(x-x')w = 0$$\n$$(x_1-x_1', x_2-x_2', x_3-x_3') · (w_1, w_2, w_3) = 0$$\n化简后得：\n$$x_1w_1 + x_2w_2 + x_3w_3 = w_1x_1' + w_2x_2' + w_3x_3'$$\n由于其为常数项，所以令：\n$$b = -w^Tx'$$\n于是超平面公式可以写成:\n$$w^Tx+b = 0$$\n同样可以推导到$$R^n$$空间\n\n### 点到超平面距离\n{% asset_img distance.png 点到超平面距离 %}\nx是平面外一点，距离平面是d，即红色线。\n通过三角函数得到：\n$$ cos{\\theta}=\\dfrac{d}{||x-x'||} $$\n又因为d和法向量平行，所以可以通过向量相乘等于模乘模乘cos得到：\n$$ |(x-x')\\omega|=||x-x'||\\cdot||\\omega||\\cdot\\cos{\\theta} $$\n联立得到：\n$$ d = \\dfrac{|(x-x')\\omega|}{||\\omega||}=\\dfrac{|\\omega x-\\omega x'|}{||\\omega||} $$\n因为$$  x' $$在超平面内，$$ \\omega x'=-b $$，于是最后得到的任意点到超平面的距离公式：\n$$ d=\\dfrac{|\\omega x+b|}{||\\omega||} $$\n\n其实高中学过一点$$ x_i, y_i $$到直线$$  ax+by+c=0 $$的距离公式：\n$$  d(x_i, y_i) = {|ax_i+by_i+c| \\over \\sqrt{a^2+b^2}}$$\n这个和上面通用的公式可以对应\n\n## 函数间隔\n在超平面确定的情况下，点到平面距离公式中，分母不变，所以分子$$|\\omega·x + b|$$可以近似表示点到超平面的距离。\n\n如果$$ \\omega · x + b > 0 $$，则被认为是正类，否则为负类\n如果都正确分类，那么$$  y(\\omega ·x +b) > 0 $$，如果分类错误，那么小于0.\n同时，$$  y(\\omega ·x +b) > 0 $$的绝对值越大，则确信度越大\n\n因此用这个来表示函数间隔。对于一个训练样本(x(i),y(i))我们定义它到超平面(w,b)的函数间隔为:\n$$\\hatγ = y^{(i)}(w^Tx^{(i)}+b)$$ \n\n函数间隔越大越好，并且如果$$ \\hatγ > 0 $$，则样本正确分类\n对于整个训练集，定义函数间隔为所有样本中最小的那个函数间隔:\n$$ \\hatγ = min_i \\hatγ^{(i)}$$\n\n## 几何间隔\n对于函数间隔，有个问题就是，可以在不改变超平面的情况下，让函数间隔任意大。\n如果$$ \\omega $$和$$  b $$倍增，函数间隔改变，但是超平面不变。\n\n因此我们对函数间隔加上一个限制：\n$$ ||\\omega|| = 1 $$\n\n这样是为了，让$$ \\omega和b $$倍增的时候，分母也会倍增，所以几何间隔就不会改变。\n当$$  ||\\omega||=1 $$的时候，几何间隔就是函数间隔\n\n所以几何间隔的公式就是：\n$$ γ^{(i)} = y^{(i)}({w^T \\over ∥w∥}x^{(i)}+{b \\over ∥w∥}) $$\n\n训练集的集合间隔是所有样本中最小的那个：\n$$ γ = min_iγ^{(i)}$$\n\n有没有发现，几何间隔其实就是**点到平面的距离**\n\n函数间隔和几何间隔的关系：\n$$  γ^{(i)}={\\hatγ^{(i)} \\over ∥w∥ }$$\n\n","source":"_posts/MachineLearning/超平面、函数间隔和几何间隔.md","raw":"---\ntitle: 超平面、函数间隔和几何间隔\ntags:\n  - 超平面\n  - 函数间隔\n  - 几何间隔\n  - SVM\ncategories:\n  - MachineLearning\ncomments: true\nmathjax: true\ndate: 2019-10-20 20:24:35\nurlname: hyperplane-functionalmargin-geometricmargin\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n关于超平面、函数间隔以及几何间隔的理解。\n这些在SVM中要用到。\n{% endnote %}\n<!--more-->\n\n## 超平面\n### 定义\n1. 超平面是指n维线性空间中维度为n-1的子空间。它可以把线性空间分割成不相交的两部分。比如二维空间中，一条直线是一维的，它把平面分成了两块；三维空间中，一个平面是二维的，它把空间分成了两块。\n2. 法向量是指垂直于超平面的向量\n\n### 法向量和超平面公式\n假设在$$R^3$$空间内，那么法向量和平面总是垂直的。如下图：\n{% asset_img faxianglaing.png 三维空间中法向量和平面横截面  %}\n\n$$ x(x_1', x_2, x_3) $$\n$$ x(x_1, x_2, x_3)，x'(x_1', x_2', x_3')，w(w_1, w_2, w_3) $$\n\n不难看出，$$x - x'$$和法向量垂直，于是：\n$$(x-x')w = 0$$\n$$(x_1-x_1', x_2-x_2', x_3-x_3') · (w_1, w_2, w_3) = 0$$\n化简后得：\n$$x_1w_1 + x_2w_2 + x_3w_3 = w_1x_1' + w_2x_2' + w_3x_3'$$\n由于其为常数项，所以令：\n$$b = -w^Tx'$$\n于是超平面公式可以写成:\n$$w^Tx+b = 0$$\n同样可以推导到$$R^n$$空间\n\n### 点到超平面距离\n{% asset_img distance.png 点到超平面距离 %}\nx是平面外一点，距离平面是d，即红色线。\n通过三角函数得到：\n$$ cos{\\theta}=\\dfrac{d}{||x-x'||} $$\n又因为d和法向量平行，所以可以通过向量相乘等于模乘模乘cos得到：\n$$ |(x-x')\\omega|=||x-x'||\\cdot||\\omega||\\cdot\\cos{\\theta} $$\n联立得到：\n$$ d = \\dfrac{|(x-x')\\omega|}{||\\omega||}=\\dfrac{|\\omega x-\\omega x'|}{||\\omega||} $$\n因为$$  x' $$在超平面内，$$ \\omega x'=-b $$，于是最后得到的任意点到超平面的距离公式：\n$$ d=\\dfrac{|\\omega x+b|}{||\\omega||} $$\n\n其实高中学过一点$$ x_i, y_i $$到直线$$  ax+by+c=0 $$的距离公式：\n$$  d(x_i, y_i) = {|ax_i+by_i+c| \\over \\sqrt{a^2+b^2}}$$\n这个和上面通用的公式可以对应\n\n## 函数间隔\n在超平面确定的情况下，点到平面距离公式中，分母不变，所以分子$$|\\omega·x + b|$$可以近似表示点到超平面的距离。\n\n如果$$ \\omega · x + b > 0 $$，则被认为是正类，否则为负类\n如果都正确分类，那么$$  y(\\omega ·x +b) > 0 $$，如果分类错误，那么小于0.\n同时，$$  y(\\omega ·x +b) > 0 $$的绝对值越大，则确信度越大\n\n因此用这个来表示函数间隔。对于一个训练样本(x(i),y(i))我们定义它到超平面(w,b)的函数间隔为:\n$$\\hatγ = y^{(i)}(w^Tx^{(i)}+b)$$ \n\n函数间隔越大越好，并且如果$$ \\hatγ > 0 $$，则样本正确分类\n对于整个训练集，定义函数间隔为所有样本中最小的那个函数间隔:\n$$ \\hatγ = min_i \\hatγ^{(i)}$$\n\n## 几何间隔\n对于函数间隔，有个问题就是，可以在不改变超平面的情况下，让函数间隔任意大。\n如果$$ \\omega $$和$$  b $$倍增，函数间隔改变，但是超平面不变。\n\n因此我们对函数间隔加上一个限制：\n$$ ||\\omega|| = 1 $$\n\n这样是为了，让$$ \\omega和b $$倍增的时候，分母也会倍增，所以几何间隔就不会改变。\n当$$  ||\\omega||=1 $$的时候，几何间隔就是函数间隔\n\n所以几何间隔的公式就是：\n$$ γ^{(i)} = y^{(i)}({w^T \\over ∥w∥}x^{(i)}+{b \\over ∥w∥}) $$\n\n训练集的集合间隔是所有样本中最小的那个：\n$$ γ = min_iγ^{(i)}$$\n\n有没有发现，几何间隔其实就是**点到平面的距离**\n\n函数间隔和几何间隔的关系：\n$$  γ^{(i)}={\\hatγ^{(i)} \\over ∥w∥ }$$\n\n","slug":"MachineLearning/超平面、函数间隔和几何间隔","published":1,"updated":"2019-10-20T13:39:38.401Z","layout":"post","photos":[],"link":"","_id":"ck2424lsu0053lksbrb6lf4gy","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>关于超平面、函数间隔以及几何间隔的理解。<br>这些在SVM中要用到。</p></div><a id=\"more\"></a><h2 id=\"超平面\"><a href=\"#超平面\" class=\"headerlink\" title=\"超平面\"></a>超平面</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ol><li>超平面是指n维线性空间中维度为n-1的子空间。它可以把线性空间分割成不相交的两部分。比如二维空间中，一条直线是一维的，它把平面分成了两块；三维空间中，一个平面是二维的，它把空间分成了两块。</li><li>法向量是指垂直于超平面的向量</li></ol><h3 id=\"法向量和超平面公式\"><a href=\"#法向量和超平面公式\" class=\"headerlink\" title=\"法向量和超平面公式\"></a>法向量和超平面公式</h3><p>假设在<script type=\"math/tex\">R^3</script>空间内，那么法向量和平面总是垂直的。如下图：<br></p><script type=\"math/tex;mode=display\">x(x_1', x_2, x_3)</script><script type=\"math/tex;mode=display\">x(x_1, x_2, x_3)，x'(x_1', x_2', x_3')，w(w_1, w_2, w_3)</script><p>不难看出，<script type=\"math/tex\">x - x'</script>和法向量垂直，于是：</p><script type=\"math/tex;mode=display\">(x-x')w = 0</script><script type=\"math/tex;mode=display\">(x_1-x_1', x_2-x_2', x_3-x_3') · (w_1, w_2, w_3) = 0</script><p>化简后得：</p><script type=\"math/tex;mode=display\">x_1w_1 + x_2w_2 + x_3w_3 = w_1x_1' + w_2x_2' + w_3x_3'</script><p>由于其为常数项，所以令：</p><script type=\"math/tex;mode=display\">b = -w^Tx'</script><p>于是超平面公式可以写成:</p><script type=\"math/tex;mode=display\">w^Tx+b = 0</script><p>同样可以推导到<script type=\"math/tex\">R^n</script>空间</p><h3 id=\"点到超平面距离\"><a href=\"#点到超平面距离\" class=\"headerlink\" title=\"点到超平面距离\"></a>点到超平面距离</h3><img src=\"/MachineLearning/2019-10-20-hyperplane-functionalmargin-geometricmargin/distance.png\" title=\"点到超平面距离\"><p>x是平面外一点，距离平面是d，即红色线。<br>通过三角函数得到：</p><script type=\"math/tex;mode=display\">cos{\\theta}=\\dfrac{d}{||x-x'||}</script><p>又因为d和法向量平行，所以可以通过向量相乘等于模乘模乘cos得到：</p><script type=\"math/tex;mode=display\">|(x-x')\\omega|=||x-x'||\\cdot||\\omega||\\cdot\\cos{\\theta}</script><p>联立得到：</p><script type=\"math/tex;mode=display\">d = \\dfrac{|(x-x')\\omega|}{||\\omega||}=\\dfrac{|\\omega x-\\omega x'|}{||\\omega||}</script><p>因为<script type=\"math/tex\">x'</script>在超平面内，<script type=\"math/tex\">\\omega x'=-b</script>，于是最后得到的任意点到超平面的距离公式：</p><script type=\"math/tex;mode=display\">d=\\dfrac{|\\omega x+b|}{||\\omega||}</script><p>其实高中学过一点<script type=\"math/tex\">x_i, y_i</script>到直线<script type=\"math/tex\">ax+by+c=0</script>的距离公式：</p><script type=\"math/tex;mode=display\">d(x_i, y_i) = {|ax_i+by_i+c| \\over \\sqrt{a^2+b^2}}</script><p>这个和上面通用的公式可以对应</p><h2 id=\"函数间隔\"><a href=\"#函数间隔\" class=\"headerlink\" title=\"函数间隔\"></a>函数间隔</h2><p>在超平面确定的情况下，点到平面距离公式中，分母不变，所以分子<script type=\"math/tex\">|\\omega·x + b|</script>可以近似表示点到超平面的距离。</p><p>如果<script type=\"math/tex\">\\omega · x + b > 0</script>，则被认为是正类，否则为负类<br>如果都正确分类，那么<script type=\"math/tex\">y(\\omega ·x +b) > 0</script>，如果分类错误，那么小于0.<br>同时，<script type=\"math/tex\">y(\\omega ·x +b) > 0</script>的绝对值越大，则确信度越大</p><p>因此用这个来表示函数间隔。对于一个训练样本(x(i),y(i))我们定义它到超平面(w,b)的函数间隔为:</p><script type=\"math/tex;mode=display\">\\hatγ = y^{(i)}(w^Tx^{(i)}+b)</script><p>函数间隔越大越好，并且如果<script type=\"math/tex\">\\hatγ > 0</script>，则样本正确分类<br>对于整个训练集，定义函数间隔为所有样本中最小的那个函数间隔:</p><script type=\"math/tex;mode=display\">\\hatγ = min_i \\hatγ^{(i)}</script><h2 id=\"几何间隔\"><a href=\"#几何间隔\" class=\"headerlink\" title=\"几何间隔\"></a>几何间隔</h2><p>对于函数间隔，有个问题就是，可以在不改变超平面的情况下，让函数间隔任意大。<br>如果<script type=\"math/tex\">\\omega</script>和<script type=\"math/tex\">b</script>倍增，函数间隔改变，但是超平面不变。</p><p>因此我们对函数间隔加上一个限制：</p><script type=\"math/tex;mode=display\">||\\omega|| = 1</script><p>这样是为了，让<script type=\"math/tex\">\\omega和b</script>倍增的时候，分母也会倍增，所以几何间隔就不会改变。<br>当<script type=\"math/tex\">||\\omega||=1</script>的时候，几何间隔就是函数间隔</p><p>所以几何间隔的公式就是：</p><script type=\"math/tex;mode=display\">γ^{(i)} = y^{(i)}({w^T \\over ∥w∥}x^{(i)}+{b \\over ∥w∥})</script><p>训练集的集合间隔是所有样本中最小的那个：</p><script type=\"math/tex;mode=display\">γ = min_iγ^{(i)}</script><p>有没有发现，几何间隔其实就是<strong>点到平面的距离</strong></p><p>函数间隔和几何间隔的关系：</p><script type=\"math/tex;mode=display\">γ^{(i)}={\\hatγ^{(i)} \\over ∥w∥ }</script><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>关于超平面、函数间隔以及几何间隔的理解。<br>这些在SVM中要用到。</p></div>","more":"<h2 id=\"超平面\"><a href=\"#超平面\" class=\"headerlink\" title=\"超平面\"></a>超平面</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ol><li>超平面是指n维线性空间中维度为n-1的子空间。它可以把线性空间分割成不相交的两部分。比如二维空间中，一条直线是一维的，它把平面分成了两块；三维空间中，一个平面是二维的，它把空间分成了两块。</li><li>法向量是指垂直于超平面的向量</li></ol><h3 id=\"法向量和超平面公式\"><a href=\"#法向量和超平面公式\" class=\"headerlink\" title=\"法向量和超平面公式\"></a>法向量和超平面公式</h3><p>假设在<script type=\"math/tex\">R^3</script>空间内，那么法向量和平面总是垂直的。如下图：<br></p><script type=\"math/tex;mode=display\">x(x_1', x_2, x_3)</script><script type=\"math/tex;mode=display\">x(x_1, x_2, x_3)，x'(x_1', x_2', x_3')，w(w_1, w_2, w_3)</script><p>不难看出，<script type=\"math/tex\">x - x'</script>和法向量垂直，于是：</p><script type=\"math/tex;mode=display\">(x-x')w = 0</script><script type=\"math/tex;mode=display\">(x_1-x_1', x_2-x_2', x_3-x_3') · (w_1, w_2, w_3) = 0</script><p>化简后得：</p><script type=\"math/tex;mode=display\">x_1w_1 + x_2w_2 + x_3w_3 = w_1x_1' + w_2x_2' + w_3x_3'</script><p>由于其为常数项，所以令：</p><script type=\"math/tex;mode=display\">b = -w^Tx'</script><p>于是超平面公式可以写成:</p><script type=\"math/tex;mode=display\">w^Tx+b = 0</script><p>同样可以推导到<script type=\"math/tex\">R^n</script>空间</p><h3 id=\"点到超平面距离\"><a href=\"#点到超平面距离\" class=\"headerlink\" title=\"点到超平面距离\"></a>点到超平面距离</h3><img src=\"/MachineLearning/2019-10-20-hyperplane-functionalmargin-geometricmargin/distance.png\" title=\"点到超平面距离\"><p>x是平面外一点，距离平面是d，即红色线。<br>通过三角函数得到：</p><script type=\"math/tex;mode=display\">cos{\\theta}=\\dfrac{d}{||x-x'||}</script><p>又因为d和法向量平行，所以可以通过向量相乘等于模乘模乘cos得到：</p><script type=\"math/tex;mode=display\">|(x-x')\\omega|=||x-x'||\\cdot||\\omega||\\cdot\\cos{\\theta}</script><p>联立得到：</p><script type=\"math/tex;mode=display\">d = \\dfrac{|(x-x')\\omega|}{||\\omega||}=\\dfrac{|\\omega x-\\omega x'|}{||\\omega||}</script><p>因为<script type=\"math/tex\">x'</script>在超平面内，<script type=\"math/tex\">\\omega x'=-b</script>，于是最后得到的任意点到超平面的距离公式：</p><script type=\"math/tex;mode=display\">d=\\dfrac{|\\omega x+b|}{||\\omega||}</script><p>其实高中学过一点<script type=\"math/tex\">x_i, y_i</script>到直线<script type=\"math/tex\">ax+by+c=0</script>的距离公式：</p><script type=\"math/tex;mode=display\">d(x_i, y_i) = {|ax_i+by_i+c| \\over \\sqrt{a^2+b^2}}</script><p>这个和上面通用的公式可以对应</p><h2 id=\"函数间隔\"><a href=\"#函数间隔\" class=\"headerlink\" title=\"函数间隔\"></a>函数间隔</h2><p>在超平面确定的情况下，点到平面距离公式中，分母不变，所以分子<script type=\"math/tex\">|\\omega·x + b|</script>可以近似表示点到超平面的距离。</p><p>如果<script type=\"math/tex\">\\omega · x + b > 0</script>，则被认为是正类，否则为负类<br>如果都正确分类，那么<script type=\"math/tex\">y(\\omega ·x +b) > 0</script>，如果分类错误，那么小于0.<br>同时，<script type=\"math/tex\">y(\\omega ·x +b) > 0</script>的绝对值越大，则确信度越大</p><p>因此用这个来表示函数间隔。对于一个训练样本(x(i),y(i))我们定义它到超平面(w,b)的函数间隔为:</p><script type=\"math/tex;mode=display\">\\hatγ = y^{(i)}(w^Tx^{(i)}+b)</script><p>函数间隔越大越好，并且如果<script type=\"math/tex\">\\hatγ > 0</script>，则样本正确分类<br>对于整个训练集，定义函数间隔为所有样本中最小的那个函数间隔:</p><script type=\"math/tex;mode=display\">\\hatγ = min_i \\hatγ^{(i)}</script><h2 id=\"几何间隔\"><a href=\"#几何间隔\" class=\"headerlink\" title=\"几何间隔\"></a>几何间隔</h2><p>对于函数间隔，有个问题就是，可以在不改变超平面的情况下，让函数间隔任意大。<br>如果<script type=\"math/tex\">\\omega</script>和<script type=\"math/tex\">b</script>倍增，函数间隔改变，但是超平面不变。</p><p>因此我们对函数间隔加上一个限制：</p><script type=\"math/tex;mode=display\">||\\omega|| = 1</script><p>这样是为了，让<script type=\"math/tex\">\\omega和b</script>倍增的时候，分母也会倍增，所以几何间隔就不会改变。<br>当<script type=\"math/tex\">||\\omega||=1</script>的时候，几何间隔就是函数间隔</p><p>所以几何间隔的公式就是：</p><script type=\"math/tex;mode=display\">γ^{(i)} = y^{(i)}({w^T \\over ∥w∥}x^{(i)}+{b \\over ∥w∥})</script><p>训练集的集合间隔是所有样本中最小的那个：</p><script type=\"math/tex;mode=display\">γ = min_iγ^{(i)}</script><p>有没有发现，几何间隔其实就是<strong>点到平面的距离</strong></p><p>函数间隔和几何间隔的关系：</p><script type=\"math/tex;mode=display\">γ^{(i)}={\\hatγ^{(i)} \\over ∥w∥ }</script><!-- rebuild by neat -->"},{"title":"LeetCode-001-Two Sum","comments":1,"mathjax":false,"date":"2019-04-07T15:31:44.000Z","urlname":"leetcode-two-sum","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/two-sum/)   \nGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. UPDATE (2016/2/13): The return format had been changed to zero-based indices. Please read the above updated description carefully.\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 刚开始第一反应就是暴力遍历，但是时间复杂度是$$ O(n^2) $$\n- 题解用了hash map，时间复杂度为$$ O(n) $$\n  - 第一种方式是两遍hash，第一遍将元素添加进去，第二遍遍历元素\n  - 第二种方式一遍hash，一边添加元素一边判断结果是否在已添加的元素中\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> res;\n        map<int,int> numMap;          //创建map\n        map<int ,int>::iterator it;   //创建迭代器\n\n        for(int i=0;i<nums.size();i++){\n            it=numMap.find(target-nums[i]);       //find函数查找key\n            if(it!=numMap.end()){                 //如果到了end就说明没找到\n                res.push_back(i);\n                res.push_back(numMap[target-nums[i]]);\n                return res;\n            }\n            numMap.insert(make_pair(nums[i],i));  //插入pair\n        }\n        return res;\n    }\n};\n```\n\n{% note info %}\n## C++中vector用法回忆：\n- 创建：$$ vector<int> vec; $$\n- 访问：int i=vec[0];\n- 插入：vec.push_back(1); vec.insert(index,val)，在第i个元素后面插入\n- 删除：\n  - vec.pop_back(),删除最后一个\n  - vec.erase(index)，删除index位置处元素\n  - vec.erase(1,3)，删除[1,3)区间的元素\n- 大小：vec.size();\n- 清空：vec.clear();\n- 翻转：reverse(vec.begin(),vec.end());将元素翻转在vecotr，要#include<algorithm>\n- 排序：\n  - sort(vec.begin(),vec.end());默认按照升序排列\n  - sort(vec.begin(),vec.end(),cmp);定义排序比较函数将序排列\n> bool cmp(const int&a,const int&b){\n>   return a>b;\n> }\n- 迭代器访问\n> vector<int>::iterator it;\n> for(it=vec.begin();it!=vec.end();it++)\n>   cout<<\\*it<<endl;\n{% endnote %}\n\n\n{% note info %}\n## C++中map的用法\n- 创建：$$ map<string, int>mapString; $$ key类型为string，val类型为int\n- 添加：\n  - mapString[\"hello\"]=1; 最常用的最简单的插入方式,**会覆盖之前的数据**\n  - mapString.insert(make_pair(\"hello\",1));  次常用,** insert()不会覆盖之前的数据**\n  - mapString.insert(pair<string,int>(\"hello\",1));\n  - mapString.insert(map<string,int>::value_type(\"hello\",1));\n- 迭代：\n> map<string,int>::iterator it;\n> for ( it = mapString.begin( ); it != mapString.end( ); it++ )\n>   cout << \" \" << it -> second;\n\n- 查找：\n  - **不建议!** mapString[\"hello\"];返回\"hello\"对应的值，如果不存在，则添加一个元素，key为\"hello\",val为类型默认值,并返回这个默认值\n  - mapString.count(\"hello\"); map::count()方法返回被查找元素的个数,只有0或1\n  - map::find()方法,返回的是被查找元素的位置，没有则返回map.end()\n> map<string,int>::iterator it;\n> it = mapString.find(\"hello\");\n> if(it==test.end()){\n>   cout<<\"hello not found\"<<endl;\n> }\n\n- 删除:\n  - mapString.erase(\"hello\");\n  - 用迭代器删除,注意在迭代期间是不能被删除的\n> map<string,int>::iterator it;\n> it = mapString.find(\"hello\");\n> \n> if(it==mapString.end())  cout<<\"hello not found\"<<endl;\n> else  mapString.erase(it);\n\n- 排序：map中元素自动按照key升序排序，不可以用sort函数\n- 大小：mapString.size();\n- 清除：mapString.clear();\n\n{% endnote %}\n\n## Python Codes\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        map = {}\n        for i, num in enumerate(nums):\n            if target - num in map:\n                return [map[target - num], i]\n            map[num] = i\n\n        return []\n```\n\n{% note info %}\nlist中遍历的三种方式：\n1. for items in list:  根据元素遍历\n2. for index in range(len(list)):  根据索引遍历\n3. enumerate(seq, [start=0])  创建枚举对象，同时列出数据下标和数据\n  - seq: 一个序列、迭代器或其他支持迭代对象, 如列表、元组或字符串\n  - start: 下标起始位置\n  - 返回：一个列表 [(下标，数据)...], 例如[(1, 'a'), (2, 'b'), (3, 'c')]\n4. iterList = iter(list)  创建迭代器遍历\n  - 用法：for item in iterList: print(item)\n{% endnote %}\n\n## 总结\n虽然第一题很简单，但是深入了看还是能学了不少东西的，在遍历这方面，时间复杂度优化可以用map，C++时间复杂度可以从$$ O(n) $$降到$$ O(logn) $$，python和java可以直接降到$$ O(1) $$.\n\n而且打完代码复习了C++中vector的用法，还有pythonlist的enumerate遍历。C++ STL中的map是现学现卖了.\n\n打算每天一题，感觉有点晚了，亡羊补牢把。\n\n--------\n\n\n\n\n","source":"_posts/LeetCode/LeetCode-001-Two-Sum.md","raw":"---\ntitle: LeetCode-001-Two Sum\ncomments: true\nmathjax: false\ndate: 2019-04-07 23:31:44\ntags: \n  - Algorithm\n  - LeetCode\n  - Hash Map\n  - Math\n  - Easy\ncategories: [LeetCode]\nurlname: leetcode-two-sum\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/two-sum/)   \nGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. UPDATE (2016/2/13): The return format had been changed to zero-based indices. Please read the above updated description carefully.\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 刚开始第一反应就是暴力遍历，但是时间复杂度是$$ O(n^2) $$\n- 题解用了hash map，时间复杂度为$$ O(n) $$\n  - 第一种方式是两遍hash，第一遍将元素添加进去，第二遍遍历元素\n  - 第二种方式一遍hash，一边添加元素一边判断结果是否在已添加的元素中\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> res;\n        map<int,int> numMap;          //创建map\n        map<int ,int>::iterator it;   //创建迭代器\n\n        for(int i=0;i<nums.size();i++){\n            it=numMap.find(target-nums[i]);       //find函数查找key\n            if(it!=numMap.end()){                 //如果到了end就说明没找到\n                res.push_back(i);\n                res.push_back(numMap[target-nums[i]]);\n                return res;\n            }\n            numMap.insert(make_pair(nums[i],i));  //插入pair\n        }\n        return res;\n    }\n};\n```\n\n{% note info %}\n## C++中vector用法回忆：\n- 创建：$$ vector<int> vec; $$\n- 访问：int i=vec[0];\n- 插入：vec.push_back(1); vec.insert(index,val)，在第i个元素后面插入\n- 删除：\n  - vec.pop_back(),删除最后一个\n  - vec.erase(index)，删除index位置处元素\n  - vec.erase(1,3)，删除[1,3)区间的元素\n- 大小：vec.size();\n- 清空：vec.clear();\n- 翻转：reverse(vec.begin(),vec.end());将元素翻转在vecotr，要#include<algorithm>\n- 排序：\n  - sort(vec.begin(),vec.end());默认按照升序排列\n  - sort(vec.begin(),vec.end(),cmp);定义排序比较函数将序排列\n> bool cmp(const int&a,const int&b){\n>   return a>b;\n> }\n- 迭代器访问\n> vector<int>::iterator it;\n> for(it=vec.begin();it!=vec.end();it++)\n>   cout<<\\*it<<endl;\n{% endnote %}\n\n\n{% note info %}\n## C++中map的用法\n- 创建：$$ map<string, int>mapString; $$ key类型为string，val类型为int\n- 添加：\n  - mapString[\"hello\"]=1; 最常用的最简单的插入方式,**会覆盖之前的数据**\n  - mapString.insert(make_pair(\"hello\",1));  次常用,** insert()不会覆盖之前的数据**\n  - mapString.insert(pair<string,int>(\"hello\",1));\n  - mapString.insert(map<string,int>::value_type(\"hello\",1));\n- 迭代：\n> map<string,int>::iterator it;\n> for ( it = mapString.begin( ); it != mapString.end( ); it++ )\n>   cout << \" \" << it -> second;\n\n- 查找：\n  - **不建议!** mapString[\"hello\"];返回\"hello\"对应的值，如果不存在，则添加一个元素，key为\"hello\",val为类型默认值,并返回这个默认值\n  - mapString.count(\"hello\"); map::count()方法返回被查找元素的个数,只有0或1\n  - map::find()方法,返回的是被查找元素的位置，没有则返回map.end()\n> map<string,int>::iterator it;\n> it = mapString.find(\"hello\");\n> if(it==test.end()){\n>   cout<<\"hello not found\"<<endl;\n> }\n\n- 删除:\n  - mapString.erase(\"hello\");\n  - 用迭代器删除,注意在迭代期间是不能被删除的\n> map<string,int>::iterator it;\n> it = mapString.find(\"hello\");\n> \n> if(it==mapString.end())  cout<<\"hello not found\"<<endl;\n> else  mapString.erase(it);\n\n- 排序：map中元素自动按照key升序排序，不可以用sort函数\n- 大小：mapString.size();\n- 清除：mapString.clear();\n\n{% endnote %}\n\n## Python Codes\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        map = {}\n        for i, num in enumerate(nums):\n            if target - num in map:\n                return [map[target - num], i]\n            map[num] = i\n\n        return []\n```\n\n{% note info %}\nlist中遍历的三种方式：\n1. for items in list:  根据元素遍历\n2. for index in range(len(list)):  根据索引遍历\n3. enumerate(seq, [start=0])  创建枚举对象，同时列出数据下标和数据\n  - seq: 一个序列、迭代器或其他支持迭代对象, 如列表、元组或字符串\n  - start: 下标起始位置\n  - 返回：一个列表 [(下标，数据)...], 例如[(1, 'a'), (2, 'b'), (3, 'c')]\n4. iterList = iter(list)  创建迭代器遍历\n  - 用法：for item in iterList: print(item)\n{% endnote %}\n\n## 总结\n虽然第一题很简单，但是深入了看还是能学了不少东西的，在遍历这方面，时间复杂度优化可以用map，C++时间复杂度可以从$$ O(n) $$降到$$ O(logn) $$，python和java可以直接降到$$ O(1) $$.\n\n而且打完代码复习了C++中vector的用法，还有pythonlist的enumerate遍历。C++ STL中的map是现学现卖了.\n\n打算每天一题，感觉有点晚了，亡羊补牢把。\n\n--------\n\n\n\n\n","slug":"LeetCode/LeetCode-001-Two-Sum","published":1,"updated":"2019-07-25T17:51:24.258Z","layout":"post","photos":[],"link":"","_id":"ck2424lt00055lksbbgjgj94u","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/two-sum/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. UPDATE (2016/2/13): The return format had been changed to zero-based indices. Please read the above updated description carefully.</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>刚开始第一反应就是暴力遍历，但是时间复杂度是<script type=\"math/tex\">O(n^2)</script></li><li>题解用了hash map，时间复杂度为<script type=\"math/tex\">O(n)</script><ul><li>第一种方式是两遍hash，第一遍将元素添加进去，第二遍遍历元素</li><li>第二种方式一遍hash，一边添加元素一边判断结果是否在已添加的元素中</li></ul></li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; numMap;          <span class=\"comment\">//创建map</span></span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span> ,<span class=\"keyword\">int</span>&gt;::iterator it;   <span class=\"comment\">//创建迭代器</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class=\"line\">            it=numMap.find(target-nums[i]);       <span class=\"comment\">//find函数查找key</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(it!=numMap.end())&#123;                 <span class=\"comment\">//如果到了end就说明没找到</span></span><br><span class=\"line\">                res.push_back(i);</span><br><span class=\"line\">                res.push_back(numMap[target-nums[i]]);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            numMap.insert(make_pair(nums[i],i));  <span class=\"comment\">//插入pair</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><div class=\"note info\"><h2 id=\"C-中vector用法回忆：\"><a href=\"#C-中vector用法回忆：\" class=\"headerlink\" title=\"C++中vector用法回忆：\"></a>C++中vector用法回忆：</h2><ul><li>创建：<script type=\"math/tex\">vector<int> vec;</script></li><li>访问：int i=vec[0];</li><li>插入：vec.push_back(1); vec.insert(index,val)，在第i个元素后面插入</li><li>删除：<ul><li>vec.pop_back(),删除最后一个</li><li>vec.erase(index)，删除index位置处元素</li><li>vec.erase(1,3)，删除[1,3)区间的元素</li></ul></li><li>大小：vec.size();</li><li>清空：vec.clear();</li><li>翻转：reverse(vec.begin(),vec.end());将元素翻转在vecotr，要#include<algorithm></algorithm></li><li>排序：<ul><li>sort(vec.begin(),vec.end());默认按照升序排列</li><li>sort(vec.begin(),vec.end(),cmp);定义排序比较函数将序排列<blockquote><p>bool cmp(const int&amp;a,const int&amp;b){<br>return a&gt;b;<br>}</p></blockquote></li></ul></li><li>迭代器访问<blockquote><p>vector<int>::iterator it;<br>for(it=vec.begin();it!=vec.end();it++)<br>cout&lt;&lt;*it&lt;&lt;endl;</int></p></blockquote></li></ul></div><div class=\"note info\"><h2 id=\"C-中map的用法\"><a href=\"#C-中map的用法\" class=\"headerlink\" title=\"C++中map的用法\"></a>C++中map的用法</h2><ul><li>创建：<script type=\"math/tex\">map<string, int>mapString;</script>key类型为string，val类型为int</li><li>添加：<ul><li>mapString[“hello”]=1; 最常用的最简单的插入方式,<strong>会覆盖之前的数据</strong></li><li>mapString.insert(make_pair(“hello”,1)); 次常用,<strong> insert()不会覆盖之前的数据</strong></li><li>mapString.insert(pair<string ,int=\"\">(“hello”,1));</string></li><li>mapString.insert(map<string ,int=\"\">::value_type(“hello”,1));</string></li></ul></li><li><p>迭代：</p><blockquote><p>map<string ,int=\"\">::iterator it;<br>for ( it = mapString.begin( ); it != mapString.end( ); it++ )<br>cout &lt;&lt; “ “ &lt;&lt; it -&gt; second;</string></p></blockquote></li><li><p>查找：</p><ul><li><strong>不建议!</strong> mapString[“hello”];返回”hello”对应的值，如果不存在，则添加一个元素，key为”hello”,val为类型默认值,并返回这个默认值</li><li>mapString.count(“hello”); map::count()方法返回被查找元素的个数,只有0或1</li><li>map::find()方法,返回的是被查找元素的位置，没有则返回map.end()<blockquote><p>map<string ,int=\"\">::iterator it;<br>it = mapString.find(“hello”);<br>if(it==test.end()){<br>cout&lt;&lt;”hello not found”&lt;&lt;endl;<br>}</string></p></blockquote></li></ul></li><li><p>删除:</p><ul><li>mapString.erase(“hello”);</li><li>用迭代器删除,注意在迭代期间是不能被删除的<blockquote><p>map<string ,int=\"\">::iterator it;<br>it = mapString.find(“hello”);</string></p><p>if(it==mapString.end()) cout&lt;&lt;”hello not found”&lt;&lt;endl;<br>else mapString.erase(it);</p></blockquote></li></ul></li><li><p>排序：map中元素自动按照key升序排序，不可以用sort函数</p></li><li>大小：mapString.size();</li><li>清除：mapString.clear();</li></ul></div><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoSum</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        map = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target - num <span class=\"keyword\">in</span> map:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [map[target - num], i]</span><br><span class=\"line\">            map[num] = i</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br></pre></td></tr></table></figure><div class=\"note info\"><p>list中遍历的三种方式：</p><ol><li>for items in list: 根据元素遍历</li><li>for index in range(len(list)): 根据索引遍历</li><li>enumerate(seq, [start=0]) 创建枚举对象，同时列出数据下标和数据<ul><li>seq: 一个序列、迭代器或其他支持迭代对象, 如列表、元组或字符串</li><li>start: 下标起始位置</li><li>返回：一个列表 [(下标，数据)…], 例如[(1, ‘a’), (2, ‘b’), (3, ‘c’)]</li></ul></li><li>iterList = iter(list) 创建迭代器遍历<ul><li>用法：for item in iterList: print(item)</li></ul></li></ol></div><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>虽然第一题很简单，但是深入了看还是能学了不少东西的，在遍历这方面，时间复杂度优化可以用map，C++时间复杂度可以从<script type=\"math/tex\">O(n)</script>降到<script type=\"math/tex\">O(logn)</script>，python和java可以直接降到<script type=\"math/tex\">O(1)</script>.</p><p>而且打完代码复习了C++中vector的用法，还有pythonlist的enumerate遍历。C++ STL中的map是现学现卖了.</p><p>打算每天一题，感觉有点晚了，亡羊补牢把。</p><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/two-sum/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. UPDATE (2016/2/13): The return format had been changed to zero-based indices. Please read the above updated description carefully.</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>刚开始第一反应就是暴力遍历，但是时间复杂度是<script type=\"math/tex\">O(n^2)</script></li><li>题解用了hash map，时间复杂度为<script type=\"math/tex\">O(n)</script><ul><li>第一种方式是两遍hash，第一遍将元素添加进去，第二遍遍历元素</li><li>第二种方式一遍hash，一边添加元素一边判断结果是否在已添加的元素中</li></ul></li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; numMap;          <span class=\"comment\">//创建map</span></span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span> ,<span class=\"keyword\">int</span>&gt;::iterator it;   <span class=\"comment\">//创建迭代器</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class=\"line\">            it=numMap.find(target-nums[i]);       <span class=\"comment\">//find函数查找key</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(it!=numMap.end())&#123;                 <span class=\"comment\">//如果到了end就说明没找到</span></span><br><span class=\"line\">                res.push_back(i);</span><br><span class=\"line\">                res.push_back(numMap[target-nums[i]]);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            numMap.insert(make_pair(nums[i],i));  <span class=\"comment\">//插入pair</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><div class=\"note info\"><h2 id=\"C-中vector用法回忆：\"><a href=\"#C-中vector用法回忆：\" class=\"headerlink\" title=\"C++中vector用法回忆：\"></a>C++中vector用法回忆：</h2><ul><li>创建：<script type=\"math/tex\">vector<int> vec;</script></li><li>访问：int i=vec[0];</li><li>插入：vec.push_back(1); vec.insert(index,val)，在第i个元素后面插入</li><li>删除：<ul><li>vec.pop_back(),删除最后一个</li><li>vec.erase(index)，删除index位置处元素</li><li>vec.erase(1,3)，删除[1,3)区间的元素</li></ul></li><li>大小：vec.size();</li><li>清空：vec.clear();</li><li>翻转：reverse(vec.begin(),vec.end());将元素翻转在vecotr，要#include<algorithm></algorithm></li><li>排序：<ul><li>sort(vec.begin(),vec.end());默认按照升序排列</li><li>sort(vec.begin(),vec.end(),cmp);定义排序比较函数将序排列<blockquote><p>bool cmp(const int&amp;a,const int&amp;b){<br>return a&gt;b;<br>}</p></blockquote></li></ul></li><li>迭代器访问<blockquote><p>vector<int>::iterator it;<br>for(it=vec.begin();it!=vec.end();it++)<br>cout&lt;&lt;*it&lt;&lt;endl;</int></p></blockquote></li></ul></div><div class=\"note info\"><h2 id=\"C-中map的用法\"><a href=\"#C-中map的用法\" class=\"headerlink\" title=\"C++中map的用法\"></a>C++中map的用法</h2><ul><li>创建：<script type=\"math/tex\">map<string, int>mapString;</script>key类型为string，val类型为int</li><li>添加：<ul><li>mapString[“hello”]=1; 最常用的最简单的插入方式,<strong>会覆盖之前的数据</strong></li><li>mapString.insert(make_pair(“hello”,1)); 次常用,<strong> insert()不会覆盖之前的数据</strong></li><li>mapString.insert(pair<string ,int=\"\">(“hello”,1));</string></li><li>mapString.insert(map<string ,int=\"\">::value_type(“hello”,1));</string></li></ul></li><li><p>迭代：</p><blockquote><p>map<string ,int=\"\">::iterator it;<br>for ( it = mapString.begin( ); it != mapString.end( ); it++ )<br>cout &lt;&lt; “ “ &lt;&lt; it -&gt; second;</string></p></blockquote></li><li><p>查找：</p><ul><li><strong>不建议!</strong> mapString[“hello”];返回”hello”对应的值，如果不存在，则添加一个元素，key为”hello”,val为类型默认值,并返回这个默认值</li><li>mapString.count(“hello”); map::count()方法返回被查找元素的个数,只有0或1</li><li>map::find()方法,返回的是被查找元素的位置，没有则返回map.end()<blockquote><p>map<string ,int=\"\">::iterator it;<br>it = mapString.find(“hello”);<br>if(it==test.end()){<br>cout&lt;&lt;”hello not found”&lt;&lt;endl;<br>}</string></p></blockquote></li></ul></li><li><p>删除:</p><ul><li>mapString.erase(“hello”);</li><li>用迭代器删除,注意在迭代期间是不能被删除的<blockquote><p>map<string ,int=\"\">::iterator it;<br>it = mapString.find(“hello”);</string></p><p>if(it==mapString.end()) cout&lt;&lt;”hello not found”&lt;&lt;endl;<br>else mapString.erase(it);</p></blockquote></li></ul></li><li><p>排序：map中元素自动按照key升序排序，不可以用sort函数</p></li><li>大小：mapString.size();</li><li>清除：mapString.clear();</li></ul></div><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoSum</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        map = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, num <span class=\"keyword\">in</span> enumerate(nums):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target - num <span class=\"keyword\">in</span> map:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> [map[target - num], i]</span><br><span class=\"line\">            map[num] = i</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> []</span><br></pre></td></tr></table></figure><div class=\"note info\"><p>list中遍历的三种方式：</p><ol><li>for items in list: 根据元素遍历</li><li>for index in range(len(list)): 根据索引遍历</li><li>enumerate(seq, [start=0]) 创建枚举对象，同时列出数据下标和数据<ul><li>seq: 一个序列、迭代器或其他支持迭代对象, 如列表、元组或字符串</li><li>start: 下标起始位置</li><li>返回：一个列表 [(下标，数据)…], 例如[(1, ‘a’), (2, ‘b’), (3, ‘c’)]</li></ul></li><li>iterList = iter(list) 创建迭代器遍历<ul><li>用法：for item in iterList: print(item)</li></ul></li></ol></div><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>虽然第一题很简单，但是深入了看还是能学了不少东西的，在遍历这方面，时间复杂度优化可以用map，C++时间复杂度可以从<script type=\"math/tex\">O(n)</script>降到<script type=\"math/tex\">O(logn)</script>，python和java可以直接降到<script type=\"math/tex\">O(1)</script>.</p><p>而且打完代码复习了C++中vector的用法，还有pythonlist的enumerate遍历。C++ STL中的map是现学现卖了.</p><p>打算每天一题，感觉有点晚了，亡羊补牢把。</p><hr><!-- rebuild by neat -->"},{"title":"LeetCode-006-ZigZag Conversion","urlname":"leetcode-zigzag-conversion","comments":1,"mathjax":false,"date":"2019-04-15T12:47:37.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/zigzag-conversion/)   \nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n> P   A   H   N\n> A P L S I I G\n> Y   I   R  \n\nAnd then read line by line: **\"PAHNAPLSIIGYIR\"**\nWrite the code that will take a string and make this conversion given a number of rows:   \n> string convert(string s, int numRows);\n{% endnote %}\n<!--more-->\n{% note info %}\n### Examples:\n**Input:** s = \"PAYPALISHIRING\", numRows = 3\n**Output:** \"PAHNAPLSIIGYIR\"\n\n**Input:** s = \"PAYPALISHIRING\", numRows = 4\n**Output:** \"PINALSIGYAHRPI\"\n**Explanation:**\n> P     I    N\n> A   L S  I G\n> Y A   H R\n> P     I\n{% endnote %}\n\n## Solutions\n- 想到的是用数学方法，遍历每一行，然后计算每一行字符的位置，逐个添加进去，是题解的第二种方法。每行的字符位置都满足一个数列，所以可以很简单的计算出来。时间复杂度是$$ O(n) $$.\n- 题解还给了一种方法是按行排序，每一行建一个字符串，从左向右迭代源字符串，判断每个字符是属于哪一行，然后加到那一行的字符串上，最后对每行字符串拼接，原理感觉和上一种方法差不多。时间复杂度也是$$ O(n) $$  \n\n## C++ Codes\n自己想到的解法，用时12ms，内存10.2MB，超过99.51%感觉还是挺快的。\n```C++\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int len = s.length();\n        int num = ceil(len*1.0/numRows);\n        string res = \"\";\n        int d = 2*numRows-2;\n\n        if(numRows==1)return s;\n        for(int i=0;i<numRows;i++){   //遍历行\n            for(int j=1;j<=num;j++){    //遍历每个Z\n                if(i==0 && (j-1)*d<len){  //第一行\n                    res+=s[(j-1)*d];\n                } else if(i==(numRows-1) && ((j-1)*d+numRows-1)<len){ //最后一行\n                    res+=s[(j-1)*d+numRows-1];\n                } else{ //其余行\n                        if((j-1)*d+i<len)\n                            res+=s[(j-1)*d+i];\n                        if(j*d-i<len)\n                            res+=s[j*d-i];\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n第二种遍历每个字符的解法:测试是20ms，12.6MB\n```C++\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n\n        if (numRows == 1) return s;\n\n        vector<string> rows(min(numRows, int(s.size())));\n        int curRow = 0;\n        bool goingDown = false;\n\n        for (char c : s) {\n            rows[curRow] += c;\n            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n            curRow += goingDown ? 1 : -1;\n        }\n\n        string ret;\n        for (string row : rows) ret += row;\n        return ret;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        slen = len(s)\n        num = math.ceil(slen/numRows);\n        res = \"\"\n        d = 2*numRows-2\n        \n        if numRows==1:\n            return s\n        for i in range(numRows):\n            for j in range(1,num+1):\n                if i==0 and (j-1)*d<slen:\n                    res = res + s[(j-1)*d]\n                elif i==numRows-1 and (j-1)*d+numRows-1<slen:\n                    res = res + s[(j-1)*d+numRows-1]\n                else :\n                    if (j-1)*d+i<slen:\n                        res = res + s[(j-1)*d+i]\n                    if(j*d-i<slen):\n                        res = res + s[j*d-i]\n                        \n        return res;\n```\n\n## 总结\n- 很多题目可以直接从数学角度着手，会很方便\n- 暴力法在很多时候都有用啊，时间复杂度不够再优化下说不定就过了\n\n\n------\n","source":"_posts/LeetCode/LeetCode-006-ZigZag-Conversion.md","raw":"---\ntitle: LeetCode-006-ZigZag Conversion\ntags:\n  - LeetCode\n  - Algorithm\n  - Medium\n  - Math\n  - String\n  - Split\ncategories:\n  - LeetCode\nurlname: leetcode-zigzag-conversion\ncomments: true\nmathjax: false\ndate: 2019-04-15 20:47:37\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/zigzag-conversion/)   \nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n> P   A   H   N\n> A P L S I I G\n> Y   I   R  \n\nAnd then read line by line: **\"PAHNAPLSIIGYIR\"**\nWrite the code that will take a string and make this conversion given a number of rows:   \n> string convert(string s, int numRows);\n{% endnote %}\n<!--more-->\n{% note info %}\n### Examples:\n**Input:** s = \"PAYPALISHIRING\", numRows = 3\n**Output:** \"PAHNAPLSIIGYIR\"\n\n**Input:** s = \"PAYPALISHIRING\", numRows = 4\n**Output:** \"PINALSIGYAHRPI\"\n**Explanation:**\n> P     I    N\n> A   L S  I G\n> Y A   H R\n> P     I\n{% endnote %}\n\n## Solutions\n- 想到的是用数学方法，遍历每一行，然后计算每一行字符的位置，逐个添加进去，是题解的第二种方法。每行的字符位置都满足一个数列，所以可以很简单的计算出来。时间复杂度是$$ O(n) $$.\n- 题解还给了一种方法是按行排序，每一行建一个字符串，从左向右迭代源字符串，判断每个字符是属于哪一行，然后加到那一行的字符串上，最后对每行字符串拼接，原理感觉和上一种方法差不多。时间复杂度也是$$ O(n) $$  \n\n## C++ Codes\n自己想到的解法，用时12ms，内存10.2MB，超过99.51%感觉还是挺快的。\n```C++\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int len = s.length();\n        int num = ceil(len*1.0/numRows);\n        string res = \"\";\n        int d = 2*numRows-2;\n\n        if(numRows==1)return s;\n        for(int i=0;i<numRows;i++){   //遍历行\n            for(int j=1;j<=num;j++){    //遍历每个Z\n                if(i==0 && (j-1)*d<len){  //第一行\n                    res+=s[(j-1)*d];\n                } else if(i==(numRows-1) && ((j-1)*d+numRows-1)<len){ //最后一行\n                    res+=s[(j-1)*d+numRows-1];\n                } else{ //其余行\n                        if((j-1)*d+i<len)\n                            res+=s[(j-1)*d+i];\n                        if(j*d-i<len)\n                            res+=s[j*d-i];\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n第二种遍历每个字符的解法:测试是20ms，12.6MB\n```C++\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n\n        if (numRows == 1) return s;\n\n        vector<string> rows(min(numRows, int(s.size())));\n        int curRow = 0;\n        bool goingDown = false;\n\n        for (char c : s) {\n            rows[curRow] += c;\n            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n            curRow += goingDown ? 1 : -1;\n        }\n\n        string ret;\n        for (string row : rows) ret += row;\n        return ret;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        slen = len(s)\n        num = math.ceil(slen/numRows);\n        res = \"\"\n        d = 2*numRows-2\n        \n        if numRows==1:\n            return s\n        for i in range(numRows):\n            for j in range(1,num+1):\n                if i==0 and (j-1)*d<slen:\n                    res = res + s[(j-1)*d]\n                elif i==numRows-1 and (j-1)*d+numRows-1<slen:\n                    res = res + s[(j-1)*d+numRows-1]\n                else :\n                    if (j-1)*d+i<slen:\n                        res = res + s[(j-1)*d+i]\n                    if(j*d-i<slen):\n                        res = res + s[j*d-i]\n                        \n        return res;\n```\n\n## 总结\n- 很多题目可以直接从数学角度着手，会很方便\n- 暴力法在很多时候都有用啊，时间复杂度不够再优化下说不定就过了\n\n\n------\n","slug":"LeetCode/LeetCode-006-ZigZag-Conversion","published":1,"updated":"2019-07-25T17:55:04.737Z","layout":"post","photos":[],"link":"","_id":"ck2424lt20058lksbo5iifdnd","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/zigzag-conversion/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><blockquote><p>P A H N<br>A P L S I I G<br>Y I R</p></blockquote><p>And then read line by line: <strong>“PAHNAPLSIIGYIR”</strong><br>Write the code that will take a string and make this conversion given a number of rows:</p><blockquote><p>string convert(string s, int numRows);</p></blockquote></div><a id=\"more\"></a><div class=\"note info\"><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> s = “PAYPALISHIRING”, numRows = 3<br><strong>Output:</strong> “PAHNAPLSIIGYIR”</p><p><strong>Input:</strong> s = “PAYPALISHIRING”, numRows = 4<br><strong>Output:</strong> “PINALSIGYAHRPI”<br><strong>Explanation:</strong></p><blockquote><p>P I N<br>A L S I G<br>Y A H R<br>P I</p></blockquote></div><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>想到的是用数学方法，遍历每一行，然后计算每一行字符的位置，逐个添加进去，是题解的第二种方法。每行的字符位置都满足一个数列，所以可以很简单的计算出来。时间复杂度是<script type=\"math/tex\">O(n)</script>.</li><li>题解还给了一种方法是按行排序，每一行建一个字符串，从左向右迭代源字符串，判断每个字符是属于哪一行，然后加到那一行的字符串上，最后对每行字符串拼接，原理感觉和上一种方法差不多。时间复杂度也是<script type=\"math/tex\">O(n)</script></li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>自己想到的解法，用时12ms，内存10.2MB，超过99.51%感觉还是挺快的。<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"built_in\">ceil</span>(len*<span class=\"number\">1.0</span>/numRows);</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d = <span class=\"number\">2</span>*numRows<span class=\"number\">-2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(numRows==<span class=\"number\">1</span>)<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;numRows;i++)&#123;   <span class=\"comment\">//遍历行</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=num;j++)&#123;    <span class=\"comment\">//遍历每个Z</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span> &amp;&amp; (j<span class=\"number\">-1</span>)*d&lt;len)&#123;  <span class=\"comment\">//第一行</span></span><br><span class=\"line\">                    res+=s[(j<span class=\"number\">-1</span>)*d];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i==(numRows<span class=\"number\">-1</span>) &amp;&amp; ((j<span class=\"number\">-1</span>)*d+numRows<span class=\"number\">-1</span>)&lt;len)&#123; <span class=\"comment\">//最后一行</span></span><br><span class=\"line\">                    res+=s[(j<span class=\"number\">-1</span>)*d+numRows<span class=\"number\">-1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span>&#123; <span class=\"comment\">//其余行</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>((j<span class=\"number\">-1</span>)*d+i&lt;len)</span><br><span class=\"line\">                            res+=s[(j<span class=\"number\">-1</span>)*d+i];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(j*d-i&lt;len)</span><br><span class=\"line\">                            res+=s[j*d-i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>第二种遍历每个字符的解法:测试是20ms，12.6MB<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; rows(min(numRows, <span class=\"keyword\">int</span>(s.size())));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> curRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> goingDown = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s) &#123;</span><br><span class=\"line\">            rows[curRow] += c;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curRow == <span class=\"number\">0</span> || curRow == numRows - <span class=\"number\">1</span>) goingDown = !goingDown;</span><br><span class=\"line\">            curRow += goingDown ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">string</span> ret;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">string</span> row : rows) ret += row;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class=\"line\">        slen = len(s)</span><br><span class=\"line\">        num = math.ceil(slen/numRows);</span><br><span class=\"line\">        res = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        d = <span class=\"number\">2</span>*numRows<span class=\"number\">-2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(numRows):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,num+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i==<span class=\"number\">0</span> <span class=\"keyword\">and</span> (j<span class=\"number\">-1</span>)*d&lt;slen:</span><br><span class=\"line\">                    res = res + s[(j<span class=\"number\">-1</span>)*d]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i==numRows<span class=\"number\">-1</span> <span class=\"keyword\">and</span> (j<span class=\"number\">-1</span>)*d+numRows<span class=\"number\">-1</span>&lt;slen:</span><br><span class=\"line\">                    res = res + s[(j<span class=\"number\">-1</span>)*d+numRows<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">else</span> :</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j<span class=\"number\">-1</span>)*d+i&lt;slen:</span><br><span class=\"line\">                        res = res + s[(j<span class=\"number\">-1</span>)*d+i]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(j*d-i&lt;slen):</span><br><span class=\"line\">                        res = res + s[j*d-i]</span><br><span class=\"line\">                        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>很多题目可以直接从数学角度着手，会很方便</li><li>暴力法在很多时候都有用啊，时间复杂度不够再优化下说不定就过了</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/zigzag-conversion/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><blockquote><p>P A H N<br>A P L S I I G<br>Y I R</p></blockquote><p>And then read line by line: <strong>“PAHNAPLSIIGYIR”</strong><br>Write the code that will take a string and make this conversion given a number of rows:</p><blockquote><p>string convert(string s, int numRows);</p></blockquote></div>","more":"<div class=\"note info\"><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> s = “PAYPALISHIRING”, numRows = 3<br><strong>Output:</strong> “PAHNAPLSIIGYIR”</p><p><strong>Input:</strong> s = “PAYPALISHIRING”, numRows = 4<br><strong>Output:</strong> “PINALSIGYAHRPI”<br><strong>Explanation:</strong></p><blockquote><p>P I N<br>A L S I G<br>Y A H R<br>P I</p></blockquote></div><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>想到的是用数学方法，遍历每一行，然后计算每一行字符的位置，逐个添加进去，是题解的第二种方法。每行的字符位置都满足一个数列，所以可以很简单的计算出来。时间复杂度是<script type=\"math/tex\">O(n)</script>.</li><li>题解还给了一种方法是按行排序，每一行建一个字符串，从左向右迭代源字符串，判断每个字符是属于哪一行，然后加到那一行的字符串上，最后对每行字符串拼接，原理感觉和上一种方法差不多。时间复杂度也是<script type=\"math/tex\">O(n)</script></li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>自己想到的解法，用时12ms，内存10.2MB，超过99.51%感觉还是挺快的。<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"built_in\">ceil</span>(len*<span class=\"number\">1.0</span>/numRows);</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d = <span class=\"number\">2</span>*numRows<span class=\"number\">-2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(numRows==<span class=\"number\">1</span>)<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;numRows;i++)&#123;   <span class=\"comment\">//遍历行</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=num;j++)&#123;    <span class=\"comment\">//遍历每个Z</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span> &amp;&amp; (j<span class=\"number\">-1</span>)*d&lt;len)&#123;  <span class=\"comment\">//第一行</span></span><br><span class=\"line\">                    res+=s[(j<span class=\"number\">-1</span>)*d];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i==(numRows<span class=\"number\">-1</span>) &amp;&amp; ((j<span class=\"number\">-1</span>)*d+numRows<span class=\"number\">-1</span>)&lt;len)&#123; <span class=\"comment\">//最后一行</span></span><br><span class=\"line\">                    res+=s[(j<span class=\"number\">-1</span>)*d+numRows<span class=\"number\">-1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span>&#123; <span class=\"comment\">//其余行</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>((j<span class=\"number\">-1</span>)*d+i&lt;len)</span><br><span class=\"line\">                            res+=s[(j<span class=\"number\">-1</span>)*d+i];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(j*d-i&lt;len)</span><br><span class=\"line\">                            res+=s[j*d-i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>第二种遍历每个字符的解法:测试是20ms，12.6MB<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; rows(min(numRows, <span class=\"keyword\">int</span>(s.size())));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> curRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> goingDown = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s) &#123;</span><br><span class=\"line\">            rows[curRow] += c;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curRow == <span class=\"number\">0</span> || curRow == numRows - <span class=\"number\">1</span>) goingDown = !goingDown;</span><br><span class=\"line\">            curRow += goingDown ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">string</span> ret;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">string</span> row : rows) ret += row;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert</span><span class=\"params\">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class=\"line\">        slen = len(s)</span><br><span class=\"line\">        num = math.ceil(slen/numRows);</span><br><span class=\"line\">        res = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        d = <span class=\"number\">2</span>*numRows<span class=\"number\">-2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> numRows==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(numRows):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,num+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i==<span class=\"number\">0</span> <span class=\"keyword\">and</span> (j<span class=\"number\">-1</span>)*d&lt;slen:</span><br><span class=\"line\">                    res = res + s[(j<span class=\"number\">-1</span>)*d]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i==numRows<span class=\"number\">-1</span> <span class=\"keyword\">and</span> (j<span class=\"number\">-1</span>)*d+numRows<span class=\"number\">-1</span>&lt;slen:</span><br><span class=\"line\">                    res = res + s[(j<span class=\"number\">-1</span>)*d+numRows<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">else</span> :</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j<span class=\"number\">-1</span>)*d+i&lt;slen:</span><br><span class=\"line\">                        res = res + s[(j<span class=\"number\">-1</span>)*d+i]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(j*d-i&lt;slen):</span><br><span class=\"line\">                        res = res + s[j*d-i]</span><br><span class=\"line\">                        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>很多题目可以直接从数学角度着手，会很方便</li><li>暴力法在很多时候都有用啊，时间复杂度不够再优化下说不定就过了</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-002-Add Two Numbers","comments":1,"mathjax":false,"date":"2019-04-08T16:39:36.000Z","urlname":"leetcode-add-two-numbers","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/add-two-numbers/)\nYou are given two **non-empty** linked lists representing two non-negative integers. \nThe digits are stored in **reverse order** and each of their nodes contain a single digit. \nAdd the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n### Example:\n> Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n> Output: 7 -> 0 -> 8\n> Explanation: 342 + 465 = 807.\n{% endnote %}\n<!--more-->\n\n## Solutions\n因为以前做过差不多的题目，而且感觉也不难，设置一个进位标志，然后一个个往后加。\n\n犯了三个小错误\n- 算当前node的值时居然没把carry一起加起来算\n- 算下次的carry时没有把上次的carry加上\n- 忘了最后一次还可能有进位，要新建一个node\n\n还纠结好久要不要头结点，刚开始以为题目不可以用头结点，毕竟Example上没有，写到后面还是出错了，看了题解换了有头结点的版本就好了。\n\n## C++ Codes\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int carry = 0;\n        ListNode *res = new ListNode(0);\n        ListNode *tmp = res;\n        ListNode *p = l1;\n        ListNode *q = l2;\n\n        while(p!=NULL && q!=NULL){\n            tmp->next = new ListNode((p->val + q->val+carry)%10);//把+carry放在了%10的后面\n            carry = (p->val + q->val+carry)/10;//居然漏了+carry\n\n            tmp = tmp->next;\n\n            p=p->next;\n            q=q->next;\n        }\n\n        while(p!=NULL){\n            tmp->next = new ListNode((p->val + carry)%10);\n            carry = (p->val + carry)/10;\n            tmp = tmp->next;\n            p = p->next;\n        }\n\n        while(q!=NULL){\n            tmp->next = new ListNode((q->val + carry)%10);\n            carry = (q->val + carry)/10;\n            tmp = tmp->next;\n            q = q->next;\n        }\n\n        if(carry>0) tmp->next = new ListNode(carry);//漏了最后的进位\n        return res->next;\n    }\n};\n```\n{% note default %}\n我这里在最后用了两个while来判断是否结束，题解上面是在第一个while里面对p和q进行了处理：\n　　只要到了NULL，就让它的值为0，时间复杂度上来说是一样的，都是$$ \\max{l1的节点数，l2的节点数} $$，简单理解为$$ O(n) $$\n{% endnote %}\n\n## Python Codes\n\n一共两种，不是自己写的，不是很熟悉Python的链表，多看看学习下。\n\n第一中的sum写法不是很懂...绝望，第二种比较好理解\n\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        res = ListNode(0)\n        tmp = res\n        left = 0\n\n        while l1 or l2 or left:\n            left, right = divmod(sum(l and l.val or 0 for l in (l1, l2)) + left, 10)\n            tmp.next = ListNode(right)\n            tmp = tmp.next\n            l1 = l1 and l1.next\n            l2 = l2 and l2.next\n\n        return res.next\n```\n\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        head = ListNode(0)\n        curr = head\n        carry, total = 0, 0\n\n        while(l1 or l2):\n            a = l1.val if l1 else 0\n            b = l2.val if l2 else 0\n            total = a + b + carry\n            carry = total // 10\n\n            if l1 or l2:\n                curr.next = ListNode(total % 10)\n\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n            curr = curr.next\n\n        if carry>0:\n            curr.next = ListNode(carry)\n\n        return head.next\n```\n\n## 总结\n感觉自己解题速度有点慢，而且粗心犯小错误。\n\n感觉是练得太少，以后加油！\n\n-----------\n","source":"_posts/LeetCode/LeetCode-002-Add-Two-Numbers.md","raw":"---\ntitle: LeetCode-002-Add Two Numbers\ncomments: true\nmathjax: false\ndate: 2019-04-09 00:39:36\ntags: \n  - Algorithm\n  - LeetCode\n  - Linked List\n  - Large Number\n  - Math\n  - Medium\ncategories: [LeetCode]\nurlname: leetcode-add-two-numbers\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/add-two-numbers/)\nYou are given two **non-empty** linked lists representing two non-negative integers. \nThe digits are stored in **reverse order** and each of their nodes contain a single digit. \nAdd the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n### Example:\n> Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n> Output: 7 -> 0 -> 8\n> Explanation: 342 + 465 = 807.\n{% endnote %}\n<!--more-->\n\n## Solutions\n因为以前做过差不多的题目，而且感觉也不难，设置一个进位标志，然后一个个往后加。\n\n犯了三个小错误\n- 算当前node的值时居然没把carry一起加起来算\n- 算下次的carry时没有把上次的carry加上\n- 忘了最后一次还可能有进位，要新建一个node\n\n还纠结好久要不要头结点，刚开始以为题目不可以用头结点，毕竟Example上没有，写到后面还是出错了，看了题解换了有头结点的版本就好了。\n\n## C++ Codes\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int carry = 0;\n        ListNode *res = new ListNode(0);\n        ListNode *tmp = res;\n        ListNode *p = l1;\n        ListNode *q = l2;\n\n        while(p!=NULL && q!=NULL){\n            tmp->next = new ListNode((p->val + q->val+carry)%10);//把+carry放在了%10的后面\n            carry = (p->val + q->val+carry)/10;//居然漏了+carry\n\n            tmp = tmp->next;\n\n            p=p->next;\n            q=q->next;\n        }\n\n        while(p!=NULL){\n            tmp->next = new ListNode((p->val + carry)%10);\n            carry = (p->val + carry)/10;\n            tmp = tmp->next;\n            p = p->next;\n        }\n\n        while(q!=NULL){\n            tmp->next = new ListNode((q->val + carry)%10);\n            carry = (q->val + carry)/10;\n            tmp = tmp->next;\n            q = q->next;\n        }\n\n        if(carry>0) tmp->next = new ListNode(carry);//漏了最后的进位\n        return res->next;\n    }\n};\n```\n{% note default %}\n我这里在最后用了两个while来判断是否结束，题解上面是在第一个while里面对p和q进行了处理：\n　　只要到了NULL，就让它的值为0，时间复杂度上来说是一样的，都是$$ \\max{l1的节点数，l2的节点数} $$，简单理解为$$ O(n) $$\n{% endnote %}\n\n## Python Codes\n\n一共两种，不是自己写的，不是很熟悉Python的链表，多看看学习下。\n\n第一中的sum写法不是很懂...绝望，第二种比较好理解\n\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        res = ListNode(0)\n        tmp = res\n        left = 0\n\n        while l1 or l2 or left:\n            left, right = divmod(sum(l and l.val or 0 for l in (l1, l2)) + left, 10)\n            tmp.next = ListNode(right)\n            tmp = tmp.next\n            l1 = l1 and l1.next\n            l2 = l2 and l2.next\n\n        return res.next\n```\n\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        head = ListNode(0)\n        curr = head\n        carry, total = 0, 0\n\n        while(l1 or l2):\n            a = l1.val if l1 else 0\n            b = l2.val if l2 else 0\n            total = a + b + carry\n            carry = total // 10\n\n            if l1 or l2:\n                curr.next = ListNode(total % 10)\n\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n            curr = curr.next\n\n        if carry>0:\n            curr.next = ListNode(carry)\n\n        return head.next\n```\n\n## 总结\n感觉自己解题速度有点慢，而且粗心犯小错误。\n\n感觉是练得太少，以后加油！\n\n-----------\n","slug":"LeetCode/LeetCode-002-Add-Two-Numbers","published":1,"updated":"2019-07-25T17:51:56.951Z","layout":"post","photos":[],"link":"","_id":"ck2424lt4005blksbo7wjd8bz","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/add-two-numbers/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers.<br>The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit.<br>Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example:\"></a>Example:</h3><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><p>因为以前做过差不多的题目，而且感觉也不难，设置一个进位标志，然后一个个往后加。</p><p>犯了三个小错误</p><ul><li>算当前node的值时居然没把carry一起加起来算</li><li>算下次的carry时没有把上次的carry加上</li><li>忘了最后一次还可能有进位，要新建一个node</li></ul><p>还纠结好久要不要头结点，刚开始以为题目不可以用头结点，毕竟Example上没有，写到后面还是出错了，看了题解换了有头结点的版本就好了。</p><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode *res = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode *tmp = res;</span><br><span class=\"line\">        ListNode *p = l1;</span><br><span class=\"line\">        ListNode *q = l2;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; q!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            tmp-&gt;next = <span class=\"keyword\">new</span> ListNode((p-&gt;val + q-&gt;val+carry)%<span class=\"number\">10</span>);<span class=\"comment\">//把+carry放在了%10的后面</span></span><br><span class=\"line\">            carry = (p-&gt;val + q-&gt;val+carry)/<span class=\"number\">10</span>;<span class=\"comment\">//居然漏了+carry</span></span><br><span class=\"line\"></span><br><span class=\"line\">            tmp = tmp-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">            p=p-&gt;next;</span><br><span class=\"line\">            q=q-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            tmp-&gt;next = <span class=\"keyword\">new</span> ListNode((p-&gt;val + carry)%<span class=\"number\">10</span>);</span><br><span class=\"line\">            carry = (p-&gt;val + carry)/<span class=\"number\">10</span>;</span><br><span class=\"line\">            tmp = tmp-&gt;next;</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(q!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            tmp-&gt;next = <span class=\"keyword\">new</span> ListNode((q-&gt;val + carry)%<span class=\"number\">10</span>);</span><br><span class=\"line\">            carry = (q-&gt;val + carry)/<span class=\"number\">10</span>;</span><br><span class=\"line\">            tmp = tmp-&gt;next;</span><br><span class=\"line\">            q = q-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(carry&gt;<span class=\"number\">0</span>) tmp-&gt;next = <span class=\"keyword\">new</span> ListNode(carry);<span class=\"comment\">//漏了最后的进位</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><div class=\"note default\"><p>我这里在最后用了两个while来判断是否结束，题解上面是在第一个while里面对p和q进行了处理：<br>只要到了NULL，就让它的值为0，时间复杂度上来说是一样的，都是<script type=\"math/tex\">\\max{l1的节点数，l2的节点数}</script>，简单理解为<script type=\"math/tex\">O(n)</script></p></div><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>一共两种，不是自己写的，不是很熟悉Python的链表，多看看学习下。</p><p>第一中的sum写法不是很懂…绝望，第二种比较好理解</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Definition for singly-linked list.</span><br><span class=\"line\"># class ListNode:</span><br><span class=\"line\">#     def __init__(self, x):</span><br><span class=\"line\">#         self.val = x</span><br><span class=\"line\">#         self.next = None</span><br><span class=\"line\"></span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class=\"line\">        res = ListNode(0)</span><br><span class=\"line\">        tmp = res</span><br><span class=\"line\">        left = 0</span><br><span class=\"line\"></span><br><span class=\"line\">        while l1 or l2 or left:</span><br><span class=\"line\">            left, right = divmod(sum(l and l.val or 0 for l in (l1, l2)) + left, 10)</span><br><span class=\"line\">            tmp.next = ListNode(right)</span><br><span class=\"line\">            tmp = tmp.next</span><br><span class=\"line\">            l1 = l1 and l1.next</span><br><span class=\"line\">            l2 = l2 and l2.next</span><br><span class=\"line\"></span><br><span class=\"line\">        return res.next</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Definition for singly-linked list.</span><br><span class=\"line\"># class ListNode:</span><br><span class=\"line\">#     def __init__(self, x):</span><br><span class=\"line\">#         self.val = x</span><br><span class=\"line\">#         self.next = None</span><br><span class=\"line\"></span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class=\"line\">        head = ListNode(0)</span><br><span class=\"line\">        curr = head</span><br><span class=\"line\">        carry, total = 0, 0</span><br><span class=\"line\"></span><br><span class=\"line\">        while(l1 or l2):</span><br><span class=\"line\">            a = l1.val if l1 else 0</span><br><span class=\"line\">            b = l2.val if l2 else 0</span><br><span class=\"line\">            total = a + b + carry</span><br><span class=\"line\">            carry = total // 10</span><br><span class=\"line\"></span><br><span class=\"line\">            if l1 or l2:</span><br><span class=\"line\">                curr.next = ListNode(total % 10)</span><br><span class=\"line\"></span><br><span class=\"line\">            if l1:</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            if l2:</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            curr = curr.next</span><br><span class=\"line\"></span><br><span class=\"line\">        if carry&gt;0:</span><br><span class=\"line\">            curr.next = ListNode(carry)</span><br><span class=\"line\"></span><br><span class=\"line\">        return head.next</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>感觉自己解题速度有点慢，而且粗心犯小错误。</p><p>感觉是练得太少，以后加油！</p><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/add-two-numbers/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers.<br>The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit.<br>Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example:\"></a>Example:</h3><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><p>因为以前做过差不多的题目，而且感觉也不难，设置一个进位标志，然后一个个往后加。</p><p>犯了三个小错误</p><ul><li>算当前node的值时居然没把carry一起加起来算</li><li>算下次的carry时没有把上次的carry加上</li><li>忘了最后一次还可能有进位，要新建一个node</li></ul><p>还纠结好久要不要头结点，刚开始以为题目不可以用头结点，毕竟Example上没有，写到后面还是出错了，看了题解换了有头结点的版本就好了。</p><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode *res = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode *tmp = res;</span><br><span class=\"line\">        ListNode *p = l1;</span><br><span class=\"line\">        ListNode *q = l2;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; q!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            tmp-&gt;next = <span class=\"keyword\">new</span> ListNode((p-&gt;val + q-&gt;val+carry)%<span class=\"number\">10</span>);<span class=\"comment\">//把+carry放在了%10的后面</span></span><br><span class=\"line\">            carry = (p-&gt;val + q-&gt;val+carry)/<span class=\"number\">10</span>;<span class=\"comment\">//居然漏了+carry</span></span><br><span class=\"line\"></span><br><span class=\"line\">            tmp = tmp-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">            p=p-&gt;next;</span><br><span class=\"line\">            q=q-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            tmp-&gt;next = <span class=\"keyword\">new</span> ListNode((p-&gt;val + carry)%<span class=\"number\">10</span>);</span><br><span class=\"line\">            carry = (p-&gt;val + carry)/<span class=\"number\">10</span>;</span><br><span class=\"line\">            tmp = tmp-&gt;next;</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(q!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            tmp-&gt;next = <span class=\"keyword\">new</span> ListNode((q-&gt;val + carry)%<span class=\"number\">10</span>);</span><br><span class=\"line\">            carry = (q-&gt;val + carry)/<span class=\"number\">10</span>;</span><br><span class=\"line\">            tmp = tmp-&gt;next;</span><br><span class=\"line\">            q = q-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(carry&gt;<span class=\"number\">0</span>) tmp-&gt;next = <span class=\"keyword\">new</span> ListNode(carry);<span class=\"comment\">//漏了最后的进位</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><div class=\"note default\"><p>我这里在最后用了两个while来判断是否结束，题解上面是在第一个while里面对p和q进行了处理：<br>只要到了NULL，就让它的值为0，时间复杂度上来说是一样的，都是<script type=\"math/tex\">\\max{l1的节点数，l2的节点数}</script>，简单理解为<script type=\"math/tex\">O(n)</script></p></div><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>一共两种，不是自己写的，不是很熟悉Python的链表，多看看学习下。</p><p>第一中的sum写法不是很懂…绝望，第二种比较好理解</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Definition for singly-linked list.</span><br><span class=\"line\"># class ListNode:</span><br><span class=\"line\">#     def __init__(self, x):</span><br><span class=\"line\">#         self.val = x</span><br><span class=\"line\">#         self.next = None</span><br><span class=\"line\"></span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class=\"line\">        res = ListNode(0)</span><br><span class=\"line\">        tmp = res</span><br><span class=\"line\">        left = 0</span><br><span class=\"line\"></span><br><span class=\"line\">        while l1 or l2 or left:</span><br><span class=\"line\">            left, right = divmod(sum(l and l.val or 0 for l in (l1, l2)) + left, 10)</span><br><span class=\"line\">            tmp.next = ListNode(right)</span><br><span class=\"line\">            tmp = tmp.next</span><br><span class=\"line\">            l1 = l1 and l1.next</span><br><span class=\"line\">            l2 = l2 and l2.next</span><br><span class=\"line\"></span><br><span class=\"line\">        return res.next</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Definition for singly-linked list.</span><br><span class=\"line\"># class ListNode:</span><br><span class=\"line\">#     def __init__(self, x):</span><br><span class=\"line\">#         self.val = x</span><br><span class=\"line\">#         self.next = None</span><br><span class=\"line\"></span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class=\"line\">        head = ListNode(0)</span><br><span class=\"line\">        curr = head</span><br><span class=\"line\">        carry, total = 0, 0</span><br><span class=\"line\"></span><br><span class=\"line\">        while(l1 or l2):</span><br><span class=\"line\">            a = l1.val if l1 else 0</span><br><span class=\"line\">            b = l2.val if l2 else 0</span><br><span class=\"line\">            total = a + b + carry</span><br><span class=\"line\">            carry = total // 10</span><br><span class=\"line\"></span><br><span class=\"line\">            if l1 or l2:</span><br><span class=\"line\">                curr.next = ListNode(total % 10)</span><br><span class=\"line\"></span><br><span class=\"line\">            if l1:</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            if l2:</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            curr = curr.next</span><br><span class=\"line\"></span><br><span class=\"line\">        if carry&gt;0:</span><br><span class=\"line\">            curr.next = ListNode(carry)</span><br><span class=\"line\"></span><br><span class=\"line\">        return head.next</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>感觉自己解题速度有点慢，而且粗心犯小错误。</p><p>感觉是练得太少，以后加油！</p><hr><!-- rebuild by neat -->"},{"title":"LeetCode-007-Reverse Integer","urlname":"leetcode-reverse-integer","comments":1,"mathjax":false,"date":"2019-04-16T14:07:29.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/reverse-integer/)   \nGiven a 32-bit signed integer, reverse digits of an integer.\n\n### Examples:\n**Input:**123\n**Output:**321\n**Input:**-123\n**Output:**-321\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 用字符串的方法，先将输入转换成字符串，然后判断第一个字符是不是‘-’，是就加到结果字符串上，最后逆序添加字符到结果字符串上，再将字符串转换成长整数，return之前判断是否有溢出\n- 题解的办法是用取模的方法获取每一位之后再加到结果上，遍历一遍，但是这种方法在计算结果时容易溢出，要事先检查\n\n\n## C++ Codes\n我的字符串方法，4ms，8.3MB\n```C++\nclass Solution {\npublic:\n    int reverse(int x) {\n        string str = to_string(x);\n        string res=\"\";\n        if(str[0]=='-'){\n            str = str.substr(1,str.length());\n            res+='-';\n        }\n        for(int i =0;i<str.length();i++){\n            res+=str[str.length()-1-i];\n        }\n        long tmp =  atol(res.c_str());\n        if(tmp>pow(2,31)-1 || tmp<pow(2,31)*(-1)){\n            return 0;\n        }\n        return (int)tmp;\n    }\n};\n```\n\n题解的数学方法，8ms，8.3MB\n```C++\nclass Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};\n```\n\n## Python Codes\nPython的和第一种方法一样做，差别不大\n\n## 总结\n- C++中int型最大最小可以用<limits.h>中的INT_MAX和INT_MIN表示，分别是$$ 2^31=2147483647 $$和$$ -2^31-1=-2147483648 $$\n- C++中有atoi(),atol(),c_str(),to_string()这几种方法，分别是字符串转int，字符串转long，字符串转C串，整形转字符串\n\n------\n","source":"_posts/LeetCode/LeetCode-007-Reverse-Integer.md","raw":"---\ntitle: LeetCode-007-Reverse Integer\ntags:\n  - LeetCode\n  - Algorithm\n  - Easy\n  - Reverse\n  - Big Number\n  - String\ncategories:\n  - LeetCode\nurlname: leetcode-reverse-integer\ncomments: true\nmathjax: false\ndate: 2019-04-16 22:07:29\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/reverse-integer/)   \nGiven a 32-bit signed integer, reverse digits of an integer.\n\n### Examples:\n**Input:**123\n**Output:**321\n**Input:**-123\n**Output:**-321\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 用字符串的方法，先将输入转换成字符串，然后判断第一个字符是不是‘-’，是就加到结果字符串上，最后逆序添加字符到结果字符串上，再将字符串转换成长整数，return之前判断是否有溢出\n- 题解的办法是用取模的方法获取每一位之后再加到结果上，遍历一遍，但是这种方法在计算结果时容易溢出，要事先检查\n\n\n## C++ Codes\n我的字符串方法，4ms，8.3MB\n```C++\nclass Solution {\npublic:\n    int reverse(int x) {\n        string str = to_string(x);\n        string res=\"\";\n        if(str[0]=='-'){\n            str = str.substr(1,str.length());\n            res+='-';\n        }\n        for(int i =0;i<str.length();i++){\n            res+=str[str.length()-1-i];\n        }\n        long tmp =  atol(res.c_str());\n        if(tmp>pow(2,31)-1 || tmp<pow(2,31)*(-1)){\n            return 0;\n        }\n        return (int)tmp;\n    }\n};\n```\n\n题解的数学方法，8ms，8.3MB\n```C++\nclass Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};\n```\n\n## Python Codes\nPython的和第一种方法一样做，差别不大\n\n## 总结\n- C++中int型最大最小可以用<limits.h>中的INT_MAX和INT_MIN表示，分别是$$ 2^31=2147483647 $$和$$ -2^31-1=-2147483648 $$\n- C++中有atoi(),atol(),c_str(),to_string()这几种方法，分别是字符串转int，字符串转long，字符串转C串，整形转字符串\n\n------\n","slug":"LeetCode/LeetCode-007-Reverse-Integer","published":1,"updated":"2019-07-25T17:55:26.461Z","layout":"post","photos":[],"link":"","_id":"ck2424lt5005elksbilmu2wvg","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/reverse-integer/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>123<br><strong>Output:</strong>321<br><strong>Input:</strong>-123<br><strong>Output:</strong>-321</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>用字符串的方法，先将输入转换成字符串，然后判断第一个字符是不是‘-’，是就加到结果字符串上，最后逆序添加字符到结果字符串上，再将字符串转换成长整数，return之前判断是否有溢出</li><li>题解的办法是用取模的方法获取每一位之后再加到结果上，遍历一遍，但是这种方法在计算结果时容易溢出，要事先检查</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>我的字符串方法，4ms，8.3MB<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> str = to_string(x);</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>]==<span class=\"string\">'-'</span>)&#123;</span><br><span class=\"line\">            str = str.substr(<span class=\"number\">1</span>,str.length());</span><br><span class=\"line\">            res+=<span class=\"string\">'-'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;str.length();i++)&#123;</span><br><span class=\"line\">            res+=str[str.length()<span class=\"number\">-1</span>-i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> tmp =  atol(res.c_str());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp&gt;<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span> || tmp&lt;<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)*(<span class=\"number\">-1</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>题解的数学方法，8ms，8.3MB<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> pop = x % <span class=\"number\">10</span>;</span><br><span class=\"line\">            x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rev &gt; INT_MAX/<span class=\"number\">10</span> || (rev == INT_MAX / <span class=\"number\">10</span> &amp;&amp; pop &gt; <span class=\"number\">7</span>)) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rev &lt; INT_MIN/<span class=\"number\">10</span> || (rev == INT_MIN / <span class=\"number\">10</span> &amp;&amp; pop &lt; <span class=\"number\">-8</span>)) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            rev = rev * <span class=\"number\">10</span> + pop;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>Python的和第一种方法一样做，差别不大</p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>C++中int型最大最小可以用<limits.h>中的INT_MAX和INT_MIN表示，分别是<script type=\"math/tex\">2^31=2147483647</script>和<script type=\"math/tex\">-2^31-1=-2147483648</script></limits.h></li><li>C++中有atoi(),atol(),c_str(),to_string()这几种方法，分别是字符串转int，字符串转long，字符串转C串，整形转字符串</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/reverse-integer/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>123<br><strong>Output:</strong>321<br><strong>Input:</strong>-123<br><strong>Output:</strong>-321</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>用字符串的方法，先将输入转换成字符串，然后判断第一个字符是不是‘-’，是就加到结果字符串上，最后逆序添加字符到结果字符串上，再将字符串转换成长整数，return之前判断是否有溢出</li><li>题解的办法是用取模的方法获取每一位之后再加到结果上，遍历一遍，但是这种方法在计算结果时容易溢出，要事先检查</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>我的字符串方法，4ms，8.3MB<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> str = to_string(x);</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[<span class=\"number\">0</span>]==<span class=\"string\">'-'</span>)&#123;</span><br><span class=\"line\">            str = str.substr(<span class=\"number\">1</span>,str.length());</span><br><span class=\"line\">            res+=<span class=\"string\">'-'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;str.length();i++)&#123;</span><br><span class=\"line\">            res+=str[str.length()<span class=\"number\">-1</span>-i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> tmp =  atol(res.c_str());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp&gt;<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span> || tmp&lt;<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)*(<span class=\"number\">-1</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>题解的数学方法，8ms，8.3MB<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> pop = x % <span class=\"number\">10</span>;</span><br><span class=\"line\">            x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rev &gt; INT_MAX/<span class=\"number\">10</span> || (rev == INT_MAX / <span class=\"number\">10</span> &amp;&amp; pop &gt; <span class=\"number\">7</span>)) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rev &lt; INT_MIN/<span class=\"number\">10</span> || (rev == INT_MIN / <span class=\"number\">10</span> &amp;&amp; pop &lt; <span class=\"number\">-8</span>)) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            rev = rev * <span class=\"number\">10</span> + pop;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>Python的和第一种方法一样做，差别不大</p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>C++中int型最大最小可以用<limits.h>中的INT_MAX和INT_MIN表示，分别是<script type=\"math/tex\">2^31=2147483647</script>和<script type=\"math/tex\">-2^31-1=-2147483648</script></limits.h></li><li>C++中有atoi(),atol(),c_str(),to_string()这几种方法，分别是字符串转int，字符串转long，字符串转C串，整形转字符串</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-008-String to Integer (atoi)","urlname":"leetcode-string-to-integer-atoi","comments":1,"mathjax":false,"date":"2019-04-16T14:26:17.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/string-to-integer-atoi/)   \n实现C++的atoi()函数\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\n\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\n\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\n\nIf no valid conversion could be performed, a zero value is returned.\n{% endnote %}\n<!--more-->\n{% note info %}\n**Note:**  \n> Only the space character ' ' is considered as whitespace character.\n> Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $$ [−2^{31},  2^{31} − 1] $$. If the numerical value is out of the range of representable values, INT_MAX $$ 2^{31}-1 $$ or INT_MIN $$ -2^{31} $$ is returned.\n{% endnote %}\n### Examples:\n**Input:**\"42\"\n**Output:**42\n**Input:**\"    -42\"\n**Output:**-42\n**Input:**\"words and 987\"\n**Output:**987\n\n## Solutions\n- 没啥思维量，就是简单的遍历每个字符，然后设置两个flag，一个用于判断有没有到数字部分，第二个判断是不是负数，如果没到数字部分，就要分情况讨论，如果到了数字部分，判断到没到非数字，到了就退出，没到就每个数字加到结果上\n\n\n## C++ Codes\n每个字符遍历过去的方法，12ms，8.4MB\n```C++\nclass Solution {\npublic:\n    int myAtoi(string str) {\n        long long tmp = 0;\n        int n = str.length();\n        if(n==0)return 0;\n        bool flag = false;//是否到数字部分\n        int flag2 = 1;//负数标志，有就变为-1\n\n        for(int i=0;i<n;i++){\n            //已经开始数字部分的情况，即flag = true\n            if(tmp>INT_MAX)break;\n            if(flag && (str[i]<'0' || str[i]>'9')) break;\n            if(flag) tmp = tmp*10+str[i]-'0';\n\n            //还没到数字的情况，前面那部分，分为空格、非数字非符号、数字或正负号\n            if(!flag && str[i]==' ') continue;\n            if(!flag && str[i]!='+' && str[i]!='-' && (str[i]<'0' || str[i]>'9') )\n                return 0;\n            if(!flag && (str[i]=='+' || str[i]=='-'|| (str[i]>='0'&&str[i]<='9'))){\n                flag = true;\n                if(str[i]=='-')flag2 = -1;\n                if(str[i]=='+'||str[i]=='-')continue;\n                tmp = tmp*10+str[i]-'0';\n            }\n        }\n\n        tmp*=flag2;\n        if(tmp>INT_MAX) return INT_MAX;\n        if(tmp<INT_MIN) return INT_MIN;\n        return (int)tmp;\n    }\n};\n```\n\n## Python Codes\n借用了[HazzaCheng的代码](http://chengfeng96.com/blog/2017/03/07/LeetCode-No-8-String-to-Integer-atoi/),这道题用python解简直作弊..\n```python\nclass Solution(object):\n    def myAtoi(self, s):\n        ls = list(s.strip())\n        if len(ls) == 0:\n            return 0\n\n        sign = -1 if ls[0] == '-' else 1\n        if ls[0] in ['-', '+']:\n            del ls[0]\n        res, i = 0, 0\n        while i < len(ls) and ls[i].isdigit():\n            res = res * 10 + ord(ls[i]) - ord('0')\n            i += 1\n        return max(-2 ** 31, min(sign * res, 2 ** 31 - 1))\n```\n\n## 总结\n- 要注意各种情况的判断\n- 就算用了long long作为中转，在循环中也要判断是否已经超过int表示范围，提前break，可能出现longlong都无法表示的测试\n- 注意空串\n- 注意前面的符号\n- 不应该进行的操作及时continue掉\n- 还是会出现'+'号的\n\n------\n","source":"_posts/LeetCode/LeetCode-008-String-to-Integer-atoi.md","raw":"---\ntitle: LeetCode-008-String to Integer (atoi)\ntags:\n  - LeetCode\n  - Algorithm\n  - Medium\ncategories:\n  - LeetCode\nurlname: leetcode-string-to-integer-atoi\ncomments: true\nmathjax: false\ndate: 2019-04-16 22:26:17\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/string-to-integer-atoi/)   \n实现C++的atoi()函数\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\n\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\n\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\n\nIf no valid conversion could be performed, a zero value is returned.\n{% endnote %}\n<!--more-->\n{% note info %}\n**Note:**  \n> Only the space character ' ' is considered as whitespace character.\n> Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $$ [−2^{31},  2^{31} − 1] $$. If the numerical value is out of the range of representable values, INT_MAX $$ 2^{31}-1 $$ or INT_MIN $$ -2^{31} $$ is returned.\n{% endnote %}\n### Examples:\n**Input:**\"42\"\n**Output:**42\n**Input:**\"    -42\"\n**Output:**-42\n**Input:**\"words and 987\"\n**Output:**987\n\n## Solutions\n- 没啥思维量，就是简单的遍历每个字符，然后设置两个flag，一个用于判断有没有到数字部分，第二个判断是不是负数，如果没到数字部分，就要分情况讨论，如果到了数字部分，判断到没到非数字，到了就退出，没到就每个数字加到结果上\n\n\n## C++ Codes\n每个字符遍历过去的方法，12ms，8.4MB\n```C++\nclass Solution {\npublic:\n    int myAtoi(string str) {\n        long long tmp = 0;\n        int n = str.length();\n        if(n==0)return 0;\n        bool flag = false;//是否到数字部分\n        int flag2 = 1;//负数标志，有就变为-1\n\n        for(int i=0;i<n;i++){\n            //已经开始数字部分的情况，即flag = true\n            if(tmp>INT_MAX)break;\n            if(flag && (str[i]<'0' || str[i]>'9')) break;\n            if(flag) tmp = tmp*10+str[i]-'0';\n\n            //还没到数字的情况，前面那部分，分为空格、非数字非符号、数字或正负号\n            if(!flag && str[i]==' ') continue;\n            if(!flag && str[i]!='+' && str[i]!='-' && (str[i]<'0' || str[i]>'9') )\n                return 0;\n            if(!flag && (str[i]=='+' || str[i]=='-'|| (str[i]>='0'&&str[i]<='9'))){\n                flag = true;\n                if(str[i]=='-')flag2 = -1;\n                if(str[i]=='+'||str[i]=='-')continue;\n                tmp = tmp*10+str[i]-'0';\n            }\n        }\n\n        tmp*=flag2;\n        if(tmp>INT_MAX) return INT_MAX;\n        if(tmp<INT_MIN) return INT_MIN;\n        return (int)tmp;\n    }\n};\n```\n\n## Python Codes\n借用了[HazzaCheng的代码](http://chengfeng96.com/blog/2017/03/07/LeetCode-No-8-String-to-Integer-atoi/),这道题用python解简直作弊..\n```python\nclass Solution(object):\n    def myAtoi(self, s):\n        ls = list(s.strip())\n        if len(ls) == 0:\n            return 0\n\n        sign = -1 if ls[0] == '-' else 1\n        if ls[0] in ['-', '+']:\n            del ls[0]\n        res, i = 0, 0\n        while i < len(ls) and ls[i].isdigit():\n            res = res * 10 + ord(ls[i]) - ord('0')\n            i += 1\n        return max(-2 ** 31, min(sign * res, 2 ** 31 - 1))\n```\n\n## 总结\n- 要注意各种情况的判断\n- 就算用了long long作为中转，在循环中也要判断是否已经超过int表示范围，提前break，可能出现longlong都无法表示的测试\n- 注意空串\n- 注意前面的符号\n- 不应该进行的操作及时continue掉\n- 还是会出现'+'号的\n\n------\n","slug":"LeetCode/LeetCode-008-String-to-Integer-atoi","published":1,"updated":"2019-07-25T17:55:48.274Z","layout":"post","photos":[],"link":"","_id":"ck2424lt6005flksb6wiq7iwv","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/string-to-integer-atoi/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>实现C++的atoi()函数<br>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p></div><a id=\"more\"></a><div class=\"note info\"><p><strong>Note:</strong></p><blockquote><p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range:<script type=\"math/tex\">[−2^{31},  2^{31} − 1]</script>. If the numerical value is out of the range of representable values, INT_MAX<script type=\"math/tex\">2^{31}-1</script>or INT_MIN<script type=\"math/tex\">-2^{31}</script>is returned.</p></blockquote></div><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>“42”<br><strong>Output:</strong>42<br><strong>Input:</strong>“ -42”<br><strong>Output:</strong>-42<br><strong>Input:</strong>“words and 987”<br><strong>Output:</strong>987</p><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>没啥思维量，就是简单的遍历每个字符，然后设置两个flag，一个用于判断有没有到数字部分，第二个判断是不是负数，如果没到数字部分，就要分情况讨论，如果到了数字部分，判断到没到非数字，到了就退出，没到就每个数字加到结果上</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>每个字符遍历过去的方法，12ms，8.4MB<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">myAtoi</span><span class=\"params\">(<span class=\"built_in\">string</span> str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = str.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;<span class=\"comment\">//是否到数字部分</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag2 = <span class=\"number\">1</span>;<span class=\"comment\">//负数标志，有就变为-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//已经开始数字部分的情况，即flag = true</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp&gt;INT_MAX)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag &amp;&amp; (str[i]&lt;<span class=\"string\">'0'</span> || str[i]&gt;<span class=\"string\">'9'</span>)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag) tmp = tmp*<span class=\"number\">10</span>+str[i]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//还没到数字的情况，前面那部分，分为空格、非数字非符号、数字或正负号</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!flag &amp;&amp; str[i]==<span class=\"string\">' '</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!flag &amp;&amp; str[i]!=<span class=\"string\">'+'</span> &amp;&amp; str[i]!=<span class=\"string\">'-'</span> &amp;&amp; (str[i]&lt;<span class=\"string\">'0'</span> || str[i]&gt;<span class=\"string\">'9'</span>) )</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!flag &amp;&amp; (str[i]==<span class=\"string\">'+'</span> || str[i]==<span class=\"string\">'-'</span>|| (str[i]&gt;=<span class=\"string\">'0'</span>&amp;&amp;str[i]&lt;=<span class=\"string\">'9'</span>)))&#123;</span><br><span class=\"line\">                flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[i]==<span class=\"string\">'-'</span>)flag2 = <span class=\"number\">-1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[i]==<span class=\"string\">'+'</span>||str[i]==<span class=\"string\">'-'</span>)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                tmp = tmp*<span class=\"number\">10</span>+str[i]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp*=flag2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp&gt;INT_MAX) <span class=\"keyword\">return</span> INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp&lt;INT_MIN) <span class=\"keyword\">return</span> INT_MIN;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>借用了<a href=\"http://chengfeng96.com/blog/2017/03/07/LeetCode-No-8-String-to-Integer-atoi/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HazzaCheng的代码</a>,这道题用python解简直作弊..<br></p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myAtoi</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        ls = list(s.strip())</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(ls) == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        sign = <span class=\"number\">-1</span> <span class=\"keyword\">if</span> ls[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ls[<span class=\"number\">0</span>] <span class=\"keyword\">in</span> [<span class=\"string\">'-'</span>, <span class=\"string\">'+'</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">del</span> ls[<span class=\"number\">0</span>]</span><br><span class=\"line\">        res, i = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(ls) <span class=\"keyword\">and</span> ls[i].isdigit():</span><br><span class=\"line\">            res = res * <span class=\"number\">10</span> + ord(ls[i]) - ord(<span class=\"string\">'0'</span>)</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(<span class=\"number\">-2</span> ** <span class=\"number\">31</span>, min(sign * res, <span class=\"number\">2</span> ** <span class=\"number\">31</span> - <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure><p></p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>要注意各种情况的判断</li><li>就算用了long long作为中转，在循环中也要判断是否已经超过int表示范围，提前break，可能出现longlong都无法表示的测试</li><li>注意空串</li><li>注意前面的符号</li><li>不应该进行的操作及时continue掉</li><li>还是会出现’+’号的</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/string-to-integer-atoi/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>实现C++的atoi()函数<br>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p></div>","more":"<div class=\"note info\"><p><strong>Note:</strong></p><blockquote><p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range:<script type=\"math/tex\">[−2^{31},  2^{31} − 1]</script>. If the numerical value is out of the range of representable values, INT_MAX<script type=\"math/tex\">2^{31}-1</script>or INT_MIN<script type=\"math/tex\">-2^{31}</script>is returned.</p></blockquote></div><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>“42”<br><strong>Output:</strong>42<br><strong>Input:</strong>“ -42”<br><strong>Output:</strong>-42<br><strong>Input:</strong>“words and 987”<br><strong>Output:</strong>987</p><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>没啥思维量，就是简单的遍历每个字符，然后设置两个flag，一个用于判断有没有到数字部分，第二个判断是不是负数，如果没到数字部分，就要分情况讨论，如果到了数字部分，判断到没到非数字，到了就退出，没到就每个数字加到结果上</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>每个字符遍历过去的方法，12ms，8.4MB<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">myAtoi</span><span class=\"params\">(<span class=\"built_in\">string</span> str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = str.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;<span class=\"comment\">//是否到数字部分</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag2 = <span class=\"number\">1</span>;<span class=\"comment\">//负数标志，有就变为-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//已经开始数字部分的情况，即flag = true</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp&gt;INT_MAX)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag &amp;&amp; (str[i]&lt;<span class=\"string\">'0'</span> || str[i]&gt;<span class=\"string\">'9'</span>)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag) tmp = tmp*<span class=\"number\">10</span>+str[i]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//还没到数字的情况，前面那部分，分为空格、非数字非符号、数字或正负号</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!flag &amp;&amp; str[i]==<span class=\"string\">' '</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!flag &amp;&amp; str[i]!=<span class=\"string\">'+'</span> &amp;&amp; str[i]!=<span class=\"string\">'-'</span> &amp;&amp; (str[i]&lt;<span class=\"string\">'0'</span> || str[i]&gt;<span class=\"string\">'9'</span>) )</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!flag &amp;&amp; (str[i]==<span class=\"string\">'+'</span> || str[i]==<span class=\"string\">'-'</span>|| (str[i]&gt;=<span class=\"string\">'0'</span>&amp;&amp;str[i]&lt;=<span class=\"string\">'9'</span>)))&#123;</span><br><span class=\"line\">                flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[i]==<span class=\"string\">'-'</span>)flag2 = <span class=\"number\">-1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[i]==<span class=\"string\">'+'</span>||str[i]==<span class=\"string\">'-'</span>)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                tmp = tmp*<span class=\"number\">10</span>+str[i]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp*=flag2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp&gt;INT_MAX) <span class=\"keyword\">return</span> INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp&lt;INT_MIN) <span class=\"keyword\">return</span> INT_MIN;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>借用了<a href=\"http://chengfeng96.com/blog/2017/03/07/LeetCode-No-8-String-to-Integer-atoi/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">HazzaCheng的代码</a>,这道题用python解简直作弊..<br></p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myAtoi</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        ls = list(s.strip())</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(ls) == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        sign = <span class=\"number\">-1</span> <span class=\"keyword\">if</span> ls[<span class=\"number\">0</span>] == <span class=\"string\">'-'</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ls[<span class=\"number\">0</span>] <span class=\"keyword\">in</span> [<span class=\"string\">'-'</span>, <span class=\"string\">'+'</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">del</span> ls[<span class=\"number\">0</span>]</span><br><span class=\"line\">        res, i = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(ls) <span class=\"keyword\">and</span> ls[i].isdigit():</span><br><span class=\"line\">            res = res * <span class=\"number\">10</span> + ord(ls[i]) - ord(<span class=\"string\">'0'</span>)</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(<span class=\"number\">-2</span> ** <span class=\"number\">31</span>, min(sign * res, <span class=\"number\">2</span> ** <span class=\"number\">31</span> - <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure><p></p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>要注意各种情况的判断</li><li>就算用了long long作为中转，在循环中也要判断是否已经超过int表示范围，提前break，可能出现longlong都无法表示的测试</li><li>注意空串</li><li>注意前面的符号</li><li>不应该进行的操作及时continue掉</li><li>还是会出现’+’号的</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-010-Regular Expression Matching","urlname":"leetcode-regular-expression-matching","comments":1,"mathjax":false,"date":"2019-04-26T17:43:57.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/regular-expression-matching/)   \nGiven an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '\\*'.\n\n> '.' Matches any single character.\n> '\\*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n**Note**:\n> s could be empty and contains only lowercase letters a-z.\n> p could be empty and contains only lowercase letters a-z, and characters like . or \\*.\n\n### Examples:\n**Input:** s=\"aa\" p=\"a\"\n**Output:** false\n**Input:** s=\"aa\" p=\"a\\*\"\n**Output:** true\n**Input:** s=\"ab\" p=\".\\*\"\n**Output:** true\n**Input:** s=\"aab\" p=\"c\\*a\\*b\"\n**Output:** true\n**Input:** s=\"mississippi\" p=\"mis\\*is\\*p\\*.\"\n**Output:** false\n\n佛了，一道题搞了两个多小时，还是有bug...貌似方法错了，题解说了递归和DP，我用到了递归，可还是不行，DP就直接没想到，先码着回头改\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 递归，首字母匹配，并且后面的子串也匹配\n- DP动态规划，自上而下和自下而上两种，自下而上的不用递归，时间复杂度上会好点\n- 自下而上的方法，在判断前一个字符的时候，因为后面的部分已经判断过了，所以可以直接从dp表里面取数据\n\n## C++ Codes\n**递归方法**\n\n```C++\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        if(p.empty())return s.empty();\n        //第一个字符匹配或者是.匹配符\n        bool first_match = (!s.empty() &&\n                            (p[0]==s[0]||p[0]=='.'));\n\n        //如果是字符加*\n        if(p.length()>=2 && p[1]=='*'){\n            return (isMatch(s, p.substr(2)) ||\n                (first_match && isMatch(s.substr(1), p)));\n        //如果没有*或者少于两个字符\n        } else {\n            return first_match &&\n                isMatch(s.substr(1), p.substr(1));\n        }\n    }\n};\n```\n\n## Java Codes\n**自上而下的DP**\n\n```Java\nenum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}\n```\n\n**自下而上的DP**\n\n```Java\nclass Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}\n```\n\n## C++ Codes\n\n暂时码着自己代码，还有bug，在s遍历完了，p没遍历完时会出错...代码太丑陋了，只会暴力吗，僵硬...\n\n```C++\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int si=0,pi=0;\n        int sn=s.length(), pn=p.length();\n        for(pi;pi<pn,si<sn;pi++){\n            cout<<s.substr(si)<<\"\\t\"<<p.substr(pi)<<endl;\n            switch(p[pi]){\n                case '.':        //任意单个字符\n                    si++;\n                    break;\n                case '*':        //零个或者多个前面的元素\n                    if(p[pi-1]=='.') \n                    {\n                        if(pi==pn-1)re后面还要改turn true;    //如果.*是最后两个字符，直接返回true\n                        while((p[pi+1]=='.'||p[pi+1]=='*')&&pi<pn){ //如果后面持续特殊字符\n                            pi++;\n                        }\n                        if(pi==pn)return true;  //如果到最后全是特殊字符\n\n                        //p[pi+1]是普通字符,让si++,找s[si]==p[pi+1]\n                        while(s[si]!=p[pi+1] && si<sn) si++;\n                        break;\n                    }\n                    if(p[pi-1]!=s[si])//零个\n                        break;\n                    \n                    //一个或者多个,后面部分的需要也匹配\n                    if(p[pi-1]==s[si])si++;\n                    if(si==sn && pi==pn-1)return true;\n                    else if(si==sn)si--;\n                    while(p[pi-1]==s[si] &&(si<sn && pi+1<pn && isMatch(s.substr(si),p.substr(pi+1))==false)){\n                        si++;\n                    }\n\n                    break; \n                default:\n                    if(p[pi]==s[si] && si<sn){           //相等就继续遍历\n                        si++;\n                        break;\n                    }//不等，则判断后面是否有*，如果有，这个字符可以跳过,注意这里si并没有自增\n                    else if(p[pi]!=s[si] && pi+1<pn && p[pi+1]=='*'){\n                        break;\n                    }\n                    else return false;\n            }\n        }\n        if(pi==pn && si==sn)return true;\n        return false;\n    }\n};\n```\n\n## Python Codes\n\n评论区有人一行Java正则就搞定了，我觉得，python一行也够了...\n\n```python\n略\n```\n\n## 总结\n- 正则匹配这里，其实应该先想到递归和DP的，但是思维太局限，训练的少，虽然会递归和DP，但是想不起来用..仿佛读了假书..\n- 算法题需要训练，不光是会算法，不然都不知道题目应该用什么算法...\n- 这道题来说，递归还是挺容易写的，首字母匹配，后面的也匹配就可以，再考虑下\\*字符的情况\n\n\n------\n","source":"_posts/LeetCode/LeetCode-010-Regular-Expression-Matching.md","raw":"---\ntitle: LeetCode-010-Regular Expression Matching\ntags:\n  - LeetCode\n  - Algorithm\n  - DP\n  - String\n  - Match\n  - Hard\ncategories:\n  - LeetCode\nurlname: leetcode-regular-expression-matching\ncomments: true\nmathjax: false\ndate: 2019-04-27 01:43:57\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/regular-expression-matching/)   \nGiven an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '\\*'.\n\n> '.' Matches any single character.\n> '\\*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n**Note**:\n> s could be empty and contains only lowercase letters a-z.\n> p could be empty and contains only lowercase letters a-z, and characters like . or \\*.\n\n### Examples:\n**Input:** s=\"aa\" p=\"a\"\n**Output:** false\n**Input:** s=\"aa\" p=\"a\\*\"\n**Output:** true\n**Input:** s=\"ab\" p=\".\\*\"\n**Output:** true\n**Input:** s=\"aab\" p=\"c\\*a\\*b\"\n**Output:** true\n**Input:** s=\"mississippi\" p=\"mis\\*is\\*p\\*.\"\n**Output:** false\n\n佛了，一道题搞了两个多小时，还是有bug...貌似方法错了，题解说了递归和DP，我用到了递归，可还是不行，DP就直接没想到，先码着回头改\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 递归，首字母匹配，并且后面的子串也匹配\n- DP动态规划，自上而下和自下而上两种，自下而上的不用递归，时间复杂度上会好点\n- 自下而上的方法，在判断前一个字符的时候，因为后面的部分已经判断过了，所以可以直接从dp表里面取数据\n\n## C++ Codes\n**递归方法**\n\n```C++\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        if(p.empty())return s.empty();\n        //第一个字符匹配或者是.匹配符\n        bool first_match = (!s.empty() &&\n                            (p[0]==s[0]||p[0]=='.'));\n\n        //如果是字符加*\n        if(p.length()>=2 && p[1]=='*'){\n            return (isMatch(s, p.substr(2)) ||\n                (first_match && isMatch(s.substr(1), p)));\n        //如果没有*或者少于两个字符\n        } else {\n            return first_match &&\n                isMatch(s.substr(1), p.substr(1));\n        }\n    }\n};\n```\n\n## Java Codes\n**自上而下的DP**\n\n```Java\nenum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}\n```\n\n**自下而上的DP**\n\n```Java\nclass Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}\n```\n\n## C++ Codes\n\n暂时码着自己代码，还有bug，在s遍历完了，p没遍历完时会出错...代码太丑陋了，只会暴力吗，僵硬...\n\n```C++\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int si=0,pi=0;\n        int sn=s.length(), pn=p.length();\n        for(pi;pi<pn,si<sn;pi++){\n            cout<<s.substr(si)<<\"\\t\"<<p.substr(pi)<<endl;\n            switch(p[pi]){\n                case '.':        //任意单个字符\n                    si++;\n                    break;\n                case '*':        //零个或者多个前面的元素\n                    if(p[pi-1]=='.') \n                    {\n                        if(pi==pn-1)re后面还要改turn true;    //如果.*是最后两个字符，直接返回true\n                        while((p[pi+1]=='.'||p[pi+1]=='*')&&pi<pn){ //如果后面持续特殊字符\n                            pi++;\n                        }\n                        if(pi==pn)return true;  //如果到最后全是特殊字符\n\n                        //p[pi+1]是普通字符,让si++,找s[si]==p[pi+1]\n                        while(s[si]!=p[pi+1] && si<sn) si++;\n                        break;\n                    }\n                    if(p[pi-1]!=s[si])//零个\n                        break;\n                    \n                    //一个或者多个,后面部分的需要也匹配\n                    if(p[pi-1]==s[si])si++;\n                    if(si==sn && pi==pn-1)return true;\n                    else if(si==sn)si--;\n                    while(p[pi-1]==s[si] &&(si<sn && pi+1<pn && isMatch(s.substr(si),p.substr(pi+1))==false)){\n                        si++;\n                    }\n\n                    break; \n                default:\n                    if(p[pi]==s[si] && si<sn){           //相等就继续遍历\n                        si++;\n                        break;\n                    }//不等，则判断后面是否有*，如果有，这个字符可以跳过,注意这里si并没有自增\n                    else if(p[pi]!=s[si] && pi+1<pn && p[pi+1]=='*'){\n                        break;\n                    }\n                    else return false;\n            }\n        }\n        if(pi==pn && si==sn)return true;\n        return false;\n    }\n};\n```\n\n## Python Codes\n\n评论区有人一行Java正则就搞定了，我觉得，python一行也够了...\n\n```python\n略\n```\n\n## 总结\n- 正则匹配这里，其实应该先想到递归和DP的，但是思维太局限，训练的少，虽然会递归和DP，但是想不起来用..仿佛读了假书..\n- 算法题需要训练，不光是会算法，不然都不知道题目应该用什么算法...\n- 这道题来说，递归还是挺容易写的，首字母匹配，后面的也匹配就可以，再考虑下\\*字符的情况\n\n\n------\n","slug":"LeetCode/LeetCode-010-Regular-Expression-Matching","published":1,"updated":"2019-07-25T17:56:32.595Z","layout":"post","photos":[],"link":"","_id":"ck2424lt8005ilksb0b3hxlki","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/regular-expression-matching/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*‘.</p><blockquote><p>‘.’ Matches any single character.<br>‘*‘ Matches zero or more of the preceding element.</p></blockquote><p>The matching should cover the entire input string (not partial).</p><p><strong>Note</strong>:</p><blockquote><p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.</p></blockquote><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> s=”aa” p=”a”<br><strong>Output:</strong> false<br><strong>Input:</strong> s=”aa” p=”a*“<br><strong>Output:</strong> true<br><strong>Input:</strong> s=”ab” p=”.*“<br><strong>Output:</strong> true<br><strong>Input:</strong> s=”aab” p=”c*a*b”<br><strong>Output:</strong> true<br><strong>Input:</strong> s=”mississippi” p=”mis*is*p*.”<br><strong>Output:</strong> false</p><p>佛了，一道题搞了两个多小时，还是有bug…貌似方法错了，题解说了递归和DP，我用到了递归，可还是不行，DP就直接没想到，先码着回头改</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>递归，首字母匹配，并且后面的子串也匹配</li><li>DP动态规划，自上而下和自下而上两种，自下而上的不用递归，时间复杂度上会好点</li><li>自下而上的方法，在判断前一个字符的时候，因为后面的部分已经判断过了，所以可以直接从dp表里面取数据</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p><strong>递归方法</strong></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p.empty())<span class=\"keyword\">return</span> s.empty();</span><br><span class=\"line\">        <span class=\"comment\">//第一个字符匹配或者是.匹配符</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> first_match = (!s.empty() &amp;&amp;</span><br><span class=\"line\">                            (p[<span class=\"number\">0</span>]==s[<span class=\"number\">0</span>]||p[<span class=\"number\">0</span>]==<span class=\"string\">'.'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果是字符加*</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p.length()&gt;=<span class=\"number\">2</span> &amp;&amp; p[<span class=\"number\">1</span>]==<span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (isMatch(s, p.substr(<span class=\"number\">2</span>)) ||</span><br><span class=\"line\">                (first_match &amp;&amp; isMatch(s.substr(<span class=\"number\">1</span>), p)));</span><br><span class=\"line\">        <span class=\"comment\">//如果没有*或者少于两个字符</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first_match &amp;&amp;</span><br><span class=\"line\">                isMatch(s.substr(<span class=\"number\">1</span>), p.substr(<span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Java-Codes\"><a href=\"#Java-Codes\" class=\"headerlink\" title=\"Java Codes\"></a>Java Codes</h2><p><strong>自上而下的DP</strong></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Result &#123;</span><br><span class=\"line\">    TRUE, FALSE</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    Result[][] memo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span><span class=\"params\">(String text, String pattern)</span> </span>&#123;</span><br><span class=\"line\">        memo = <span class=\"keyword\">new</span> Result[text.length() + <span class=\"number\">1</span>][pattern.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp(<span class=\"number\">0</span>, <span class=\"number\">0</span>, text, pattern);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dp</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, String text, String pattern)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (memo[i][j] != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[i][j] == Result.TRUE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> ans;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == pattern.length())&#123;</span><br><span class=\"line\">            ans = i == text.length();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> first_match = (i &lt; text.length() &amp;&amp;</span><br><span class=\"line\">                                   (pattern.charAt(j) == text.charAt(i) ||</span><br><span class=\"line\">                                    pattern.charAt(j) == <span class=\"string\">'.'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class=\"number\">1</span>) == <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">                ans = (dp(i, j+<span class=\"number\">2</span>, text, pattern) ||</span><br><span class=\"line\">                       first_match &amp;&amp; dp(i+<span class=\"number\">1</span>, j, text, pattern));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = first_match &amp;&amp; dp(i+<span class=\"number\">1</span>, j+<span class=\"number\">1</span>, text, pattern);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        memo[i][j] = ans ? Result.TRUE : Result.FALSE;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>自下而上的DP</strong></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span><span class=\"params\">(String text, String pattern)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[text.length() + <span class=\"number\">1</span>][pattern.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[text.length()][pattern.length()] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = text.length(); i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = pattern.length() - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> first_match = (i &lt; text.length() &amp;&amp;</span><br><span class=\"line\">                                       (pattern.charAt(j) == text.charAt(i) ||</span><br><span class=\"line\">                                        pattern.charAt(j) == <span class=\"string\">'.'</span>));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class=\"number\">1</span>) == <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i][j+<span class=\"number\">2</span>] || first_match &amp;&amp; dp[i+<span class=\"number\">1</span>][j];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = first_match &amp;&amp; dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"C-Codes-1\"><a href=\"#C-Codes-1\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>暂时码着自己代码，还有bug，在s遍历完了，p没遍历完时会出错…代码太丑陋了，只会暴力吗，僵硬…</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> si=<span class=\"number\">0</span>,pi=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sn=s.length(), pn=p.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(pi;pi&lt;pn,si&lt;sn;pi++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;s.substr(si)&lt;&lt;<span class=\"string\">\"\\t\"</span>&lt;&lt;p.substr(pi)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span>(p[pi])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'.'</span>:        <span class=\"comment\">//任意单个字符</span></span><br><span class=\"line\">                    si++;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:        <span class=\"comment\">//零个或者多个前面的元素</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(p[pi<span class=\"number\">-1</span>]==<span class=\"string\">'.'</span>) </span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(pi==pn<span class=\"number\">-1</span>)re后面还要改turn <span class=\"literal\">true</span>;    <span class=\"comment\">//如果.*是最后两个字符，直接返回true</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span>((p[pi+<span class=\"number\">1</span>]==<span class=\"string\">'.'</span>||p[pi+<span class=\"number\">1</span>]==<span class=\"string\">'*'</span>)&amp;&amp;pi&lt;pn)&#123; <span class=\"comment\">//如果后面持续特殊字符</span></span><br><span class=\"line\">                            pi++;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(pi==pn)<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  <span class=\"comment\">//如果到最后全是特殊字符</span></span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">//p[pi+1]是普通字符,让si++,找s[si]==p[pi+1]</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span>(s[si]!=p[pi+<span class=\"number\">1</span>] &amp;&amp; si&lt;sn) si++;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(p[pi<span class=\"number\">-1</span>]!=s[si])<span class=\"comment\">//零个</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">//一个或者多个,后面部分的需要也匹配</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(p[pi<span class=\"number\">-1</span>]==s[si])si++;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(si==sn &amp;&amp; pi==pn<span class=\"number\">-1</span>)<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(si==sn)si--;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(p[pi<span class=\"number\">-1</span>]==s[si] &amp;&amp;(si&lt;sn &amp;&amp; pi+<span class=\"number\">1</span>&lt;pn &amp;&amp; isMatch(s.substr(si),p.substr(pi+<span class=\"number\">1</span>))==<span class=\"literal\">false</span>))&#123;</span><br><span class=\"line\">                        si++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>; </span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(p[pi]==s[si] &amp;&amp; si&lt;sn)&#123;           <span class=\"comment\">//相等就继续遍历</span></span><br><span class=\"line\">                        si++;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;<span class=\"comment\">//不等，则判断后面是否有*，如果有，这个字符可以跳过,注意这里si并没有自增</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(p[pi]!=s[si] &amp;&amp; pi+<span class=\"number\">1</span>&lt;pn &amp;&amp; p[pi+<span class=\"number\">1</span>]==<span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pi==pn &amp;&amp; si==sn)<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>评论区有人一行Java正则就搞定了，我觉得，python一行也够了…</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">略</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>正则匹配这里，其实应该先想到递归和DP的，但是思维太局限，训练的少，虽然会递归和DP，但是想不起来用..仿佛读了假书..</li><li>算法题需要训练，不光是会算法，不然都不知道题目应该用什么算法…</li><li>这道题来说，递归还是挺容易写的，首字母匹配，后面的也匹配就可以，再考虑下*字符的情况</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/regular-expression-matching/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*‘.</p><blockquote><p>‘.’ Matches any single character.<br>‘*‘ Matches zero or more of the preceding element.</p></blockquote><p>The matching should cover the entire input string (not partial).</p><p><strong>Note</strong>:</p><blockquote><p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.</p></blockquote><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> s=”aa” p=”a”<br><strong>Output:</strong> false<br><strong>Input:</strong> s=”aa” p=”a*“<br><strong>Output:</strong> true<br><strong>Input:</strong> s=”ab” p=”.*“<br><strong>Output:</strong> true<br><strong>Input:</strong> s=”aab” p=”c*a*b”<br><strong>Output:</strong> true<br><strong>Input:</strong> s=”mississippi” p=”mis*is*p*.”<br><strong>Output:</strong> false</p><p>佛了，一道题搞了两个多小时，还是有bug…貌似方法错了，题解说了递归和DP，我用到了递归，可还是不行，DP就直接没想到，先码着回头改</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>递归，首字母匹配，并且后面的子串也匹配</li><li>DP动态规划，自上而下和自下而上两种，自下而上的不用递归，时间复杂度上会好点</li><li>自下而上的方法，在判断前一个字符的时候，因为后面的部分已经判断过了，所以可以直接从dp表里面取数据</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p><strong>递归方法</strong></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p.empty())<span class=\"keyword\">return</span> s.empty();</span><br><span class=\"line\">        <span class=\"comment\">//第一个字符匹配或者是.匹配符</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> first_match = (!s.empty() &amp;&amp;</span><br><span class=\"line\">                            (p[<span class=\"number\">0</span>]==s[<span class=\"number\">0</span>]||p[<span class=\"number\">0</span>]==<span class=\"string\">'.'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果是字符加*</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p.length()&gt;=<span class=\"number\">2</span> &amp;&amp; p[<span class=\"number\">1</span>]==<span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (isMatch(s, p.substr(<span class=\"number\">2</span>)) ||</span><br><span class=\"line\">                (first_match &amp;&amp; isMatch(s.substr(<span class=\"number\">1</span>), p)));</span><br><span class=\"line\">        <span class=\"comment\">//如果没有*或者少于两个字符</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first_match &amp;&amp;</span><br><span class=\"line\">                isMatch(s.substr(<span class=\"number\">1</span>), p.substr(<span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Java-Codes\"><a href=\"#Java-Codes\" class=\"headerlink\" title=\"Java Codes\"></a>Java Codes</h2><p><strong>自上而下的DP</strong></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Result &#123;</span><br><span class=\"line\">    TRUE, FALSE</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    Result[][] memo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span><span class=\"params\">(String text, String pattern)</span> </span>&#123;</span><br><span class=\"line\">        memo = <span class=\"keyword\">new</span> Result[text.length() + <span class=\"number\">1</span>][pattern.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp(<span class=\"number\">0</span>, <span class=\"number\">0</span>, text, pattern);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dp</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, String text, String pattern)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (memo[i][j] != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[i][j] == Result.TRUE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> ans;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == pattern.length())&#123;</span><br><span class=\"line\">            ans = i == text.length();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> first_match = (i &lt; text.length() &amp;&amp;</span><br><span class=\"line\">                                   (pattern.charAt(j) == text.charAt(i) ||</span><br><span class=\"line\">                                    pattern.charAt(j) == <span class=\"string\">'.'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class=\"number\">1</span>) == <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">                ans = (dp(i, j+<span class=\"number\">2</span>, text, pattern) ||</span><br><span class=\"line\">                       first_match &amp;&amp; dp(i+<span class=\"number\">1</span>, j, text, pattern));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = first_match &amp;&amp; dp(i+<span class=\"number\">1</span>, j+<span class=\"number\">1</span>, text, pattern);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        memo[i][j] = ans ? Result.TRUE : Result.FALSE;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>自下而上的DP</strong></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span><span class=\"params\">(String text, String pattern)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[text.length() + <span class=\"number\">1</span>][pattern.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[text.length()][pattern.length()] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = text.length(); i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = pattern.length() - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> first_match = (i &lt; text.length() &amp;&amp;</span><br><span class=\"line\">                                       (pattern.charAt(j) == text.charAt(i) ||</span><br><span class=\"line\">                                        pattern.charAt(j) == <span class=\"string\">'.'</span>));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class=\"number\">1</span>) == <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i][j+<span class=\"number\">2</span>] || first_match &amp;&amp; dp[i+<span class=\"number\">1</span>][j];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = first_match &amp;&amp; dp[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"C-Codes-1\"><a href=\"#C-Codes-1\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>暂时码着自己代码，还有bug，在s遍历完了，p没遍历完时会出错…代码太丑陋了，只会暴力吗，僵硬…</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> si=<span class=\"number\">0</span>,pi=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sn=s.length(), pn=p.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(pi;pi&lt;pn,si&lt;sn;pi++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;s.substr(si)&lt;&lt;<span class=\"string\">\"\\t\"</span>&lt;&lt;p.substr(pi)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span>(p[pi])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'.'</span>:        <span class=\"comment\">//任意单个字符</span></span><br><span class=\"line\">                    si++;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:        <span class=\"comment\">//零个或者多个前面的元素</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(p[pi<span class=\"number\">-1</span>]==<span class=\"string\">'.'</span>) </span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(pi==pn<span class=\"number\">-1</span>)re后面还要改turn <span class=\"literal\">true</span>;    <span class=\"comment\">//如果.*是最后两个字符，直接返回true</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span>((p[pi+<span class=\"number\">1</span>]==<span class=\"string\">'.'</span>||p[pi+<span class=\"number\">1</span>]==<span class=\"string\">'*'</span>)&amp;&amp;pi&lt;pn)&#123; <span class=\"comment\">//如果后面持续特殊字符</span></span><br><span class=\"line\">                            pi++;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(pi==pn)<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  <span class=\"comment\">//如果到最后全是特殊字符</span></span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">//p[pi+1]是普通字符,让si++,找s[si]==p[pi+1]</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span>(s[si]!=p[pi+<span class=\"number\">1</span>] &amp;&amp; si&lt;sn) si++;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(p[pi<span class=\"number\">-1</span>]!=s[si])<span class=\"comment\">//零个</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">//一个或者多个,后面部分的需要也匹配</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(p[pi<span class=\"number\">-1</span>]==s[si])si++;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(si==sn &amp;&amp; pi==pn<span class=\"number\">-1</span>)<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(si==sn)si--;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(p[pi<span class=\"number\">-1</span>]==s[si] &amp;&amp;(si&lt;sn &amp;&amp; pi+<span class=\"number\">1</span>&lt;pn &amp;&amp; isMatch(s.substr(si),p.substr(pi+<span class=\"number\">1</span>))==<span class=\"literal\">false</span>))&#123;</span><br><span class=\"line\">                        si++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>; </span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(p[pi]==s[si] &amp;&amp; si&lt;sn)&#123;           <span class=\"comment\">//相等就继续遍历</span></span><br><span class=\"line\">                        si++;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;<span class=\"comment\">//不等，则判断后面是否有*，如果有，这个字符可以跳过,注意这里si并没有自增</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(p[pi]!=s[si] &amp;&amp; pi+<span class=\"number\">1</span>&lt;pn &amp;&amp; p[pi+<span class=\"number\">1</span>]==<span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pi==pn &amp;&amp; si==sn)<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>评论区有人一行Java正则就搞定了，我觉得，python一行也够了…</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">略</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>正则匹配这里，其实应该先想到递归和DP的，但是思维太局限，训练的少，虽然会递归和DP，但是想不起来用..仿佛读了假书..</li><li>算法题需要训练，不光是会算法，不然都不知道题目应该用什么算法…</li><li>这道题来说，递归还是挺容易写的，首字母匹配，后面的也匹配就可以，再考虑下*字符的情况</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-003-Longest Substring Without Repeating Characters","comments":1,"mathjax":false,"date":"2019-04-12T17:02:13.000Z","urlname":"leetcode-longest-substring-without-repeating-characters","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/longest-substring-without-repeating-characters/) \nGiven a string, find the length of the **longest substring** without repeating characters.\n### Examples:\n> \"abcabcbb\" ---> 3\n> \"bbbbb\" ---> 1\n> \"pwwkew\" ---> 3\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 第一反应下想到的也是暴力遍历，写一个判断有没有重复字符串的函数，然后遍历每个子串，时间复杂度是$$ O(n^3) $$，太高了，导致第一次提交没过，后面优化了下暴力法，过了。\n- 除了暴力，题解上给出了**滑动窗口**的解法，利用前后两个指针i,j 不断移动来遍历字符串以及子串，i,j中间的就是没有重复字符的,如果遇到重复字符，就把i自增，一直到没有重复字符为止（就是相当于找到和j处的相同字符的为止），时间复杂度是$$ O(n) $$\n- 最后是优化的滑动窗口，先记录每个字符第一次出现的位置pos，然后第二次出现的时候，将第一个指针i直接变成pos+1\n- 对上面的优化还有一个技巧是利用整数数组代替Map，也可以用bitmap每一位表示一个字符数量\n\n## C++ Codes\n这是我优化过的暴力法，勉强过了，判断函数那边用了太大的数组，可以用bitmap降低空间复杂度\n\n用了72ms,20.1MB...僵硬\n\n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.length()==0)return 0;\n        int max=1;\n        //i是最大长度，j是每次遍历的起始位置\n        for(int j=0;j<s.length();j++){\n            //这里让i直接从max开始，可以少一点没用的遍历\n            for(int i=max;i+j<=s.length();i++){\n                //如果有重复字符直接退出循环\n                if(!judgeSubstring(s.substr(j,i))) break;\n                max=i;\n            }\n        }\n        return max;\n    }\n\n    bool judgeSubstring(string substr){\n        int tmp[128]={0};\n        for(int i=0;i<substr.length();i++){\n            //如果不是0就肯定有重复字符\n            if(tmp[int(substr[i])])return false;\n            tmp[int(substr[i])]+=1;\n        }\n        return true;\n    }\n};\n```\n\n好了，这是第三种方法对应的代码，这次只用了12ms,9.1MB，话说感觉这种滑动窗口有点像快排...\n\n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n=s.length();\n        //用来保存每个字符的下一个位置，用于出现重复字符的时候直接赋值给i\n        int cNum[128]={0};      \n        int max=0;\n        //i是第一个指针，j是第二个\n        for(int j=0,i=0;j<n;j++){\n            //如果不为0就是出现了和s[j]一样的字符，让i等于那个字符的后一个位置\n            if(cNum[s[j]]){\n                i = cNum[s[j]]>i?cNum[s[j]]:i;\n            }\n            //这里不管有没有重复字符都要更新max和cNum[s[j]]\n            //很明显，如果有，i已经被更新，相当于已经变成了没有重复字符的情形，位置也要更新\n            max=(j-i+1)>max?(j-i+1):max;\n            cNum[s[j]]=j+1;\n        }\n        return max;\n    }\n\n};\n```\n\n## Python Codes\n用时52ms，12.7MB\n\n```Python\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        cNum=dict()\n        res=0\n        start=0\n        for i in range(len(s)):\n            if s[i] in cNum:\n                start=max(start,cNum[s[i]])\n            res=max(res,i-start+1)\n            cNum[s[i]]=i+1\n        return res\n```\n\n## 总结\n总感觉自己想的太简单，优化还是有点难度的，这道题关键的就是一次遍历，用两个指针表示字符串，并且没有单独拿出字符串判断，而是用set或者map、dict这种方式记录当前子串的内容，用于判断是否有没有出现重复字符，优化的时候减少无用的遍历\n\n------\n","source":"_posts/LeetCode/LeetCode-003-Longest-Substring-Without-Repeating-Characters.md","raw":"---\ntitle: LeetCode-003-Longest Substring Without Repeating Characters\ncomments: true\nmathjax: false\ndate: 2019-04-13 01:02:13\ntags: \n  - Algorithm\n  - LeetCode\n  - String\n  - Math\n  - Medium\ncategories: LeetCode\nurlname: leetcode-longest-substring-without-repeating-characters \n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/longest-substring-without-repeating-characters/) \nGiven a string, find the length of the **longest substring** without repeating characters.\n### Examples:\n> \"abcabcbb\" ---> 3\n> \"bbbbb\" ---> 1\n> \"pwwkew\" ---> 3\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 第一反应下想到的也是暴力遍历，写一个判断有没有重复字符串的函数，然后遍历每个子串，时间复杂度是$$ O(n^3) $$，太高了，导致第一次提交没过，后面优化了下暴力法，过了。\n- 除了暴力，题解上给出了**滑动窗口**的解法，利用前后两个指针i,j 不断移动来遍历字符串以及子串，i,j中间的就是没有重复字符的,如果遇到重复字符，就把i自增，一直到没有重复字符为止（就是相当于找到和j处的相同字符的为止），时间复杂度是$$ O(n) $$\n- 最后是优化的滑动窗口，先记录每个字符第一次出现的位置pos，然后第二次出现的时候，将第一个指针i直接变成pos+1\n- 对上面的优化还有一个技巧是利用整数数组代替Map，也可以用bitmap每一位表示一个字符数量\n\n## C++ Codes\n这是我优化过的暴力法，勉强过了，判断函数那边用了太大的数组，可以用bitmap降低空间复杂度\n\n用了72ms,20.1MB...僵硬\n\n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.length()==0)return 0;\n        int max=1;\n        //i是最大长度，j是每次遍历的起始位置\n        for(int j=0;j<s.length();j++){\n            //这里让i直接从max开始，可以少一点没用的遍历\n            for(int i=max;i+j<=s.length();i++){\n                //如果有重复字符直接退出循环\n                if(!judgeSubstring(s.substr(j,i))) break;\n                max=i;\n            }\n        }\n        return max;\n    }\n\n    bool judgeSubstring(string substr){\n        int tmp[128]={0};\n        for(int i=0;i<substr.length();i++){\n            //如果不是0就肯定有重复字符\n            if(tmp[int(substr[i])])return false;\n            tmp[int(substr[i])]+=1;\n        }\n        return true;\n    }\n};\n```\n\n好了，这是第三种方法对应的代码，这次只用了12ms,9.1MB，话说感觉这种滑动窗口有点像快排...\n\n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n=s.length();\n        //用来保存每个字符的下一个位置，用于出现重复字符的时候直接赋值给i\n        int cNum[128]={0};      \n        int max=0;\n        //i是第一个指针，j是第二个\n        for(int j=0,i=0;j<n;j++){\n            //如果不为0就是出现了和s[j]一样的字符，让i等于那个字符的后一个位置\n            if(cNum[s[j]]){\n                i = cNum[s[j]]>i?cNum[s[j]]:i;\n            }\n            //这里不管有没有重复字符都要更新max和cNum[s[j]]\n            //很明显，如果有，i已经被更新，相当于已经变成了没有重复字符的情形，位置也要更新\n            max=(j-i+1)>max?(j-i+1):max;\n            cNum[s[j]]=j+1;\n        }\n        return max;\n    }\n\n};\n```\n\n## Python Codes\n用时52ms，12.7MB\n\n```Python\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        cNum=dict()\n        res=0\n        start=0\n        for i in range(len(s)):\n            if s[i] in cNum:\n                start=max(start,cNum[s[i]])\n            res=max(res,i-start+1)\n            cNum[s[i]]=i+1\n        return res\n```\n\n## 总结\n总感觉自己想的太简单，优化还是有点难度的，这道题关键的就是一次遍历，用两个指针表示字符串，并且没有单独拿出字符串判断，而是用set或者map、dict这种方式记录当前子串的内容，用于判断是否有没有出现重复字符，优化的时候减少无用的遍历\n\n------\n","slug":"LeetCode/LeetCode-003-Longest-Substring-Without-Repeating-Characters","published":1,"updated":"2019-07-25T17:52:50.672Z","layout":"post","photos":[],"link":"","_id":"ck2424lta005jlksbmbsn54ac","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><blockquote><p>“abcabcbb” —-&gt; 3<br>“bbbbb” —-&gt; 1<br>“pwwkew” —-&gt; 3</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>第一反应下想到的也是暴力遍历，写一个判断有没有重复字符串的函数，然后遍历每个子串，时间复杂度是<script type=\"math/tex\">O(n^3)</script>，太高了，导致第一次提交没过，后面优化了下暴力法，过了。</li><li>除了暴力，题解上给出了<strong>滑动窗口</strong>的解法，利用前后两个指针i,j 不断移动来遍历字符串以及子串，i,j中间的就是没有重复字符的,如果遇到重复字符，就把i自增，一直到没有重复字符为止（就是相当于找到和j处的相同字符的为止），时间复杂度是<script type=\"math/tex\">O(n)</script></li><li>最后是优化的滑动窗口，先记录每个字符第一次出现的位置pos，然后第二次出现的时候，将第一个指针i直接变成pos+1</li><li>对上面的优化还有一个技巧是利用整数数组代替Map，也可以用bitmap每一位表示一个字符数量</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>这是我优化过的暴力法，勉强过了，判断函数那边用了太大的数组，可以用bitmap降低空间复杂度</p><p>用了72ms,20.1MB…僵硬</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//i是最大长度，j是每次遍历的起始位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;s.length();j++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//这里让i直接从max开始，可以少一点没用的遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=max;i+j&lt;=s.length();i++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果有重复字符直接退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!judgeSubstring(s.substr(j,i))) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                max=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judgeSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> substr)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp[<span class=\"number\">128</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;substr.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果不是0就肯定有重复字符</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp[<span class=\"keyword\">int</span>(substr[i])])<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            tmp[<span class=\"keyword\">int</span>(substr[i])]+=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>好了，这是第三种方法对应的代码，这次只用了12ms,9.1MB，话说感觉这种滑动窗口有点像快排…</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n=s.length();</span><br><span class=\"line\">        <span class=\"comment\">//用来保存每个字符的下一个位置，用于出现重复字符的时候直接赋值给i</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cNum[<span class=\"number\">128</span>]=&#123;<span class=\"number\">0</span>&#125;;      </span><br><span class=\"line\">        <span class=\"keyword\">int</span> max=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//i是第一个指针，j是第二个</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>,i=<span class=\"number\">0</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果不为0就是出现了和s[j]一样的字符，让i等于那个字符的后一个位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cNum[s[j]])&#123;</span><br><span class=\"line\">                i = cNum[s[j]]&gt;i?cNum[s[j]]:i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//这里不管有没有重复字符都要更新max和cNum[s[j]]</span></span><br><span class=\"line\">            <span class=\"comment\">//很明显，如果有，i已经被更新，相当于已经变成了没有重复字符的情形，位置也要更新</span></span><br><span class=\"line\">            max=(j-i+<span class=\"number\">1</span>)&gt;max?(j-i+<span class=\"number\">1</span>):max;</span><br><span class=\"line\">            cNum[s[j]]=j+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>用时52ms，12.7MB</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        cNum=dict()</span><br><span class=\"line\">        res=<span class=\"number\">0</span></span><br><span class=\"line\">        start=<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] <span class=\"keyword\">in</span> cNum:</span><br><span class=\"line\">                start=max(start,cNum[s[i]])</span><br><span class=\"line\">            res=max(res,i-start+<span class=\"number\">1</span>)</span><br><span class=\"line\">            cNum[s[i]]=i+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总感觉自己想的太简单，优化还是有点难度的，这道题关键的就是一次遍历，用两个指针表示字符串，并且没有单独拿出字符串判断，而是用set或者map、dict这种方式记录当前子串的内容，用于判断是否有没有出现重复字符，优化的时候减少无用的遍历</p><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><blockquote><p>“abcabcbb” —-&gt; 3<br>“bbbbb” —-&gt; 1<br>“pwwkew” —-&gt; 3</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>第一反应下想到的也是暴力遍历，写一个判断有没有重复字符串的函数，然后遍历每个子串，时间复杂度是<script type=\"math/tex\">O(n^3)</script>，太高了，导致第一次提交没过，后面优化了下暴力法，过了。</li><li>除了暴力，题解上给出了<strong>滑动窗口</strong>的解法，利用前后两个指针i,j 不断移动来遍历字符串以及子串，i,j中间的就是没有重复字符的,如果遇到重复字符，就把i自增，一直到没有重复字符为止（就是相当于找到和j处的相同字符的为止），时间复杂度是<script type=\"math/tex\">O(n)</script></li><li>最后是优化的滑动窗口，先记录每个字符第一次出现的位置pos，然后第二次出现的时候，将第一个指针i直接变成pos+1</li><li>对上面的优化还有一个技巧是利用整数数组代替Map，也可以用bitmap每一位表示一个字符数量</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>这是我优化过的暴力法，勉强过了，判断函数那边用了太大的数组，可以用bitmap降低空间复杂度</p><p>用了72ms,20.1MB…僵硬</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//i是最大长度，j是每次遍历的起始位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;s.length();j++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//这里让i直接从max开始，可以少一点没用的遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=max;i+j&lt;=s.length();i++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果有重复字符直接退出循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!judgeSubstring(s.substr(j,i))) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                max=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judgeSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> substr)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp[<span class=\"number\">128</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;substr.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果不是0就肯定有重复字符</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp[<span class=\"keyword\">int</span>(substr[i])])<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            tmp[<span class=\"keyword\">int</span>(substr[i])]+=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>好了，这是第三种方法对应的代码，这次只用了12ms,9.1MB，话说感觉这种滑动窗口有点像快排…</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n=s.length();</span><br><span class=\"line\">        <span class=\"comment\">//用来保存每个字符的下一个位置，用于出现重复字符的时候直接赋值给i</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cNum[<span class=\"number\">128</span>]=&#123;<span class=\"number\">0</span>&#125;;      </span><br><span class=\"line\">        <span class=\"keyword\">int</span> max=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//i是第一个指针，j是第二个</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>,i=<span class=\"number\">0</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果不为0就是出现了和s[j]一样的字符，让i等于那个字符的后一个位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cNum[s[j]])&#123;</span><br><span class=\"line\">                i = cNum[s[j]]&gt;i?cNum[s[j]]:i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//这里不管有没有重复字符都要更新max和cNum[s[j]]</span></span><br><span class=\"line\">            <span class=\"comment\">//很明显，如果有，i已经被更新，相当于已经变成了没有重复字符的情形，位置也要更新</span></span><br><span class=\"line\">            max=(j-i+<span class=\"number\">1</span>)&gt;max?(j-i+<span class=\"number\">1</span>):max;</span><br><span class=\"line\">            cNum[s[j]]=j+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>用时52ms，12.7MB</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        cNum=dict()</span><br><span class=\"line\">        res=<span class=\"number\">0</span></span><br><span class=\"line\">        start=<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i] <span class=\"keyword\">in</span> cNum:</span><br><span class=\"line\">                start=max(start,cNum[s[i]])</span><br><span class=\"line\">            res=max(res,i-start+<span class=\"number\">1</span>)</span><br><span class=\"line\">            cNum[s[i]]=i+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总感觉自己想的太简单，优化还是有点难度的，这道题关键的就是一次遍历，用两个指针表示字符串，并且没有单独拿出字符串判断，而是用set或者map、dict这种方式记录当前子串的内容，用于判断是否有没有出现重复字符，优化的时候减少无用的遍历</p><hr><!-- rebuild by neat -->"},{"title":"LeetCode-011-Container With Most Water","urlname":"leetcode-container-with-most-water","comments":1,"mathjax":false,"date":"2019-04-30T01:28:09.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/container-with-most-water/)   \nGiven n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\n**Note**: You may not slant the container and n is at least 2.\n{% asset_img 011.png %}\n\n### Examples:\n**Input:** [1,8,6,2,5,4,8,3,7]\n**Output:** 49\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 第一种方法就是暴力法，遍历每种情况，是$$ O(n^2) $$复杂度，找到这里面的最大容量的情况，尝试了会超时，所以只能尽量优化到$$ O(n) $$，于是有了下一种方法\n- 第二种方法是用两个指针，初始情况是一个指向最开头，一个指向结尾，此时的宽度是最大的，然后比较当前两个指针所在位置的高度，低的一方向里面移动，移动会导致宽度减小，所以只能高度低的一边向内移，可能会有更高的。时间复杂度是$$ O(n) $$\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        if(height.size() <= 1) return -1;\n        int i = 0, j = height.size() - 1, res = 0;\n        while(i < j){\n            res = max(res, min(height[i], height[j]) * (j - i));\n            height[i] < height[j] ? i++ : j--;\n        }\n        return res;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n        if len(height) <= 1:\n            return -1\n        i = res = 0\n        j = len(height) - 1\n        while i < j:\n            res = max(res, min(height[i], height[j]) * (j - i))\n            if height[i]<height[j]:\n                i += 1\n            else:\n                j -= 1\n        return res\n```\n\n## 总结\n- 这道题思维上很简单，就是找到最大面积的两个值，但是如果简单的暴力法，中等难度的题目很明显没这么无脑，所以直接就超时了\n- 之前做过的题目里也用到过两个指针遍历的方法，这样的$$ O(n) $$复杂度还是很快的\n\n\n------\n","source":"_posts/LeetCode/LeetCode-011-Container-With-Most-Water.md","raw":"---\ntitle: LeetCode-011-Container With Most Water\ntags:\n  - LeetCode\n  - Algorithm\n  - Math\n  - Medium\n  - Pointer\ncategories:\n  - LeetCode\nurlname: leetcode-container-with-most-water\ncomments: true\nmathjax: false\ndate: 2019-04-30 09:28:09\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/container-with-most-water/)   \nGiven n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\n**Note**: You may not slant the container and n is at least 2.\n{% asset_img 011.png %}\n\n### Examples:\n**Input:** [1,8,6,2,5,4,8,3,7]\n**Output:** 49\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 第一种方法就是暴力法，遍历每种情况，是$$ O(n^2) $$复杂度，找到这里面的最大容量的情况，尝试了会超时，所以只能尽量优化到$$ O(n) $$，于是有了下一种方法\n- 第二种方法是用两个指针，初始情况是一个指向最开头，一个指向结尾，此时的宽度是最大的，然后比较当前两个指针所在位置的高度，低的一方向里面移动，移动会导致宽度减小，所以只能高度低的一边向内移，可能会有更高的。时间复杂度是$$ O(n) $$\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        if(height.size() <= 1) return -1;\n        int i = 0, j = height.size() - 1, res = 0;\n        while(i < j){\n            res = max(res, min(height[i], height[j]) * (j - i));\n            height[i] < height[j] ? i++ : j--;\n        }\n        return res;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n        if len(height) <= 1:\n            return -1\n        i = res = 0\n        j = len(height) - 1\n        while i < j:\n            res = max(res, min(height[i], height[j]) * (j - i))\n            if height[i]<height[j]:\n                i += 1\n            else:\n                j -= 1\n        return res\n```\n\n## 总结\n- 这道题思维上很简单，就是找到最大面积的两个值，但是如果简单的暴力法，中等难度的题目很明显没这么无脑，所以直接就超时了\n- 之前做过的题目里也用到过两个指针遍历的方法，这样的$$ O(n) $$复杂度还是很快的\n\n\n------\n","slug":"LeetCode/LeetCode-011-Container-With-Most-Water","published":1,"updated":"2019-07-25T17:56:52.015Z","layout":"post","photos":[],"link":"","_id":"ck2424ltc005mlksb6t2uhjkk","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/container-with-most-water/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p><strong>Note</strong>: You may not slant the container and n is at least 2.<br><img src=\"/LeetCode/2019-04-30-leetcode-container-with-most-water/011.png\"></p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> [1,8,6,2,5,4,8,3,7]<br><strong>Output:</strong> 49</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>第一种方法就是暴力法，遍历每种情况，是<script type=\"math/tex\">O(n^2)</script>复杂度，找到这里面的最大容量的情况，尝试了会超时，所以只能尽量优化到<script type=\"math/tex\">O(n)</script>，于是有了下一种方法</li><li>第二种方法是用两个指针，初始情况是一个指向最开头，一个指向结尾，此时的宽度是最大的，然后比较当前两个指针所在位置的高度，低的一方向里面移动，移动会导致宽度减小，所以只能高度低的一边向内移，可能会有更高的。时间复杂度是<script type=\"math/tex\">O(n)</script></li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(height.size() &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = height.size() - <span class=\"number\">1</span>, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j)&#123;</span><br><span class=\"line\">            res = max(res, min(height[i], height[j]) * (j - i));</span><br><span class=\"line\">            height[i] &lt; height[j] ? i++ : j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxArea</span><span class=\"params\">(self, height: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(height) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        i = res = <span class=\"number\">0</span></span><br><span class=\"line\">        j = len(height) - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; j:</span><br><span class=\"line\">            res = max(res, min(height[i], height[j]) * (j - i))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> height[i]&lt;height[j]:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                j -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>这道题思维上很简单，就是找到最大面积的两个值，但是如果简单的暴力法，中等难度的题目很明显没这么无脑，所以直接就超时了</li><li>之前做过的题目里也用到过两个指针遍历的方法，这样的<script type=\"math/tex\">O(n)</script>复杂度还是很快的</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/container-with-most-water/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p><strong>Note</strong>: You may not slant the container and n is at least 2.<br><img src=\"/LeetCode/2019-04-30-leetcode-container-with-most-water/011.png\"></p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> [1,8,6,2,5,4,8,3,7]<br><strong>Output:</strong> 49</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>第一种方法就是暴力法，遍历每种情况，是<script type=\"math/tex\">O(n^2)</script>复杂度，找到这里面的最大容量的情况，尝试了会超时，所以只能尽量优化到<script type=\"math/tex\">O(n)</script>，于是有了下一种方法</li><li>第二种方法是用两个指针，初始情况是一个指向最开头，一个指向结尾，此时的宽度是最大的，然后比较当前两个指针所在位置的高度，低的一方向里面移动，移动会导致宽度减小，所以只能高度低的一边向内移，可能会有更高的。时间复杂度是<script type=\"math/tex\">O(n)</script></li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(height.size() &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = height.size() - <span class=\"number\">1</span>, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j)&#123;</span><br><span class=\"line\">            res = max(res, min(height[i], height[j]) * (j - i));</span><br><span class=\"line\">            height[i] &lt; height[j] ? i++ : j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxArea</span><span class=\"params\">(self, height: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(height) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        i = res = <span class=\"number\">0</span></span><br><span class=\"line\">        j = len(height) - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; j:</span><br><span class=\"line\">            res = max(res, min(height[i], height[j]) * (j - i))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> height[i]&lt;height[j]:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                j -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>这道题思维上很简单，就是找到最大面积的两个值，但是如果简单的暴力法，中等难度的题目很明显没这么无脑，所以直接就超时了</li><li>之前做过的题目里也用到过两个指针遍历的方法，这样的<script type=\"math/tex\">O(n)</script>复杂度还是很快的</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-012-Integer to Roman","urlname":"leetcode-integer-to-roman","comments":1,"mathjax":false,"date":"2019-04-30T01:28:41.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/integer-to-roman/)   \nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n> Symbol　　　Value\n> I　　　　　　1\n> V　　　　　　5\n> X　　　　　　10\n> L　　　　　　50\n> C　　　　　　100\n> D　　　　　　500\n> M　　　　　　1000\n\nFor example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n- I can be placed before V (5) and X (10) to make 4 and 9. \n- X can be placed before L (50) and C (100) to make 40 and 90. \n- C can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n\n### Examples:\n**Input:** 3\n**Output:** \"III\"\n**Input:** 4\n**Output:** \"IV\"\n**Input:** 58\n**Output:** \"LVIII\"\n**Input:** 1994\n**Output:** \"MCMXCIV\"\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 这题，题目比较长，可能容易晕，但是很好理解，就是把一个整数转成罗马数字，给出了每个字符表示的大小\n- 简单的办法就是从最大值开始，整除得到这个字母的个数，求模得到剩余的数字，然后再次对较小的整除、求模一直到“I”，就是1为止，过程中把字符加到结果字符串上\n- 这里由于有对应关系，所以C++中用两个数组表示对应关系，也可以用map<string,int>表示，Python直接用字典就可以\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        int values[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        string chr[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n        \n        string res;\n        for(int i=0; i<13; i++){\n            for(int j=0;j<num/values[i];j++)\n                res += chr[i];\n            num %= values[i];\n        }\n        return res;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        values = {\"M\":1000,\"CM\":900,\"D\":500,\"CD\":400,\"C\":100,\"XC\":90,\"L\":50,\"XL\":40,\"X\":10,\"IX\":9,\"V\":5,\"IV\":4,\"I\":1}\n        res = \"\"\n        for key,value in values.items():\n            for i in range(num//value):\n                res += key\n            num %= value                \n        return res;\n```\n\n## 总结\n- 有对应关系的时候，没必要写很多重复代码，用map或者两个列表对应起来，遍历一遍就可以 \n\n\n------\n","source":"_posts/LeetCode/LeetCode-012-Integer-to-Roman.md","raw":"---\ntitle: LeetCode-012-Integer to Roman\ntags:\n  - LeetCode\n  - Algorithm\n  - Map\n  - Integer\n  - String\n  - Medium\ncategories:\n  - LeetCode\nurlname: leetcode-integer-to-roman\ncomments: true\nmathjax: false\ndate: 2019-04-30 09:28:41\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/integer-to-roman/)   \nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n> Symbol　　　Value\n> I　　　　　　1\n> V　　　　　　5\n> X　　　　　　10\n> L　　　　　　50\n> C　　　　　　100\n> D　　　　　　500\n> M　　　　　　1000\n\nFor example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n- I can be placed before V (5) and X (10) to make 4 and 9. \n- X can be placed before L (50) and C (100) to make 40 and 90. \n- C can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n\n### Examples:\n**Input:** 3\n**Output:** \"III\"\n**Input:** 4\n**Output:** \"IV\"\n**Input:** 58\n**Output:** \"LVIII\"\n**Input:** 1994\n**Output:** \"MCMXCIV\"\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 这题，题目比较长，可能容易晕，但是很好理解，就是把一个整数转成罗马数字，给出了每个字符表示的大小\n- 简单的办法就是从最大值开始，整除得到这个字母的个数，求模得到剩余的数字，然后再次对较小的整除、求模一直到“I”，就是1为止，过程中把字符加到结果字符串上\n- 这里由于有对应关系，所以C++中用两个数组表示对应关系，也可以用map<string,int>表示，Python直接用字典就可以\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        int values[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        string chr[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n        \n        string res;\n        for(int i=0; i<13; i++){\n            for(int j=0;j<num/values[i];j++)\n                res += chr[i];\n            num %= values[i];\n        }\n        return res;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        values = {\"M\":1000,\"CM\":900,\"D\":500,\"CD\":400,\"C\":100,\"XC\":90,\"L\":50,\"XL\":40,\"X\":10,\"IX\":9,\"V\":5,\"IV\":4,\"I\":1}\n        res = \"\"\n        for key,value in values.items():\n            for i in range(num//value):\n                res += key\n            num %= value                \n        return res;\n```\n\n## 总结\n- 有对应关系的时候，没必要写很多重复代码，用map或者两个列表对应起来，遍历一遍就可以 \n\n\n------\n","slug":"LeetCode/LeetCode-012-Integer-to-Roman","published":1,"updated":"2019-07-25T17:57:07.982Z","layout":"post","photos":[],"link":"","_id":"ck2424ltd005qlksb9zqqb9sj","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/integer-to-roman/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><blockquote><p>Symbol　　　Value<br>I　　　　　　1<br>V　　　　　　5<br>X　　　　　　10<br>L　　　　　　50<br>C　　　　　　100<br>D　　　　　　500<br>M　　　　　　1000</p></blockquote><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9.</li><li>X can be placed before L (50) and C (100) to make 40 and 90.</li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul><p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> 3<br><strong>Output:</strong> “III”<br><strong>Input:</strong> 4<br><strong>Output:</strong> “IV”<br><strong>Input:</strong> 58<br><strong>Output:</strong> “LVIII”<br><strong>Input:</strong> 1994<br><strong>Output:</strong> “MCMXCIV”</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>这题，题目比较长，可能容易晕，但是很好理解，就是把一个整数转成罗马数字，给出了每个字符表示的大小</li><li>简单的办法就是从最大值开始，整除得到这个字母的个数，求模得到剩余的数字，然后再次对较小的整除、求模一直到“I”，就是1为止，过程中把字符加到结果字符串上</li><li>这里由于有对应关系，所以C++中用两个数组表示对应关系，也可以用map<string ,int=\"\">表示，Python直接用字典就可以</string></li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">intToRoman</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> values[]=&#123;<span class=\"number\">1000</span>,<span class=\"number\">900</span>,<span class=\"number\">500</span>,<span class=\"number\">400</span>,<span class=\"number\">100</span>,<span class=\"number\">90</span>,<span class=\"number\">50</span>,<span class=\"number\">40</span>,<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> chr[]=&#123;<span class=\"string\">\"M\"</span>,<span class=\"string\">\"CM\"</span>,<span class=\"string\">\"D\"</span>,<span class=\"string\">\"CD\"</span>,<span class=\"string\">\"C\"</span>,<span class=\"string\">\"XC\"</span>,<span class=\"string\">\"L\"</span>,<span class=\"string\">\"XL\"</span>,<span class=\"string\">\"X\"</span>,<span class=\"string\">\"IX\"</span>,<span class=\"string\">\"V\"</span>,<span class=\"string\">\"IV\"</span>,<span class=\"string\">\"I\"</span>&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">13</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;num/values[i];j++)</span><br><span class=\"line\">                res += chr[i];</span><br><span class=\"line\">            num %= values[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intToRoman</span><span class=\"params\">(self, num: int)</span> -&gt; str:</span></span><br><span class=\"line\">        values = &#123;<span class=\"string\">\"M\"</span>:<span class=\"number\">1000</span>,<span class=\"string\">\"CM\"</span>:<span class=\"number\">900</span>,<span class=\"string\">\"D\"</span>:<span class=\"number\">500</span>,<span class=\"string\">\"CD\"</span>:<span class=\"number\">400</span>,<span class=\"string\">\"C\"</span>:<span class=\"number\">100</span>,<span class=\"string\">\"XC\"</span>:<span class=\"number\">90</span>,<span class=\"string\">\"L\"</span>:<span class=\"number\">50</span>,<span class=\"string\">\"XL\"</span>:<span class=\"number\">40</span>,<span class=\"string\">\"X\"</span>:<span class=\"number\">10</span>,<span class=\"string\">\"IX\"</span>:<span class=\"number\">9</span>,<span class=\"string\">\"V\"</span>:<span class=\"number\">5</span>,<span class=\"string\">\"IV\"</span>:<span class=\"number\">4</span>,<span class=\"string\">\"I\"</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">        res = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> key,value <span class=\"keyword\">in</span> values.items():</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(num//value):</span><br><span class=\"line\">                res += key</span><br><span class=\"line\">            num %= value                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>有对应关系的时候，没必要写很多重复代码，用map或者两个列表对应起来，遍历一遍就可以</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/integer-to-roman/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><blockquote><p>Symbol　　　Value<br>I　　　　　　1<br>V　　　　　　5<br>X　　　　　　10<br>L　　　　　　50<br>C　　　　　　100<br>D　　　　　　500<br>M　　　　　　1000</p></blockquote><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9.</li><li>X can be placed before L (50) and C (100) to make 40 and 90.</li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul><p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> 3<br><strong>Output:</strong> “III”<br><strong>Input:</strong> 4<br><strong>Output:</strong> “IV”<br><strong>Input:</strong> 58<br><strong>Output:</strong> “LVIII”<br><strong>Input:</strong> 1994<br><strong>Output:</strong> “MCMXCIV”</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>这题，题目比较长，可能容易晕，但是很好理解，就是把一个整数转成罗马数字，给出了每个字符表示的大小</li><li>简单的办法就是从最大值开始，整除得到这个字母的个数，求模得到剩余的数字，然后再次对较小的整除、求模一直到“I”，就是1为止，过程中把字符加到结果字符串上</li><li>这里由于有对应关系，所以C++中用两个数组表示对应关系，也可以用map<string ,int=\"\">表示，Python直接用字典就可以</string></li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">intToRoman</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> values[]=&#123;<span class=\"number\">1000</span>,<span class=\"number\">900</span>,<span class=\"number\">500</span>,<span class=\"number\">400</span>,<span class=\"number\">100</span>,<span class=\"number\">90</span>,<span class=\"number\">50</span>,<span class=\"number\">40</span>,<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> chr[]=&#123;<span class=\"string\">\"M\"</span>,<span class=\"string\">\"CM\"</span>,<span class=\"string\">\"D\"</span>,<span class=\"string\">\"CD\"</span>,<span class=\"string\">\"C\"</span>,<span class=\"string\">\"XC\"</span>,<span class=\"string\">\"L\"</span>,<span class=\"string\">\"XL\"</span>,<span class=\"string\">\"X\"</span>,<span class=\"string\">\"IX\"</span>,<span class=\"string\">\"V\"</span>,<span class=\"string\">\"IV\"</span>,<span class=\"string\">\"I\"</span>&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">13</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;num/values[i];j++)</span><br><span class=\"line\">                res += chr[i];</span><br><span class=\"line\">            num %= values[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intToRoman</span><span class=\"params\">(self, num: int)</span> -&gt; str:</span></span><br><span class=\"line\">        values = &#123;<span class=\"string\">\"M\"</span>:<span class=\"number\">1000</span>,<span class=\"string\">\"CM\"</span>:<span class=\"number\">900</span>,<span class=\"string\">\"D\"</span>:<span class=\"number\">500</span>,<span class=\"string\">\"CD\"</span>:<span class=\"number\">400</span>,<span class=\"string\">\"C\"</span>:<span class=\"number\">100</span>,<span class=\"string\">\"XC\"</span>:<span class=\"number\">90</span>,<span class=\"string\">\"L\"</span>:<span class=\"number\">50</span>,<span class=\"string\">\"XL\"</span>:<span class=\"number\">40</span>,<span class=\"string\">\"X\"</span>:<span class=\"number\">10</span>,<span class=\"string\">\"IX\"</span>:<span class=\"number\">9</span>,<span class=\"string\">\"V\"</span>:<span class=\"number\">5</span>,<span class=\"string\">\"IV\"</span>:<span class=\"number\">4</span>,<span class=\"string\">\"I\"</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">        res = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> key,value <span class=\"keyword\">in</span> values.items():</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(num//value):</span><br><span class=\"line\">                res += key</span><br><span class=\"line\">            num %= value                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>有对应关系的时候，没必要写很多重复代码，用map或者两个列表对应起来，遍历一遍就可以</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-004-Median of Two Sorted Arrays","urlname":"leetcode-median-of-two-sorted-arrays","comments":1,"mathjax":false,"date":"2019-04-13T17:48:43.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/median-of-two-sorted-arrays/)   \nThere are two sorted arrays nums1 and nums2 of size m and n respectively.\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\nYou may assume nums1 and nums2 cannot be both empty\n### Examples:\n> a = [1, 3], b = [2] ---> 2.0\n> a = [1, 2], b = [3, 4] ---> 2.5\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 刚开始是一点思路都么得...如果没有O(log (m+n))的限制，还能用遍历的方法找到，但是加了log，应该是要用二叉的\n- 题解里面给出了将两个数组，以i，j为分界，分为两部分:[0,i-1], [i,m-1], [0, j-1], [j,n-1]，使得左边的[0,i-1], [0,j-1] 全都小于右边的[i,m-1], [j,n-1]，利用中位数的意义\n- 前提要**确保m<=n**，这很重要！刚开始就弄反了导致一直找不到bug..\n- 同时配合二叉搜索，这时搜索的条件就变成了：如果左边的有大于右边的数，就缩小，如果右边的有小于左边的数，就扩大\n- 这里需要判断几个边界条件：i=0, j=0, i=m, j=n这四种\n\n\n## C++ Codes\n用时是36ms, 内存9.6MB\n\n```C++\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m=nums1.size();\n        int n=nums2.size();\n        if(m>n){    //确保m<=n,不然会造成j可能是负数\n            nums1.swap(nums2);\n            int tmp=m; m=n; n=tmp;\n        }\n        \n        int imin=0,imax=m,half=(m+n+1)/2;\n        while(imin<=imax){\n            int i=(imin+imax)/2;\n            int j=half - i;\n            int maxLeft = 0, minRight=0;\n            \n            if(i<imax && nums2[j-1]>nums1[i]){  //i太小\n                imin = i+1;\n            } else if(i>imin && nums1[i-1]>nums2[j]){   //i太大\n                imax=i-1;\n            } else{\n                //maxleft = max(nums1[i-1],nums2[j-1]), i, j可能是0, i-1就可能为-1\n                if(i==0){ maxLeft=nums2[j-1];}\n                else if(j==0){ maxLeft = nums1[i-1];}\n                else { maxLeft = nums1[i-1]>nums2[j-1]?nums1[i-1]:nums2[j-1];}\n                \n                //如果是奇数个\n                if((m+n)%2){ return maxLeft;}\n                \n                //maxRight = max(nums1[i], nums2[j]), i, j可能是m和n，nums1[i]就会越界\n                if(i==m){ minRight=nums2[j];}\n                else if(j==n){ minRight = nums1[i];}\n                else { minRight=nums1[i]<nums2[j]?nums1[i]:nums2[j];}\n                \n                return (minRight+maxLeft)/2.0;\n            }\n        }\n        return 0;\n    }\n};\n\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        m = len(nums1)\n        n = len(nums2)\n        if(m>n):\n            nums1,nums2,m,n = nums2,nums1,n,m\n    \n        # 整除\n        imin, imax, half = 0, m, (m+n+1)//2\n        while imin<=imax:\n            i = (imin+imax)//2;\n            j = half - i;\n            maxLeft = 0\n            minRight = 0\n            print(i,j)\n            if i<m and nums2[j-1]>nums1[i]:\n                imin = i+1\n            elif i>0 and nums1[i-1]>nums2[j]:\n                imax = i-1\n            else :\n                if i==0: maxLeft = nums2[j-1]\n                elif j==0: maxLeft = nums1[i-1]\n                else:\n                    maxLeft = max(nums2[j-1],nums1[i-1])\n                \n                if (m+n)%2==1: return maxLeft\n                \n                if i==m: minRight = nums2[j]\n                elif j==n: minRight = nums1[i]\n                else :\n                    minRight = min(nums1[i],nums2[j])\n                    \n                return (minRight+maxLeft)/2\n```\n\n## 总结\n- 对用到中位数的题目可以想想中位数的意义，搜索那个分界点，可以直接遍历分界点也可以二叉找，看时间复杂度。\n- 要注意前提是m<=n，不然会出错\n- 注意搜索时候变化条件，还有几个边界情况注意判断\n- while循环的条件这里是imin<=imax，等于的时候就是到叶子节点了\n- python这里居然只能用双斜线整除\n\n------\n","source":"_posts/LeetCode/LeetCode-004-Median-of-Two-Sorted-Arrays.md","raw":"---\ntitle: LeetCode-004-Median of Two Sorted Arrays\ntags:\n  - LeetCode\n  - Algorithm\n  - Math\n  - Binary Search\n  - Array\n  - Hard\ncategories:\n  - LeetCode\nurlname: leetcode-median-of-two-sorted-arrays\ncomments: true\nmathjax: false\ndate: 2019-04-14 01:48:43\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/median-of-two-sorted-arrays/)   \nThere are two sorted arrays nums1 and nums2 of size m and n respectively.\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\nYou may assume nums1 and nums2 cannot be both empty\n### Examples:\n> a = [1, 3], b = [2] ---> 2.0\n> a = [1, 2], b = [3, 4] ---> 2.5\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 刚开始是一点思路都么得...如果没有O(log (m+n))的限制，还能用遍历的方法找到，但是加了log，应该是要用二叉的\n- 题解里面给出了将两个数组，以i，j为分界，分为两部分:[0,i-1], [i,m-1], [0, j-1], [j,n-1]，使得左边的[0,i-1], [0,j-1] 全都小于右边的[i,m-1], [j,n-1]，利用中位数的意义\n- 前提要**确保m<=n**，这很重要！刚开始就弄反了导致一直找不到bug..\n- 同时配合二叉搜索，这时搜索的条件就变成了：如果左边的有大于右边的数，就缩小，如果右边的有小于左边的数，就扩大\n- 这里需要判断几个边界条件：i=0, j=0, i=m, j=n这四种\n\n\n## C++ Codes\n用时是36ms, 内存9.6MB\n\n```C++\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m=nums1.size();\n        int n=nums2.size();\n        if(m>n){    //确保m<=n,不然会造成j可能是负数\n            nums1.swap(nums2);\n            int tmp=m; m=n; n=tmp;\n        }\n        \n        int imin=0,imax=m,half=(m+n+1)/2;\n        while(imin<=imax){\n            int i=(imin+imax)/2;\n            int j=half - i;\n            int maxLeft = 0, minRight=0;\n            \n            if(i<imax && nums2[j-1]>nums1[i]){  //i太小\n                imin = i+1;\n            } else if(i>imin && nums1[i-1]>nums2[j]){   //i太大\n                imax=i-1;\n            } else{\n                //maxleft = max(nums1[i-1],nums2[j-1]), i, j可能是0, i-1就可能为-1\n                if(i==0){ maxLeft=nums2[j-1];}\n                else if(j==0){ maxLeft = nums1[i-1];}\n                else { maxLeft = nums1[i-1]>nums2[j-1]?nums1[i-1]:nums2[j-1];}\n                \n                //如果是奇数个\n                if((m+n)%2){ return maxLeft;}\n                \n                //maxRight = max(nums1[i], nums2[j]), i, j可能是m和n，nums1[i]就会越界\n                if(i==m){ minRight=nums2[j];}\n                else if(j==n){ minRight = nums1[i];}\n                else { minRight=nums1[i]<nums2[j]?nums1[i]:nums2[j];}\n                \n                return (minRight+maxLeft)/2.0;\n            }\n        }\n        return 0;\n    }\n};\n\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        m = len(nums1)\n        n = len(nums2)\n        if(m>n):\n            nums1,nums2,m,n = nums2,nums1,n,m\n    \n        # 整除\n        imin, imax, half = 0, m, (m+n+1)//2\n        while imin<=imax:\n            i = (imin+imax)//2;\n            j = half - i;\n            maxLeft = 0\n            minRight = 0\n            print(i,j)\n            if i<m and nums2[j-1]>nums1[i]:\n                imin = i+1\n            elif i>0 and nums1[i-1]>nums2[j]:\n                imax = i-1\n            else :\n                if i==0: maxLeft = nums2[j-1]\n                elif j==0: maxLeft = nums1[i-1]\n                else:\n                    maxLeft = max(nums2[j-1],nums1[i-1])\n                \n                if (m+n)%2==1: return maxLeft\n                \n                if i==m: minRight = nums2[j]\n                elif j==n: minRight = nums1[i]\n                else :\n                    minRight = min(nums1[i],nums2[j])\n                    \n                return (minRight+maxLeft)/2\n```\n\n## 总结\n- 对用到中位数的题目可以想想中位数的意义，搜索那个分界点，可以直接遍历分界点也可以二叉找，看时间复杂度。\n- 要注意前提是m<=n，不然会出错\n- 注意搜索时候变化条件，还有几个边界情况注意判断\n- while循环的条件这里是imin<=imax，等于的时候就是到叶子节点了\n- python这里居然只能用双斜线整除\n\n------\n","slug":"LeetCode/LeetCode-004-Median-of-Two-Sorted-Arrays","published":1,"updated":"2019-07-25T17:53:27.089Z","layout":"post","photos":[],"link":"","_id":"ck2424ltf005tlksb97jo22xc","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/median-of-two-sorted-arrays/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.<br>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br>You may assume nums1 and nums2 cannot be both empty</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><blockquote><p>a = [1, 3], b = [2] —-&gt; 2.0<br>a = [1, 2], b = [3, 4] —-&gt; 2.5</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>刚开始是一点思路都么得…如果没有O(log (m+n))的限制，还能用遍历的方法找到，但是加了log，应该是要用二叉的</li><li>题解里面给出了将两个数组，以i，j为分界，分为两部分:[0,i-1], [i,m-1], [0, j-1], [j,n-1]，使得左边的[0,i-1], [0,j-1] 全都小于右边的[i,m-1], [j,n-1]，利用中位数的意义</li><li>前提要<strong>确保m&lt;=n</strong>，这很重要！刚开始就弄反了导致一直找不到bug..</li><li>同时配合二叉搜索，这时搜索的条件就变成了：如果左边的有大于右边的数，就缩小，如果右边的有小于左边的数，就扩大</li><li>这里需要判断几个边界条件：i=0, j=0, i=m, j=n这四种</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>用时是36ms, 内存9.6MB</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m=nums1.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n=nums2.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m&gt;n)&#123;    <span class=\"comment\">//确保m&lt;=n,不然会造成j可能是负数</span></span><br><span class=\"line\">            nums1.swap(nums2);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp=m; m=n; n=tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> imin=<span class=\"number\">0</span>,imax=m,half=(m+n+<span class=\"number\">1</span>)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(imin&lt;=imax)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i=(imin+imax)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j=half - i;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxLeft = <span class=\"number\">0</span>, minRight=<span class=\"number\">0</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&lt;imax &amp;&amp; nums2[j<span class=\"number\">-1</span>]&gt;nums1[i])&#123;  <span class=\"comment\">//i太小</span></span><br><span class=\"line\">                imin = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i&gt;imin &amp;&amp; nums1[i<span class=\"number\">-1</span>]&gt;nums2[j])&#123;   <span class=\"comment\">//i太大</span></span><br><span class=\"line\">                imax=i<span class=\"number\">-1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//maxleft = max(nums1[i-1],nums2[j-1]), i, j可能是0, i-1就可能为-1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>)&#123; maxLeft=nums2[j<span class=\"number\">-1</span>];&#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j==<span class=\"number\">0</span>)&#123; maxLeft = nums1[i<span class=\"number\">-1</span>];&#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; maxLeft = nums1[i<span class=\"number\">-1</span>]&gt;nums2[j<span class=\"number\">-1</span>]?nums1[i<span class=\"number\">-1</span>]:nums2[j<span class=\"number\">-1</span>];&#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//如果是奇数个</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>((m+n)%<span class=\"number\">2</span>)&#123; <span class=\"keyword\">return</span> maxLeft;&#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//maxRight = max(nums1[i], nums2[j]), i, j可能是m和n，nums1[i]就会越界</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i==m)&#123; minRight=nums2[j];&#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j==n)&#123; minRight = nums1[i];&#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; minRight=nums1[i]&lt;nums2[j]?nums1[i]:nums2[j];&#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">return</span> (minRight+maxLeft)/<span class=\"number\">2.0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class=\"line\">        m = len(nums1)</span><br><span class=\"line\">        n = len(nums2)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m&gt;n):</span><br><span class=\"line\">            nums1,nums2,m,n = nums2,nums1,n,m</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\"># 整除</span></span><br><span class=\"line\">        imin, imax, half = <span class=\"number\">0</span>, m, (m+n+<span class=\"number\">1</span>)//<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> imin&lt;=imax:</span><br><span class=\"line\">            i = (imin+imax)//<span class=\"number\">2</span>;</span><br><span class=\"line\">            j = half - i;</span><br><span class=\"line\">            maxLeft = <span class=\"number\">0</span></span><br><span class=\"line\">            minRight = <span class=\"number\">0</span></span><br><span class=\"line\">            print(i,j)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i&lt;m <span class=\"keyword\">and</span> nums2[j<span class=\"number\">-1</span>]&gt;nums1[i]:</span><br><span class=\"line\">                imin = i+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> i&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> nums1[i<span class=\"number\">-1</span>]&gt;nums2[j]:</span><br><span class=\"line\">                imax = i<span class=\"number\">-1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> :</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i==<span class=\"number\">0</span>: maxLeft = nums2[j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j==<span class=\"number\">0</span>: maxLeft = nums1[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    maxLeft = max(nums2[j<span class=\"number\">-1</span>],nums1[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m+n)%<span class=\"number\">2</span>==<span class=\"number\">1</span>: <span class=\"keyword\">return</span> maxLeft</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> i==m: minRight = nums2[j]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j==n: minRight = nums1[i]</span><br><span class=\"line\">                <span class=\"keyword\">else</span> :</span><br><span class=\"line\">                    minRight = min(nums1[i],nums2[j])</span><br><span class=\"line\">                    </span><br><span class=\"line\">                <span class=\"keyword\">return</span> (minRight+maxLeft)/<span class=\"number\">2</span></span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>对用到中位数的题目可以想想中位数的意义，搜索那个分界点，可以直接遍历分界点也可以二叉找，看时间复杂度。</li><li>要注意前提是m&lt;=n，不然会出错</li><li>注意搜索时候变化条件，还有几个边界情况注意判断</li><li>while循环的条件这里是imin&lt;=imax，等于的时候就是到叶子节点了</li><li>python这里居然只能用双斜线整除</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/median-of-two-sorted-arrays/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.<br>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br>You may assume nums1 and nums2 cannot be both empty</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><blockquote><p>a = [1, 3], b = [2] —-&gt; 2.0<br>a = [1, 2], b = [3, 4] —-&gt; 2.5</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>刚开始是一点思路都么得…如果没有O(log (m+n))的限制，还能用遍历的方法找到，但是加了log，应该是要用二叉的</li><li>题解里面给出了将两个数组，以i，j为分界，分为两部分:[0,i-1], [i,m-1], [0, j-1], [j,n-1]，使得左边的[0,i-1], [0,j-1] 全都小于右边的[i,m-1], [j,n-1]，利用中位数的意义</li><li>前提要<strong>确保m&lt;=n</strong>，这很重要！刚开始就弄反了导致一直找不到bug..</li><li>同时配合二叉搜索，这时搜索的条件就变成了：如果左边的有大于右边的数，就缩小，如果右边的有小于左边的数，就扩大</li><li>这里需要判断几个边界条件：i=0, j=0, i=m, j=n这四种</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>用时是36ms, 内存9.6MB</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m=nums1.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n=nums2.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m&gt;n)&#123;    <span class=\"comment\">//确保m&lt;=n,不然会造成j可能是负数</span></span><br><span class=\"line\">            nums1.swap(nums2);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp=m; m=n; n=tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> imin=<span class=\"number\">0</span>,imax=m,half=(m+n+<span class=\"number\">1</span>)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(imin&lt;=imax)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i=(imin+imax)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j=half - i;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxLeft = <span class=\"number\">0</span>, minRight=<span class=\"number\">0</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&lt;imax &amp;&amp; nums2[j<span class=\"number\">-1</span>]&gt;nums1[i])&#123;  <span class=\"comment\">//i太小</span></span><br><span class=\"line\">                imin = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i&gt;imin &amp;&amp; nums1[i<span class=\"number\">-1</span>]&gt;nums2[j])&#123;   <span class=\"comment\">//i太大</span></span><br><span class=\"line\">                imax=i<span class=\"number\">-1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//maxleft = max(nums1[i-1],nums2[j-1]), i, j可能是0, i-1就可能为-1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>)&#123; maxLeft=nums2[j<span class=\"number\">-1</span>];&#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j==<span class=\"number\">0</span>)&#123; maxLeft = nums1[i<span class=\"number\">-1</span>];&#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; maxLeft = nums1[i<span class=\"number\">-1</span>]&gt;nums2[j<span class=\"number\">-1</span>]?nums1[i<span class=\"number\">-1</span>]:nums2[j<span class=\"number\">-1</span>];&#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//如果是奇数个</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>((m+n)%<span class=\"number\">2</span>)&#123; <span class=\"keyword\">return</span> maxLeft;&#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//maxRight = max(nums1[i], nums2[j]), i, j可能是m和n，nums1[i]就会越界</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i==m)&#123; minRight=nums2[j];&#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j==n)&#123; minRight = nums1[i];&#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; minRight=nums1[i]&lt;nums2[j]?nums1[i]:nums2[j];&#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">return</span> (minRight+maxLeft)/<span class=\"number\">2.0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class=\"line\">        m = len(nums1)</span><br><span class=\"line\">        n = len(nums2)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m&gt;n):</span><br><span class=\"line\">            nums1,nums2,m,n = nums2,nums1,n,m</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\"># 整除</span></span><br><span class=\"line\">        imin, imax, half = <span class=\"number\">0</span>, m, (m+n+<span class=\"number\">1</span>)//<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> imin&lt;=imax:</span><br><span class=\"line\">            i = (imin+imax)//<span class=\"number\">2</span>;</span><br><span class=\"line\">            j = half - i;</span><br><span class=\"line\">            maxLeft = <span class=\"number\">0</span></span><br><span class=\"line\">            minRight = <span class=\"number\">0</span></span><br><span class=\"line\">            print(i,j)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i&lt;m <span class=\"keyword\">and</span> nums2[j<span class=\"number\">-1</span>]&gt;nums1[i]:</span><br><span class=\"line\">                imin = i+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> i&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> nums1[i<span class=\"number\">-1</span>]&gt;nums2[j]:</span><br><span class=\"line\">                imax = i<span class=\"number\">-1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> :</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i==<span class=\"number\">0</span>: maxLeft = nums2[j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j==<span class=\"number\">0</span>: maxLeft = nums1[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    maxLeft = max(nums2[j<span class=\"number\">-1</span>],nums1[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m+n)%<span class=\"number\">2</span>==<span class=\"number\">1</span>: <span class=\"keyword\">return</span> maxLeft</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> i==m: minRight = nums2[j]</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> j==n: minRight = nums1[i]</span><br><span class=\"line\">                <span class=\"keyword\">else</span> :</span><br><span class=\"line\">                    minRight = min(nums1[i],nums2[j])</span><br><span class=\"line\">                    </span><br><span class=\"line\">                <span class=\"keyword\">return</span> (minRight+maxLeft)/<span class=\"number\">2</span></span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>对用到中位数的题目可以想想中位数的意义，搜索那个分界点，可以直接遍历分界点也可以二叉找，看时间复杂度。</li><li>要注意前提是m&lt;=n，不然会出错</li><li>注意搜索时候变化条件，还有几个边界情况注意判断</li><li>while循环的条件这里是imin&lt;=imax，等于的时候就是到叶子节点了</li><li>python这里居然只能用双斜线整除</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-005-Longest Palindromic Substring","urlname":"leetcode-longest-palindromic-substring","comments":1,"mathjax":false,"date":"2019-04-14T13:22:07.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/longest-palindromic-substring/)   \nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n\n### Examples:\n> \"babad\" ---> \"bab\"\n> \"cbbd\" ---> \"bb\"\n{% endnote %}\n<!--more-->\n\n## Solutions\n- **暴力法**：首先想到的当然是暴力法...暴力大法好/斜眼笑\n- **遍历中心点暴力:**感觉直接暴力子串太幼稚，想了想可以遍历所有字串的中心点，于是产生了下面第一种解法，遍历每个下标，然后对子串是奇数个字符和偶数个字符分别查找最长子串，记录最长子串起始下标和长度，最后返回。时间复杂度是$$ O(n^2) $$\n- **动态规划: **看了题解，里面讲到了动态规划的解法，首先是有一个二维数组P[i, j]，用于保存i-j位置这段子串是不是回文，是就是true，不是就是false，初始化P中长度为1和2的子串，P[i-1, j+1]=True相当于：**P[i, j]==true && S[i-1]==S[j+1]**\n- **翻转字符串和原字符串比较：**:把字符串翻转，然后和原来的比较，找到最长的公共子串就是要的结果，这种方法有缺陷就是可能存在非回文子串的反向副本，改进的办法也很简单，就是比较找到的公共子串的索引是否和反向子串的原索引相同，不相同就可以排除了\n\n\n## C++ Codes\n遍历中心点法：用了32ms，8.8MB\n\n```C++\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int maxLen = 1;\n        int pos = 0;\n        int n = s.length();\n        for(int i=0;i<n;i++){\n            //判断子串为奇数个字符时\n            int tmp = 1;\n            while(i-tmp>=0 && i+tmp<n && s[i-tmp]==s[i+tmp]){\n                if((2*tmp+1)>maxLen){\n                    maxLen = 2*tmp+1;\n                    pos = i-tmp;\n                }\n                tmp++;\n            }\n            \n            //断子串为偶数个字符时\n            tmp = 1;\n            while(i-tmp+1>=0 && i+tmp<n && s[i-tmp+1]==s[i+tmp] ){\n                if(2*tmp>maxLen){\n                    maxLen = 2*tmp;\n                    pos = i-tmp+1;\n                }\n                tmp++;\n            }\n        }    \n\n        return s.substr(pos,maxLen);\n    }\n};\n```\n\n动态规划版本：用了140ms，13.1MB\n\n```C++\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int n = s.length();\n        if(n==0)return \"\";\n        \n        int p[n][n]={0};\n        int pos = 0;\n        int maxLen = 1;\n        \n        //初始化数组边界\n        for(int i=0;i<n-1;i++){\n            p[i][i]=1;\n            p[i][i+1]=s[i]==s[i+1]?1:0;\n            if(p[i][i+1]){\n                pos = i;\n                maxLen = 2;\n            }\n        }\n        p[n-1][n-1]=1;\n        \n        //动规循环\n        for(int i=2;i<n;i++){   //长度-1\n            for(int j=0;j+i<n;j++){   //起始下标\n                if( p[j+1][j+i-1]==1 && s[j]==s[j+i]){\n                    p[j][j+i]=1;\n                    if((i+1)>maxLen){\n                        maxLen = i+1;\n                        pos = j;\n                    }\n                }\n            }\n        }\n        return s.substr(pos,maxLen);\n    }\n};\n```\n\n## 总结\n- 算法题要注意边界问题，遍历的时候别下标越界\n- C++中数组要注意初始化，不会像java那样有默认值\n- 动态规划注意初始化边界\n- 暴力的时候注意子串长度还可以是偶数\n\n------\n","source":"_posts/LeetCode/LeetCode-005-Longest-Palindromic-Substring.md","raw":"---\ntitle: LeetCode-005-Longest Palindromic Substring\ntags:\n  - LeetCode\n  - Algorithm\n  - Medium\n  - Math\n  - String\n  - Palindromic\n  - DP\ncategories:\n  - LeetCode\nurlname: leetcode-longest-palindromic-substring\ncomments: true\nmathjax: false\ndate: 2019-04-14 21:22:07\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/longest-palindromic-substring/)   \nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n\n### Examples:\n> \"babad\" ---> \"bab\"\n> \"cbbd\" ---> \"bb\"\n{% endnote %}\n<!--more-->\n\n## Solutions\n- **暴力法**：首先想到的当然是暴力法...暴力大法好/斜眼笑\n- **遍历中心点暴力:**感觉直接暴力子串太幼稚，想了想可以遍历所有字串的中心点，于是产生了下面第一种解法，遍历每个下标，然后对子串是奇数个字符和偶数个字符分别查找最长子串，记录最长子串起始下标和长度，最后返回。时间复杂度是$$ O(n^2) $$\n- **动态规划: **看了题解，里面讲到了动态规划的解法，首先是有一个二维数组P[i, j]，用于保存i-j位置这段子串是不是回文，是就是true，不是就是false，初始化P中长度为1和2的子串，P[i-1, j+1]=True相当于：**P[i, j]==true && S[i-1]==S[j+1]**\n- **翻转字符串和原字符串比较：**:把字符串翻转，然后和原来的比较，找到最长的公共子串就是要的结果，这种方法有缺陷就是可能存在非回文子串的反向副本，改进的办法也很简单，就是比较找到的公共子串的索引是否和反向子串的原索引相同，不相同就可以排除了\n\n\n## C++ Codes\n遍历中心点法：用了32ms，8.8MB\n\n```C++\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int maxLen = 1;\n        int pos = 0;\n        int n = s.length();\n        for(int i=0;i<n;i++){\n            //判断子串为奇数个字符时\n            int tmp = 1;\n            while(i-tmp>=0 && i+tmp<n && s[i-tmp]==s[i+tmp]){\n                if((2*tmp+1)>maxLen){\n                    maxLen = 2*tmp+1;\n                    pos = i-tmp;\n                }\n                tmp++;\n            }\n            \n            //断子串为偶数个字符时\n            tmp = 1;\n            while(i-tmp+1>=0 && i+tmp<n && s[i-tmp+1]==s[i+tmp] ){\n                if(2*tmp>maxLen){\n                    maxLen = 2*tmp;\n                    pos = i-tmp+1;\n                }\n                tmp++;\n            }\n        }    \n\n        return s.substr(pos,maxLen);\n    }\n};\n```\n\n动态规划版本：用了140ms，13.1MB\n\n```C++\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int n = s.length();\n        if(n==0)return \"\";\n        \n        int p[n][n]={0};\n        int pos = 0;\n        int maxLen = 1;\n        \n        //初始化数组边界\n        for(int i=0;i<n-1;i++){\n            p[i][i]=1;\n            p[i][i+1]=s[i]==s[i+1]?1:0;\n            if(p[i][i+1]){\n                pos = i;\n                maxLen = 2;\n            }\n        }\n        p[n-1][n-1]=1;\n        \n        //动规循环\n        for(int i=2;i<n;i++){   //长度-1\n            for(int j=0;j+i<n;j++){   //起始下标\n                if( p[j+1][j+i-1]==1 && s[j]==s[j+i]){\n                    p[j][j+i]=1;\n                    if((i+1)>maxLen){\n                        maxLen = i+1;\n                        pos = j;\n                    }\n                }\n            }\n        }\n        return s.substr(pos,maxLen);\n    }\n};\n```\n\n## 总结\n- 算法题要注意边界问题，遍历的时候别下标越界\n- C++中数组要注意初始化，不会像java那样有默认值\n- 动态规划注意初始化边界\n- 暴力的时候注意子串长度还可以是偶数\n\n------\n","slug":"LeetCode/LeetCode-005-Longest-Palindromic-Substring","published":1,"updated":"2019-07-25T17:54:25.307Z","layout":"post","photos":[],"link":"","_id":"ck2424ltg005xlksbsvn1znr7","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/longest-palindromic-substring/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><blockquote><p>“babad” —-&gt; “bab”<br>“cbbd” —-&gt; “bb”</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li><strong>暴力法</strong>：首先想到的当然是暴力法…暴力大法好/斜眼笑</li><li><strong>遍历中心点暴力:</strong>感觉直接暴力子串太幼稚，想了想可以遍历所有字串的中心点，于是产生了下面第一种解法，遍历每个下标，然后对子串是奇数个字符和偶数个字符分别查找最长子串，记录最长子串起始下标和长度，最后返回。时间复杂度是<script type=\"math/tex\">O(n^2)</script></li><li><strong>动态规划: </strong>看了题解，里面讲到了动态规划的解法，首先是有一个二维数组P[i, j]，用于保存i-j位置这段子串是不是回文，是就是true，不是就是false，初始化P中长度为1和2的子串，P[i-1, j+1]=True相当于：<strong>P[i, j]==true &amp;&amp; S[i-1]==S[j+1]</strong></li><li><strong>翻转字符串和原字符串比较：</strong>:把字符串翻转，然后和原来的比较，找到最长的公共子串就是要的结果，这种方法有缺陷就是可能存在非回文子串的反向副本，改进的办法也很简单，就是比较找到的公共子串的索引是否和反向子串的原索引相同，不相同就可以排除了</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>遍历中心点法：用了32ms，8.8MB</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxLen = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断子串为奇数个字符时</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i-tmp&gt;=<span class=\"number\">0</span> &amp;&amp; i+tmp&lt;n &amp;&amp; s[i-tmp]==s[i+tmp])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((<span class=\"number\">2</span>*tmp+<span class=\"number\">1</span>)&gt;maxLen)&#123;</span><br><span class=\"line\">                    maxLen = <span class=\"number\">2</span>*tmp+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    pos = i-tmp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                tmp++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//断子串为偶数个字符时</span></span><br><span class=\"line\">            tmp = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i-tmp+<span class=\"number\">1</span>&gt;=<span class=\"number\">0</span> &amp;&amp; i+tmp&lt;n &amp;&amp; s[i-tmp+<span class=\"number\">1</span>]==s[i+tmp] )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"number\">2</span>*tmp&gt;maxLen)&#123;</span><br><span class=\"line\">                    maxLen = <span class=\"number\">2</span>*tmp;</span><br><span class=\"line\">                    pos = i-tmp+<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                tmp++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substr(pos,maxLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>动态规划版本：用了140ms，13.1MB</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> p[n][n]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxLen = <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//初始化数组边界</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">            p[i][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">            p[i][i+<span class=\"number\">1</span>]=s[i]==s[i+<span class=\"number\">1</span>]?<span class=\"number\">1</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p[i][i+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                pos = i;</span><br><span class=\"line\">                maxLen = <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p[n<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//动规循环</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;n;i++)&#123;   <span class=\"comment\">//长度-1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j+i&lt;n;j++)&#123;   <span class=\"comment\">//起始下标</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>( p[j+<span class=\"number\">1</span>][j+i<span class=\"number\">-1</span>]==<span class=\"number\">1</span> &amp;&amp; s[j]==s[j+i])&#123;</span><br><span class=\"line\">                    p[j][j+i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>((i+<span class=\"number\">1</span>)&gt;maxLen)&#123;</span><br><span class=\"line\">                        maxLen = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                        pos = j;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substr(pos,maxLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>算法题要注意边界问题，遍历的时候别下标越界</li><li>C++中数组要注意初始化，不会像java那样有默认值</li><li>动态规划注意初始化边界</li><li>暴力的时候注意子串长度还可以是偶数</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/longest-palindromic-substring/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><blockquote><p>“babad” —-&gt; “bab”<br>“cbbd” —-&gt; “bb”</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li><strong>暴力法</strong>：首先想到的当然是暴力法…暴力大法好/斜眼笑</li><li><strong>遍历中心点暴力:</strong>感觉直接暴力子串太幼稚，想了想可以遍历所有字串的中心点，于是产生了下面第一种解法，遍历每个下标，然后对子串是奇数个字符和偶数个字符分别查找最长子串，记录最长子串起始下标和长度，最后返回。时间复杂度是<script type=\"math/tex\">O(n^2)</script></li><li><strong>动态规划: </strong>看了题解，里面讲到了动态规划的解法，首先是有一个二维数组P[i, j]，用于保存i-j位置这段子串是不是回文，是就是true，不是就是false，初始化P中长度为1和2的子串，P[i-1, j+1]=True相当于：<strong>P[i, j]==true &amp;&amp; S[i-1]==S[j+1]</strong></li><li><strong>翻转字符串和原字符串比较：</strong>:把字符串翻转，然后和原来的比较，找到最长的公共子串就是要的结果，这种方法有缺陷就是可能存在非回文子串的反向副本，改进的办法也很简单，就是比较找到的公共子串的索引是否和反向子串的原索引相同，不相同就可以排除了</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>遍历中心点法：用了32ms，8.8MB</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxLen = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断子串为奇数个字符时</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i-tmp&gt;=<span class=\"number\">0</span> &amp;&amp; i+tmp&lt;n &amp;&amp; s[i-tmp]==s[i+tmp])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((<span class=\"number\">2</span>*tmp+<span class=\"number\">1</span>)&gt;maxLen)&#123;</span><br><span class=\"line\">                    maxLen = <span class=\"number\">2</span>*tmp+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    pos = i-tmp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                tmp++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//断子串为偶数个字符时</span></span><br><span class=\"line\">            tmp = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i-tmp+<span class=\"number\">1</span>&gt;=<span class=\"number\">0</span> &amp;&amp; i+tmp&lt;n &amp;&amp; s[i-tmp+<span class=\"number\">1</span>]==s[i+tmp] )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"number\">2</span>*tmp&gt;maxLen)&#123;</span><br><span class=\"line\">                    maxLen = <span class=\"number\">2</span>*tmp;</span><br><span class=\"line\">                    pos = i-tmp+<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                tmp++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substr(pos,maxLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>动态规划版本：用了140ms，13.1MB</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> p[n][n]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxLen = <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//初始化数组边界</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">            p[i][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">            p[i][i+<span class=\"number\">1</span>]=s[i]==s[i+<span class=\"number\">1</span>]?<span class=\"number\">1</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p[i][i+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                pos = i;</span><br><span class=\"line\">                maxLen = <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p[n<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//动规循环</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;n;i++)&#123;   <span class=\"comment\">//长度-1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j+i&lt;n;j++)&#123;   <span class=\"comment\">//起始下标</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>( p[j+<span class=\"number\">1</span>][j+i<span class=\"number\">-1</span>]==<span class=\"number\">1</span> &amp;&amp; s[j]==s[j+i])&#123;</span><br><span class=\"line\">                    p[j][j+i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>((i+<span class=\"number\">1</span>)&gt;maxLen)&#123;</span><br><span class=\"line\">                        maxLen = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                        pos = j;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substr(pos,maxLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>算法题要注意边界问题，遍历的时候别下标越界</li><li>C++中数组要注意初始化，不会像java那样有默认值</li><li>动态规划注意初始化边界</li><li>暴力的时候注意子串长度还可以是偶数</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-013-Roman to Integer","urlname":"leetcode-roman-to-integer","comments":1,"mathjax":false,"date":"2019-04-30T19:57:54.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/roman-to-integer/)   \nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol　　　Value\nI　　　　　　 1\nV　　　　　　 5\nX　　　　　　 10\nL　　　　　　 50\nC　　　　　　 100\nD　　　　　　 500\nM　　　　　　 1000\n\nFor example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n- I can be placed before V (5) and X (10) to make 4 and 9. \n- X can be placed before L (50) and C (100) to make 40 and 90. \n- C can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\n\n### Examples:\n**Input:**\"III\"\n**Output:**3\n\n**Input:**\"IV\"\n**Output:**4\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 想到两种方法，第一种是遍历字符串，判断每个字符和右边字符代表数字的大小，如果不小于右边的，就加上这个字符代表的数字，否则减去。遍历之前要建立字符对应数字的map，时间复杂度是O(n)\n- 还有一种方法是遍历每种情况，然后从左向右查找字符串中的字符，并且记录出现的次数，最后加上次数乘以数字,时间复杂度也是O(n),但是比第一种会花更多时间，因为有无用的比较\n\n\n## C++ Codes\n第一种，遍历字符串，40ms，10.8MB\n```C++\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        int res = 0;\n        map<char,int> values;\n        values['M']=1000;\n        values['D']=500;\n        values['C']=100;\n        values['L']=50;\n        values['X']=10;\n        values['V']=5;\n        values['I']=1;\n        \n        for(int i=0;i<s.length()-1;i++)\n          values[s[i]]>=values[s[i+1]]?\n              res+=values[s[i]]:res-=values[s[i]];\n        \n        //加上最后一位\n        res += values[s[s.length()-1]];\n        return res;\n    }\n};\n```\n\n第二种，遍历每种情况，160ms，8.6MB\n```C++\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        int values[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        string chr[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n        int pos = 0, cnt = 0, res = 0;\n\n        for(int i=0;i<13;i++){\n            while(s.substr(pos,chr[i].length())==chr[i]){\n                cnt++;\n                pos+=chr[i].length();\n            }\n            res += values[i]*cnt;\n            cnt = 0;\n        }\n        return res;\n    }\n};\n```\n\n## Python Codes\n和C++相差不多，就不写了，比较简单\n\n## 总结\n- map真好用\n- 尽量不要有没有用的比较判断之类的\n\n\n------\n","source":"_posts/LeetCode/LeetCode-013-Roman-to-Integer.md","raw":"---\ntitle: LeetCode-013-Roman to Integer\ntags:\n  - LeetCode\n  - Algorithm\n  - Math\n  - String\n  - Integer\n  - Easy\ncategories:\n  - LeetCode\nurlname: leetcode-roman-to-integer\ncomments: true\nmathjax: false\ndate: 2019-05-01 03:57:54\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/roman-to-integer/)   \nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol　　　Value\nI　　　　　　 1\nV　　　　　　 5\nX　　　　　　 10\nL　　　　　　 50\nC　　　　　　 100\nD　　　　　　 500\nM　　　　　　 1000\n\nFor example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n- I can be placed before V (5) and X (10) to make 4 and 9. \n- X can be placed before L (50) and C (100) to make 40 and 90. \n- C can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\n\n### Examples:\n**Input:**\"III\"\n**Output:**3\n\n**Input:**\"IV\"\n**Output:**4\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 想到两种方法，第一种是遍历字符串，判断每个字符和右边字符代表数字的大小，如果不小于右边的，就加上这个字符代表的数字，否则减去。遍历之前要建立字符对应数字的map，时间复杂度是O(n)\n- 还有一种方法是遍历每种情况，然后从左向右查找字符串中的字符，并且记录出现的次数，最后加上次数乘以数字,时间复杂度也是O(n),但是比第一种会花更多时间，因为有无用的比较\n\n\n## C++ Codes\n第一种，遍历字符串，40ms，10.8MB\n```C++\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        int res = 0;\n        map<char,int> values;\n        values['M']=1000;\n        values['D']=500;\n        values['C']=100;\n        values['L']=50;\n        values['X']=10;\n        values['V']=5;\n        values['I']=1;\n        \n        for(int i=0;i<s.length()-1;i++)\n          values[s[i]]>=values[s[i+1]]?\n              res+=values[s[i]]:res-=values[s[i]];\n        \n        //加上最后一位\n        res += values[s[s.length()-1]];\n        return res;\n    }\n};\n```\n\n第二种，遍历每种情况，160ms，8.6MB\n```C++\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        int values[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        string chr[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n        int pos = 0, cnt = 0, res = 0;\n\n        for(int i=0;i<13;i++){\n            while(s.substr(pos,chr[i].length())==chr[i]){\n                cnt++;\n                pos+=chr[i].length();\n            }\n            res += values[i]*cnt;\n            cnt = 0;\n        }\n        return res;\n    }\n};\n```\n\n## Python Codes\n和C++相差不多，就不写了，比较简单\n\n## 总结\n- map真好用\n- 尽量不要有没有用的比较判断之类的\n\n\n------\n","slug":"LeetCode/LeetCode-013-Roman-to-Integer","published":1,"updated":"2019-07-25T17:57:29.365Z","layout":"post","photos":[],"link":"","_id":"ck2424lti0060lksbhnsiyrfv","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/roman-to-integer/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br>Symbol　　　Value<br>I　　　　　　 1<br>V　　　　　　 5<br>X　　　　　　 10<br>L　　　　　　 50<br>C　　　　　　 100<br>D　　　　　　 500<br>M　　　　　　 1000</p><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9.</li><li>X can be placed before L (50) and C (100) to make 40 and 90.</li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>“III”<br><strong>Output:</strong>3</p><p><strong>Input:</strong>“IV”<br><strong>Output:</strong>4</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>想到两种方法，第一种是遍历字符串，判断每个字符和右边字符代表数字的大小，如果不小于右边的，就加上这个字符代表的数字，否则减去。遍历之前要建立字符对应数字的map，时间复杂度是O(n)</li><li>还有一种方法是遍历每种情况，然后从左向右查找字符串中的字符，并且记录出现的次数，最后加上次数乘以数字,时间复杂度也是O(n),但是比第一种会花更多时间，因为有无用的比较</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>第一种，遍历字符串，40ms，10.8MB<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; values;</span><br><span class=\"line\">        values[<span class=\"string\">'M'</span>]=<span class=\"number\">1000</span>;</span><br><span class=\"line\">        values[<span class=\"string\">'D'</span>]=<span class=\"number\">500</span>;</span><br><span class=\"line\">        values[<span class=\"string\">'C'</span>]=<span class=\"number\">100</span>;</span><br><span class=\"line\">        values[<span class=\"string\">'L'</span>]=<span class=\"number\">50</span>;</span><br><span class=\"line\">        values[<span class=\"string\">'X'</span>]=<span class=\"number\">10</span>;</span><br><span class=\"line\">        values[<span class=\"string\">'V'</span>]=<span class=\"number\">5</span>;</span><br><span class=\"line\">        values[<span class=\"string\">'I'</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.length()<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">          values[s[i]]&gt;=values[s[i+<span class=\"number\">1</span>]]?</span><br><span class=\"line\">              res+=values[s[i]]:res-=values[s[i]];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//加上最后一位</span></span><br><span class=\"line\">        res += values[s[s.length()<span class=\"number\">-1</span>]];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>第二种，遍历每种情况，160ms，8.6MB<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> values[]=&#123;<span class=\"number\">1000</span>,<span class=\"number\">900</span>,<span class=\"number\">500</span>,<span class=\"number\">400</span>,<span class=\"number\">100</span>,<span class=\"number\">90</span>,<span class=\"number\">50</span>,<span class=\"number\">40</span>,<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> chr[]=&#123;<span class=\"string\">\"M\"</span>,<span class=\"string\">\"CM\"</span>,<span class=\"string\">\"D\"</span>,<span class=\"string\">\"CD\"</span>,<span class=\"string\">\"C\"</span>,<span class=\"string\">\"XC\"</span>,<span class=\"string\">\"L\"</span>,<span class=\"string\">\"XL\"</span>,<span class=\"string\">\"X\"</span>,<span class=\"string\">\"IX\"</span>,<span class=\"string\">\"V\"</span>,<span class=\"string\">\"IV\"</span>,<span class=\"string\">\"I\"</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>, cnt = <span class=\"number\">0</span>, res = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">13</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(s.substr(pos,chr[i].length())==chr[i])&#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">                pos+=chr[i].length();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res += values[i]*cnt;</span><br><span class=\"line\">            cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>和C++相差不多，就不写了，比较简单</p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>map真好用</li><li>尽量不要有没有用的比较判断之类的</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/roman-to-integer/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br>Symbol　　　Value<br>I　　　　　　 1<br>V　　　　　　 5<br>X　　　　　　 10<br>L　　　　　　 50<br>C　　　　　　 100<br>D　　　　　　 500<br>M　　　　　　 1000</p><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9.</li><li>X can be placed before L (50) and C (100) to make 40 and 90.</li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>“III”<br><strong>Output:</strong>3</p><p><strong>Input:</strong>“IV”<br><strong>Output:</strong>4</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>想到两种方法，第一种是遍历字符串，判断每个字符和右边字符代表数字的大小，如果不小于右边的，就加上这个字符代表的数字，否则减去。遍历之前要建立字符对应数字的map，时间复杂度是O(n)</li><li>还有一种方法是遍历每种情况，然后从左向右查找字符串中的字符，并且记录出现的次数，最后加上次数乘以数字,时间复杂度也是O(n),但是比第一种会花更多时间，因为有无用的比较</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>第一种，遍历字符串，40ms，10.8MB<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; values;</span><br><span class=\"line\">        values[<span class=\"string\">'M'</span>]=<span class=\"number\">1000</span>;</span><br><span class=\"line\">        values[<span class=\"string\">'D'</span>]=<span class=\"number\">500</span>;</span><br><span class=\"line\">        values[<span class=\"string\">'C'</span>]=<span class=\"number\">100</span>;</span><br><span class=\"line\">        values[<span class=\"string\">'L'</span>]=<span class=\"number\">50</span>;</span><br><span class=\"line\">        values[<span class=\"string\">'X'</span>]=<span class=\"number\">10</span>;</span><br><span class=\"line\">        values[<span class=\"string\">'V'</span>]=<span class=\"number\">5</span>;</span><br><span class=\"line\">        values[<span class=\"string\">'I'</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.length()<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">          values[s[i]]&gt;=values[s[i+<span class=\"number\">1</span>]]?</span><br><span class=\"line\">              res+=values[s[i]]:res-=values[s[i]];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//加上最后一位</span></span><br><span class=\"line\">        res += values[s[s.length()<span class=\"number\">-1</span>]];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>第二种，遍历每种情况，160ms，8.6MB<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> values[]=&#123;<span class=\"number\">1000</span>,<span class=\"number\">900</span>,<span class=\"number\">500</span>,<span class=\"number\">400</span>,<span class=\"number\">100</span>,<span class=\"number\">90</span>,<span class=\"number\">50</span>,<span class=\"number\">40</span>,<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> chr[]=&#123;<span class=\"string\">\"M\"</span>,<span class=\"string\">\"CM\"</span>,<span class=\"string\">\"D\"</span>,<span class=\"string\">\"CD\"</span>,<span class=\"string\">\"C\"</span>,<span class=\"string\">\"XC\"</span>,<span class=\"string\">\"L\"</span>,<span class=\"string\">\"XL\"</span>,<span class=\"string\">\"X\"</span>,<span class=\"string\">\"IX\"</span>,<span class=\"string\">\"V\"</span>,<span class=\"string\">\"IV\"</span>,<span class=\"string\">\"I\"</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>, cnt = <span class=\"number\">0</span>, res = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">13</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(s.substr(pos,chr[i].length())==chr[i])&#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">                pos+=chr[i].length();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res += values[i]*cnt;</span><br><span class=\"line\">            cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>和C++相差不多，就不写了，比较简单</p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>map真好用</li><li>尽量不要有没有用的比较判断之类的</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-014-Longest Common Prefix","urlname":"leetcode-longest-common-prefix","comments":1,"mathjax":false,"date":"2019-05-18T04:55:53.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n一道简单题，看到腾讯50题里有，还是花点时间补上了，没想到简单题方法还这么多\n\n## [Problem](https://leetcode.com/problems/longest-common-prefix/)   \nWrite a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n### Examples:\n**Input:**[\"flower\",\"flow\",\"flight\"]\n**Output:**\"fl\"\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 找公共前缀这个问题，比较简单的想法就是一个个比较嘛，最先想到的也是这种方法，以第一个字符串为基准，从前往后比较每个字符是否和后面的字符全部相等，如果有不等的，那肯定前面的就是最长的公共前缀了，如果都相等，那就继续比较后一个字符\n- 另一种差不多的方法是从后往前，先比较最长的，再慢慢减小\n- 优化的办法是二分查找，minLen作为最短字符串的长度，二分查找这个是否为最长公共前缀\n- 题解中还有分治法，这个算法的思路来自于LCP操作的结合律。 我们可以发现： LCP(S1…Sn)=LCP(LCP(S1…Sk),LCP(Sk+1…Sn))，其中LCP(S1...Sn)是字符串[S1...Sn]的最长公共前缀\n- 基于二分查找，更进一步是用字典树，详细的看题解把\n\n## C++ Codes\n第一种解法，最容易想到的\n```C++\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string prefix;\n        int flag = 1;\n        if(strs.size()==0 || strs[0].length()==0)return prefix;\n\n        for(int i=0;i<strs[0].length();i++){\n            for(int j=1;j<strs.size();j++){\n                if(strs[j].length()<i+1 || strs[j][i]!=strs[0][i]){\n                    flag = 0;\n                    break;\n                }\n            }\n\n            if(flag) prefix += strs[0][i];\n            else break;\n        }\n        return prefix;\n    }\n};\n```\n\n## 总结\n- emm，简单题也有这么多种做法...\n- 最长公共前缀可以1.遍历前缀，2.二分查找前缀，3.分治找前缀，4.字典树找前缀\n\n\n------\n","source":"_posts/LeetCode/LeetCode-014-Longest-Common-Prefix.md","raw":"---\ntitle: LeetCode-014-Longest Common Prefix\ntags:\n  - LeetCode\n  - Algorithm\n  - Prefix\n  - String\n  - Easy\ncategories:\n  - LeetCode\nurlname: leetcode-longest-common-prefix\ncomments: true\nmathjax: false\ndate: 2019-05-18 12:55:53\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n一道简单题，看到腾讯50题里有，还是花点时间补上了，没想到简单题方法还这么多\n\n## [Problem](https://leetcode.com/problems/longest-common-prefix/)   \nWrite a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n### Examples:\n**Input:**[\"flower\",\"flow\",\"flight\"]\n**Output:**\"fl\"\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 找公共前缀这个问题，比较简单的想法就是一个个比较嘛，最先想到的也是这种方法，以第一个字符串为基准，从前往后比较每个字符是否和后面的字符全部相等，如果有不等的，那肯定前面的就是最长的公共前缀了，如果都相等，那就继续比较后一个字符\n- 另一种差不多的方法是从后往前，先比较最长的，再慢慢减小\n- 优化的办法是二分查找，minLen作为最短字符串的长度，二分查找这个是否为最长公共前缀\n- 题解中还有分治法，这个算法的思路来自于LCP操作的结合律。 我们可以发现： LCP(S1…Sn)=LCP(LCP(S1…Sk),LCP(Sk+1…Sn))，其中LCP(S1...Sn)是字符串[S1...Sn]的最长公共前缀\n- 基于二分查找，更进一步是用字典树，详细的看题解把\n\n## C++ Codes\n第一种解法，最容易想到的\n```C++\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string prefix;\n        int flag = 1;\n        if(strs.size()==0 || strs[0].length()==0)return prefix;\n\n        for(int i=0;i<strs[0].length();i++){\n            for(int j=1;j<strs.size();j++){\n                if(strs[j].length()<i+1 || strs[j][i]!=strs[0][i]){\n                    flag = 0;\n                    break;\n                }\n            }\n\n            if(flag) prefix += strs[0][i];\n            else break;\n        }\n        return prefix;\n    }\n};\n```\n\n## 总结\n- emm，简单题也有这么多种做法...\n- 最长公共前缀可以1.遍历前缀，2.二分查找前缀，3.分治找前缀，4.字典树找前缀\n\n\n------\n","slug":"LeetCode/LeetCode-014-Longest-Common-Prefix","published":1,"updated":"2019-07-25T17:57:44.585Z","layout":"post","photos":[],"link":"","_id":"ck2424ltj0064lksblqwquhk6","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>一道简单题，看到腾讯50题里有，还是花点时间补上了，没想到简单题方法还这么多</p><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/longest-common-prefix/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>[“flower”,”flow”,”flight”]<br><strong>Output:</strong>“fl”</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>找公共前缀这个问题，比较简单的想法就是一个个比较嘛，最先想到的也是这种方法，以第一个字符串为基准，从前往后比较每个字符是否和后面的字符全部相等，如果有不等的，那肯定前面的就是最长的公共前缀了，如果都相等，那就继续比较后一个字符</li><li>另一种差不多的方法是从后往前，先比较最长的，再慢慢减小</li><li>优化的办法是二分查找，minLen作为最短字符串的长度，二分查找这个是否为最长公共前缀</li><li>题解中还有分治法，这个算法的思路来自于LCP操作的结合律。 我们可以发现： LCP(S1…Sn)=LCP(LCP(S1…Sk),LCP(Sk+1…Sn))，其中LCP(S1…Sn)是字符串[S1…Sn]的最长公共前缀</li><li>基于二分查找，更进一步是用字典树，详细的看题解把</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>第一种解法，最容易想到的<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> prefix;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(strs.size()==<span class=\"number\">0</span> || strs[<span class=\"number\">0</span>].length()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> prefix;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;strs[<span class=\"number\">0</span>].length();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;strs.size();j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(strs[j].length()&lt;i+<span class=\"number\">1</span> || strs[j][i]!=strs[<span class=\"number\">0</span>][i])&#123;</span><br><span class=\"line\">                    flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag) prefix += strs[<span class=\"number\">0</span>][i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prefix;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>emm，简单题也有这么多种做法…</li><li>最长公共前缀可以1.遍历前缀，2.二分查找前缀，3.分治找前缀，4.字典树找前缀</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>一道简单题，看到腾讯50题里有，还是花点时间补上了，没想到简单题方法还这么多</p><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/longest-common-prefix/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>[“flower”,”flow”,”flight”]<br><strong>Output:</strong>“fl”</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>找公共前缀这个问题，比较简单的想法就是一个个比较嘛，最先想到的也是这种方法，以第一个字符串为基准，从前往后比较每个字符是否和后面的字符全部相等，如果有不等的，那肯定前面的就是最长的公共前缀了，如果都相等，那就继续比较后一个字符</li><li>另一种差不多的方法是从后往前，先比较最长的，再慢慢减小</li><li>优化的办法是二分查找，minLen作为最短字符串的长度，二分查找这个是否为最长公共前缀</li><li>题解中还有分治法，这个算法的思路来自于LCP操作的结合律。 我们可以发现： LCP(S1…Sn)=LCP(LCP(S1…Sk),LCP(Sk+1…Sn))，其中LCP(S1…Sn)是字符串[S1…Sn]的最长公共前缀</li><li>基于二分查找，更进一步是用字典树，详细的看题解把</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>第一种解法，最容易想到的<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> prefix;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(strs.size()==<span class=\"number\">0</span> || strs[<span class=\"number\">0</span>].length()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> prefix;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;strs[<span class=\"number\">0</span>].length();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;strs.size();j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(strs[j].length()&lt;i+<span class=\"number\">1</span> || strs[j][i]!=strs[<span class=\"number\">0</span>][i])&#123;</span><br><span class=\"line\">                    flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag) prefix += strs[<span class=\"number\">0</span>][i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prefix;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>emm，简单题也有这么多种做法…</li><li>最长公共前缀可以1.遍历前缀，2.二分查找前缀，3.分治找前缀，4.字典树找前缀</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-016-3Sum Closest","urlname":"leetcode-3sum-closest","comments":1,"mathjax":false,"date":"2019-05-22T05:28:15.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/3sum-closest/)   \nGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n### Examples:\n**Input:**Given array nums = [-1, 2, 1, -4], and target = 1.\n**Output:**The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 还是基于上一道题，用三指针，在将向量排序后，第一个指针从前往后移动，后面两个指针一个指向第一个指针的后一个元素，另一个指向最后一个元素。记录和target相差最小的三数之和，每次比较target和当前三数之和，如果三数之和比target大，那就减小第三个指针位置，如果比target小，就增加第二个指针位置，相等就直接返回了。\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n        if(nums.size()<3) return 0;\n        \n        //初始化为前三个的和与target的差\n        int min_diff = nums[0]+nums[1]+nums[2];\n        for(int i=0;i<nums.size()-2;i++){\n            if(i>0 && nums[i]==nums[i-1]) continue;\n            \n            int l = i+1, r = nums.size()-1;\n            while(l<r){\n                //当前三个数和target的差\n                int cur_diff = nums[i]+nums[l]+nums[r];\n                if(target == cur_diff)return target;\n                if(abs(target-cur_diff) < abs(target-min_diff))min_diff = cur_diff;\n                if(target > cur_diff)l++;\n                if(target < cur_diff)r--;\n            }\n        }\n        return min_diff;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        res = float(\"inf\")\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            left = i + 1\n            right = n - 1\n            while left < right :\n                #print(left,right)\n                cur = nums[i] + nums[left] + nums[right]\n                if cur == target:return target\n                if abs(res-target) > abs(cur-target):\n                    res = cur\n                if cur > target:\n                    right -= 1\n                elif cur < target:\n                    left += 1\n        return res\n```\n\n## 总结\n- 基本办法和第15题一样，中间处理有点差别\n\n\n------\n","source":"_posts/LeetCode/LeetCode-016-3Sum-Closest.md","raw":"---\ntitle: LeetCode-016-3Sum Closest\ntags:\n  - LeetCode\n  - Algorithm\n  - Closest\n  - 3Sum\n  - Medium\ncategories:\n  - LeetCode\nurlname: leetcode-3sum-closest\ncomments: true\nmathjax: false\ndate: 2019-05-22 13:28:15\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/3sum-closest/)   \nGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n### Examples:\n**Input:**Given array nums = [-1, 2, 1, -4], and target = 1.\n**Output:**The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 还是基于上一道题，用三指针，在将向量排序后，第一个指针从前往后移动，后面两个指针一个指向第一个指针的后一个元素，另一个指向最后一个元素。记录和target相差最小的三数之和，每次比较target和当前三数之和，如果三数之和比target大，那就减小第三个指针位置，如果比target小，就增加第二个指针位置，相等就直接返回了。\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n        if(nums.size()<3) return 0;\n        \n        //初始化为前三个的和与target的差\n        int min_diff = nums[0]+nums[1]+nums[2];\n        for(int i=0;i<nums.size()-2;i++){\n            if(i>0 && nums[i]==nums[i-1]) continue;\n            \n            int l = i+1, r = nums.size()-1;\n            while(l<r){\n                //当前三个数和target的差\n                int cur_diff = nums[i]+nums[l]+nums[r];\n                if(target == cur_diff)return target;\n                if(abs(target-cur_diff) < abs(target-min_diff))min_diff = cur_diff;\n                if(target > cur_diff)l++;\n                if(target < cur_diff)r--;\n            }\n        }\n        return min_diff;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        res = float(\"inf\")\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            left = i + 1\n            right = n - 1\n            while left < right :\n                #print(left,right)\n                cur = nums[i] + nums[left] + nums[right]\n                if cur == target:return target\n                if abs(res-target) > abs(cur-target):\n                    res = cur\n                if cur > target:\n                    right -= 1\n                elif cur < target:\n                    left += 1\n        return res\n```\n\n## 总结\n- 基本办法和第15题一样，中间处理有点差别\n\n\n------\n","slug":"LeetCode/LeetCode-016-3Sum-Closest","published":1,"updated":"2019-07-25T17:58:18.736Z","layout":"post","photos":[],"link":"","_id":"ck2424ltm0067lksbah9dubn1","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/3sum-closest/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>Given array nums = [-1, 2, 1, -4], and target = 1.<br><strong>Output:</strong>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>还是基于上一道题，用三指针，在将向量排序后，第一个指针从前往后移动，后面两个指针一个指向第一个指针的后一个元素，另一个指向最后一个元素。记录和target相差最小的三数之和，每次比较target和当前三数之和，如果三数之和比target大，那就减小第三个指针位置，如果比target小，就增加第二个指针位置，相等就直接返回了。</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        sort(nums.begin(),nums.end());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.size()&lt;<span class=\"number\">3</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//初始化为前三个的和与target的差</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> min_diff = nums[<span class=\"number\">0</span>]+nums[<span class=\"number\">1</span>]+nums[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.size()<span class=\"number\">-2</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span> &amp;&amp; nums[i]==nums[i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">int</span> l = i+<span class=\"number\">1</span>, r = nums.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//当前三个数和target的差</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> cur_diff = nums[i]+nums[l]+nums[r];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target == cur_diff)<span class=\"keyword\">return</span> target;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(target-cur_diff) &lt; <span class=\"built_in\">abs</span>(target-min_diff))min_diff = cur_diff;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt; cur_diff)l++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &lt; cur_diff)r--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min_diff;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        res = float(<span class=\"string\">\"inf\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            left = i + <span class=\"number\">1</span></span><br><span class=\"line\">            right = n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> left &lt; right :</span><br><span class=\"line\">                <span class=\"comment\">#print(left,right)</span></span><br><span class=\"line\">                cur = nums[i] + nums[left] + nums[right]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cur == target:<span class=\"keyword\">return</span> target</span><br><span class=\"line\">                <span class=\"keyword\">if</span> abs(res-target) &gt; abs(cur-target):</span><br><span class=\"line\">                    res = cur</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cur &gt; target:</span><br><span class=\"line\">                    right -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> cur &lt; target:</span><br><span class=\"line\">                    left += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>基本办法和第15题一样，中间处理有点差别</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/3sum-closest/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>Given array nums = [-1, 2, 1, -4], and target = 1.<br><strong>Output:</strong>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>还是基于上一道题，用三指针，在将向量排序后，第一个指针从前往后移动，后面两个指针一个指向第一个指针的后一个元素，另一个指向最后一个元素。记录和target相差最小的三数之和，每次比较target和当前三数之和，如果三数之和比target大，那就减小第三个指针位置，如果比target小，就增加第二个指针位置，相等就直接返回了。</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        sort(nums.begin(),nums.end());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.size()&lt;<span class=\"number\">3</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//初始化为前三个的和与target的差</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> min_diff = nums[<span class=\"number\">0</span>]+nums[<span class=\"number\">1</span>]+nums[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.size()<span class=\"number\">-2</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span> &amp;&amp; nums[i]==nums[i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">int</span> l = i+<span class=\"number\">1</span>, r = nums.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//当前三个数和target的差</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> cur_diff = nums[i]+nums[l]+nums[r];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target == cur_diff)<span class=\"keyword\">return</span> target;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(target-cur_diff) &lt; <span class=\"built_in\">abs</span>(target-min_diff))min_diff = cur_diff;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt; cur_diff)l++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &lt; cur_diff)r--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min_diff;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        res = float(<span class=\"string\">\"inf\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            left = i + <span class=\"number\">1</span></span><br><span class=\"line\">            right = n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> left &lt; right :</span><br><span class=\"line\">                <span class=\"comment\">#print(left,right)</span></span><br><span class=\"line\">                cur = nums[i] + nums[left] + nums[right]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cur == target:<span class=\"keyword\">return</span> target</span><br><span class=\"line\">                <span class=\"keyword\">if</span> abs(res-target) &gt; abs(cur-target):</span><br><span class=\"line\">                    res = cur</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cur &gt; target:</span><br><span class=\"line\">                    right -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> cur &lt; target:</span><br><span class=\"line\">                    left += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>基本办法和第15题一样，中间处理有点差别</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-009-Palindrome Number","urlname":"leetcode-palindrome-number","comments":1,"mathjax":false,"date":"2019-04-18T16:24:57.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/palindrome-number/)   \nDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.\n\n### Examples:\n**Input:**121\n**Output:**true\n**Input:**-121\n**Output:**true\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 首先想到的肯定是转成字符串，然后前后每个数判断是否相等，遇到不等的就return，这种方法会创建一个字符串，可能会慢一点\n- 另一种方法也很容易想，就是把数字翻转过来嘛，再比较，相等的就是回文数了，但是可能会出现翻转后的数字溢出的问题，所以，可以只把后半部分的数字翻转，和前半部分的数字比较，如果是奇数位，可以把多一位的那部分除以10再比较。\n\n\n## C++ Codes\n转成字符串的方法，36ms，8.2MB\n\n```\n```C++\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        string xstr = to_string(x);\n        int n = xstr.length();\n        for(int i=0;i<n/2;i++){\n            if(xstr[i]!=xstr[n-i-1]) return false;\n        }\n        return true;\n    }\n};\n```\n\n## Python Codes\nPython的代码和这个几乎一样，就不写了\n\n## 总结\n- 因为是简单题，所以没啥思维难度，很容易想到方法，要注意的还是细节上面小心点 \n\n------\n","source":"_posts/LeetCode/LeetCode-009-Palindrome-Number.md","raw":"---\ntitle: LeetCode-009-Palindrome Number\ntags:\n  - LeetCode\n  - Algorithm\n  - Palindrome\n  - String\n  - Easy\ncategories:\n  - LeetCode\nurlname: leetcode-palindrome-number\ncomments: true\nmathjax: false\ndate: 2019-04-19 00:24:57\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/palindrome-number/)   \nDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.\n\n### Examples:\n**Input:**121\n**Output:**true\n**Input:**-121\n**Output:**true\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 首先想到的肯定是转成字符串，然后前后每个数判断是否相等，遇到不等的就return，这种方法会创建一个字符串，可能会慢一点\n- 另一种方法也很容易想，就是把数字翻转过来嘛，再比较，相等的就是回文数了，但是可能会出现翻转后的数字溢出的问题，所以，可以只把后半部分的数字翻转，和前半部分的数字比较，如果是奇数位，可以把多一位的那部分除以10再比较。\n\n\n## C++ Codes\n转成字符串的方法，36ms，8.2MB\n\n```\n```C++\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        string xstr = to_string(x);\n        int n = xstr.length();\n        for(int i=0;i<n/2;i++){\n            if(xstr[i]!=xstr[n-i-1]) return false;\n        }\n        return true;\n    }\n};\n```\n\n## Python Codes\nPython的代码和这个几乎一样，就不写了\n\n## 总结\n- 因为是简单题，所以没啥思维难度，很容易想到方法，要注意的还是细节上面小心点 \n\n------\n","slug":"LeetCode/LeetCode-009-Palindrome-Number","published":1,"updated":"2019-07-25T17:56:12.324Z","layout":"post","photos":[],"link":"","_id":"ck2424ltn006blksbxbu257ti","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/palindrome-number/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>121<br><strong>Output:</strong>true<br><strong>Input:</strong>-121<br><strong>Output:</strong>true</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>首先想到的肯定是转成字符串，然后前后每个数判断是否相等，遇到不等的就return，这种方法会创建一个字符串，可能会慢一点</li><li>另一种方法也很容易想，就是把数字翻转过来嘛，再比较，相等的就是回文数了，但是可能会出现翻转后的数字溢出的问题，所以，可以只把后半部分的数字翻转，和前半部分的数字比较，如果是奇数位，可以把多一位的那部分除以10再比较。</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>转成字符串的方法，36ms，8.2MB</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```C++</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool isPalindrome(int x) &#123;</span><br><span class=\"line\">        string xstr = to_string(x);</span><br><span class=\"line\">        int n = xstr.length();</span><br><span class=\"line\">        for(int i=0;i&lt;n/2;i++)&#123;</span><br><span class=\"line\">            if(xstr[i]!=xstr[n-i-1]) return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>Python的代码和这个几乎一样，就不写了</p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>因为是简单题，所以没啥思维难度，很容易想到方法，要注意的还是细节上面小心点</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/palindrome-number/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>121<br><strong>Output:</strong>true<br><strong>Input:</strong>-121<br><strong>Output:</strong>true</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>首先想到的肯定是转成字符串，然后前后每个数判断是否相等，遇到不等的就return，这种方法会创建一个字符串，可能会慢一点</li><li>另一种方法也很容易想，就是把数字翻转过来嘛，再比较，相等的就是回文数了，但是可能会出现翻转后的数字溢出的问题，所以，可以只把后半部分的数字翻转，和前半部分的数字比较，如果是奇数位，可以把多一位的那部分除以10再比较。</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>转成字符串的方法，36ms，8.2MB</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```C++</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool isPalindrome(int x) &#123;</span><br><span class=\"line\">        string xstr = to_string(x);</span><br><span class=\"line\">        int n = xstr.length();</span><br><span class=\"line\">        for(int i=0;i&lt;n/2;i++)&#123;</span><br><span class=\"line\">            if(xstr[i]!=xstr[n-i-1]) return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>Python的代码和这个几乎一样，就不写了</p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>因为是简单题，所以没啥思维难度，很容易想到方法，要注意的还是细节上面小心点</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-015-3Sum","urlname":"leetcode-3sum","comments":1,"mathjax":false,"date":"2019-05-19T13:22:18.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n快半月没更新了，也没怎么刷题，家里有事情耽误了，后面一周又忙着别的，以后简单难度的题就直接略过了，加快进度，么得时间咯\n\n## [Problem](https://leetcode.com/problems/3sum/)   \nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\n**Note:**  \nThe solution set must not contain duplicate triplets.\n\n### Examples:\n**Input:**nums = [-1, 0, 1, 2, -1, -4]\n**Output:**[ [-1, 0, 1], [-1, -1, 2] ]\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 暴力法，但是想想不优化的花$$ n^3 $$的复杂度还是算了，就算优化估计也难过\n- 想了递归的方法，先固定一个数，问题变成找两个数和为第一个数的负数，然后再固定一个数，找最后一个，但是相当于也是$$ n^3 $$，想了用类似dp那样的优化，似乎也不行，数字只能用一次\n- 最后的方法是，先选第一个数，然后找剩下的连个数，让三个数和为0，剩下的两个数找的时候优化一下，排序后一个从前一个从后找，具体看代码\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //先排序预处理，如果发现全都是大于0或者全小于0，或者少于三个元素，就返回\n        sort(nums.begin(),nums.end());\n        if(nums.size()<3||nums.front()>0||nums.back()<0) return {};\n\n        vector<vector<int>> res;\n        int len = nums.size();\n\n        for(int i=0;i<len;i++){\n            //很明显只需要找第一个数小于0的\n            if(nums[i]>0)break;\n            //这里记得要写i>0，边界判断，容易丢\n            if(i>0 && nums[i]==nums[i-1]) continue;\n\n            //left自增，right自减\n            int left = i+1, right = len-1;\n            while(left<right){\n                int tmp = nums[i]+nums[left]+nums[right];\n                if(tmp==0){\n                    res.push_back(vector<int>{nums[i], nums[left], nums[right]});\n                    \n                    //如果出现数字相同跳过，注意边界条件：left < right\n                    while (left < right && nums[left] == nums[left + 1]) left += 1;\n                    while (left < right && nums[right] == nums[right - 1]) right -= 1;\n\n                    left++;\n                    right--;\n                }\n                //很好理解，大于0说明正数太大，小于0说明负数太小\n                else if(tmp>0) right--;\n                else if(tmp<0) left++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n):\n            if res[i] > 0\n                break\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n\n            left = i + 1\n            right = n - 1\n            while left < right:\n                cur_sum = nums[i] + nums[left] + nums[right]\n                if cur_sum == 0:\n                    tmp = [nums[i],nums[left],nums[right]]\n                    res.append(tmp)\n                    while left < right and nums[left] == nums[left+1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right-1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif cur_sum > 0:\n                    right -= 1\n                else:\n                    left += 1\n        return res\n```\n\n## 总结\n- 找符合条件的数的时候，双指针前后开始找很好用\n- 边界条件判断很重要，条件语句要多想想，容易漏\n\n\n------\n","source":"_posts/LeetCode/LeetCode-015-3Sum.md","raw":"---\ntitle: LeetCode-015-3Sum\ntags:\n  - LeetCode\n  - Algorithm\n  - Medium\ncategories:\n  - LeetCode\nurlname: leetcode-3sum\ncomments: true\nmathjax: false\ndate: 2019-05-19 21:22:18\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n快半月没更新了，也没怎么刷题，家里有事情耽误了，后面一周又忙着别的，以后简单难度的题就直接略过了，加快进度，么得时间咯\n\n## [Problem](https://leetcode.com/problems/3sum/)   \nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\n**Note:**  \nThe solution set must not contain duplicate triplets.\n\n### Examples:\n**Input:**nums = [-1, 0, 1, 2, -1, -4]\n**Output:**[ [-1, 0, 1], [-1, -1, 2] ]\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 暴力法，但是想想不优化的花$$ n^3 $$的复杂度还是算了，就算优化估计也难过\n- 想了递归的方法，先固定一个数，问题变成找两个数和为第一个数的负数，然后再固定一个数，找最后一个，但是相当于也是$$ n^3 $$，想了用类似dp那样的优化，似乎也不行，数字只能用一次\n- 最后的方法是，先选第一个数，然后找剩下的连个数，让三个数和为0，剩下的两个数找的时候优化一下，排序后一个从前一个从后找，具体看代码\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //先排序预处理，如果发现全都是大于0或者全小于0，或者少于三个元素，就返回\n        sort(nums.begin(),nums.end());\n        if(nums.size()<3||nums.front()>0||nums.back()<0) return {};\n\n        vector<vector<int>> res;\n        int len = nums.size();\n\n        for(int i=0;i<len;i++){\n            //很明显只需要找第一个数小于0的\n            if(nums[i]>0)break;\n            //这里记得要写i>0，边界判断，容易丢\n            if(i>0 && nums[i]==nums[i-1]) continue;\n\n            //left自增，right自减\n            int left = i+1, right = len-1;\n            while(left<right){\n                int tmp = nums[i]+nums[left]+nums[right];\n                if(tmp==0){\n                    res.push_back(vector<int>{nums[i], nums[left], nums[right]});\n                    \n                    //如果出现数字相同跳过，注意边界条件：left < right\n                    while (left < right && nums[left] == nums[left + 1]) left += 1;\n                    while (left < right && nums[right] == nums[right - 1]) right -= 1;\n\n                    left++;\n                    right--;\n                }\n                //很好理解，大于0说明正数太大，小于0说明负数太小\n                else if(tmp>0) right--;\n                else if(tmp<0) left++;\n            }\n        }\n        return res;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n):\n            if res[i] > 0\n                break\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n\n            left = i + 1\n            right = n - 1\n            while left < right:\n                cur_sum = nums[i] + nums[left] + nums[right]\n                if cur_sum == 0:\n                    tmp = [nums[i],nums[left],nums[right]]\n                    res.append(tmp)\n                    while left < right and nums[left] == nums[left+1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right-1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif cur_sum > 0:\n                    right -= 1\n                else:\n                    left += 1\n        return res\n```\n\n## 总结\n- 找符合条件的数的时候，双指针前后开始找很好用\n- 边界条件判断很重要，条件语句要多想想，容易漏\n\n\n------\n","slug":"LeetCode/LeetCode-015-3Sum","published":1,"updated":"2019-07-25T17:58:00.299Z","layout":"post","photos":[],"link":"","_id":"ck2424ltp006elksbw4pbytrn","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>快半月没更新了，也没怎么刷题，家里有事情耽误了，后面一周又忙着别的，以后简单难度的题就直接略过了，加快进度，么得时间咯</p><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/3sum/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong><br>The solution set must not contain duplicate triplets.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>nums = [-1, 0, 1, 2, -1, -4]<br><strong>Output:</strong>[ [-1, 0, 1], [-1, -1, 2] ]</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>暴力法，但是想想不优化的花<script type=\"math/tex\">n^3</script>的复杂度还是算了，就算优化估计也难过</li><li>想了递归的方法，先固定一个数，问题变成找两个数和为第一个数的负数，然后再固定一个数，找最后一个，但是相当于也是<script type=\"math/tex\">n^3</script>，想了用类似dp那样的优化，似乎也不行，数字只能用一次</li><li>最后的方法是，先选第一个数，然后找剩下的连个数，让三个数和为0，剩下的两个数找的时候优化一下，排序后一个从前一个从后找，具体看代码</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; threeSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//先排序预处理，如果发现全都是大于0或者全小于0，或者少于三个元素，就返回</span></span><br><span class=\"line\">        sort(nums.begin(),nums.end());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.size()&lt;<span class=\"number\">3</span>||nums.front()&gt;<span class=\"number\">0</span>||nums.back()&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.size();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//很明显只需要找第一个数小于0的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]&gt;<span class=\"number\">0</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">//这里记得要写i&gt;0，边界判断，容易丢</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span> &amp;&amp; nums[i]==nums[i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//left自增，right自减</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> left = i+<span class=\"number\">1</span>, right = len<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(left&lt;right)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp = nums[i]+nums[left]+nums[right];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    res.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">//如果出现数字相同跳过，注意边界条件：left &lt; right</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class=\"number\">1</span>]) left += <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class=\"number\">1</span>]) right -= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    left++;</span><br><span class=\"line\">                    right--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//很好理解，大于0说明正数太大，小于0说明负数太小</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp&gt;<span class=\"number\">0</span>) right--;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp&lt;<span class=\"number\">0</span>) left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        res = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> res[i] &gt; <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">            left = i + <span class=\"number\">1</span></span><br><span class=\"line\">            right = n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">                cur_sum = nums[i] + nums[left] + nums[right]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cur_sum == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    tmp = [nums[i],nums[left],nums[right]]</span><br><span class=\"line\">                    res.append(tmp)</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> nums[left] == nums[left+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                        left += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> nums[right] == nums[right<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                        right -= <span class=\"number\">1</span></span><br><span class=\"line\">                    left += <span class=\"number\">1</span></span><br><span class=\"line\">                    right -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> cur_sum &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    right -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    left += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>找符合条件的数的时候，双指针前后开始找很好用</li><li>边界条件判断很重要，条件语句要多想想，容易漏</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>快半月没更新了，也没怎么刷题，家里有事情耽误了，后面一周又忙着别的，以后简单难度的题就直接略过了，加快进度，么得时间咯</p><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/3sum/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong><br>The solution set must not contain duplicate triplets.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>nums = [-1, 0, 1, 2, -1, -4]<br><strong>Output:</strong>[ [-1, 0, 1], [-1, -1, 2] ]</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>暴力法，但是想想不优化的花<script type=\"math/tex\">n^3</script>的复杂度还是算了，就算优化估计也难过</li><li>想了递归的方法，先固定一个数，问题变成找两个数和为第一个数的负数，然后再固定一个数，找最后一个，但是相当于也是<script type=\"math/tex\">n^3</script>，想了用类似dp那样的优化，似乎也不行，数字只能用一次</li><li>最后的方法是，先选第一个数，然后找剩下的连个数，让三个数和为0，剩下的两个数找的时候优化一下，排序后一个从前一个从后找，具体看代码</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; threeSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//先排序预处理，如果发现全都是大于0或者全小于0，或者少于三个元素，就返回</span></span><br><span class=\"line\">        sort(nums.begin(),nums.end());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.size()&lt;<span class=\"number\">3</span>||nums.front()&gt;<span class=\"number\">0</span>||nums.back()&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.size();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//很明显只需要找第一个数小于0的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]&gt;<span class=\"number\">0</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">//这里记得要写i&gt;0，边界判断，容易丢</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span> &amp;&amp; nums[i]==nums[i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//left自增，right自减</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> left = i+<span class=\"number\">1</span>, right = len<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(left&lt;right)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp = nums[i]+nums[left]+nums[right];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    res.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">//如果出现数字相同跳过，注意边界条件：left &lt; right</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class=\"number\">1</span>]) left += <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class=\"number\">1</span>]) right -= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    left++;</span><br><span class=\"line\">                    right--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//很好理解，大于0说明正数太大，小于0说明负数太小</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp&gt;<span class=\"number\">0</span>) right--;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp&lt;<span class=\"number\">0</span>) left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">threeSum</span><span class=\"params\">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        res = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> res[i] &gt; <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">            left = i + <span class=\"number\">1</span></span><br><span class=\"line\">            right = n - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">                cur_sum = nums[i] + nums[left] + nums[right]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cur_sum == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    tmp = [nums[i],nums[left],nums[right]]</span><br><span class=\"line\">                    res.append(tmp)</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> nums[left] == nums[left+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                        left += <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> nums[right] == nums[right<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                        right -= <span class=\"number\">1</span></span><br><span class=\"line\">                    left += <span class=\"number\">1</span></span><br><span class=\"line\">                    right -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> cur_sum &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    right -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    left += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>找符合条件的数的时候，双指针前后开始找很好用</li><li>边界条件判断很重要，条件语句要多想想，容易漏</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-017-Letter Combinations of a Phone Number","urlname":"leetcode-letter-combinations-of-a-phone-number","comments":1,"mathjax":false,"date":"2019-05-22T05:48:56.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)   \nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\n2：\"abc\", 3-\"def\", 4-\"ghi\", 5-\"jkl\", 6-\"mno\", 7-\"pqrs\", 8-\"tuv\", 9-\"wxyz\"\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n### Examples:\n**Input:**\"23\"\n**Output:**[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 递归，当后面的全部完成了排列之后，前面的加上就是全部的排列方式，这里要记录前缀，到最后没有数字的时候，就添加前缀并返回\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:        \n    string mapChar[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n    vector<string> letterCombinations(string digits) {\n        if(digits.length()==0)return {};\n        vector<string> res;\n        recurDigit(digits,\"\",res);\n        return res;\n    }\n    \n    void recurDigit(string digits,string prefix, vector<string>& res){\n        //边界条件\n        if(digits==\"\") {\n            res.push_back(prefix);\n            return;\n        }\n        \n        string key = mapChar[digits[0]-'0'];\n        int n = key.length();\n        for(int i=0;i<n;i++)\n            recurDigit(digits.substr(1), prefix+key[i], res);\n        \n    }\n    \n};\n```\n\n## 总结\n- 递归要处理好边界条件，这里是当digits为空的时候，就返回\n- 这里用了记录前缀的方式，感觉也可以使用前面的加上后缀的方式，返回的时候返回字符，应该也可以\n- 这题让我想到了全排列的解法\n\n\n------\n","source":"_posts/LeetCode/LeetCode-017-Letter-Combinations-of-a-Phone-Number.md","raw":"---\ntitle: LeetCode-017-Letter Combinations of a Phone Number\ntags:\n  - LeetCode\n  - Algorithm\n  - Recursive\n  - Map\n  - Medium\ncategories:\n  - LeetCode\nurlname: leetcode-letter-combinations-of-a-phone-number\ncomments: true\nmathjax: false\ndate: 2019-05-22 13:48:56\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)   \nGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\n2：\"abc\", 3-\"def\", 4-\"ghi\", 5-\"jkl\", 6-\"mno\", 7-\"pqrs\", 8-\"tuv\", 9-\"wxyz\"\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n### Examples:\n**Input:**\"23\"\n**Output:**[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 递归，当后面的全部完成了排列之后，前面的加上就是全部的排列方式，这里要记录前缀，到最后没有数字的时候，就添加前缀并返回\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:        \n    string mapChar[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n    vector<string> letterCombinations(string digits) {\n        if(digits.length()==0)return {};\n        vector<string> res;\n        recurDigit(digits,\"\",res);\n        return res;\n    }\n    \n    void recurDigit(string digits,string prefix, vector<string>& res){\n        //边界条件\n        if(digits==\"\") {\n            res.push_back(prefix);\n            return;\n        }\n        \n        string key = mapChar[digits[0]-'0'];\n        int n = key.length();\n        for(int i=0;i<n;i++)\n            recurDigit(digits.substr(1), prefix+key[i], res);\n        \n    }\n    \n};\n```\n\n## 总结\n- 递归要处理好边界条件，这里是当digits为空的时候，就返回\n- 这里用了记录前缀的方式，感觉也可以使用前面的加上后缀的方式，返回的时候返回字符，应该也可以\n- 这题让我想到了全排列的解法\n\n\n------\n","slug":"LeetCode/LeetCode-017-Letter-Combinations-of-a-Phone-Number","published":1,"updated":"2019-07-25T17:58:41.552Z","layout":"post","photos":[],"link":"","_id":"ck2424ltq006ilksbtvzq8593","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.<br>2：”abc”, 3-“def”, 4-“ghi”, 5-“jkl”, 6-“mno”, 7-“pqrs”, 8-“tuv”, 9-“wxyz”</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>“23”<br><strong>Output:</strong>[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>递归，当后面的全部完成了排列之后，前面的加上就是全部的排列方式，这里要记录前缀，到最后没有数字的时候，就添加前缀并返回</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:        </span><br><span class=\"line\">    <span class=\"built_in\">string</span> mapChar[<span class=\"number\">10</span>] = &#123;<span class=\"string\">\"\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"abc\"</span>,<span class=\"string\">\"def\"</span>,<span class=\"string\">\"ghi\"</span>,<span class=\"string\">\"jkl\"</span>,<span class=\"string\">\"mno\"</span>,<span class=\"string\">\"pqrs\"</span>,<span class=\"string\">\"tuv\"</span>,<span class=\"string\">\"wxyz\"</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; letterCombinations(<span class=\"built_in\">string</span> digits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(digits.length()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; res;</span><br><span class=\"line\">        recurDigit(digits,<span class=\"string\">\"\"</span>,res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recurDigit</span><span class=\"params\">(<span class=\"built_in\">string</span> digits,<span class=\"built_in\">string</span> prefix, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//边界条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(digits==<span class=\"string\">\"\"</span>) &#123;</span><br><span class=\"line\">            res.push_back(prefix);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">string</span> key = mapChar[digits[<span class=\"number\">0</span>]-<span class=\"string\">'0'</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = key.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">            recurDigit(digits.substr(<span class=\"number\">1</span>), prefix+key[i], res);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>递归要处理好边界条件，这里是当digits为空的时候，就返回</li><li>这里用了记录前缀的方式，感觉也可以使用前面的加上后缀的方式，返回的时候返回字符，应该也可以</li><li>这题让我想到了全排列的解法</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.<br>2：”abc”, 3-“def”, 4-“ghi”, 5-“jkl”, 6-“mno”, 7-“pqrs”, 8-“tuv”, 9-“wxyz”</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>“23”<br><strong>Output:</strong>[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>递归，当后面的全部完成了排列之后，前面的加上就是全部的排列方式，这里要记录前缀，到最后没有数字的时候，就添加前缀并返回</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:        </span><br><span class=\"line\">    <span class=\"built_in\">string</span> mapChar[<span class=\"number\">10</span>] = &#123;<span class=\"string\">\"\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"abc\"</span>,<span class=\"string\">\"def\"</span>,<span class=\"string\">\"ghi\"</span>,<span class=\"string\">\"jkl\"</span>,<span class=\"string\">\"mno\"</span>,<span class=\"string\">\"pqrs\"</span>,<span class=\"string\">\"tuv\"</span>,<span class=\"string\">\"wxyz\"</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; letterCombinations(<span class=\"built_in\">string</span> digits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(digits.length()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; res;</span><br><span class=\"line\">        recurDigit(digits,<span class=\"string\">\"\"</span>,res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recurDigit</span><span class=\"params\">(<span class=\"built_in\">string</span> digits,<span class=\"built_in\">string</span> prefix, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//边界条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(digits==<span class=\"string\">\"\"</span>) &#123;</span><br><span class=\"line\">            res.push_back(prefix);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">string</span> key = mapChar[digits[<span class=\"number\">0</span>]-<span class=\"string\">'0'</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = key.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">            recurDigit(digits.substr(<span class=\"number\">1</span>), prefix+key[i], res);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>递归要处理好边界条件，这里是当digits为空的时候，就返回</li><li>这里用了记录前缀的方式，感觉也可以使用前面的加上后缀的方式，返回的时候返回字符，应该也可以</li><li>这题让我想到了全排列的解法</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-019-Remove Nth Node From End of List","urlname":"leetcode-remove-nth-node-from-end-of-list","comments":1,"mathjax":false,"date":"2019-07-21T15:51:02.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/)   \nGiven a linked list, remove the n-th node from the end of list and return its head.\n\nNote:\nGiven n will always be valid.\n\n### Examples:\n**Input:**1->2->3->4->5, and n = 2.\nAfter removing the second node from the end, the linked list becomes 1->2->3->5.\n{% endnote %}\n<!--more-->\n\n## Solutions\n-\n第一种方法是两次遍历,第一次计算出一共多少个节点,然后算出应该向后移动多少次,\n找到那个节点, 删掉\n- 第二种方法是使用双指针一次遍历, 两个指针初始化为head,\n后一个指针先跑n步, 然后当后一个指针到达最后一个位置时,\n前一个指针是倒数第n+1个, 删掉第n个位置就可以\n\n## C++ Codes\n双指针\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* p = head;\n        ListNode* pre=head;\n        for(n;n>=1;n--) p=p->next;\n        if(p==NULL)return head->next;\n        while(p->next!=NULL){\n            p=p->next;\n            pre=pre->next;\n        }\n        pre->next=pre->next->next;\n        return head;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        if not head:return \n        dummy = ListNode(0)\n        dummy.next = head\n        fast = dummy\n        while n:\n            fast = fast.next\n            n -= 1\n        slow = dummy\n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n        slow.next = slow.next.next\n        return dummy.next\n```\n\n## 总结\n- 双指针另一个用法: 链表固定相差n个位置移动, 查找节点\n\n------\n","source":"_posts/LeetCode/LeetCode-019-Remove-Nth-Node-From-End-of-List.md","raw":"---\ntitle: LeetCode-019-Remove Nth Node From End of List\ntags:\n  - LeetCode\n  - Algorithm\n  - LinkedList\n  - TwoPointer\n  - Medium\ncategories:\n  - LeetCode\nurlname: leetcode-remove-nth-node-from-end-of-list\ncomments: true\nmathjax: false\ndate: 2019-07-21 23:51:02\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/)   \nGiven a linked list, remove the n-th node from the end of list and return its head.\n\nNote:\nGiven n will always be valid.\n\n### Examples:\n**Input:**1->2->3->4->5, and n = 2.\nAfter removing the second node from the end, the linked list becomes 1->2->3->5.\n{% endnote %}\n<!--more-->\n\n## Solutions\n-\n第一种方法是两次遍历,第一次计算出一共多少个节点,然后算出应该向后移动多少次,\n找到那个节点, 删掉\n- 第二种方法是使用双指针一次遍历, 两个指针初始化为head,\n后一个指针先跑n步, 然后当后一个指针到达最后一个位置时,\n前一个指针是倒数第n+1个, 删掉第n个位置就可以\n\n## C++ Codes\n双指针\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* p = head;\n        ListNode* pre=head;\n        for(n;n>=1;n--) p=p->next;\n        if(p==NULL)return head->next;\n        while(p->next!=NULL){\n            p=p->next;\n            pre=pre->next;\n        }\n        pre->next=pre->next->next;\n        return head;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        if not head:return \n        dummy = ListNode(0)\n        dummy.next = head\n        fast = dummy\n        while n:\n            fast = fast.next\n            n -= 1\n        slow = dummy\n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n        slow.next = slow.next.next\n        return dummy.next\n```\n\n## 总结\n- 双指针另一个用法: 链表固定相差n个位置移动, 查找节点\n\n------\n","slug":"LeetCode/LeetCode-019-Remove-Nth-Node-From-End-of-List","published":1,"updated":"2019-07-25T17:59:21.026Z","layout":"post","photos":[],"link":"","_id":"ck2424lts006llksbd02qcx81","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a linked list, remove the n-th node from the end of list and return its head.</p><p>Note:<br>Given n will always be valid.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.<br>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><p>-<br>第一种方法是两次遍历,第一次计算出一共多少个节点,然后算出应该向后移动多少次,<br>找到那个节点, 删掉</p><ul><li>第二种方法是使用双指针一次遍历, 两个指针初始化为head,<br>后一个指针先跑n步, 然后当后一个指针到达最后一个位置时,<br>前一个指针是倒数第n+1个, 删掉第n个位置就可以</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>双指针<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* p = head;</span><br><span class=\"line\">        ListNode* pre=head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(n;n&gt;=<span class=\"number\">1</span>;n--) p=p-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p-&gt;next!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            p=p-&gt;next;</span><br><span class=\"line\">            pre=pre-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre-&gt;next=pre-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:<span class=\"keyword\">return</span> </span><br><span class=\"line\">        dummy = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        dummy.next = head</span><br><span class=\"line\">        fast = dummy</span><br><span class=\"line\">        <span class=\"keyword\">while</span> n:</span><br><span class=\"line\">            fast = fast.next</span><br><span class=\"line\">            n -= <span class=\"number\">1</span></span><br><span class=\"line\">        slow = dummy</span><br><span class=\"line\">        <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">            fast = fast.next</span><br><span class=\"line\">            slow = slow.next</span><br><span class=\"line\">        slow.next = slow.next.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>双指针另一个用法: 链表固定相差n个位置移动, 查找节点</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a linked list, remove the n-th node from the end of list and return its head.</p><p>Note:<br>Given n will always be valid.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.<br>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><p>-<br>第一种方法是两次遍历,第一次计算出一共多少个节点,然后算出应该向后移动多少次,<br>找到那个节点, 删掉</p><ul><li>第二种方法是使用双指针一次遍历, 两个指针初始化为head,<br>后一个指针先跑n步, 然后当后一个指针到达最后一个位置时,<br>前一个指针是倒数第n+1个, 删掉第n个位置就可以</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>双指针<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* p = head;</span><br><span class=\"line\">        ListNode* pre=head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(n;n&gt;=<span class=\"number\">1</span>;n--) p=p-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p-&gt;next!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            p=p-&gt;next;</span><br><span class=\"line\">            pre=pre-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre-&gt;next=pre-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:<span class=\"keyword\">return</span> </span><br><span class=\"line\">        dummy = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        dummy.next = head</span><br><span class=\"line\">        fast = dummy</span><br><span class=\"line\">        <span class=\"keyword\">while</span> n:</span><br><span class=\"line\">            fast = fast.next</span><br><span class=\"line\">            n -= <span class=\"number\">1</span></span><br><span class=\"line\">        slow = dummy</span><br><span class=\"line\">        <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">            fast = fast.next</span><br><span class=\"line\">            slow = slow.next</span><br><span class=\"line\">        slow.next = slow.next.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>双指针另一个用法: 链表固定相差n个位置移动, 查找节点</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-018-4Sum","urlname":"leetcode-4sum","comments":1,"mathjax":false,"date":"2019-07-17T07:00:41.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/4sum/)  \nGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n\n**Note:**\nThe solution set must not contain duplicate quadruplets.\n\n### Examples:\n**Input:** nums = [1, 0, -1, 0, -2, 2], and target = 0\n**Output:**\nA solution set is:\n> [\n> [-1, 0, 0, 1],\n> [-2, -1, 1, 2],\n> [-2, 0, 0, 2]\n> ]\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n-\n和[第15题3Sum](https://catchdream.me/2019/05/19/LeetCode-015-3Sum/)思路类似，十五题是固定一个数字，然后双指针求三数之和，这题固定两个数字，然后双指针求四数之和。其实原理和3Sum一样\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    set<vector<int> >res;\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        if(nums.size()<4)return {};\n        sort(nums.begin(), nums.end());\n        for(int i=0;i<nums.size()-3;i++){\n            for(int j=i+1;j<nums.size()-2;j++){\n                int l = j+1;\n                int r = nums.size()-1;\n                while(l<r){\n                    int tmp = nums[i]+nums[j]+nums[l]+nums[r];\n                    if(tmp==target){\n                        res.insert({nums[i], nums[j], nums[l], nums[r]});\n                        r--;\n                        l++;\n                    }\n                    else if(tmp>target) r--;\n                    else if(tmp<target) l++;\n                }\n            }\n        }\n        return vector<vector<int> >(res.begin(), res.end());\n    }\n};\n```\n\n## Python Codes\n为啥我总是不想用python再写一遍，感觉很没意思…\n附上题解里找到[Python版本代码](https://leetcode-cn.com/problems/4sum/solution/gu-ding-liang-ge-shu-yong-shuang-zhi-zhen-zhao-lin/)\n\n```python\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        n = len(nums)\n        if n < 4: return []\n        nums.sort()\n        res = []\n        for i in range(n-3):\n            # 防止重复 数组进入 res\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            # 当数组最小值和都大于target 跳出\n            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target:\n                break\n            # 当数组最大值和都小于target,说明i这个数还是太小,遍历下一个\n            if nums[i] + nums[n-1] + nums[n-2] + nums[n-3] < target:\n                continue\n            for j in range(i+1,n-2):\n                # 防止重复 数组进入 res\n                if j - i > 1 and nums[j] == nums[j-1]:\n                    continue\n                # 同理\n                if nums[i] + nums[j] + nums[j+1] + nums[j+2] > target:\n                    break\n                # 同理\n                if nums[i] + nums[j] + nums[n-1] + nums[n-2] < target:\n                    continue\n                # 双指针\n                left = j + 1\n                right = n - 1\n                while left < right:\n                    tmp = nums[i] + nums[j] + nums[left] + nums[right]\n                    if tmp == target:\n                        res.append([nums[i],nums[j],nums[left],nums[right]])\n                        while left < right and nums[left] == nums[left+1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right-1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif tmp > target:\n                        right -= 1\n                    else:\n                        left += 1\n        return res\n```\n\n## 总结\n- 双指针用法之一：找目标数字，四个数可以固定两个数，另外两个数双指针求\n- 差不多类型的题，，，要学会套,举一反三不成,举一反一可以把\n\n\n------\n","source":"_posts/LeetCode/LeetCode-018-4Sum.md","raw":"---\ntitle: LeetCode-018-4Sum\ntags:\n  - LeetCode\n  - Algorithm\n  - Math\n  - TwoPointer\n  - Medium\ncategories:\n  - LeetCode\nurlname: leetcode-4sum\ncomments: true\nmathjax: false\ndate: 2019-07-17 15:00:41\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/4sum/)  \nGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n\n**Note:**\nThe solution set must not contain duplicate quadruplets.\n\n### Examples:\n**Input:** nums = [1, 0, -1, 0, -2, 2], and target = 0\n**Output:**\nA solution set is:\n> [\n> [-1, 0, 0, 1],\n> [-2, -1, 1, 2],\n> [-2, 0, 0, 2]\n> ]\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n-\n和[第15题3Sum](https://catchdream.me/2019/05/19/LeetCode-015-3Sum/)思路类似，十五题是固定一个数字，然后双指针求三数之和，这题固定两个数字，然后双指针求四数之和。其实原理和3Sum一样\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    set<vector<int> >res;\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        if(nums.size()<4)return {};\n        sort(nums.begin(), nums.end());\n        for(int i=0;i<nums.size()-3;i++){\n            for(int j=i+1;j<nums.size()-2;j++){\n                int l = j+1;\n                int r = nums.size()-1;\n                while(l<r){\n                    int tmp = nums[i]+nums[j]+nums[l]+nums[r];\n                    if(tmp==target){\n                        res.insert({nums[i], nums[j], nums[l], nums[r]});\n                        r--;\n                        l++;\n                    }\n                    else if(tmp>target) r--;\n                    else if(tmp<target) l++;\n                }\n            }\n        }\n        return vector<vector<int> >(res.begin(), res.end());\n    }\n};\n```\n\n## Python Codes\n为啥我总是不想用python再写一遍，感觉很没意思…\n附上题解里找到[Python版本代码](https://leetcode-cn.com/problems/4sum/solution/gu-ding-liang-ge-shu-yong-shuang-zhi-zhen-zhao-lin/)\n\n```python\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        n = len(nums)\n        if n < 4: return []\n        nums.sort()\n        res = []\n        for i in range(n-3):\n            # 防止重复 数组进入 res\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            # 当数组最小值和都大于target 跳出\n            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target:\n                break\n            # 当数组最大值和都小于target,说明i这个数还是太小,遍历下一个\n            if nums[i] + nums[n-1] + nums[n-2] + nums[n-3] < target:\n                continue\n            for j in range(i+1,n-2):\n                # 防止重复 数组进入 res\n                if j - i > 1 and nums[j] == nums[j-1]:\n                    continue\n                # 同理\n                if nums[i] + nums[j] + nums[j+1] + nums[j+2] > target:\n                    break\n                # 同理\n                if nums[i] + nums[j] + nums[n-1] + nums[n-2] < target:\n                    continue\n                # 双指针\n                left = j + 1\n                right = n - 1\n                while left < right:\n                    tmp = nums[i] + nums[j] + nums[left] + nums[right]\n                    if tmp == target:\n                        res.append([nums[i],nums[j],nums[left],nums[right]])\n                        while left < right and nums[left] == nums[left+1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right-1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif tmp > target:\n                        right -= 1\n                    else:\n                        left += 1\n        return res\n```\n\n## 总结\n- 双指针用法之一：找目标数字，四个数可以固定两个数，另外两个数双指针求\n- 差不多类型的题，，，要学会套,举一反三不成,举一反一可以把\n\n\n------\n","slug":"LeetCode/LeetCode-018-4Sum","published":1,"updated":"2019-07-25T17:58:52.523Z","layout":"post","photos":[],"link":"","_id":"ck2424ltt006olksbf6kcf3ce","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/4sum/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p><p><strong>Note:</strong><br>The solution set must not contain duplicate quadruplets.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> nums = [1, 0, -1, 0, -2, 2], and target = 0<br><strong>Output:</strong><br>A solution set is:</p><blockquote><p>[<br>[-1, 0, 0, 1],<br>[-2, -1, 1, 2],<br>[-2, 0, 0, 2]<br>]</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><p>-<br>和<a href=\"https://catchdream.me/2019/05/19/LeetCode-015-3Sum/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">第15题3Sum</a>思路类似，十五题是固定一个数字，然后双指针求三数之和，这题固定两个数字，然后双指针求四数之和。其实原理和3Sum一样</p><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt;res;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; fourSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.size()&lt;<span class=\"number\">4</span>)<span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        sort(nums.begin(), nums.end());</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.size()<span class=\"number\">-3</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;nums.size()<span class=\"number\">-2</span>;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> l = j+<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = nums.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tmp = nums[i]+nums[j]+nums[l]+nums[r];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(tmp==target)&#123;</span><br><span class=\"line\">                        res.insert(&#123;nums[i], nums[j], nums[l], nums[r]&#125;);</span><br><span class=\"line\">                        r--;</span><br><span class=\"line\">                        l++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp&gt;target) r--;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp&lt;target) l++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt;(res.begin(), res.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>为啥我总是不想用python再写一遍，感觉很没意思…<br>附上题解里找到<a href=\"https://leetcode-cn.com/problems/4sum/solution/gu-ding-liang-ge-shu-yong-shuang-zhi-zhen-zhao-lin/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Python版本代码</a></p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">4</span>: <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        res = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-3</span>):</span><br><span class=\"line\">            <span class=\"comment\"># 防止重复 数组进入 res</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"comment\"># 当数组最小值和都大于target 跳出</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] + nums[i+<span class=\"number\">1</span>] + nums[i+<span class=\"number\">2</span>] + nums[i+<span class=\"number\">3</span>] &gt; target:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"comment\"># 当数组最大值和都小于target,说明i这个数还是太小,遍历下一个</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] + nums[n<span class=\"number\">-1</span>] + nums[n<span class=\"number\">-2</span>] + nums[n<span class=\"number\">-3</span>] &lt; target:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>,n<span class=\"number\">-2</span>):</span><br><span class=\"line\">                <span class=\"comment\"># 防止重复 数组进入 res</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> j - i &gt; <span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[j] == nums[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"comment\"># 同理</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[i] + nums[j] + nums[j+<span class=\"number\">1</span>] + nums[j+<span class=\"number\">2</span>] &gt; target:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"comment\"># 同理</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[i] + nums[j] + nums[n<span class=\"number\">-1</span>] + nums[n<span class=\"number\">-2</span>] &lt; target:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"comment\"># 双指针</span></span><br><span class=\"line\">                left = j + <span class=\"number\">1</span></span><br><span class=\"line\">                right = n - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">                    tmp = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> tmp == target:</span><br><span class=\"line\">                        res.append([nums[i],nums[j],nums[left],nums[right]])</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> nums[left] == nums[left+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                            left += <span class=\"number\">1</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> nums[right] == nums[right<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                            right -= <span class=\"number\">1</span></span><br><span class=\"line\">                        left += <span class=\"number\">1</span></span><br><span class=\"line\">                        right -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> tmp &gt; target:</span><br><span class=\"line\">                        right -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        left += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>双指针用法之一：找目标数字，四个数可以固定两个数，另外两个数双指针求</li><li>差不多类型的题，，，要学会套,举一反三不成,举一反一可以把</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/4sum/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p><p><strong>Note:</strong><br>The solution set must not contain duplicate quadruplets.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> nums = [1, 0, -1, 0, -2, 2], and target = 0<br><strong>Output:</strong><br>A solution set is:</p><blockquote><p>[<br>[-1, 0, 0, 1],<br>[-2, -1, 1, 2],<br>[-2, 0, 0, 2]<br>]</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><p>-<br>和<a href=\"https://catchdream.me/2019/05/19/LeetCode-015-3Sum/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">第15题3Sum</a>思路类似，十五题是固定一个数字，然后双指针求三数之和，这题固定两个数字，然后双指针求四数之和。其实原理和3Sum一样</p><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">set</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt;res;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; fourSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.size()&lt;<span class=\"number\">4</span>)<span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        sort(nums.begin(), nums.end());</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.size()<span class=\"number\">-3</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;nums.size()<span class=\"number\">-2</span>;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> l = j+<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = nums.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tmp = nums[i]+nums[j]+nums[l]+nums[r];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(tmp==target)&#123;</span><br><span class=\"line\">                        res.insert(&#123;nums[i], nums[j], nums[l], nums[r]&#125;);</span><br><span class=\"line\">                        r--;</span><br><span class=\"line\">                        l++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp&gt;target) r--;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp&lt;target) l++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt;(res.begin(), res.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>为啥我总是不想用python再写一遍，感觉很没意思…<br>附上题解里找到<a href=\"https://leetcode-cn.com/problems/4sum/solution/gu-ding-liang-ge-shu-yong-shuang-zhi-zhen-zhao-lin/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Python版本代码</a></p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fourSum</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">4</span>: <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        res = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n<span class=\"number\">-3</span>):</span><br><span class=\"line\">            <span class=\"comment\"># 防止重复 数组进入 res</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"comment\"># 当数组最小值和都大于target 跳出</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] + nums[i+<span class=\"number\">1</span>] + nums[i+<span class=\"number\">2</span>] + nums[i+<span class=\"number\">3</span>] &gt; target:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"comment\"># 当数组最大值和都小于target,说明i这个数还是太小,遍历下一个</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] + nums[n<span class=\"number\">-1</span>] + nums[n<span class=\"number\">-2</span>] + nums[n<span class=\"number\">-3</span>] &lt; target:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>,n<span class=\"number\">-2</span>):</span><br><span class=\"line\">                <span class=\"comment\"># 防止重复 数组进入 res</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> j - i &gt; <span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[j] == nums[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"comment\"># 同理</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[i] + nums[j] + nums[j+<span class=\"number\">1</span>] + nums[j+<span class=\"number\">2</span>] &gt; target:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"comment\"># 同理</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[i] + nums[j] + nums[n<span class=\"number\">-1</span>] + nums[n<span class=\"number\">-2</span>] &lt; target:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"comment\"># 双指针</span></span><br><span class=\"line\">                left = j + <span class=\"number\">1</span></span><br><span class=\"line\">                right = n - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">                    tmp = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> tmp == target:</span><br><span class=\"line\">                        res.append([nums[i],nums[j],nums[left],nums[right]])</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> nums[left] == nums[left+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                            left += <span class=\"number\">1</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> nums[right] == nums[right<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                            right -= <span class=\"number\">1</span></span><br><span class=\"line\">                        left += <span class=\"number\">1</span></span><br><span class=\"line\">                        right -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> tmp &gt; target:</span><br><span class=\"line\">                        right -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        left += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>双指针用法之一：找目标数字，四个数可以固定两个数，另外两个数双指针求</li><li>差不多类型的题，，，要学会套,举一反三不成,举一反一可以把</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-024-Swap Nodes in Pairs","urlname":"leetcode-swap-nodes-in-pairs","comments":1,"mathjax":false,"date":"2019-07-23T17:15:46.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)   \nGiven a linked list, swap every two adjacent nodes and return its head.\n\nYou may **not** modify the values in the list's nodes, only nodes itself may be changed.\n\n### Examples:\n**Input:** 1-2-3-4\n**Output:** 2-1-4-3\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 很直接的, 每两个节点交换一下顺序, 可以递归但是并不需要.\n- 指针之间的交换要注意不要漏了某个next的赋值, 可能会导致出现环\n- 多指针的题目宁愿多弄几个变量, 更清楚, 而不是一直next, next这样赋值\n\n## C++ Codes\n**非递归做法**\n8ms, 一般般把, 题目不是特别复杂\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head==NULL || head->next==NULL)return head;\n        ListNode* q=head->next;\n        ListNode *t, *s, *tmp;\n        t=q->next;//第三个节点\n        //交换第一第二节点, head->q 变为q->head, 然后q等于第二个节点\n        q->next=head;\n        head->next=t;\n        head=q;\n        q=head->next;\n        //1234, 此时变为2134, q->val=1, t->val=3, s->val=4, tmp=NULL\n        while(t!=NULL && t->next!=NULL){\n            s=t->next;\n            //tmp用于t的迭代\n            tmp=s->next;\n            //令q->next等于第四个节点, 且交换3, 4节点, t->s变成s->t\n            q->next=s;\n            s->next=t;\n            //这步防止t和s形成环, t->next==s, s->next==t\n            t->next=tmp;\n            //更新q和t\n            q=t;\n            t=tmp;\n        }\n        return head;\n    }\n};\n```\n\n**递归做法**\n\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head==nullptr || head->next==nullptr) {\n            return head;\n        }\n\n        ListNode *p1 = head;\n        ListNode *p2 = p1->next;\n\n        p1->next = swapPairs(p2->next);\n        p2->next = p1;\n\n        return p2;\n    }\n};\n```\n\n## Python Codes\n\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        pre = ListNode(0)\n        p = pre\n        h = head\n        while h:\n            if h and h.next:\n                tmp = h.next\n                p.next = tmp\n                h.next = h.next.next\n                tmp.next = h\n                h = h.next\n                p = p.next.next\n            else:\n                p.next = h\n                h = h.next\n        return pre.next\n```\n\n## 总结\n- 链表指针操作要注意别出现环\n------\n","source":"_posts/LeetCode/LeetCode-024-Swap-Nodes-in-Pairs.md","raw":"---\ntitle: LeetCode-024-Swap Nodes in Pairs\ntags:\n  - LeetCode\n  - Algorithm\n  - Swap\n  - LinkedList\n  - Medium\ncategories:\n  - LeetCode\nurlname: leetcode-swap-nodes-in-pairs\ncomments: true\nmathjax: false\ndate: 2019-07-24 01:15:46\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)   \nGiven a linked list, swap every two adjacent nodes and return its head.\n\nYou may **not** modify the values in the list's nodes, only nodes itself may be changed.\n\n### Examples:\n**Input:** 1-2-3-4\n**Output:** 2-1-4-3\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 很直接的, 每两个节点交换一下顺序, 可以递归但是并不需要.\n- 指针之间的交换要注意不要漏了某个next的赋值, 可能会导致出现环\n- 多指针的题目宁愿多弄几个变量, 更清楚, 而不是一直next, next这样赋值\n\n## C++ Codes\n**非递归做法**\n8ms, 一般般把, 题目不是特别复杂\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head==NULL || head->next==NULL)return head;\n        ListNode* q=head->next;\n        ListNode *t, *s, *tmp;\n        t=q->next;//第三个节点\n        //交换第一第二节点, head->q 变为q->head, 然后q等于第二个节点\n        q->next=head;\n        head->next=t;\n        head=q;\n        q=head->next;\n        //1234, 此时变为2134, q->val=1, t->val=3, s->val=4, tmp=NULL\n        while(t!=NULL && t->next!=NULL){\n            s=t->next;\n            //tmp用于t的迭代\n            tmp=s->next;\n            //令q->next等于第四个节点, 且交换3, 4节点, t->s变成s->t\n            q->next=s;\n            s->next=t;\n            //这步防止t和s形成环, t->next==s, s->next==t\n            t->next=tmp;\n            //更新q和t\n            q=t;\n            t=tmp;\n        }\n        return head;\n    }\n};\n```\n\n**递归做法**\n\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head==nullptr || head->next==nullptr) {\n            return head;\n        }\n\n        ListNode *p1 = head;\n        ListNode *p2 = p1->next;\n\n        p1->next = swapPairs(p2->next);\n        p2->next = p1;\n\n        return p2;\n    }\n};\n```\n\n## Python Codes\n\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        pre = ListNode(0)\n        p = pre\n        h = head\n        while h:\n            if h and h.next:\n                tmp = h.next\n                p.next = tmp\n                h.next = h.next.next\n                tmp.next = h\n                h = h.next\n                p = p.next.next\n            else:\n                p.next = h\n                h = h.next\n        return pre.next\n```\n\n## 总结\n- 链表指针操作要注意别出现环\n------\n","slug":"LeetCode/LeetCode-024-Swap-Nodes-in-Pairs","published":1,"updated":"2019-07-25T18:27:33.469Z","layout":"post","photos":[],"link":"","_id":"ck2424ltu006slksbyjdo1il4","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> 1-2-3-4<br><strong>Output:</strong> 2-1-4-3</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>很直接的, 每两个节点交换一下顺序, 可以递归但是并不需要.</li><li>指针之间的交换要注意不要漏了某个next的赋值, 可能会导致出现环</li><li>多指针的题目宁愿多弄几个变量, 更清楚, 而不是一直next, next这样赋值</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p><strong>非递归做法</strong><br>8ms, 一般般把, 题目不是特别复杂</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span> || head-&gt;next==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode* q=head-&gt;next;</span><br><span class=\"line\">        ListNode *t, *s, *tmp;</span><br><span class=\"line\">        t=q-&gt;next;<span class=\"comment\">//第三个节点</span></span><br><span class=\"line\">        <span class=\"comment\">//交换第一第二节点, head-&gt;q 变为q-&gt;head, 然后q等于第二个节点</span></span><br><span class=\"line\">        q-&gt;next=head;</span><br><span class=\"line\">        head-&gt;next=t;</span><br><span class=\"line\">        head=q;</span><br><span class=\"line\">        q=head-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">//1234, 此时变为2134, q-&gt;val=1, t-&gt;val=3, s-&gt;val=4, tmp=NULL</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(t!=<span class=\"literal\">NULL</span> &amp;&amp; t-&gt;next!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            s=t-&gt;next;</span><br><span class=\"line\">            <span class=\"comment\">//tmp用于t的迭代</span></span><br><span class=\"line\">            tmp=s-&gt;next;</span><br><span class=\"line\">            <span class=\"comment\">//令q-&gt;next等于第四个节点, 且交换3, 4节点, t-&gt;s变成s-&gt;t</span></span><br><span class=\"line\">            q-&gt;next=s;</span><br><span class=\"line\">            s-&gt;next=t;</span><br><span class=\"line\">            <span class=\"comment\">//这步防止t和s形成环, t-&gt;next==s, s-&gt;next==t</span></span><br><span class=\"line\">            t-&gt;next=tmp;</span><br><span class=\"line\">            <span class=\"comment\">//更新q和t</span></span><br><span class=\"line\">            q=t;</span><br><span class=\"line\">            t=tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p><strong>递归做法</strong></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head==<span class=\"literal\">nullptr</span> || head-&gt;next==<span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode *p1 = head;</span><br><span class=\"line\">        ListNode *p2 = p1-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        p1-&gt;next = swapPairs(p2-&gt;next);</span><br><span class=\"line\">        p2-&gt;next = p1;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">swapPairs</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        pre = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p = pre</span><br><span class=\"line\">        h = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> h:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> h <span class=\"keyword\">and</span> h.next:</span><br><span class=\"line\">                tmp = h.next</span><br><span class=\"line\">                p.next = tmp</span><br><span class=\"line\">                h.next = h.next.next</span><br><span class=\"line\">                tmp.next = h</span><br><span class=\"line\">                h = h.next</span><br><span class=\"line\">                p = p.next.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                p.next = h</span><br><span class=\"line\">                h = h.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre.next</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h2 id=\"链表指针操作要注意别出现环\"><a href=\"#链表指针操作要注意别出现环\" class=\"headerlink\" title=\"- 链表指针操作要注意别出现环\"></a>- 链表指针操作要注意别出现环</h2><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> 1-2-3-4<br><strong>Output:</strong> 2-1-4-3</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>很直接的, 每两个节点交换一下顺序, 可以递归但是并不需要.</li><li>指针之间的交换要注意不要漏了某个next的赋值, 可能会导致出现环</li><li>多指针的题目宁愿多弄几个变量, 更清楚, 而不是一直next, next这样赋值</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p><strong>非递归做法</strong><br>8ms, 一般般把, 题目不是特别复杂</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span> || head-&gt;next==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode* q=head-&gt;next;</span><br><span class=\"line\">        ListNode *t, *s, *tmp;</span><br><span class=\"line\">        t=q-&gt;next;<span class=\"comment\">//第三个节点</span></span><br><span class=\"line\">        <span class=\"comment\">//交换第一第二节点, head-&gt;q 变为q-&gt;head, 然后q等于第二个节点</span></span><br><span class=\"line\">        q-&gt;next=head;</span><br><span class=\"line\">        head-&gt;next=t;</span><br><span class=\"line\">        head=q;</span><br><span class=\"line\">        q=head-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">//1234, 此时变为2134, q-&gt;val=1, t-&gt;val=3, s-&gt;val=4, tmp=NULL</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(t!=<span class=\"literal\">NULL</span> &amp;&amp; t-&gt;next!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            s=t-&gt;next;</span><br><span class=\"line\">            <span class=\"comment\">//tmp用于t的迭代</span></span><br><span class=\"line\">            tmp=s-&gt;next;</span><br><span class=\"line\">            <span class=\"comment\">//令q-&gt;next等于第四个节点, 且交换3, 4节点, t-&gt;s变成s-&gt;t</span></span><br><span class=\"line\">            q-&gt;next=s;</span><br><span class=\"line\">            s-&gt;next=t;</span><br><span class=\"line\">            <span class=\"comment\">//这步防止t和s形成环, t-&gt;next==s, s-&gt;next==t</span></span><br><span class=\"line\">            t-&gt;next=tmp;</span><br><span class=\"line\">            <span class=\"comment\">//更新q和t</span></span><br><span class=\"line\">            q=t;</span><br><span class=\"line\">            t=tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p><strong>递归做法</strong></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head==<span class=\"literal\">nullptr</span> || head-&gt;next==<span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode *p1 = head;</span><br><span class=\"line\">        ListNode *p2 = p1-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        p1-&gt;next = swapPairs(p2-&gt;next);</span><br><span class=\"line\">        p2-&gt;next = p1;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">swapPairs</span><span class=\"params\">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        pre = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p = pre</span><br><span class=\"line\">        h = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> h:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> h <span class=\"keyword\">and</span> h.next:</span><br><span class=\"line\">                tmp = h.next</span><br><span class=\"line\">                p.next = tmp</span><br><span class=\"line\">                h.next = h.next.next</span><br><span class=\"line\">                tmp.next = h</span><br><span class=\"line\">                h = h.next</span><br><span class=\"line\">                p = p.next.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                p.next = h</span><br><span class=\"line\">                h = h.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre.next</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h2 id=\"链表指针操作要注意别出现环\"><a href=\"#链表指针操作要注意别出现环\" class=\"headerlink\" title=\"- 链表指针操作要注意别出现环\"></a>- 链表指针操作要注意别出现环</h2><!-- rebuild by neat -->"},{"title":"LeetCode-020-Valid Parentheses","urlname":"leetcode-valid-parentheses","comments":1,"mathjax":false,"date":"2019-05-22T05:59:04.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/valid-parentheses/)   \nGiven a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n\nNote that an empty string is also considered valid.\n\n### Examples:\n**Input:**\"()\"\n**Output:** true\n**Input:**\"[(])\"\n**Output:** false\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 简单的利用栈，如果是左括号，就入栈，如果是右括号，就和栈顶匹配，相同，就让栈顶出栈，否则返回错误 ，这里用哈希表映射左右括号\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    bool isValid(string s) {\n        if(s.length()==0)return true;\n        \n        //定义栈和哈希表\n        stack<char> chstack;\n        map<char,char> mp;\n        mp[')']='(';\n        mp[']']='[';\n        mp['}']='{';\n\n        for(int i=0;i<s.length();i++){\n            //左括号入栈\n            if(s[i]=='(' || s[i]=='[' || s[i]=='{'){\n                chstack.push(s[i]);\n            }\n            //右括号匹配栈顶\n            else{\n                if(chstack.empty()) return false;\n                if(mp[s[i]]==chstack.top()) chstack.pop();\n                else return false;\n            }\n        }\n        //如果匹配完了栈为空，就是符合要求的\n        if(chstack.empty())return true;\n        else return false;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        lookup = {\n            \"(\":\")\",\n            \"[\":\"]\",\n            \"{\":\"}\"\n        }\n        for alp in s:\n            if alp in lookup:\n                stack.append(alp)\n                continue\n            if stack and lookup[stack[-1]] == alp:\n                stack.pop()\n            else:\n                return False\n        return True if not stack else False\n```\n\n## 总结\n- 做过的题，简单的利用出栈入栈进行括号匹配 \n\n\n------\n","source":"_posts/LeetCode/LeetCode-020-Valid-Parentheses.md","raw":"---\ntitle: LeetCode-020-Valid Parentheses\ntags:\n  - LeetCode\n  - Algorithm\n  - Stack\n  - Pair\n  - String\n  - Easy\ncategories:\n  - LeetCode\nurlname: leetcode-valid-parentheses\ncomments: true\nmathjax: false\ndate: 2019-05-22 13:59:04\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/valid-parentheses/)   \nGiven a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n\nNote that an empty string is also considered valid.\n\n### Examples:\n**Input:**\"()\"\n**Output:** true\n**Input:**\"[(])\"\n**Output:** false\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 简单的利用栈，如果是左括号，就入栈，如果是右括号，就和栈顶匹配，相同，就让栈顶出栈，否则返回错误 ，这里用哈希表映射左右括号\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    bool isValid(string s) {\n        if(s.length()==0)return true;\n        \n        //定义栈和哈希表\n        stack<char> chstack;\n        map<char,char> mp;\n        mp[')']='(';\n        mp[']']='[';\n        mp['}']='{';\n\n        for(int i=0;i<s.length();i++){\n            //左括号入栈\n            if(s[i]=='(' || s[i]=='[' || s[i]=='{'){\n                chstack.push(s[i]);\n            }\n            //右括号匹配栈顶\n            else{\n                if(chstack.empty()) return false;\n                if(mp[s[i]]==chstack.top()) chstack.pop();\n                else return false;\n            }\n        }\n        //如果匹配完了栈为空，就是符合要求的\n        if(chstack.empty())return true;\n        else return false;\n    }\n};\n```\n\n## Python Codes\n\n```python\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        lookup = {\n            \"(\":\")\",\n            \"[\":\"]\",\n            \"{\":\"}\"\n        }\n        for alp in s:\n            if alp in lookup:\n                stack.append(alp)\n                continue\n            if stack and lookup[stack[-1]] == alp:\n                stack.pop()\n            else:\n                return False\n        return True if not stack else False\n```\n\n## 总结\n- 做过的题，简单的利用出栈入栈进行括号匹配 \n\n\n------\n","slug":"LeetCode/LeetCode-020-Valid-Parentheses","published":1,"updated":"2019-07-25T18:24:42.259Z","layout":"post","photos":[],"link":"","_id":"ck2424ltv006vlksb374gv5v8","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/valid-parentheses/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>“()”<br><strong>Output:</strong> true<br><strong>Input:</strong>“[(])”<br><strong>Output:</strong> false</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>简单的利用栈，如果是左括号，就入栈，如果是右括号，就和栈顶匹配，相同，就让栈顶出栈，否则返回错误 ，这里用哈希表映射左右括号</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//定义栈和哈希表</span></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; chstack;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">char</span>&gt; mp;</span><br><span class=\"line\">        mp[<span class=\"string\">')'</span>]=<span class=\"string\">'('</span>;</span><br><span class=\"line\">        mp[<span class=\"string\">']'</span>]=<span class=\"string\">'['</span>;</span><br><span class=\"line\">        mp[<span class=\"string\">'&#125;'</span>]=<span class=\"string\">'&#123;'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//左括号入栈</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">'('</span> || s[i]==<span class=\"string\">'['</span> || s[i]==<span class=\"string\">'&#123;'</span>)&#123;</span><br><span class=\"line\">                chstack.push(s[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//右括号匹配栈顶</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(chstack.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(mp[s[i]]==chstack.top()) chstack.pop();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果匹配完了栈为空，就是符合要求的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(chstack.empty())<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        lookup = &#123;</span><br><span class=\"line\">            <span class=\"string\">\"(\"</span>:<span class=\"string\">\")\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"[\"</span>:<span class=\"string\">\"]\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&#123;\"</span>:<span class=\"string\">\"&#125;\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> alp <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> alp <span class=\"keyword\">in</span> lookup:</span><br><span class=\"line\">                stack.append(alp)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> stack <span class=\"keyword\">and</span> lookup[stack[<span class=\"number\">-1</span>]] == alp:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span> <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> stack <span class=\"keyword\">else</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>做过的题，简单的利用出栈入栈进行括号匹配</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/valid-parentheses/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>“()”<br><strong>Output:</strong> true<br><strong>Input:</strong>“[(])”<br><strong>Output:</strong> false</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>简单的利用栈，如果是左括号，就入栈，如果是右括号，就和栈顶匹配，相同，就让栈顶出栈，否则返回错误 ，这里用哈希表映射左右括号</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//定义栈和哈希表</span></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; chstack;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">char</span>&gt; mp;</span><br><span class=\"line\">        mp[<span class=\"string\">')'</span>]=<span class=\"string\">'('</span>;</span><br><span class=\"line\">        mp[<span class=\"string\">']'</span>]=<span class=\"string\">'['</span>;</span><br><span class=\"line\">        mp[<span class=\"string\">'&#125;'</span>]=<span class=\"string\">'&#123;'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//左括号入栈</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">'('</span> || s[i]==<span class=\"string\">'['</span> || s[i]==<span class=\"string\">'&#123;'</span>)&#123;</span><br><span class=\"line\">                chstack.push(s[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//右括号匹配栈顶</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(chstack.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(mp[s[i]]==chstack.top()) chstack.pop();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果匹配完了栈为空，就是符合要求的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(chstack.empty())<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        lookup = &#123;</span><br><span class=\"line\">            <span class=\"string\">\"(\"</span>:<span class=\"string\">\")\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"[\"</span>:<span class=\"string\">\"]\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&#123;\"</span>:<span class=\"string\">\"&#125;\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> alp <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> alp <span class=\"keyword\">in</span> lookup:</span><br><span class=\"line\">                stack.append(alp)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> stack <span class=\"keyword\">and</span> lookup[stack[<span class=\"number\">-1</span>]] == alp:</span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span> <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> stack <span class=\"keyword\">else</span> <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>做过的题，简单的利用出栈入栈进行括号匹配</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-022-Generate Parentheses","urlname":"leetcode-generate-parentheses","comments":1,"mathjax":false,"date":"2019-07-22T17:00:33.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/generate-parentheses/)   \nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. \n\n### Examples:\n**Input:** n=3\n**Output:**\n> [\n>   \"((()))\",\n>   \"(()())\",\n>   \"(())()\",\n>   \"()(())\",\n>   \"()()()\"\n> ]\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 可以暴力求解, 将所有括号的全排列找出来,然后把里面括号匹配的拿出来\n- 动态规划, 第n个括号总是在第n-1个括号的基础上添加的,假设最左边的左括号是添加上去的. 那么, 前面的n-1个括号便分为两部分,在新加入括号内部的, 和不在新括号内部的. 我们遍历在括号内部的括号对数0-idx-1,然后遍历在括号内的每个排列, 以及不在括号内的每个排列, 将他们拼凑到一起\n\n\n## C++ Codes\n四层循环, 第一层求2-n的结果, 第二层遍历在新括号内部的括号对数, 第三层和第四层, 遍历在新括号内部的括号排列, 和不在括号内部的括号排列, 加起来就是一个新的排列\n\n```C++\nclass Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<vector<string> > dp(n+1);\n        dp[0]={\"\"};\n        dp[1]={\"()\"};\n        //假设最左边的左括号是第n对括号新加进来的\n        //遍历在第一个左括号对应的括号内的pair数, [0, idx-1]\n        for(int idx=2;idx<=n;idx++) \n            for(int i=0;i<=idx-1;i++)   //在第一个左括号内的括号数\n                for(string si:dp[i])    //在第一个括号内的括号数的每个排列\n                    for(string sk:dp[idx-1-i])  //不在第一个括号内的括号的每个排列\n                        dp[idx].push_back(\"(\"+si+\")\"+sk);\n\n        return dp[n];\n    }\n};\n```\n\n## Python Codes\n算法同C++\n\n```python\nclass Solutin:\n    def generateParenthesis(self, n: int) -> List[str]:\n        if n == 0:\n            return []\n        total_l = []\n        total_l.append([None])\n        total_l.append([\"()\"])\n        for i in range(2,n+1):  # 开始计算i时的括号组合，记为l\n            l = []\n            for j in range(i): #遍历所有可能的括号内外组合\n                now_list1 = total_l[j]\n                now_list2 = total_l[i-1-j]\n                for k1 in now_list1:  #开始具体取内外组合的实例\n                    for k2 in now_list2:\n                        if k1 == None:\n                            k1 = \"\"\n                        if k2 == None:\n                            k2 = \"\"\n                        el = \"(\" + k1 + \")\" + k2\n                        l.append(el)\n            total_l.append(l)\n        return total_l[n]\n```\n\n## 总结\n- 动态规划往往是递归转化过来, 如果能想到递归, 那可以考虑下DP怎么做, 当然, 暴力求解通常就是递归求解\n\n\n------\n","source":"_posts/LeetCode/LeetCode-022-Generate-Parentheses.md","raw":"---\ntitle: LeetCode-022-Generate Parentheses\ntags:\n  - LeetCode\n  - Algorithm\n  - Parentheses\n  - DP\n  - Medium\ncategories:\n  - LeetCode\nurlname: leetcode-generate-parentheses\ncomments: true\nmathjax: false\ndate: 2019-07-23 01:00:33\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/generate-parentheses/)   \nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. \n\n### Examples:\n**Input:** n=3\n**Output:**\n> [\n>   \"((()))\",\n>   \"(()())\",\n>   \"(())()\",\n>   \"()(())\",\n>   \"()()()\"\n> ]\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 可以暴力求解, 将所有括号的全排列找出来,然后把里面括号匹配的拿出来\n- 动态规划, 第n个括号总是在第n-1个括号的基础上添加的,假设最左边的左括号是添加上去的. 那么, 前面的n-1个括号便分为两部分,在新加入括号内部的, 和不在新括号内部的. 我们遍历在括号内部的括号对数0-idx-1,然后遍历在括号内的每个排列, 以及不在括号内的每个排列, 将他们拼凑到一起\n\n\n## C++ Codes\n四层循环, 第一层求2-n的结果, 第二层遍历在新括号内部的括号对数, 第三层和第四层, 遍历在新括号内部的括号排列, 和不在括号内部的括号排列, 加起来就是一个新的排列\n\n```C++\nclass Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<vector<string> > dp(n+1);\n        dp[0]={\"\"};\n        dp[1]={\"()\"};\n        //假设最左边的左括号是第n对括号新加进来的\n        //遍历在第一个左括号对应的括号内的pair数, [0, idx-1]\n        for(int idx=2;idx<=n;idx++) \n            for(int i=0;i<=idx-1;i++)   //在第一个左括号内的括号数\n                for(string si:dp[i])    //在第一个括号内的括号数的每个排列\n                    for(string sk:dp[idx-1-i])  //不在第一个括号内的括号的每个排列\n                        dp[idx].push_back(\"(\"+si+\")\"+sk);\n\n        return dp[n];\n    }\n};\n```\n\n## Python Codes\n算法同C++\n\n```python\nclass Solutin:\n    def generateParenthesis(self, n: int) -> List[str]:\n        if n == 0:\n            return []\n        total_l = []\n        total_l.append([None])\n        total_l.append([\"()\"])\n        for i in range(2,n+1):  # 开始计算i时的括号组合，记为l\n            l = []\n            for j in range(i): #遍历所有可能的括号内外组合\n                now_list1 = total_l[j]\n                now_list2 = total_l[i-1-j]\n                for k1 in now_list1:  #开始具体取内外组合的实例\n                    for k2 in now_list2:\n                        if k1 == None:\n                            k1 = \"\"\n                        if k2 == None:\n                            k2 = \"\"\n                        el = \"(\" + k1 + \")\" + k2\n                        l.append(el)\n            total_l.append(l)\n        return total_l[n]\n```\n\n## 总结\n- 动态规划往往是递归转化过来, 如果能想到递归, 那可以考虑下DP怎么做, 当然, 暴力求解通常就是递归求解\n\n\n------\n","slug":"LeetCode/LeetCode-022-Generate-Parentheses","published":1,"updated":"2019-07-25T18:26:27.056Z","layout":"post","photos":[],"link":"","_id":"ck2424ltx006zlksb7paxbkt5","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/generate-parentheses/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> n=3<br><strong>Output:</strong></p><blockquote><p>[<br>“((()))”,<br>“(()())”,<br>“(())()”,<br>“()(())”,<br>“()()()”<br>]</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>可以暴力求解, 将所有括号的全排列找出来,然后把里面括号匹配的拿出来</li><li>动态规划, 第n个括号总是在第n-1个括号的基础上添加的,假设最左边的左括号是添加上去的. 那么, 前面的n-1个括号便分为两部分,在新加入括号内部的, 和不在新括号内部的. 我们遍历在括号内部的括号对数0-idx-1,然后遍历在括号内的每个排列, 以及不在括号内的每个排列, 将他们拼凑到一起</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>四层循环, 第一层求2-n的结果, 第二层遍历在新括号内部的括号对数, 第三层和第四层, 遍历在新括号内部的括号排列, 和不在括号内部的括号排列, 加起来就是一个新的排列</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; generateParenthesis(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &gt; dp(n+<span class=\"number\">1</span>);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>]=&#123;<span class=\"string\">\"\"</span>&#125;;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>]=&#123;<span class=\"string\">\"()\"</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//假设最左边的左括号是第n对括号新加进来的</span></span><br><span class=\"line\">        <span class=\"comment\">//遍历在第一个左括号对应的括号内的pair数, [0, idx-1]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> idx=<span class=\"number\">2</span>;idx&lt;=n;idx++) </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=idx<span class=\"number\">-1</span>;i++)   <span class=\"comment\">//在第一个左括号内的括号数</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"built_in\">string</span> si:dp[i])    <span class=\"comment\">//在第一个括号内的括号数的每个排列</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"built_in\">string</span> sk:dp[idx<span class=\"number\">-1</span>-i])  <span class=\"comment\">//不在第一个括号内的括号的每个排列</span></span><br><span class=\"line\">                        dp[idx].push_back(<span class=\"string\">\"(\"</span>+si+<span class=\"string\">\")\"</span>+sk);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>算法同C++</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solutin</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        total_l = []</span><br><span class=\"line\">        total_l.append([<span class=\"keyword\">None</span>])</span><br><span class=\"line\">        total_l.append([<span class=\"string\">\"()\"</span>])</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,n+<span class=\"number\">1</span>):  <span class=\"comment\"># 开始计算i时的括号组合，记为l</span></span><br><span class=\"line\">            l = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i): <span class=\"comment\">#遍历所有可能的括号内外组合</span></span><br><span class=\"line\">                now_list1 = total_l[j]</span><br><span class=\"line\">                now_list2 = total_l[i<span class=\"number\">-1</span>-j]</span><br><span class=\"line\">                <span class=\"keyword\">for</span> k1 <span class=\"keyword\">in</span> now_list1:  <span class=\"comment\">#开始具体取内外组合的实例</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span> k2 <span class=\"keyword\">in</span> now_list2:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> k1 == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                            k1 = <span class=\"string\">\"\"</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> k2 == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                            k2 = <span class=\"string\">\"\"</span></span><br><span class=\"line\">                        el = <span class=\"string\">\"(\"</span> + k1 + <span class=\"string\">\")\"</span> + k2</span><br><span class=\"line\">                        l.append(el)</span><br><span class=\"line\">            total_l.append(l)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total_l[n]</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>动态规划往往是递归转化过来, 如果能想到递归, 那可以考虑下DP怎么做, 当然, 暴力求解通常就是递归求解</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/generate-parentheses/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> n=3<br><strong>Output:</strong></p><blockquote><p>[<br>“((()))”,<br>“(()())”,<br>“(())()”,<br>“()(())”,<br>“()()()”<br>]</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>可以暴力求解, 将所有括号的全排列找出来,然后把里面括号匹配的拿出来</li><li>动态规划, 第n个括号总是在第n-1个括号的基础上添加的,假设最左边的左括号是添加上去的. 那么, 前面的n-1个括号便分为两部分,在新加入括号内部的, 和不在新括号内部的. 我们遍历在括号内部的括号对数0-idx-1,然后遍历在括号内的每个排列, 以及不在括号内的每个排列, 将他们拼凑到一起</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>四层循环, 第一层求2-n的结果, 第二层遍历在新括号内部的括号对数, 第三层和第四层, 遍历在新括号内部的括号排列, 和不在括号内部的括号排列, 加起来就是一个新的排列</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; generateParenthesis(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &gt; dp(n+<span class=\"number\">1</span>);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>]=&#123;<span class=\"string\">\"\"</span>&#125;;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>]=&#123;<span class=\"string\">\"()\"</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//假设最左边的左括号是第n对括号新加进来的</span></span><br><span class=\"line\">        <span class=\"comment\">//遍历在第一个左括号对应的括号内的pair数, [0, idx-1]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> idx=<span class=\"number\">2</span>;idx&lt;=n;idx++) </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=idx<span class=\"number\">-1</span>;i++)   <span class=\"comment\">//在第一个左括号内的括号数</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"built_in\">string</span> si:dp[i])    <span class=\"comment\">//在第一个括号内的括号数的每个排列</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"built_in\">string</span> sk:dp[idx<span class=\"number\">-1</span>-i])  <span class=\"comment\">//不在第一个括号内的括号的每个排列</span></span><br><span class=\"line\">                        dp[idx].push_back(<span class=\"string\">\"(\"</span>+si+<span class=\"string\">\")\"</span>+sk);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>算法同C++</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solutin</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        total_l = []</span><br><span class=\"line\">        total_l.append([<span class=\"keyword\">None</span>])</span><br><span class=\"line\">        total_l.append([<span class=\"string\">\"()\"</span>])</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,n+<span class=\"number\">1</span>):  <span class=\"comment\"># 开始计算i时的括号组合，记为l</span></span><br><span class=\"line\">            l = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i): <span class=\"comment\">#遍历所有可能的括号内外组合</span></span><br><span class=\"line\">                now_list1 = total_l[j]</span><br><span class=\"line\">                now_list2 = total_l[i<span class=\"number\">-1</span>-j]</span><br><span class=\"line\">                <span class=\"keyword\">for</span> k1 <span class=\"keyword\">in</span> now_list1:  <span class=\"comment\">#开始具体取内外组合的实例</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span> k2 <span class=\"keyword\">in</span> now_list2:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> k1 == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                            k1 = <span class=\"string\">\"\"</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> k2 == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                            k2 = <span class=\"string\">\"\"</span></span><br><span class=\"line\">                        el = <span class=\"string\">\"(\"</span> + k1 + <span class=\"string\">\")\"</span> + k2</span><br><span class=\"line\">                        l.append(el)</span><br><span class=\"line\">            total_l.append(l)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total_l[n]</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>动态规划往往是递归转化过来, 如果能想到递归, 那可以考虑下DP怎么做, 当然, 暴力求解通常就是递归求解</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-026-Remove Duplicates from Sorted Array","comments":1,"mathjax":false,"date":"2019-10-24T01:19:10.000Z","urlname":"Remove-Duplicates-from-Sorted-Array","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/)   \nGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\n\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n### Examples:\n**Input:**\n> Given nums = [1,1,2]\n\n**Output:**\n> Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 和前一个元素比较，直接对vector进行元素删除 \n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size()==0)return 0;\n        for(int i=1;i<nums.size();){\n            if(nums[i]==nums[i-1]){\n                nums.erase(nums.begin()+i);\n            }else{\n                i++;\n            }\n        }\n        return nums.size();\n    }\n};\n```\n\n\n\n------\n","source":"_posts/LeetCode/LeetCode-026-Remove-Duplicates-from-Sorted-Array.md","raw":"---\ntitle: LeetCode-026-Remove Duplicates from Sorted Array\ntags:\n  - LeetCode\n  - Algorithm\n  - Vector\n  - Easy\ncategories:\n  - LeetCode\ncomments: true\nmathjax: false\ndate: 2019-10-24 09:19:10\nurlname: Remove-Duplicates-from-Sorted-Array\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/)   \nGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\n\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n### Examples:\n**Input:**\n> Given nums = [1,1,2]\n\n**Output:**\n> Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 和前一个元素比较，直接对vector进行元素删除 \n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size()==0)return 0;\n        for(int i=1;i<nums.size();){\n            if(nums[i]==nums[i-1]){\n                nums.erase(nums.begin()+i);\n            }else{\n                i++;\n            }\n        }\n        return nums.size();\n    }\n};\n```\n\n\n\n------\n","slug":"LeetCode/LeetCode-026-Remove-Duplicates-from-Sorted-Array","published":1,"updated":"2019-10-24T01:25:49.715Z","layout":"post","photos":[],"link":"","_id":"ck2424lty0071lksbhon558xs","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>Given nums = [1,1,2]</p></blockquote><p><strong>Output:</strong></p><blockquote><p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>和前一个元素比较，直接对vector进行元素删除</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.size()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.size();)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]==nums[i<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                nums.erase(nums.begin()+i);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>Given nums = [1,1,2]</p></blockquote><p><strong>Output:</strong></p><blockquote><p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>和前一个元素比较，直接对vector进行元素删除</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.size()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.size();)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]==nums[i<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                nums.erase(nums.begin()+i);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"LeetCode-088-Merge Sorted Array","urlname":"leetcode-merge-sorted-array","comments":1,"mathjax":false,"date":"2019-06-01T16:40:13.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/merge-sorted-array/)   \nGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\n\n**Note:** \n\n- The number of elements initialized in nums1 and nums2 are m and n respectively.\n- You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.\n\n合并两个有序数组，合并到第一个数组里\n\n### Examples:\n**Input:**\n> nums1 = [1,2,3,0,0,0], m = 3\n> nums2 = [2,5,6],       n = 3\n**Output:**\n> [1,2,2,3,5,6]\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 简单题，所以可以直接暴力求解\n- 先把第一个数组备份到tmp，然后对tmp和第二个数组进行合并，结果放到nums1里面就行\n\n\n## C++ Codes\n12ms，超90%，大部分人都是这个时间\n\n```C++\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> tmp;\n        for(int i=0;i<m;i++)\n            tmp.push_back(nums1[i]);\n        \n        int cnt=0, i, j;\n        for(i=0,j=0;i<m && j<n;cnt++){\n            if(tmp[i]<nums2[j]){\n                nums1[cnt]=tmp[i++];\n            }else{\n                nums1[cnt]=nums2[j++];\n            }\n        }\n        while(i<m) nums1[cnt++]=tmp[i++];\n        while(j<n) nums1[cnt++]=nums2[j++];\n    }\n};\n```\n\n## 总结\n- 如果是多个链表合并，不是这种有序数组两个合并的，可以看另一个题目，网站搜索合并多个链表\n\n\n------\n","source":"_posts/LeetCode/LeetCode-088-Merge-Sorted-Array.md","raw":"---\ntitle: LeetCode-088-Merge Sorted Array\ntags:\n  - LeetCode\n  - Algorithm\n  - Array\n  - Merge\n  - Easy\ncategories:\n  - LeetCode\nurlname: leetcode-merge-sorted-array\ncomments: true\nmathjax: false\ndate: 2019-06-02 00:40:13\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/merge-sorted-array/)   \nGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\n\n**Note:** \n\n- The number of elements initialized in nums1 and nums2 are m and n respectively.\n- You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.\n\n合并两个有序数组，合并到第一个数组里\n\n### Examples:\n**Input:**\n> nums1 = [1,2,3,0,0,0], m = 3\n> nums2 = [2,5,6],       n = 3\n**Output:**\n> [1,2,2,3,5,6]\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 简单题，所以可以直接暴力求解\n- 先把第一个数组备份到tmp，然后对tmp和第二个数组进行合并，结果放到nums1里面就行\n\n\n## C++ Codes\n12ms，超90%，大部分人都是这个时间\n\n```C++\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int> tmp;\n        for(int i=0;i<m;i++)\n            tmp.push_back(nums1[i]);\n        \n        int cnt=0, i, j;\n        for(i=0,j=0;i<m && j<n;cnt++){\n            if(tmp[i]<nums2[j]){\n                nums1[cnt]=tmp[i++];\n            }else{\n                nums1[cnt]=nums2[j++];\n            }\n        }\n        while(i<m) nums1[cnt++]=tmp[i++];\n        while(j<n) nums1[cnt++]=nums2[j++];\n    }\n};\n```\n\n## 总结\n- 如果是多个链表合并，不是这种有序数组两个合并的，可以看另一个题目，网站搜索合并多个链表\n\n\n------\n","slug":"LeetCode/LeetCode-088-Merge-Sorted-Array","published":1,"updated":"2019-07-25T18:28:53.859Z","layout":"post","photos":[],"link":"","_id":"ck2424lu00074lksbt8wxnjd1","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/merge-sorted-array/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p><p><strong>Note:</strong></p><ul><li>The number of elements initialized in nums1 and nums2 are m and n respectively.</li><li>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</li></ul><p>合并两个有序数组，合并到第一个数组里</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6], n = 3<br><strong>Output:</strong><br>[1,2,2,3,5,6]</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>简单题，所以可以直接暴力求解</li><li>先把第一个数组备份到tmp，然后对tmp和第二个数组进行合并，结果放到nums1里面就行</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>12ms，超90%，大部分人都是这个时间</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)</span><br><span class=\"line\">            tmp.push_back(nums1[i]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt=<span class=\"number\">0</span>, i, j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>;i&lt;m &amp;&amp; j&lt;n;cnt++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp[i]&lt;nums2[j])&#123;</span><br><span class=\"line\">                nums1[cnt]=tmp[i++];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                nums1[cnt]=nums2[j++];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;m) nums1[cnt++]=tmp[i++];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;n) nums1[cnt++]=nums2[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>如果是多个链表合并，不是这种有序数组两个合并的，可以看另一个题目，网站搜索合并多个链表</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/merge-sorted-array/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p><p><strong>Note:</strong></p><ul><li>The number of elements initialized in nums1 and nums2 are m and n respectively.</li><li>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</li></ul><p>合并两个有序数组，合并到第一个数组里</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6], n = 3<br><strong>Output:</strong><br>[1,2,2,3,5,6]</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>简单题，所以可以直接暴力求解</li><li>先把第一个数组备份到tmp，然后对tmp和第二个数组进行合并，结果放到nums1里面就行</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>12ms，超90%，大部分人都是这个时间</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)</span><br><span class=\"line\">            tmp.push_back(nums1[i]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt=<span class=\"number\">0</span>, i, j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>;i&lt;m &amp;&amp; j&lt;n;cnt++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp[i]&lt;nums2[j])&#123;</span><br><span class=\"line\">                nums1[cnt]=tmp[i++];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                nums1[cnt]=nums2[j++];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;m) nums1[cnt++]=tmp[i++];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;n) nums1[cnt++]=nums2[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>如果是多个链表合并，不是这种有序数组两个合并的，可以看另一个题目，网站搜索合并多个链表</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-027-Remove-Element","comments":1,"mathjax":false,"date":"2019-10-24T01:27:06.000Z","urlname":null,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/remove-element/)   \nGiven an array nums and a value val, remove all instances of that value in-place and return the new length.\n\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\n### Examples:\n**Input:**\n> Given nums = [3,2,2,3], val = 3,\n\n**Output:**\n> Your function should return length = 2, with the first two elements of nums being 2.\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 题目要求就地，不使用额外空间，所以只能在原数组修改\n- 双指针，以前的题目中用了很多。如果后一个指针内容和前一个不相等，就赋值，然后全部自增。否则就只有后指针自增。\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int pos = 0;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]!=val) nums[pos++]=nums[i];\n        }\n        return pos;\n    }\n};\n```\n\n","source":"_posts/LeetCode/LeetCode-027-Remove-Element.md","raw":"---\ntitle: LeetCode-027-Remove-Element\ntags:\n  - LeetCode\n  - Algorithm\n  - Easy\n  - Vector\ncategories:\n  - LeetCode\ncomments: true\nmathjax: false\ndate: 2019-10-24 09:27:06\nurlname:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/remove-element/)   \nGiven an array nums and a value val, remove all instances of that value in-place and return the new length.\n\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\n### Examples:\n**Input:**\n> Given nums = [3,2,2,3], val = 3,\n\n**Output:**\n> Your function should return length = 2, with the first two elements of nums being 2.\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 题目要求就地，不使用额外空间，所以只能在原数组修改\n- 双指针，以前的题目中用了很多。如果后一个指针内容和前一个不相等，就赋值，然后全部自增。否则就只有后指针自增。\n\n\n## C++ Codes\n\n```C++\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int pos = 0;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]!=val) nums[pos++]=nums[i];\n        }\n        return pos;\n    }\n};\n```\n\n","slug":"LeetCode/LeetCode-027-Remove-Element","published":1,"updated":"2019-10-24T01:57:58.133Z","layout":"post","photos":[],"link":"","_id":"ck2424lu10076lksb7o6nwoqu","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/remove-element/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>Given nums = [3,2,2,3], val = 3,</p></blockquote><p><strong>Output:</strong></p><blockquote><p>Your function should return length = 2, with the first two elements of nums being 2.</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>题目要求就地，不使用额外空间，所以只能在原数组修改</li><li>双指针，以前的题目中用了很多。如果后一个指针内容和前一个不相等，就赋值，然后全部自增。否则就只有后指针自增。</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]!=val) nums[pos++]=nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/remove-element/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>Given nums = [3,2,2,3], val = 3,</p></blockquote><p><strong>Output:</strong></p><blockquote><p>Your function should return length = 2, with the first two elements of nums being 2.</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>题目要求就地，不使用额外空间，所以只能在原数组修改</li><li>双指针，以前的题目中用了很多。如果后一个指针内容和前一个不相等，就赋值，然后全部自增。否则就只有后指针自增。</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]!=val) nums[pos++]=nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"LeetCode-021-Merge Two Sorted Lists","urlname":"leetcode-merge-two-sorted-lists","comments":1,"mathjax":false,"date":"2019-05-22T16:28:14.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/merge-two-sorted-lists/)   \nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n\n简单说就是合并两个有序链表\n\n### Examples:\n**Input:**1->2->4, 1->3->4\n**Output:**1->1->2->3->4->4\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 第一种方法是新建一个链表，每次创建新的节点，不影响原始链表。在两个链表都非空的是比较结点值大小，将小的值作为新节点的值插入结果链表中，并移动指针。\n- 第二种方法也挺简单，只是单纯的改变指针，就地合并，但是会影响原始链表。\n- Python使用的方法，递归，也是就地的，前面的较小的节点加上后面所有的排好序的节点就是要的结果\n\n\n## C++ Codes\n\n### 方法一\n创建一个头结点，依次比较l1和l2的节点，逐个插入到新链表中，插入过程是创建了新的节点\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode* res = new ListNode(0);\n        ListNode *p = res;\n        ListNode *p1 = l1;\n        ListNode *p2 = l2;\n        while(p1!=NULL && p2!=NULL){\n            if(p1->val > p2->val){\n                p->next = new ListNode(p2->val);\n                p2 = p2->next;\n            }\n            else{\n                p->next = new ListNode(p1->val);\n                p1 = p1->next;\n            }\n            p = p->next;\n        }\n        while(p1!=NULL){\n            p->next = new ListNode(p1->val);\n            p = p->next;\n            p1 = p1->next;\n        }\n        while(p2!=NULL){\n            p->next = new ListNode(p2->val);\n            p = p->next;\n            p2 = p2->next;\n        }\n        return res->next;\n    }\n};\n```\n\n### 方法二\n这种方法也可以像方法一那样，创建一个头结点，然后比较l1和l2，依次改变两个链表的指针\n\n我用了另一种就地方法，其中一个链表不变，另一个链表依次找到合适位置插入这个这个链表\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        //p1: 结果链表头结点，指向较小的\n        //p2: 另一个链表的头结点\n        if(l1==NULL)return l2;\n        if(l2==NULL)return l1;\n        ListNode *p1, *p2;\n        if(l1->val < l2->val){\n            p1 = l1; p2 = l2;\n        }else{\n            p1 = l2; p2 = l1;\n        }\n        ListNode *prefix=p1, *res = p1;\n        p1 = p1->next;\n        while(p2!=NULL){\n            //找到p2指向的节点第一次小于p1节点的位置，前插\n            while(p1!=NULL && p2->val > p1->val){\n                prefix = prefix->next;\n                p1 = p1->next;\n            }\n            //p1到结尾\n            if(p1==NULL){\n                prefix->next = p2;\n                return res;\n            }\n            else{\n                prefix->next = p2;\n                p2 = p2->next;\n                prefix->next->next = p1;\n                prefix = prefix->next;\n            }\n            \n        }\n        return res;\n    }\n};\n```\n\n## Python Codes\n递归的方法，每次保证递归返回的是较小的节点\n\n这里用了交换l1和l2指针的方法，事实证明....不交换直接判断哪个小来调用递归时间少一点...佛了，交换是64ms，不交换是48ms...\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        if not l1: return l2\n        if not l2: return l1\n        if l1.val>l2.val: l1, l2 = l2, l1\n        l1.next = self.mergeTwoLists(l1.next,l2)\n        return l1\n```\n\n## 总结\n- 链表的问题这里总结是两种方法，一种是迭代，一种是递归，迭代过程中要注意节点指针不要混乱了。\n\n\n------\n","source":"_posts/LeetCode/LeetCode-021-Merge-Two-Sorted-Lists.md","raw":"---\ntitle: LeetCode-021-Merge Two Sorted Lists\ntags:\n  - LeetCode\n  - Algorithm\n  - LinkedList\n  - List\n  - Merge\n  - Easy\ncategories:\n  - LeetCode\nurlname: leetcode-merge-two-sorted-lists\ncomments: true\nmathjax: false\ndate: 2019-05-23 00:28:14\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/merge-two-sorted-lists/)   \nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n\n简单说就是合并两个有序链表\n\n### Examples:\n**Input:**1->2->4, 1->3->4\n**Output:**1->1->2->3->4->4\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 第一种方法是新建一个链表，每次创建新的节点，不影响原始链表。在两个链表都非空的是比较结点值大小，将小的值作为新节点的值插入结果链表中，并移动指针。\n- 第二种方法也挺简单，只是单纯的改变指针，就地合并，但是会影响原始链表。\n- Python使用的方法，递归，也是就地的，前面的较小的节点加上后面所有的排好序的节点就是要的结果\n\n\n## C++ Codes\n\n### 方法一\n创建一个头结点，依次比较l1和l2的节点，逐个插入到新链表中，插入过程是创建了新的节点\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode* res = new ListNode(0);\n        ListNode *p = res;\n        ListNode *p1 = l1;\n        ListNode *p2 = l2;\n        while(p1!=NULL && p2!=NULL){\n            if(p1->val > p2->val){\n                p->next = new ListNode(p2->val);\n                p2 = p2->next;\n            }\n            else{\n                p->next = new ListNode(p1->val);\n                p1 = p1->next;\n            }\n            p = p->next;\n        }\n        while(p1!=NULL){\n            p->next = new ListNode(p1->val);\n            p = p->next;\n            p1 = p1->next;\n        }\n        while(p2!=NULL){\n            p->next = new ListNode(p2->val);\n            p = p->next;\n            p2 = p2->next;\n        }\n        return res->next;\n    }\n};\n```\n\n### 方法二\n这种方法也可以像方法一那样，创建一个头结点，然后比较l1和l2，依次改变两个链表的指针\n\n我用了另一种就地方法，其中一个链表不变，另一个链表依次找到合适位置插入这个这个链表\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        //p1: 结果链表头结点，指向较小的\n        //p2: 另一个链表的头结点\n        if(l1==NULL)return l2;\n        if(l2==NULL)return l1;\n        ListNode *p1, *p2;\n        if(l1->val < l2->val){\n            p1 = l1; p2 = l2;\n        }else{\n            p1 = l2; p2 = l1;\n        }\n        ListNode *prefix=p1, *res = p1;\n        p1 = p1->next;\n        while(p2!=NULL){\n            //找到p2指向的节点第一次小于p1节点的位置，前插\n            while(p1!=NULL && p2->val > p1->val){\n                prefix = prefix->next;\n                p1 = p1->next;\n            }\n            //p1到结尾\n            if(p1==NULL){\n                prefix->next = p2;\n                return res;\n            }\n            else{\n                prefix->next = p2;\n                p2 = p2->next;\n                prefix->next->next = p1;\n                prefix = prefix->next;\n            }\n            \n        }\n        return res;\n    }\n};\n```\n\n## Python Codes\n递归的方法，每次保证递归返回的是较小的节点\n\n这里用了交换l1和l2指针的方法，事实证明....不交换直接判断哪个小来调用递归时间少一点...佛了，交换是64ms，不交换是48ms...\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        if not l1: return l2\n        if not l2: return l1\n        if l1.val>l2.val: l1, l2 = l2, l1\n        l1.next = self.mergeTwoLists(l1.next,l2)\n        return l1\n```\n\n## 总结\n- 链表的问题这里总结是两种方法，一种是迭代，一种是递归，迭代过程中要注意节点指针不要混乱了。\n\n\n------\n","slug":"LeetCode/LeetCode-021-Merge-Two-Sorted-Lists","published":1,"updated":"2019-07-25T18:26:05.373Z","layout":"post","photos":[],"link":"","_id":"ck2424lu20079lksb06ya682c","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p>简单说就是合并两个有序链表</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>Output:</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>第一种方法是新建一个链表，每次创建新的节点，不影响原始链表。在两个链表都非空的是比较结点值大小，将小的值作为新节点的值插入结果链表中，并移动指针。</li><li>第二种方法也挺简单，只是单纯的改变指针，就地合并，但是会影响原始链表。</li><li>Python使用的方法，递归，也是就地的，前面的较小的节点加上后面所有的排好序的节点就是要的结果</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>创建一个头结点，依次比较l1和l2的节点，逐个插入到新链表中，插入过程是创建了新的节点</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* res = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode *p = res;</span><br><span class=\"line\">        ListNode *p1 = l1;</span><br><span class=\"line\">        ListNode *p2 = l2;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p1!=<span class=\"literal\">NULL</span> &amp;&amp; p2!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p1-&gt;val &gt; p2-&gt;val)&#123;</span><br><span class=\"line\">                p-&gt;next = <span class=\"keyword\">new</span> ListNode(p2-&gt;val);</span><br><span class=\"line\">                p2 = p2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                p-&gt;next = <span class=\"keyword\">new</span> ListNode(p1-&gt;val);</span><br><span class=\"line\">                p1 = p1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p1!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            p-&gt;next = <span class=\"keyword\">new</span> ListNode(p1-&gt;val);</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">            p1 = p1-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p2!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            p-&gt;next = <span class=\"keyword\">new</span> ListNode(p2-&gt;val);</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">            p2 = p2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>这种方法也可以像方法一那样，创建一个头结点，然后比较l1和l2，依次改变两个链表的指针</p><p>我用了另一种就地方法，其中一个链表不变，另一个链表依次找到合适位置插入这个这个链表</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//p1: 结果链表头结点，指向较小的</span></span><br><span class=\"line\">        <span class=\"comment\">//p2: 另一个链表的头结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l2==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        ListNode *p1, *p2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class=\"line\">            p1 = l1; p2 = l2;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            p1 = l2; p2 = l1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode *prefix=p1, *res = p1;</span><br><span class=\"line\">        p1 = p1-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p2!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//找到p2指向的节点第一次小于p1节点的位置，前插</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p1!=<span class=\"literal\">NULL</span> &amp;&amp; p2-&gt;val &gt; p1-&gt;val)&#123;</span><br><span class=\"line\">                prefix = prefix-&gt;next;</span><br><span class=\"line\">                p1 = p1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//p1到结尾</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p1==<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                prefix-&gt;next = p2;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                prefix-&gt;next = p2;</span><br><span class=\"line\">                p2 = p2-&gt;next;</span><br><span class=\"line\">                prefix-&gt;next-&gt;next = p1;</span><br><span class=\"line\">                prefix = prefix-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>递归的方法，每次保证递归返回的是较小的节点</p><p>这里用了交换l1和l2指针的方法，事实证明….不交换直接判断哪个小来调用递归时间少一点…佛了，交换是64ms，不交换是48ms…</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l1: <span class=\"keyword\">return</span> l2</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l2: <span class=\"keyword\">return</span> l1</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1.val&gt;l2.val: l1, l2 = l2, l1</span><br><span class=\"line\">        l1.next = self.mergeTwoLists(l1.next,l2)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>链表的问题这里总结是两种方法，一种是迭代，一种是递归，迭代过程中要注意节点指针不要混乱了。</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p>简单说就是合并两个有序链表</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>Output:</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>第一种方法是新建一个链表，每次创建新的节点，不影响原始链表。在两个链表都非空的是比较结点值大小，将小的值作为新节点的值插入结果链表中，并移动指针。</li><li>第二种方法也挺简单，只是单纯的改变指针，就地合并，但是会影响原始链表。</li><li>Python使用的方法，递归，也是就地的，前面的较小的节点加上后面所有的排好序的节点就是要的结果</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>创建一个头结点，依次比较l1和l2的节点，逐个插入到新链表中，插入过程是创建了新的节点</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* res = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode *p = res;</span><br><span class=\"line\">        ListNode *p1 = l1;</span><br><span class=\"line\">        ListNode *p2 = l2;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p1!=<span class=\"literal\">NULL</span> &amp;&amp; p2!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p1-&gt;val &gt; p2-&gt;val)&#123;</span><br><span class=\"line\">                p-&gt;next = <span class=\"keyword\">new</span> ListNode(p2-&gt;val);</span><br><span class=\"line\">                p2 = p2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                p-&gt;next = <span class=\"keyword\">new</span> ListNode(p1-&gt;val);</span><br><span class=\"line\">                p1 = p1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p1!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            p-&gt;next = <span class=\"keyword\">new</span> ListNode(p1-&gt;val);</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">            p1 = p1-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p2!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            p-&gt;next = <span class=\"keyword\">new</span> ListNode(p2-&gt;val);</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">            p2 = p2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>这种方法也可以像方法一那样，创建一个头结点，然后比较l1和l2，依次改变两个链表的指针</p><p>我用了另一种就地方法，其中一个链表不变，另一个链表依次找到合适位置插入这个这个链表</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//p1: 结果链表头结点，指向较小的</span></span><br><span class=\"line\">        <span class=\"comment\">//p2: 另一个链表的头结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l2==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        ListNode *p1, *p2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class=\"line\">            p1 = l1; p2 = l2;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            p1 = l2; p2 = l1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode *prefix=p1, *res = p1;</span><br><span class=\"line\">        p1 = p1-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p2!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//找到p2指向的节点第一次小于p1节点的位置，前插</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p1!=<span class=\"literal\">NULL</span> &amp;&amp; p2-&gt;val &gt; p1-&gt;val)&#123;</span><br><span class=\"line\">                prefix = prefix-&gt;next;</span><br><span class=\"line\">                p1 = p1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//p1到结尾</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p1==<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                prefix-&gt;next = p2;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                prefix-&gt;next = p2;</span><br><span class=\"line\">                p2 = p2-&gt;next;</span><br><span class=\"line\">                prefix-&gt;next-&gt;next = p1;</span><br><span class=\"line\">                prefix = prefix-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>递归的方法，每次保证递归返回的是较小的节点</p><p>这里用了交换l1和l2指针的方法，事实证明….不交换直接判断哪个小来调用递归时间少一点…佛了，交换是64ms，不交换是48ms…</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l1: <span class=\"keyword\">return</span> l2</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> l2: <span class=\"keyword\">return</span> l1</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1.val&gt;l2.val: l1, l2 = l2, l1</span><br><span class=\"line\">        l1.next = self.mergeTwoLists(l1.next,l2)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>链表的问题这里总结是两种方法，一种是迭代，一种是递归，迭代过程中要注意节点指针不要混乱了。</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-125-Valid Palindrome","urlname":"leetcode-valid-palindrome","comments":1,"mathjax":false,"date":"2019-06-01T16:55:08.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/valid-palindrome/)   \nGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n\nNote: For the purpose of this problem, we define empty string as valid palindrome.\n\n### Examples:\n**Input:**\"A man, a plan, a canal: Panama\"\n**Output:**true\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 如果是单纯的回文串验证，那很简单，很多种方法\n- 可以直接用函数将字符串逆序作比较\n- 可以用两个指针指向头和尾，逐个字符比较\n- 这道题因为还有空格，标点符号，大小写的问题，需要简单的处理下\n\n\n## C++ Codes\n8ms，超99%\n\n```C++\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        //全部变成小写并去掉非数字和字符的\n        transform(s.begin(),s.end(),s.begin(),::tolower);\n        string res;\n        for(int i=0;i<s.length();i++){\n            if((s[i]>='0' && s[i]<='9') || (s[i]>='a' && s[i]<='z')) \n                res+=s[i];\n        }\n        cout<<res<<endl;\n        if(res.empty()) return true;  \n        int l=0, r=res.length()-1;\n        while(l<res.length() && r>=0 && l<=r){\n            if(res[l]==res[r]){\n                l++;\n                r--;\n            }else{\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n{% note info %}\nC++里面没有直接对字符串进行全部转换大写或者小写的方法\n可以用`transform(s.begin(),s.end(),s.begin(),::tolower)`\n更多方法可以进行百度，如果懒得找也可以自己遍历字符修改大小写\n{% endnote %}\n\n\n## 总结\n- 要注意的就是字符串的预处理，并且处理之后如果是空串要返回true \n\n\n------\n","source":"_posts/LeetCode/LeetCode-125-Valid-Palindrome.md","raw":"---\ntitle: LeetCode-125-Valid Palindrome\ntags:\n  - LeetCode\n  - Algorithm\n  - Palindrome\n  - String\n  - Easy\ncategories:\n  - LeetCode\nurlname: leetcode-valid-palindrome\ncomments: true\nmathjax: false\ndate: 2019-06-02 00:55:08\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/valid-palindrome/)   \nGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n\nNote: For the purpose of this problem, we define empty string as valid palindrome.\n\n### Examples:\n**Input:**\"A man, a plan, a canal: Panama\"\n**Output:**true\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 如果是单纯的回文串验证，那很简单，很多种方法\n- 可以直接用函数将字符串逆序作比较\n- 可以用两个指针指向头和尾，逐个字符比较\n- 这道题因为还有空格，标点符号，大小写的问题，需要简单的处理下\n\n\n## C++ Codes\n8ms，超99%\n\n```C++\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        //全部变成小写并去掉非数字和字符的\n        transform(s.begin(),s.end(),s.begin(),::tolower);\n        string res;\n        for(int i=0;i<s.length();i++){\n            if((s[i]>='0' && s[i]<='9') || (s[i]>='a' && s[i]<='z')) \n                res+=s[i];\n        }\n        cout<<res<<endl;\n        if(res.empty()) return true;  \n        int l=0, r=res.length()-1;\n        while(l<res.length() && r>=0 && l<=r){\n            if(res[l]==res[r]){\n                l++;\n                r--;\n            }else{\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n{% note info %}\nC++里面没有直接对字符串进行全部转换大写或者小写的方法\n可以用`transform(s.begin(),s.end(),s.begin(),::tolower)`\n更多方法可以进行百度，如果懒得找也可以自己遍历字符修改大小写\n{% endnote %}\n\n\n## 总结\n- 要注意的就是字符串的预处理，并且处理之后如果是空串要返回true \n\n\n------\n","slug":"LeetCode/LeetCode-125-Valid-Palindrome","published":1,"updated":"2019-07-25T18:29:36.169Z","layout":"post","photos":[],"link":"","_id":"ck2424lu4007clksb0bv5bxfj","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/valid-palindrome/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>“A man, a plan, a canal: Panama”<br><strong>Output:</strong>true</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>如果是单纯的回文串验证，那很简单，很多种方法</li><li>可以直接用函数将字符串逆序作比较</li><li>可以用两个指针指向头和尾，逐个字符比较</li><li>这道题因为还有空格，标点符号，大小写的问题，需要简单的处理下</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>8ms，超99%</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//全部变成小写并去掉非数字和字符的</span></span><br><span class=\"line\">        transform(s.begin(),s.end(),s.begin(),::<span class=\"built_in\">tolower</span>);</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((s[i]&gt;=<span class=\"string\">'0'</span> &amp;&amp; s[i]&lt;=<span class=\"string\">'9'</span>) || (s[i]&gt;=<span class=\"string\">'a'</span> &amp;&amp; s[i]&lt;=<span class=\"string\">'z'</span>)) </span><br><span class=\"line\">                res+=s[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> l=<span class=\"number\">0</span>, r=res.length()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&lt;res.length() &amp;&amp; r&gt;=<span class=\"number\">0</span> &amp;&amp; l&lt;=r)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(res[l]==res[r])&#123;</span><br><span class=\"line\">                l++;</span><br><span class=\"line\">                r--;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><div class=\"note info\"><p>C++里面没有直接对字符串进行全部转换大写或者小写的方法<br>可以用<code>transform(s.begin(),s.end(),s.begin(),::tolower)</code><br>更多方法可以进行百度，如果懒得找也可以自己遍历字符修改大小写</p></div><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>要注意的就是字符串的预处理，并且处理之后如果是空串要返回true</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/valid-palindrome/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>“A man, a plan, a canal: Panama”<br><strong>Output:</strong>true</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>如果是单纯的回文串验证，那很简单，很多种方法</li><li>可以直接用函数将字符串逆序作比较</li><li>可以用两个指针指向头和尾，逐个字符比较</li><li>这道题因为还有空格，标点符号，大小写的问题，需要简单的处理下</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>8ms，超99%</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//全部变成小写并去掉非数字和字符的</span></span><br><span class=\"line\">        transform(s.begin(),s.end(),s.begin(),::<span class=\"built_in\">tolower</span>);</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;s.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((s[i]&gt;=<span class=\"string\">'0'</span> &amp;&amp; s[i]&lt;=<span class=\"string\">'9'</span>) || (s[i]&gt;=<span class=\"string\">'a'</span> &amp;&amp; s[i]&lt;=<span class=\"string\">'z'</span>)) </span><br><span class=\"line\">                res+=s[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> l=<span class=\"number\">0</span>, r=res.length()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&lt;res.length() &amp;&amp; r&gt;=<span class=\"number\">0</span> &amp;&amp; l&lt;=r)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(res[l]==res[r])&#123;</span><br><span class=\"line\">                l++;</span><br><span class=\"line\">                r--;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><div class=\"note info\"><p>C++里面没有直接对字符串进行全部转换大写或者小写的方法<br>可以用<code>transform(s.begin(),s.end(),s.begin(),::tolower)</code><br>更多方法可以进行百度，如果懒得找也可以自己遍历字符修改大小写</p></div><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>要注意的就是字符串的预处理，并且处理之后如果是空串要返回true</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-136-Single Number","urlname":"leetcode-single-number","comments":1,"mathjax":false,"date":"2019-05-25T16:57:09.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n看到有算法面试集锦，刷点题，刚开始刷，前面都是简单题，随便看看了\n\n## [Problem](https://leetcode-cn.com/problems/single-number/)   \nGiven a non-empty array of integers, every element appears twice except for one. Find that single one.\n\n**Note:**\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n\n### Examples:\n**Input:**[2,2,1]\n**Output:**1\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 刚开始就是向简单的遍历一遍，用map存出现次数，但是要$$ O(1) $$ 的空间复杂度，所以不可以\n- 然后想到排序，排序完找，但是要线性时间复杂度。。。\n- 最后是用异或的方法，因为题目说的是，只有一个出现一次，其他的全部出现两次\n- 两个相同的数异或（XOR），结果为0，0和0异或当然还是0，然后就剩下了单独的一个数字，0和非0数异或等于非0数本身\n\n\n## C++ Codes\n时间复杂度$$ O(n) $$，空间复杂度$$ O(1) $$\n\n```C++\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        if(nums.size()==0)return 0;\n        int res = 0;\n        for(int i=0;i<nums.size();i++){\n            res = res^nums[i];\n        }\n        return res;\n    }\n};\n```\n\n\n## 总结\n- 注意题目细节，每个重复的数字都是出现两次 \n\n\n------\n","source":"_posts/LeetCode/LeetCode-136-Single-Number.md","raw":"---\ntitle: LeetCode-136-Single Number\ntags:\n  - LeetCode\n  - Algorithm\n  - Xor\n  - Math\n  - Linear\n  - Easy\ncategories:\n  - LeetCode\nurlname: leetcode-single-number\ncomments: true\nmathjax: false\ndate: 2019-05-26 00:57:09\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n看到有算法面试集锦，刷点题，刚开始刷，前面都是简单题，随便看看了\n\n## [Problem](https://leetcode-cn.com/problems/single-number/)   \nGiven a non-empty array of integers, every element appears twice except for one. Find that single one.\n\n**Note:**\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n\n### Examples:\n**Input:**[2,2,1]\n**Output:**1\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 刚开始就是向简单的遍历一遍，用map存出现次数，但是要$$ O(1) $$ 的空间复杂度，所以不可以\n- 然后想到排序，排序完找，但是要线性时间复杂度。。。\n- 最后是用异或的方法，因为题目说的是，只有一个出现一次，其他的全部出现两次\n- 两个相同的数异或（XOR），结果为0，0和0异或当然还是0，然后就剩下了单独的一个数字，0和非0数异或等于非0数本身\n\n\n## C++ Codes\n时间复杂度$$ O(n) $$，空间复杂度$$ O(1) $$\n\n```C++\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        if(nums.size()==0)return 0;\n        int res = 0;\n        for(int i=0;i<nums.size();i++){\n            res = res^nums[i];\n        }\n        return res;\n    }\n};\n```\n\n\n## 总结\n- 注意题目细节，每个重复的数字都是出现两次 \n\n\n------\n","slug":"LeetCode/LeetCode-136-Single-Number","published":1,"updated":"2019-07-25T18:29:50.839Z","layout":"post","photos":[],"link":"","_id":"ck2424lu5007flksbov6tzn2d","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>看到有算法面试集锦，刷点题，刚开始刷，前面都是简单题，随便看看了</p><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/single-number/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p><p><strong>Note:</strong><br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>[2,2,1]<br><strong>Output:</strong>1</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>刚开始就是向简单的遍历一遍，用map存出现次数，但是要<script type=\"math/tex\">O(1)</script>的空间复杂度，所以不可以</li><li>然后想到排序，排序完找，但是要线性时间复杂度。。。</li><li>最后是用异或的方法，因为题目说的是，只有一个出现一次，其他的全部出现两次</li><li>两个相同的数异或（XOR），结果为0，0和0异或当然还是0，然后就剩下了单独的一个数字，0和非0数异或等于非0数本身</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>时间复杂度<script type=\"math/tex\">O(n)</script>，空间复杂度<script type=\"math/tex\">O(1)</script></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.size()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class=\"line\">            res = res^nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>注意题目细节，每个重复的数字都是出现两次</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>看到有算法面试集锦，刷点题，刚开始刷，前面都是简单题，随便看看了</p><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/single-number/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p><p><strong>Note:</strong><br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>[2,2,1]<br><strong>Output:</strong>1</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>刚开始就是向简单的遍历一遍，用map存出现次数，但是要<script type=\"math/tex\">O(1)</script>的空间复杂度，所以不可以</li><li>然后想到排序，排序完找，但是要线性时间复杂度。。。</li><li>最后是用异或的方法，因为题目说的是，只有一个出现一次，其他的全部出现两次</li><li>两个相同的数异或（XOR），结果为0，0和0异或当然还是0，然后就剩下了单独的一个数字，0和非0数异或等于非0数本身</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>时间复杂度<script type=\"math/tex\">O(n)</script>，空间复杂度<script type=\"math/tex\">O(1)</script></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.size()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class=\"line\">            res = res^nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>注意题目细节，每个重复的数字都是出现两次</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-025-Reverse Nodes in k-Group","urlname":"leetcode-reverse-nodes-in-k-group","comments":1,"mathjax":false,"date":"2019-07-24T16:46:48.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)   \nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n\n### Examples:\n**Input:** 1-2-3-4-5\n**Output:** \n> k=2, 2-1-4-3-5\n> k=3, 3-2-1-4-5\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 递归, 每次改变k个节点的链接顺序, 然后令最后一个节点的next等于下一次递归的返回值, 最后返回头节点, 如果本次不满k个, 直接返回. 每次递归的内容可以是迭代或者用栈, 两种方式的时间差不多\n- 迭代, 基于第24题的迭代, 每次修改完一段之后, 要将此段和前一段相连, 还要和后一段相连, 要注意很多细节\n- 利用栈, 因为k个节点进栈顺序和出栈顺序正好相反\n\n\n## C++ Codes\n节点数据结构\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\n```\n\n递归+栈\n\n```C++\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if(k==1 || head==NULL) return head;\n        ListNode* stack[k];\n        ListNode *p=head;\n        //存入栈中\n        for(int i=0;i<k;i++){\n            if(p==NULL)return head;\n            stack[i]=p;\n            p=p->next;\n        }\n        //逆序\n        for(int i=k-1;i>0;i--){\n            stack[i]->next=stack[i-1];\n        }\n        //和后一段相连\n        stack[0]->next=reverseKGroup(p, k);\n        //每次递归返回头节点\n        return stack[k-1]; \n    }\n};\n```\n\n纯迭代, 相对递归感觉比较麻烦, 逻辑上要想更多, 但是资源肯定比递归消耗少\n```C++\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if(k==1) return head;\n        ListNode *front, *rear, *tmp, *p, *q, *s;\n        front=head;\n        for(int i=0;i<k;i++){\n            if(front!=NULL) front=front->next;\n            else return head;\n        }\n        front=rear=head;\n        //front指向第一个节点, rear指向k+1个节点\n        for(int i=0;i<k;i++){\n            if(i==k-1) head=rear;\n            rear=rear->next;\n        }\n        \n        //pre是前一段最后一个节点\n        ListNode *pre=new ListNode(0);\n        while(true){\n            p=front;q=front->next;s=q->next;\n            while(q!=rear){\n                q->next=p;\n                p=q;q=s;\n                //这里要注意rear可能是NULL, s->next需判断\n                if(s==rear && s==NULL) break;\n                else s=s->next;                \n            }\n            //本段和后一段相连,此时q=rear, s=rear->next, \n            front->next=rear;\n            //前面一段和本段第一个节点相连 \n            pre->next=p;\n            pre=front;\n            //更新front和rear\n            front=rear;\n            for(int i=0;i<k;i++) {\n                //rear可能没到目标就成了NULL\n                if(rear==NULL)return head;\n                rear=rear->next;\n            }\n        }\n        return head;  \n    }\n};\n```\n\n## Python Codes\n递归+栈\n\n```python\nclass Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        if k==1 or head==None:\n            return head\n        stack=[]\n        p=head;\n        #存入栈中\n        for i in range(k):\n            if p==None:\n                return head\n            stack.append(p);\n            p=p.next\n        \n        #逆序\n        for i in range(k-1, 0, -1):\n            stack[i].next=stack[i-1]\n        #和后一段相连, python递归要self.reverseKGroup()\n        stack[0].next=self.reverseKGroup(p, k)\n        #每次递归返回头节点\n        return stack[k-1] \n```\n\n迭代\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        if k==1:\n            return head\n        front=head\n        for i in range(k):\n            if front!=None:\n                front=front.next\n            else:\n              return head    \n        \n        front=rear=head\n        #front指向第一个节点, rear指向k+1个节点\n        for i in range(k):\n            if i==k-1:\n                head=rear\n            rear=rear.next \n            \n        #pre是前一段最后一个节点\n        pre=ListNode(0);\n        while True:\n            p=front\n            q=front.next\n            s=q.next\n            while q!=rear:\n                q.next=p\n                p=q\n                q=s\n                #这里要注意rear可能是NULL, s->next需判断\n                if s==rear and s==None:\n                    break\n                else:\n                    s=s.next                     \n            #本段和后一段相连,此时q=rear, s=rear->next, \n            front.next=rear\n            #前面一段和本段第一个节点相连 \n            pre.next=p\n            pre=front\n            #新front和rear\n            front=rear;\n            for i in range(k):\n                #rear可能没到目标就成了NULL\n                if rear==None:\n                    return head\n                rear=rear.next\n        return head;  \n```\n\n## 总结\n- 逆序问题可利用栈的特性\n- 发现问题可以分为多个子问题, 利用递归\n- 迭代的过程注意避免空指针和环\n\n-------\nPython是真的不太熟悉啦\n","source":"_posts/LeetCode/LeetCode-025-Reverse-Nodes-in-k-Group.md","raw":"---\ntitle: LeetCode-025-Reverse Nodes in k-Group\ntags:\n  - LeetCode\n  - Algorithm\n  - Stack\n  - Recursive\n  - LinkedList\n  - Reverse\n  - Hard\ncategories:\n  - LeetCode\nurlname: leetcode-reverse-nodes-in-k-group\ncomments: true\nmathjax: false\ndate: 2019-07-25 00:46:48\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)   \nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n\n### Examples:\n**Input:** 1-2-3-4-5\n**Output:** \n> k=2, 2-1-4-3-5\n> k=3, 3-2-1-4-5\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 递归, 每次改变k个节点的链接顺序, 然后令最后一个节点的next等于下一次递归的返回值, 最后返回头节点, 如果本次不满k个, 直接返回. 每次递归的内容可以是迭代或者用栈, 两种方式的时间差不多\n- 迭代, 基于第24题的迭代, 每次修改完一段之后, 要将此段和前一段相连, 还要和后一段相连, 要注意很多细节\n- 利用栈, 因为k个节点进栈顺序和出栈顺序正好相反\n\n\n## C++ Codes\n节点数据结构\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\n```\n\n递归+栈\n\n```C++\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if(k==1 || head==NULL) return head;\n        ListNode* stack[k];\n        ListNode *p=head;\n        //存入栈中\n        for(int i=0;i<k;i++){\n            if(p==NULL)return head;\n            stack[i]=p;\n            p=p->next;\n        }\n        //逆序\n        for(int i=k-1;i>0;i--){\n            stack[i]->next=stack[i-1];\n        }\n        //和后一段相连\n        stack[0]->next=reverseKGroup(p, k);\n        //每次递归返回头节点\n        return stack[k-1]; \n    }\n};\n```\n\n纯迭代, 相对递归感觉比较麻烦, 逻辑上要想更多, 但是资源肯定比递归消耗少\n```C++\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if(k==1) return head;\n        ListNode *front, *rear, *tmp, *p, *q, *s;\n        front=head;\n        for(int i=0;i<k;i++){\n            if(front!=NULL) front=front->next;\n            else return head;\n        }\n        front=rear=head;\n        //front指向第一个节点, rear指向k+1个节点\n        for(int i=0;i<k;i++){\n            if(i==k-1) head=rear;\n            rear=rear->next;\n        }\n        \n        //pre是前一段最后一个节点\n        ListNode *pre=new ListNode(0);\n        while(true){\n            p=front;q=front->next;s=q->next;\n            while(q!=rear){\n                q->next=p;\n                p=q;q=s;\n                //这里要注意rear可能是NULL, s->next需判断\n                if(s==rear && s==NULL) break;\n                else s=s->next;                \n            }\n            //本段和后一段相连,此时q=rear, s=rear->next, \n            front->next=rear;\n            //前面一段和本段第一个节点相连 \n            pre->next=p;\n            pre=front;\n            //更新front和rear\n            front=rear;\n            for(int i=0;i<k;i++) {\n                //rear可能没到目标就成了NULL\n                if(rear==NULL)return head;\n                rear=rear->next;\n            }\n        }\n        return head;  \n    }\n};\n```\n\n## Python Codes\n递归+栈\n\n```python\nclass Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        if k==1 or head==None:\n            return head\n        stack=[]\n        p=head;\n        #存入栈中\n        for i in range(k):\n            if p==None:\n                return head\n            stack.append(p);\n            p=p.next\n        \n        #逆序\n        for i in range(k-1, 0, -1):\n            stack[i].next=stack[i-1]\n        #和后一段相连, python递归要self.reverseKGroup()\n        stack[0].next=self.reverseKGroup(p, k)\n        #每次递归返回头节点\n        return stack[k-1] \n```\n\n迭代\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nclass Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        if k==1:\n            return head\n        front=head\n        for i in range(k):\n            if front!=None:\n                front=front.next\n            else:\n              return head    \n        \n        front=rear=head\n        #front指向第一个节点, rear指向k+1个节点\n        for i in range(k):\n            if i==k-1:\n                head=rear\n            rear=rear.next \n            \n        #pre是前一段最后一个节点\n        pre=ListNode(0);\n        while True:\n            p=front\n            q=front.next\n            s=q.next\n            while q!=rear:\n                q.next=p\n                p=q\n                q=s\n                #这里要注意rear可能是NULL, s->next需判断\n                if s==rear and s==None:\n                    break\n                else:\n                    s=s.next                     \n            #本段和后一段相连,此时q=rear, s=rear->next, \n            front.next=rear\n            #前面一段和本段第一个节点相连 \n            pre.next=p\n            pre=front\n            #新front和rear\n            front=rear;\n            for i in range(k):\n                #rear可能没到目标就成了NULL\n                if rear==None:\n                    return head\n                rear=rear.next\n        return head;  \n```\n\n## 总结\n- 逆序问题可利用栈的特性\n- 发现问题可以分为多个子问题, 利用递归\n- 迭代的过程注意避免空指针和环\n\n-------\nPython是真的不太熟悉啦\n","slug":"LeetCode/LeetCode-025-Reverse-Nodes-in-k-Group","published":1,"updated":"2019-09-17T13:43:40.703Z","layout":"post","photos":[],"link":"","_id":"ck2424lu6007jlksbds0bqjgo","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> 1-2-3-4-5<br><strong>Output:</strong></p><blockquote><p>k=2, 2-1-4-3-5<br>k=3, 3-2-1-4-5</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>递归, 每次改变k个节点的链接顺序, 然后令最后一个节点的next等于下一次递归的返回值, 最后返回头节点, 如果本次不满k个, 直接返回. 每次递归的内容可以是迭代或者用栈, 两种方式的时间差不多</li><li>迭代, 基于第24题的迭代, 每次修改完一段之后, 要将此段和前一段相连, 还要和后一段相连, 要注意很多细节</li><li>利用栈, 因为k个节点进栈顺序和出栈顺序正好相反</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>节点数据结构</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure><p>递归+栈</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseKGroup</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k==<span class=\"number\">1</span> || head==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode* <span class=\"built_in\">stack</span>[k];</span><br><span class=\"line\">        ListNode *p=head;</span><br><span class=\"line\">        <span class=\"comment\">//存入栈中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[i]=p;</span><br><span class=\"line\">            p=p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//逆序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=k<span class=\"number\">-1</span>;i&gt;<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[i]-&gt;next=<span class=\"built_in\">stack</span>[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//和后一段相连</span></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>[<span class=\"number\">0</span>]-&gt;next=reverseKGroup(p, k);</span><br><span class=\"line\">        <span class=\"comment\">//每次递归返回头节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>[k<span class=\"number\">-1</span>]; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>纯迭代, 相对递归感觉比较麻烦, 逻辑上要想更多, 但是资源肯定比递归消耗少<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseKGroup</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode *front, *rear, *tmp, *p, *q, *s;</span><br><span class=\"line\">        front=head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(front!=<span class=\"literal\">NULL</span>) front=front-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        front=rear=head;</span><br><span class=\"line\">        <span class=\"comment\">//front指向第一个节点, rear指向k+1个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==k<span class=\"number\">-1</span>) head=rear;</span><br><span class=\"line\">            rear=rear-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//pre是前一段最后一个节点</span></span><br><span class=\"line\">        ListNode *pre=<span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            p=front;q=front-&gt;next;s=q-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(q!=rear)&#123;</span><br><span class=\"line\">                q-&gt;next=p;</span><br><span class=\"line\">                p=q;q=s;</span><br><span class=\"line\">                <span class=\"comment\">//这里要注意rear可能是NULL, s-&gt;next需判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s==rear &amp;&amp; s==<span class=\"literal\">NULL</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> s=s-&gt;next;                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//本段和后一段相连,此时q=rear, s=rear-&gt;next, </span></span><br><span class=\"line\">            front-&gt;next=rear;</span><br><span class=\"line\">            <span class=\"comment\">//前面一段和本段第一个节点相连 </span></span><br><span class=\"line\">            pre-&gt;next=p;</span><br><span class=\"line\">            pre=front;</span><br><span class=\"line\">            <span class=\"comment\">//更新front和rear</span></span><br><span class=\"line\">            front=rear;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//rear可能没到目标就成了NULL</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(rear==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">                rear=rear-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>递归+栈</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k==<span class=\"number\">1</span> <span class=\"keyword\">or</span> head==<span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        stack=[]</span><br><span class=\"line\">        p=head;</span><br><span class=\"line\">        <span class=\"comment\">#存入栈中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p==<span class=\"keyword\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> head</span><br><span class=\"line\">            stack.append(p);</span><br><span class=\"line\">            p=p.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">#逆序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            stack[i].next=stack[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"comment\">#和后一段相连, python递归要self.reverseKGroup()</span></span><br><span class=\"line\">        stack[<span class=\"number\">0</span>].next=self.reverseKGroup(p, k)</span><br><span class=\"line\">        <span class=\"comment\">#每次递归返回头节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack[k<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure><p>迭代</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        front=head</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> front!=<span class=\"keyword\">None</span>:</span><br><span class=\"line\">                front=front.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">              <span class=\"keyword\">return</span> head    </span><br><span class=\"line\">        </span><br><span class=\"line\">        front=rear=head</span><br><span class=\"line\">        <span class=\"comment\">#front指向第一个节点, rear指向k+1个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i==k<span class=\"number\">-1</span>:</span><br><span class=\"line\">                head=rear</span><br><span class=\"line\">            rear=rear.next </span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">#pre是前一段最后一个节点</span></span><br><span class=\"line\">        pre=ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">            p=front</span><br><span class=\"line\">            q=front.next</span><br><span class=\"line\">            s=q.next</span><br><span class=\"line\">            <span class=\"keyword\">while</span> q!=rear:</span><br><span class=\"line\">                q.next=p</span><br><span class=\"line\">                p=q</span><br><span class=\"line\">                q=s</span><br><span class=\"line\">                <span class=\"comment\">#这里要注意rear可能是NULL, s-&gt;next需判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> s==rear <span class=\"keyword\">and</span> s==<span class=\"keyword\">None</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    s=s.next                     </span><br><span class=\"line\">            <span class=\"comment\">#本段和后一段相连,此时q=rear, s=rear-&gt;next, </span></span><br><span class=\"line\">            front.next=rear</span><br><span class=\"line\">            <span class=\"comment\">#前面一段和本段第一个节点相连 </span></span><br><span class=\"line\">            pre.next=p</span><br><span class=\"line\">            pre=front</span><br><span class=\"line\">            <span class=\"comment\">#新front和rear</span></span><br><span class=\"line\">            front=rear;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">                <span class=\"comment\">#rear可能没到目标就成了NULL</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> rear==<span class=\"keyword\">None</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> head</span><br><span class=\"line\">                rear=rear.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>逆序问题可利用栈的特性</li><li>发现问题可以分为多个子问题, 利用递归</li><li>迭代的过程注意避免空指针和环</li></ul><hr><p>Python是真的不太熟悉啦</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> 1-2-3-4-5<br><strong>Output:</strong></p><blockquote><p>k=2, 2-1-4-3-5<br>k=3, 3-2-1-4-5</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>递归, 每次改变k个节点的链接顺序, 然后令最后一个节点的next等于下一次递归的返回值, 最后返回头节点, 如果本次不满k个, 直接返回. 每次递归的内容可以是迭代或者用栈, 两种方式的时间差不多</li><li>迭代, 基于第24题的迭代, 每次修改完一段之后, 要将此段和前一段相连, 还要和后一段相连, 要注意很多细节</li><li>利用栈, 因为k个节点进栈顺序和出栈顺序正好相反</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>节点数据结构</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure><p>递归+栈</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseKGroup</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k==<span class=\"number\">1</span> || head==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode* <span class=\"built_in\">stack</span>[k];</span><br><span class=\"line\">        ListNode *p=head;</span><br><span class=\"line\">        <span class=\"comment\">//存入栈中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[i]=p;</span><br><span class=\"line\">            p=p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//逆序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=k<span class=\"number\">-1</span>;i&gt;<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[i]-&gt;next=<span class=\"built_in\">stack</span>[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//和后一段相连</span></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>[<span class=\"number\">0</span>]-&gt;next=reverseKGroup(p, k);</span><br><span class=\"line\">        <span class=\"comment\">//每次递归返回头节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>[k<span class=\"number\">-1</span>]; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>纯迭代, 相对递归感觉比较麻烦, 逻辑上要想更多, 但是资源肯定比递归消耗少<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseKGroup</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode *front, *rear, *tmp, *p, *q, *s;</span><br><span class=\"line\">        front=head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(front!=<span class=\"literal\">NULL</span>) front=front-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        front=rear=head;</span><br><span class=\"line\">        <span class=\"comment\">//front指向第一个节点, rear指向k+1个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==k<span class=\"number\">-1</span>) head=rear;</span><br><span class=\"line\">            rear=rear-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//pre是前一段最后一个节点</span></span><br><span class=\"line\">        ListNode *pre=<span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            p=front;q=front-&gt;next;s=q-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(q!=rear)&#123;</span><br><span class=\"line\">                q-&gt;next=p;</span><br><span class=\"line\">                p=q;q=s;</span><br><span class=\"line\">                <span class=\"comment\">//这里要注意rear可能是NULL, s-&gt;next需判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s==rear &amp;&amp; s==<span class=\"literal\">NULL</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> s=s-&gt;next;                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//本段和后一段相连,此时q=rear, s=rear-&gt;next, </span></span><br><span class=\"line\">            front-&gt;next=rear;</span><br><span class=\"line\">            <span class=\"comment\">//前面一段和本段第一个节点相连 </span></span><br><span class=\"line\">            pre-&gt;next=p;</span><br><span class=\"line\">            pre=front;</span><br><span class=\"line\">            <span class=\"comment\">//更新front和rear</span></span><br><span class=\"line\">            front=rear;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//rear可能没到目标就成了NULL</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(rear==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">                rear=rear-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>递归+栈</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k==<span class=\"number\">1</span> <span class=\"keyword\">or</span> head==<span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        stack=[]</span><br><span class=\"line\">        p=head;</span><br><span class=\"line\">        <span class=\"comment\">#存入栈中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> p==<span class=\"keyword\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> head</span><br><span class=\"line\">            stack.append(p);</span><br><span class=\"line\">            p=p.next</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">#逆序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">            stack[i].next=stack[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"comment\">#和后一段相连, python递归要self.reverseKGroup()</span></span><br><span class=\"line\">        stack[<span class=\"number\">0</span>].next=self.reverseKGroup(p, k)</span><br><span class=\"line\">        <span class=\"comment\">#每次递归返回头节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack[k<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure><p>迭代</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> k==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        front=head</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> front!=<span class=\"keyword\">None</span>:</span><br><span class=\"line\">                front=front.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">              <span class=\"keyword\">return</span> head    </span><br><span class=\"line\">        </span><br><span class=\"line\">        front=rear=head</span><br><span class=\"line\">        <span class=\"comment\">#front指向第一个节点, rear指向k+1个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i==k<span class=\"number\">-1</span>:</span><br><span class=\"line\">                head=rear</span><br><span class=\"line\">            rear=rear.next </span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">#pre是前一段最后一个节点</span></span><br><span class=\"line\">        pre=ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">            p=front</span><br><span class=\"line\">            q=front.next</span><br><span class=\"line\">            s=q.next</span><br><span class=\"line\">            <span class=\"keyword\">while</span> q!=rear:</span><br><span class=\"line\">                q.next=p</span><br><span class=\"line\">                p=q</span><br><span class=\"line\">                q=s</span><br><span class=\"line\">                <span class=\"comment\">#这里要注意rear可能是NULL, s-&gt;next需判断</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> s==rear <span class=\"keyword\">and</span> s==<span class=\"keyword\">None</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    s=s.next                     </span><br><span class=\"line\">            <span class=\"comment\">#本段和后一段相连,此时q=rear, s=rear-&gt;next, </span></span><br><span class=\"line\">            front.next=rear</span><br><span class=\"line\">            <span class=\"comment\">#前面一段和本段第一个节点相连 </span></span><br><span class=\"line\">            pre.next=p</span><br><span class=\"line\">            pre=front</span><br><span class=\"line\">            <span class=\"comment\">#新front和rear</span></span><br><span class=\"line\">            front=rear;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(k):</span><br><span class=\"line\">                <span class=\"comment\">#rear可能没到目标就成了NULL</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> rear==<span class=\"keyword\">None</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> head</span><br><span class=\"line\">                rear=rear.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>逆序问题可利用栈的特性</li><li>发现问题可以分为多个子问题, 利用递归</li><li>迭代的过程注意避免空指针和环</li></ul><hr><p>Python是真的不太熟悉啦</p><!-- rebuild by neat -->"},{"title":"LeetCode-023-Merge k Sorted Lists","urlname":"leetcode-merge-k-sorted-lists","comments":1,"mathjax":false,"date":"2019-05-23T05:10:02.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/merge-k-sorted-lists/)   \nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n\n### Examples:\n**Input:**\n> [\n> 　　1->4->5,\n> 　　1->3->4,\n> 　　2->6\n> ]\n**Output:** 1->1->2->3->4->4->5->6\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 相对上一题难度加大了一点，但是如果按照上一题的思路也是可以做的，就是时间复杂度会有点高\n- 这里介绍两种方法，第一种就是类似上一题的解法，每次循环找到所有链表中最小的头结点，然后改变指针指向，并不新建节点，中间有个坑是测试用例中会有空的链表，要注意处理下。每次加一个节点，加的时候遍历所有链表，所以时间复杂度是$$ O(n \\times k) $$,n是节点总数，k是链表数\n- 第二种方法是使用优先级队列，先将所有链表加入队列中，每次从队列中找到最小的节点，然后也是找n个节点，相对上一种方法是在$$ O(n \\times k) $$的k这里进行了优化，因为优先级队列存取是log()级别，因此时间复杂度是$$ O(n \\times log(k)) $$\n- 还想到一种方法是迭代，用上一题的方法进行两两合并，没有实现这种方法，看了题解有分治法，使用递归进两两合并\n\n\n## C++ Codes\n\n### 方法一\n就地改变链表指针指向，时间复杂度$$ O(n \\times k) $$\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.size()==0)return NULL;\n        ListNode *res = new ListNode(0);\n        ListNode *pre = res;\n        int min = 0;\n\n        while(lists.size()!=0){ \n            //确保lists[0]非NULL\n            while(lists.size()>0 && lists[min]==NULL){\n                lists.erase(lists.begin()+min);\n                min = 0;\n            }\n            if(lists.size()==0) return res->next;\n   \n            for(int i=0;i<lists.size();i++){\n                if(lists[i]==NULL) \n                    continue;\n                if(lists[i]->val<lists[min]->val)\n                    min = i;\n            }\n            pre->next = lists[min];\n            pre = pre->next;\n            lists[min] = lists[min]->next;\n        }\n        \n        return res->next;\n    }\n};\n```\n\n### 方法二\n使用优先级队列进行每轮插入最小的节点，时间复杂度为$$ O(n \\times log(k)) $$\n\n这里使用最小优先队列，最小的值优先级最大\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        //定义优先级队列比较结构\n        struct cmp{\n            bool operator ()(ListNode* a, ListNode* b){\n                return a->val > b->val;\n            }\n        };\n        ListNode *res = new ListNode(0);\n        ListNode *p = res;\n        \n        //建立优先级队列，这里是最小优先队列，最小的值优先级最大\n        priority_queue<ListNode*, vector<ListNode*>, cmp> pq;\n        for(ListNode* list : lists){\n            if(list!=NULL) pq.push(list);\n        }\n        \n        while(pq.size()>0){\n            p->next = pq.top();//获取优先级最高的元素，即数字最小的\n            pq.pop();//删除队首元素\n            p = p->next;\n            if(p->next != NULL) pq.push(p->next);\n        }\n        return res->next;\n    }\n};\n```\n\n###方法三\n分治法，使用递归两两合并，最终的链表等于合并好的前半部分加上合并好的后半部分，对前半部分在进行半部分和半部分的合并。\n\n下面贴一下题解的代码，Java\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n   public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) return null;\n        return merge(lists, 0, lists.length - 1);\n    }\n\n    private ListNode merge(ListNode[] lists, int left, int right) {\n        if (left == right) return lists[left];\n        int mid = left + (right - left) / 2;\n        ListNode l1 = merge(lists, left, mid);\n        ListNode l2 = merge(lists, mid + 1, right);\n        return mergeTwoLists(l1, l2);\n    }\n\n    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) return l2;\n        if (l2 == null) return l1;\n        if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1,l2.next);\n            return l2;\n        }\n    }\n}\n```\n\n\n## Python Codes\n这里使用方法二\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        import heapq\n        dummy = ListNode(0)\n        p = dummy\n        head = []\n        for i in range(len(lists)):\n            if lists[i] :\n                heapq.heappush(head, (lists[i].val, i))\n                lists[i] = lists[i].next\n        while head:\n            val, idx = heapq.heappop(head)\n            p.next = ListNode(val)\n            p = p.next\n            if lists[idx]:\n                heapq.heappush(head, (lists[idx].val, idx))\n                lists[idx] = lists[idx].next\n        return dummy.next\n```\n\n## 总结\n- 合并多个链表相对上一题就是链表数变多之后的处理，可以用优先级队列加快节点的查找，也可以使用分治法，合并症各部分就是先合并前半部分和后半部分，再将这两个部分合在一起 \n\n\n------\n","source":"_posts/LeetCode/LeetCode-023-Merge-k-Sorted-Lists.md","raw":"---\ntitle: LeetCode-023-Merge k Sorted Lists\ntags:\n  - LeetCode\n  - Algorithm\n  - List\n  - LinkedList\n  - PriorityQueue\n  - Merge\n  - Hard\ncategories:\n  - LeetCode\nurlname: leetcode-merge-k-sorted-lists\ncomments: true\nmathjax: false\ndate: 2019-05-23 13:10:02\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode.com/problems/merge-k-sorted-lists/)   \nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n\n### Examples:\n**Input:**\n> [\n> 　　1->4->5,\n> 　　1->3->4,\n> 　　2->6\n> ]\n**Output:** 1->1->2->3->4->4->5->6\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 相对上一题难度加大了一点，但是如果按照上一题的思路也是可以做的，就是时间复杂度会有点高\n- 这里介绍两种方法，第一种就是类似上一题的解法，每次循环找到所有链表中最小的头结点，然后改变指针指向，并不新建节点，中间有个坑是测试用例中会有空的链表，要注意处理下。每次加一个节点，加的时候遍历所有链表，所以时间复杂度是$$ O(n \\times k) $$,n是节点总数，k是链表数\n- 第二种方法是使用优先级队列，先将所有链表加入队列中，每次从队列中找到最小的节点，然后也是找n个节点，相对上一种方法是在$$ O(n \\times k) $$的k这里进行了优化，因为优先级队列存取是log()级别，因此时间复杂度是$$ O(n \\times log(k)) $$\n- 还想到一种方法是迭代，用上一题的方法进行两两合并，没有实现这种方法，看了题解有分治法，使用递归进两两合并\n\n\n## C++ Codes\n\n### 方法一\n就地改变链表指针指向，时间复杂度$$ O(n \\times k) $$\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.size()==0)return NULL;\n        ListNode *res = new ListNode(0);\n        ListNode *pre = res;\n        int min = 0;\n\n        while(lists.size()!=0){ \n            //确保lists[0]非NULL\n            while(lists.size()>0 && lists[min]==NULL){\n                lists.erase(lists.begin()+min);\n                min = 0;\n            }\n            if(lists.size()==0) return res->next;\n   \n            for(int i=0;i<lists.size();i++){\n                if(lists[i]==NULL) \n                    continue;\n                if(lists[i]->val<lists[min]->val)\n                    min = i;\n            }\n            pre->next = lists[min];\n            pre = pre->next;\n            lists[min] = lists[min]->next;\n        }\n        \n        return res->next;\n    }\n};\n```\n\n### 方法二\n使用优先级队列进行每轮插入最小的节点，时间复杂度为$$ O(n \\times log(k)) $$\n\n这里使用最小优先队列，最小的值优先级最大\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        //定义优先级队列比较结构\n        struct cmp{\n            bool operator ()(ListNode* a, ListNode* b){\n                return a->val > b->val;\n            }\n        };\n        ListNode *res = new ListNode(0);\n        ListNode *p = res;\n        \n        //建立优先级队列，这里是最小优先队列，最小的值优先级最大\n        priority_queue<ListNode*, vector<ListNode*>, cmp> pq;\n        for(ListNode* list : lists){\n            if(list!=NULL) pq.push(list);\n        }\n        \n        while(pq.size()>0){\n            p->next = pq.top();//获取优先级最高的元素，即数字最小的\n            pq.pop();//删除队首元素\n            p = p->next;\n            if(p->next != NULL) pq.push(p->next);\n        }\n        return res->next;\n    }\n};\n```\n\n###方法三\n分治法，使用递归两两合并，最终的链表等于合并好的前半部分加上合并好的后半部分，对前半部分在进行半部分和半部分的合并。\n\n下面贴一下题解的代码，Java\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n   public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) return null;\n        return merge(lists, 0, lists.length - 1);\n    }\n\n    private ListNode merge(ListNode[] lists, int left, int right) {\n        if (left == right) return lists[left];\n        int mid = left + (right - left) / 2;\n        ListNode l1 = merge(lists, left, mid);\n        ListNode l2 = merge(lists, mid + 1, right);\n        return mergeTwoLists(l1, l2);\n    }\n\n    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) return l2;\n        if (l2 == null) return l1;\n        if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1,l2.next);\n            return l2;\n        }\n    }\n}\n```\n\n\n## Python Codes\n这里使用方法二\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        import heapq\n        dummy = ListNode(0)\n        p = dummy\n        head = []\n        for i in range(len(lists)):\n            if lists[i] :\n                heapq.heappush(head, (lists[i].val, i))\n                lists[i] = lists[i].next\n        while head:\n            val, idx = heapq.heappop(head)\n            p.next = ListNode(val)\n            p = p.next\n            if lists[idx]:\n                heapq.heappush(head, (lists[idx].val, idx))\n                lists[idx] = lists[idx].next\n        return dummy.next\n```\n\n## 总结\n- 合并多个链表相对上一题就是链表数变多之后的处理，可以用优先级队列加快节点的查找，也可以使用分治法，合并症各部分就是先合并前半部分和后半部分，再将这两个部分合在一起 \n\n\n------\n","slug":"LeetCode/LeetCode-023-Merge-k-Sorted-Lists","published":1,"updated":"2019-07-25T18:27:07.719Z","layout":"post","photos":[],"link":"","_id":"ck2424lu7007mlksbe569uyni","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>[<br>1-&gt;4-&gt;5,<br>1-&gt;3-&gt;4,<br>2-&gt;6<br>]<br><strong>Output:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>相对上一题难度加大了一点，但是如果按照上一题的思路也是可以做的，就是时间复杂度会有点高</li><li>这里介绍两种方法，第一种就是类似上一题的解法，每次循环找到所有链表中最小的头结点，然后改变指针指向，并不新建节点，中间有个坑是测试用例中会有空的链表，要注意处理下。每次加一个节点，加的时候遍历所有链表，所以时间复杂度是<script type=\"math/tex\">O(n \\times k)</script>,n是节点总数，k是链表数</li><li>第二种方法是使用优先级队列，先将所有链表加入队列中，每次从队列中找到最小的节点，然后也是找n个节点，相对上一种方法是在<script type=\"math/tex\">O(n \\times k)</script>的k这里进行了优化，因为优先级队列存取是log()级别，因此时间复杂度是<script type=\"math/tex\">O(n \\times log(k))</script></li><li>还想到一种方法是迭代，用上一题的方法进行两两合并，没有实现这种方法，看了题解有分治法，使用递归进两两合并</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>就地改变链表指针指向，时间复杂度<script type=\"math/tex\">O(n \\times k)</script></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lists.size()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        ListNode *res = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode *pre = res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lists.size()!=<span class=\"number\">0</span>)&#123; </span><br><span class=\"line\">            <span class=\"comment\">//确保lists[0]非NULL</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(lists.size()&gt;<span class=\"number\">0</span> &amp;&amp; lists[min]==<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                lists.erase(lists.begin()+min);</span><br><span class=\"line\">                min = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lists.size()==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> res-&gt;next;</span><br><span class=\"line\">   </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;lists.size();i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(lists[i]==<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(lists[i]-&gt;val&lt;lists[min]-&gt;val)</span><br><span class=\"line\">                    min = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre-&gt;next = lists[min];</span><br><span class=\"line\">            pre = pre-&gt;next;</span><br><span class=\"line\">            lists[min] = lists[min]-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>使用优先级队列进行每轮插入最小的节点，时间复杂度为<script type=\"math/tex\">O(n \\times log(k))</script></p><p>这里使用最小优先队列，最小的值优先级最大</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//定义优先级队列比较结构</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp</span>&#123;</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span> <span class=\"params\">()</span><span class=\"params\">(ListNode* a, ListNode* b)</span></span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        ListNode *res = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode *p = res;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//建立优先级队列，这里是最小优先队列，最小的值优先级最大</span></span><br><span class=\"line\">        priority_queue&lt;ListNode*, <span class=\"built_in\">vector</span>&lt;ListNode*&gt;, cmp&gt; pq;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(ListNode* <span class=\"built_in\">list</span> : lists)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">list</span>!=<span class=\"literal\">NULL</span>) pq.push(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pq.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            p-&gt;next = pq.top();<span class=\"comment\">//获取优先级最高的元素，即数字最小的</span></span><br><span class=\"line\">            pq.pop();<span class=\"comment\">//删除队首元素</span></span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p-&gt;next != <span class=\"literal\">NULL</span>) pq.push(p-&gt;next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h3 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h3><p>分治法，使用递归两两合并，最终的链表等于合并好的前半部分加上合并好的后半部分，对前半部分在进行半部分和半部分的合并。</p><p>下面贴一下题解的代码，Java</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeKLists</span><span class=\"params\">(ListNode[] lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lists == <span class=\"keyword\">null</span> || lists.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(lists, <span class=\"number\">0</span>, lists.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">merge</span><span class=\"params\">(ListNode[] lists, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == right) <span class=\"keyword\">return</span> lists[left];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        ListNode l1 = merge(lists, left, mid);</span><br><span class=\"line\">        ListNode l2 = merge(lists, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mergeTwoLists(l1, l2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class=\"line\">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>这里使用方法二</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">import</span> heapq</span><br><span class=\"line\">        dummy = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p = dummy</span><br><span class=\"line\">        head = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(lists)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[i] :</span><br><span class=\"line\">                heapq.heappush(head, (lists[i].val, i))</span><br><span class=\"line\">                lists[i] = lists[i].next</span><br><span class=\"line\">        <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">            val, idx = heapq.heappop(head)</span><br><span class=\"line\">            p.next = ListNode(val)</span><br><span class=\"line\">            p = p.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[idx]:</span><br><span class=\"line\">                heapq.heappush(head, (lists[idx].val, idx))</span><br><span class=\"line\">                lists[idx] = lists[idx].next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>合并多个链表相对上一题就是链表数变多之后的处理，可以用优先级队列加快节点的查找，也可以使用分治法，合并症各部分就是先合并前半部分和后半部分，再将这两个部分合在一起</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>[<br>1-&gt;4-&gt;5,<br>1-&gt;3-&gt;4,<br>2-&gt;6<br>]<br><strong>Output:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>相对上一题难度加大了一点，但是如果按照上一题的思路也是可以做的，就是时间复杂度会有点高</li><li>这里介绍两种方法，第一种就是类似上一题的解法，每次循环找到所有链表中最小的头结点，然后改变指针指向，并不新建节点，中间有个坑是测试用例中会有空的链表，要注意处理下。每次加一个节点，加的时候遍历所有链表，所以时间复杂度是<script type=\"math/tex\">O(n \\times k)</script>,n是节点总数，k是链表数</li><li>第二种方法是使用优先级队列，先将所有链表加入队列中，每次从队列中找到最小的节点，然后也是找n个节点，相对上一种方法是在<script type=\"math/tex\">O(n \\times k)</script>的k这里进行了优化，因为优先级队列存取是log()级别，因此时间复杂度是<script type=\"math/tex\">O(n \\times log(k))</script></li><li>还想到一种方法是迭代，用上一题的方法进行两两合并，没有实现这种方法，看了题解有分治法，使用递归进两两合并</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>就地改变链表指针指向，时间复杂度<script type=\"math/tex\">O(n \\times k)</script></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lists.size()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        ListNode *res = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode *pre = res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lists.size()!=<span class=\"number\">0</span>)&#123; </span><br><span class=\"line\">            <span class=\"comment\">//确保lists[0]非NULL</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(lists.size()&gt;<span class=\"number\">0</span> &amp;&amp; lists[min]==<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                lists.erase(lists.begin()+min);</span><br><span class=\"line\">                min = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lists.size()==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> res-&gt;next;</span><br><span class=\"line\">   </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;lists.size();i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(lists[i]==<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(lists[i]-&gt;val&lt;lists[min]-&gt;val)</span><br><span class=\"line\">                    min = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pre-&gt;next = lists[min];</span><br><span class=\"line\">            pre = pre-&gt;next;</span><br><span class=\"line\">            lists[min] = lists[min]-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>使用优先级队列进行每轮插入最小的节点，时间复杂度为<script type=\"math/tex\">O(n \\times log(k))</script></p><p>这里使用最小优先队列，最小的值优先级最大</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//定义优先级队列比较结构</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp</span>&#123;</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span> <span class=\"params\">()</span><span class=\"params\">(ListNode* a, ListNode* b)</span></span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        ListNode *res = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode *p = res;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//建立优先级队列，这里是最小优先队列，最小的值优先级最大</span></span><br><span class=\"line\">        priority_queue&lt;ListNode*, <span class=\"built_in\">vector</span>&lt;ListNode*&gt;, cmp&gt; pq;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(ListNode* <span class=\"built_in\">list</span> : lists)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">list</span>!=<span class=\"literal\">NULL</span>) pq.push(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pq.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            p-&gt;next = pq.top();<span class=\"comment\">//获取优先级最高的元素，即数字最小的</span></span><br><span class=\"line\">            pq.pop();<span class=\"comment\">//删除队首元素</span></span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p-&gt;next != <span class=\"literal\">NULL</span>) pq.push(p-&gt;next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h3 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h3><p>分治法，使用递归两两合并，最终的链表等于合并好的前半部分加上合并好的后半部分，对前半部分在进行半部分和半部分的合并。</p><p>下面贴一下题解的代码，Java</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeKLists</span><span class=\"params\">(ListNode[] lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lists == <span class=\"keyword\">null</span> || lists.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(lists, <span class=\"number\">0</span>, lists.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">merge</span><span class=\"params\">(ListNode[] lists, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == right) <span class=\"keyword\">return</span> lists[left];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        ListNode l1 = merge(lists, left, mid);</span><br><span class=\"line\">        ListNode l2 = merge(lists, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mergeTwoLists(l1, l2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class=\"line\">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>这里使用方法二</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"># class ListNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.next = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeKLists</span><span class=\"params\">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class=\"line\">        <span class=\"keyword\">import</span> heapq</span><br><span class=\"line\">        dummy = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        p = dummy</span><br><span class=\"line\">        head = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(lists)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[i] :</span><br><span class=\"line\">                heapq.heappush(head, (lists[i].val, i))</span><br><span class=\"line\">                lists[i] = lists[i].next</span><br><span class=\"line\">        <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">            val, idx = heapq.heappop(head)</span><br><span class=\"line\">            p.next = ListNode(val)</span><br><span class=\"line\">            p = p.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> lists[idx]:</span><br><span class=\"line\">                heapq.heappush(head, (lists[idx].val, idx))</span><br><span class=\"line\">                lists[idx] = lists[idx].next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>合并多个链表相对上一题就是链表数变多之后的处理，可以用优先级队列加快节点的查找，也可以使用分治法，合并症各部分就是先合并前半部分和后半部分，再将这两个部分合在一起</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-240-Search a 2D Matrix II","urlname":"leetcode-search-a-2d-matrix-ii","comments":1,"mathjax":false,"date":"2019-06-01T16:29:32.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)   \nWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n- Integers in each row are sorted in ascending from left to right.\n- Integers in each column are sorted in ascending from top to bottom.\n\n简单点说就是二维数组，从左向右递增，从上向下递增，然后查找输入的数组，要求高效\n\n### Examples:\n**Input:**\n> [\n>   [1,   4,  7, 11, 15],\n>   [2,   5,  8, 12, 19],\n>   [3,   6,  9, 16, 22],\n>   [10, 13, 14, 17, 24],\n>   [18, 21, 23, 26, 30]\n> ]\n**Output:**\n> Given target = 5, return true.\n> Given target = 20, return false.\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 如果是$$ O(n) $$可能不行，毕竟要高效的算法，这里从数组的结构入手\n- 以右上角为起点进行查找，如果比它大，就向下，如果比它小，就向左，一直找到边界位置\n\n\n## C++ Codes\n用时108ms\n\n```C++\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        if(matrix.size()==0 || matrix[0].size()==0)return false;\n        int col = matrix[0].size()-1;\n        int row = 0;\n        int n = matrix.size();\n        //边界条件就是col>=0 && row<n\n        while(col>=0 && row<n){\n            if(matrix[row][col]>target)\n                col--;\n            else if(matrix[row][col]<target)\n                row++;\n            else return true;\n        }\n        return false;\n    }\n};\n```\n\n\n## 总结\n- 对于这种排序好结构很明显的，尽量从结构上入手，找特点，而不是暴力解\n\n\n------\n","source":"_posts/LeetCode/LeetCode-240-Search-a-2D-Matrix-II.md","raw":"---\ntitle: LeetCode-240-Search a 2D Matrix II\ntags:\n  - LeetCode\n  - Algorithm\n  - Matrix\n  - Search\n  - Medium\ncategories:\n  - LeetCode\nurlname: leetcode-search-a-2d-matrix-ii\ncomments: true\nmathjax: false\ndate: 2019-06-02 00:29:32\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)   \nWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n- Integers in each row are sorted in ascending from left to right.\n- Integers in each column are sorted in ascending from top to bottom.\n\n简单点说就是二维数组，从左向右递增，从上向下递增，然后查找输入的数组，要求高效\n\n### Examples:\n**Input:**\n> [\n>   [1,   4,  7, 11, 15],\n>   [2,   5,  8, 12, 19],\n>   [3,   6,  9, 16, 22],\n>   [10, 13, 14, 17, 24],\n>   [18, 21, 23, 26, 30]\n> ]\n**Output:**\n> Given target = 5, return true.\n> Given target = 20, return false.\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 如果是$$ O(n) $$可能不行，毕竟要高效的算法，这里从数组的结构入手\n- 以右上角为起点进行查找，如果比它大，就向下，如果比它小，就向左，一直找到边界位置\n\n\n## C++ Codes\n用时108ms\n\n```C++\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        if(matrix.size()==0 || matrix[0].size()==0)return false;\n        int col = matrix[0].size()-1;\n        int row = 0;\n        int n = matrix.size();\n        //边界条件就是col>=0 && row<n\n        while(col>=0 && row<n){\n            if(matrix[row][col]>target)\n                col--;\n            else if(matrix[row][col]<target)\n                row++;\n            else return true;\n        }\n        return false;\n    }\n};\n```\n\n\n## 总结\n- 对于这种排序好结构很明显的，尽量从结构上入手，找特点，而不是暴力解\n\n\n------\n","slug":"LeetCode/LeetCode-240-Search-a-2D-Matrix-II","published":1,"updated":"2019-07-25T18:30:34.109Z","layout":"post","photos":[],"link":"","_id":"ck2424lub007plksbmci3id9e","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><p>简单点说就是二维数组，从左向右递增，从上向下递增，然后查找输入的数组，要求高效</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>[<br>[1, 4, 7, 11, 15],<br>[2, 5, 8, 12, 19],<br>[3, 6, 9, 16, 22],<br>[10, 13, 14, 17, 24],<br>[18, 21, 23, 26, 30]<br>]<br><strong>Output:</strong><br>Given target = 5, return true.<br>Given target = 20, return false.</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>如果是<script type=\"math/tex\">O(n)</script>可能不行，毕竟要高效的算法，这里从数组的结构入手</li><li>以右上角为起点进行查找，如果比它大，就向下，如果比它小，就向左，一直找到边界位置</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>用时108ms</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(matrix.size()==<span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].size()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> col = matrix[<span class=\"number\">0</span>].size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> row = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = matrix.size();</span><br><span class=\"line\">        <span class=\"comment\">//边界条件就是col&gt;=0 &amp;&amp; row&lt;n</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(col&gt;=<span class=\"number\">0</span> &amp;&amp; row&lt;n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matrix[row][col]&gt;target)</span><br><span class=\"line\">                col--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(matrix[row][col]&lt;target)</span><br><span class=\"line\">                row++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>对于这种排序好结构很明显的，尽量从结构上入手，找特点，而不是暴力解</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><p>简单点说就是二维数组，从左向右递增，从上向下递增，然后查找输入的数组，要求高效</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>[<br>[1, 4, 7, 11, 15],<br>[2, 5, 8, 12, 19],<br>[3, 6, 9, 16, 22],<br>[10, 13, 14, 17, 24],<br>[18, 21, 23, 26, 30]<br>]<br><strong>Output:</strong><br>Given target = 5, return true.<br>Given target = 20, return false.</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>如果是<script type=\"math/tex\">O(n)</script>可能不行，毕竟要高效的算法，这里从数组的结构入手</li><li>以右上角为起点进行查找，如果比它大，就向下，如果比它小，就向左，一直找到边界位置</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>用时108ms</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(matrix.size()==<span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].size()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> col = matrix[<span class=\"number\">0</span>].size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> row = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = matrix.size();</span><br><span class=\"line\">        <span class=\"comment\">//边界条件就是col&gt;=0 &amp;&amp; row&lt;n</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(col&gt;=<span class=\"number\">0</span> &amp;&amp; row&lt;n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matrix[row][col]&gt;target)</span><br><span class=\"line\">                col--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(matrix[row][col]&lt;target)</span><br><span class=\"line\">                row++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>对于这种排序好结构很明显的，尽量从结构上入手，找特点，而不是暴力解</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-124-Binary Tree Maximum Path Sum","urlname":"leetcode-binary-tree-maximum-path-sum","comments":1,"mathjax":false,"date":"2019-06-13T15:41:23.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n落了好多题没记录了，而且因为刷的是专项，没有按照顺序了，所以....顺序很乱，这阵子就先这样把，后面夏令营结束再按照顺序来，把以前的慢慢补上。\n\nLeetCode中国还是挺方便的，加载速度比原版的快很多，而且可以中英文切换。\n\n## [Problem](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)   \nGiven a non-empty binary tree, find the maximum path sum.\n\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\n\n求二叉树最大的路径和，任意节点到任意节点的最大路径和\n\n### Examples:\n**Input:**[1,2,3]\n**Output:**6\n**Input:**[-10,9,20,null,null,15,7]\n**Output:**42\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 二叉树一般就是递归，这道题也很明显用递归，找到左子树、右子树的最大路径和，一共算了下，大概有一下几种情况\n\n1. 左子树路径和加根节点值最大\n2. 右子树路径和加根节点值最大\n3. 左右子树路径和都是负数，所以单独的根节点值最大\n4. 左右子树路径和加上根节点值最大，$$ 如果左右子树路径和都非负，那肯定就得加上嘛 $$\n\n这里之所以不把左子树路径和与右子树路径和单独列出来，是因为递归到左右子树的时候就相当于判断过来\n\n按照这样的思路，就可以想到办法了，求左右子树路径和，然后找到最大的一边，加上根节点值，这是前三种情况，再和第四种情况：三者之和 比较，就可以得到最后的结果resSum，然后和全局遍历maxSum比较：$$ maxSum = max(maxSum, resSum) $$\n\n- 改进的方法是，判断左右子树的路径和是否小于0，如果小于0，那肯定就不走这边，所以令其为0，最后就变成了一种情况，就是上面的第四种，只要把三者相加，再和全局变量maxSum比较就可以\n\n解释下，如果某一边大于0，那肯定要加上，如果小于0，不走那边就相当于加上0，就可以\n\n但是最后的结果发现，虽然第二种办法，将四种情况缩成了一种情况，但是似乎时间会花的更多。第一种情况是32ms，第二种是40ms+。\n\n\n## C++ Codes\n递归，第一种解法，判断四种情况的，32ms\n\n```C++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int maxSum;\n    int maxPathSum(TreeNode* root) {\n        maxSum = root->val;\n        int rootGain = maxGain(root);\n        return maxSum;\n    }\n    int maxGain(TreeNode *root){\n        if(root==NULL) return 0;\n        int leftGain = maxGain(root->left);\n        int rightGain = maxGain(root->right);\n        int rootGain = max(leftGain, rightGain)+root->val;\n        int newPathGain = leftGain + rightGain + root->val;\n        int resGain = max(newPathGain, rootGain);\n        if(resGain > maxSum)\n            maxSum = resGain;\n        if(rootGain<=0) return 0;\n        return rootGain;\n    }\n};\n```\n\n## C++ Codes\n第二种解法，合并成一种情况的，44ms\n\n```C++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int maxSum;\n    int maxPathSum(TreeNode* root) {\n        maxSum = root->val;\n        int rootGain = maxGain(root);\n        return maxSum;\n    }\n    int maxGain(TreeNode *root){\n        if(root==NULL) return 0;\n        int leftGain = max(maxGain(root->left), 0);\n        int rightGain = max(maxGain(root->right), 0);\n        int newPathGain = leftGain + rightGain + root->val;\n        maxSum = max(newPathGain, maxSum);\n        return max(leftGain, rightGain)+root->val;\n    }\n};\n```\n\n\n## 总结\n- 二叉树一般用递归就好了，查找还是啥操作的，一般递归+剪枝就可以，往这方向想 \n\n\n------\n","source":"_posts/LeetCode/LeetCode-124-Binary-Tree-Maximum-Path-Sum.md","raw":"---\ntitle: LeetCode-124-Binary Tree Maximum Path Sum\ntags:\n  - LeetCode\n  - Algorithm\n  - Hard\n  - BinaryTree\n  - Recursive\n  - DP\n  - Hard\ncategories:\n  - LeetCode\nurlname: leetcode-binary-tree-maximum-path-sum\ncomments: true\nmathjax: false\ndate: 2019-06-13 23:41:23\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 前言\n落了好多题没记录了，而且因为刷的是专项，没有按照顺序了，所以....顺序很乱，这阵子就先这样把，后面夏令营结束再按照顺序来，把以前的慢慢补上。\n\nLeetCode中国还是挺方便的，加载速度比原版的快很多，而且可以中英文切换。\n\n## [Problem](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)   \nGiven a non-empty binary tree, find the maximum path sum.\n\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\n\n求二叉树最大的路径和，任意节点到任意节点的最大路径和\n\n### Examples:\n**Input:**[1,2,3]\n**Output:**6\n**Input:**[-10,9,20,null,null,15,7]\n**Output:**42\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 二叉树一般就是递归，这道题也很明显用递归，找到左子树、右子树的最大路径和，一共算了下，大概有一下几种情况\n\n1. 左子树路径和加根节点值最大\n2. 右子树路径和加根节点值最大\n3. 左右子树路径和都是负数，所以单独的根节点值最大\n4. 左右子树路径和加上根节点值最大，$$ 如果左右子树路径和都非负，那肯定就得加上嘛 $$\n\n这里之所以不把左子树路径和与右子树路径和单独列出来，是因为递归到左右子树的时候就相当于判断过来\n\n按照这样的思路，就可以想到办法了，求左右子树路径和，然后找到最大的一边，加上根节点值，这是前三种情况，再和第四种情况：三者之和 比较，就可以得到最后的结果resSum，然后和全局遍历maxSum比较：$$ maxSum = max(maxSum, resSum) $$\n\n- 改进的方法是，判断左右子树的路径和是否小于0，如果小于0，那肯定就不走这边，所以令其为0，最后就变成了一种情况，就是上面的第四种，只要把三者相加，再和全局变量maxSum比较就可以\n\n解释下，如果某一边大于0，那肯定要加上，如果小于0，不走那边就相当于加上0，就可以\n\n但是最后的结果发现，虽然第二种办法，将四种情况缩成了一种情况，但是似乎时间会花的更多。第一种情况是32ms，第二种是40ms+。\n\n\n## C++ Codes\n递归，第一种解法，判断四种情况的，32ms\n\n```C++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int maxSum;\n    int maxPathSum(TreeNode* root) {\n        maxSum = root->val;\n        int rootGain = maxGain(root);\n        return maxSum;\n    }\n    int maxGain(TreeNode *root){\n        if(root==NULL) return 0;\n        int leftGain = maxGain(root->left);\n        int rightGain = maxGain(root->right);\n        int rootGain = max(leftGain, rightGain)+root->val;\n        int newPathGain = leftGain + rightGain + root->val;\n        int resGain = max(newPathGain, rootGain);\n        if(resGain > maxSum)\n            maxSum = resGain;\n        if(rootGain<=0) return 0;\n        return rootGain;\n    }\n};\n```\n\n## C++ Codes\n第二种解法，合并成一种情况的，44ms\n\n```C++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int maxSum;\n    int maxPathSum(TreeNode* root) {\n        maxSum = root->val;\n        int rootGain = maxGain(root);\n        return maxSum;\n    }\n    int maxGain(TreeNode *root){\n        if(root==NULL) return 0;\n        int leftGain = max(maxGain(root->left), 0);\n        int rightGain = max(maxGain(root->right), 0);\n        int newPathGain = leftGain + rightGain + root->val;\n        maxSum = max(newPathGain, maxSum);\n        return max(leftGain, rightGain)+root->val;\n    }\n};\n```\n\n\n## 总结\n- 二叉树一般用递归就好了，查找还是啥操作的，一般递归+剪枝就可以，往这方向想 \n\n\n------\n","slug":"LeetCode/LeetCode-124-Binary-Tree-Maximum-Path-Sum","published":1,"updated":"2019-07-25T18:29:17.632Z","layout":"post","photos":[],"link":"","_id":"ck2424luc007rlksbftn3gwyp","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>落了好多题没记录了，而且因为刷的是专项，没有按照顺序了，所以….顺序很乱，这阵子就先这样把，后面夏令营结束再按照顺序来，把以前的慢慢补上。</p><p>LeetCode中国还是挺方便的，加载速度比原版的快很多，而且可以中英文切换。</p><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a non-empty binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p><p>求二叉树最大的路径和，任意节点到任意节点的最大路径和</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>[1,2,3]<br><strong>Output:</strong>6<br><strong>Input:</strong>[-10,9,20,null,null,15,7]<br><strong>Output:</strong>42</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>二叉树一般就是递归，这道题也很明显用递归，找到左子树、右子树的最大路径和，一共算了下，大概有一下几种情况</li></ul><ol><li>左子树路径和加根节点值最大</li><li>右子树路径和加根节点值最大</li><li>左右子树路径和都是负数，所以单独的根节点值最大</li><li>左右子树路径和加上根节点值最大，<script type=\"math/tex\">如果左右子树路径和都非负，那肯定就得加上嘛</script></li></ol><p>这里之所以不把左子树路径和与右子树路径和单独列出来，是因为递归到左右子树的时候就相当于判断过来</p><p>按照这样的思路，就可以想到办法了，求左右子树路径和，然后找到最大的一边，加上根节点值，这是前三种情况，再和第四种情况：三者之和 比较，就可以得到最后的结果resSum，然后和全局遍历maxSum比较：<script type=\"math/tex\">maxSum = max(maxSum, resSum)</script></p><ul><li>改进的方法是，判断左右子树的路径和是否小于0，如果小于0，那肯定就不走这边，所以令其为0，最后就变成了一种情况，就是上面的第四种，只要把三者相加，再和全局变量maxSum比较就可以</li></ul><p>解释下，如果某一边大于0，那肯定要加上，如果小于0，不走那边就相当于加上0，就可以</p><p>但是最后的结果发现，虽然第二种办法，将四种情况缩成了一种情况，但是似乎时间会花的更多。第一种情况是32ms，第二种是40ms+。</p><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>递归，第一种解法，判断四种情况的，32ms</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxSum;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        maxSum = root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rootGain = maxGain(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxGain</span><span class=\"params\">(TreeNode *root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftGain = maxGain(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rightGain = maxGain(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rootGain = max(leftGain, rightGain)+root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newPathGain = leftGain + rightGain + root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> resGain = max(newPathGain, rootGain);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(resGain &gt; maxSum)</span><br><span class=\"line\">            maxSum = resGain;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rootGain&lt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rootGain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"C-Codes-1\"><a href=\"#C-Codes-1\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>第二种解法，合并成一种情况的，44ms</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxSum;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        maxSum = root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rootGain = maxGain(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxGain</span><span class=\"params\">(TreeNode *root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftGain = max(maxGain(root-&gt;left), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rightGain = max(maxGain(root-&gt;right), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newPathGain = leftGain + rightGain + root-&gt;val;</span><br><span class=\"line\">        maxSum = max(newPathGain, maxSum);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(leftGain, rightGain)+root-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>二叉树一般用递归就好了，查找还是啥操作的，一般递归+剪枝就可以，往这方向想</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>落了好多题没记录了，而且因为刷的是专项，没有按照顺序了，所以….顺序很乱，这阵子就先这样把，后面夏令营结束再按照顺序来，把以前的慢慢补上。</p><p>LeetCode中国还是挺方便的，加载速度比原版的快很多，而且可以中英文切换。</p><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given a non-empty binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p><p>求二叉树最大的路径和，任意节点到任意节点的最大路径和</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>[1,2,3]<br><strong>Output:</strong>6<br><strong>Input:</strong>[-10,9,20,null,null,15,7]<br><strong>Output:</strong>42</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>二叉树一般就是递归，这道题也很明显用递归，找到左子树、右子树的最大路径和，一共算了下，大概有一下几种情况</li></ul><ol><li>左子树路径和加根节点值最大</li><li>右子树路径和加根节点值最大</li><li>左右子树路径和都是负数，所以单独的根节点值最大</li><li>左右子树路径和加上根节点值最大，<script type=\"math/tex\">如果左右子树路径和都非负，那肯定就得加上嘛</script></li></ol><p>这里之所以不把左子树路径和与右子树路径和单独列出来，是因为递归到左右子树的时候就相当于判断过来</p><p>按照这样的思路，就可以想到办法了，求左右子树路径和，然后找到最大的一边，加上根节点值，这是前三种情况，再和第四种情况：三者之和 比较，就可以得到最后的结果resSum，然后和全局遍历maxSum比较：<script type=\"math/tex\">maxSum = max(maxSum, resSum)</script></p><ul><li>改进的方法是，判断左右子树的路径和是否小于0，如果小于0，那肯定就不走这边，所以令其为0，最后就变成了一种情况，就是上面的第四种，只要把三者相加，再和全局变量maxSum比较就可以</li></ul><p>解释下，如果某一边大于0，那肯定要加上，如果小于0，不走那边就相当于加上0，就可以</p><p>但是最后的结果发现，虽然第二种办法，将四种情况缩成了一种情况，但是似乎时间会花的更多。第一种情况是32ms，第二种是40ms+。</p><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>递归，第一种解法，判断四种情况的，32ms</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxSum;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        maxSum = root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rootGain = maxGain(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxGain</span><span class=\"params\">(TreeNode *root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftGain = maxGain(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rightGain = maxGain(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rootGain = max(leftGain, rightGain)+root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newPathGain = leftGain + rightGain + root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> resGain = max(newPathGain, rootGain);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(resGain &gt; maxSum)</span><br><span class=\"line\">            maxSum = resGain;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rootGain&lt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rootGain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"C-Codes-1\"><a href=\"#C-Codes-1\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>第二种解法，合并成一种情况的，44ms</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxSum;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        maxSum = root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rootGain = maxGain(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxGain</span><span class=\"params\">(TreeNode *root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftGain = max(maxGain(root-&gt;left), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rightGain = max(maxGain(root-&gt;right), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newPathGain = leftGain + rightGain + root-&gt;val;</span><br><span class=\"line\">        maxSum = max(newPathGain, maxSum);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(leftGain, rightGain)+root-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>二叉树一般用递归就好了，查找还是啥操作的，一般递归+剪枝就可以，往这方向想</li></ul><hr><!-- rebuild by neat -->"},{"title":"LeetCode-169-Majority Element","urlname":"leetcode-majority-element","comments":1,"mathjax":false,"date":"2019-05-25T16:55:31.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/majority-element/)   \nGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n\nYou may assume that the array is non-empty and the majority element always exist in the array.\n\n### Examples:\n**Input:**[3,2,3]\n**Output:**3\n**Input:**[2,2,1,1,1,2,2]\n**Output:**2\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 找众数嘛，只要记录下来他们每个出现的次数就好了啊\n- 用map存放每个数字出现的次数，然后遇到比n/2.0大的就return\n\n\n## C++ Codes\n时间复杂度$$ O(n) $$,用时32ms\n\n```C++\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        map<int, int> mymap;\n        int n = nums.size();\n        int res = 0;\n        for(int i=0;i<n;i++){\n            if(mymap.count(nums[i])==1)\n                mymap[nums[i]] = mymap[nums[i]]+1;\n            else\n                mymap[nums[i]] = 1;\n\n            if(mymap[nums[i]]>n/2.0){\n                res = nums[i];\n                break;\n            }\n\n        }\n        return res;\n    }\n};\n\n```\n\n## Python Codes\n简单题就不写py版本了\n\n## 总结\n- map真好用。。真香\n- 数据量特别大的时候，可以用hash_map\n- map的查找方式是二分查找，如果是100万条记录，最多也只要20次的string.compare的比较，200万条记录，也只要用21次的比较\n- 如果想要在如此大的记录量下，只用一两次的string.compare就找到记录，那就要用hash_map\n\n\n------\n","source":"_posts/LeetCode/LeetCode-169-Majority-Element.md","raw":"---\ntitle: LeetCode-169-Majority Element\ntags:\n  - LeetCode\n  - Algorithm\n  - Math\n  - Map\n  - Majority\n  - Easy\ncategories:\n  - LeetCode\nurlname: leetcode-majority-element\ncomments: true\nmathjax: false\ndate: 2019-05-26 00:55:31\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://leetcode-cn.com/problems/majority-element/)   \nGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n\nYou may assume that the array is non-empty and the majority element always exist in the array.\n\n### Examples:\n**Input:**[3,2,3]\n**Output:**3\n**Input:**[2,2,1,1,1,2,2]\n**Output:**2\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 找众数嘛，只要记录下来他们每个出现的次数就好了啊\n- 用map存放每个数字出现的次数，然后遇到比n/2.0大的就return\n\n\n## C++ Codes\n时间复杂度$$ O(n) $$,用时32ms\n\n```C++\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        map<int, int> mymap;\n        int n = nums.size();\n        int res = 0;\n        for(int i=0;i<n;i++){\n            if(mymap.count(nums[i])==1)\n                mymap[nums[i]] = mymap[nums[i]]+1;\n            else\n                mymap[nums[i]] = 1;\n\n            if(mymap[nums[i]]>n/2.0){\n                res = nums[i];\n                break;\n            }\n\n        }\n        return res;\n    }\n};\n\n```\n\n## Python Codes\n简单题就不写py版本了\n\n## 总结\n- map真好用。。真香\n- 数据量特别大的时候，可以用hash_map\n- map的查找方式是二分查找，如果是100万条记录，最多也只要20次的string.compare的比较，200万条记录，也只要用21次的比较\n- 如果想要在如此大的记录量下，只用一两次的string.compare就找到记录，那就要用hash_map\n\n\n------\n","slug":"LeetCode/LeetCode-169-Majority-Element","published":1,"updated":"2019-07-25T18:30:11.532Z","layout":"post","photos":[],"link":"","_id":"ck2424lue007ulksbbz7bunk8","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/majority-element/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>[3,2,3]<br><strong>Output:</strong>3<br><strong>Input:</strong>[2,2,1,1,1,2,2]<br><strong>Output:</strong>2</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>找众数嘛，只要记录下来他们每个出现的次数就好了啊</li><li>用map存放每个数字出现的次数，然后遇到比n/2.0大的就return</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>时间复杂度<script type=\"math/tex\">O(n)</script>,用时32ms</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; mymap;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mymap.count(nums[i])==<span class=\"number\">1</span>)</span><br><span class=\"line\">                mymap[nums[i]] = mymap[nums[i]]+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                mymap[nums[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mymap[nums[i]]&gt;n/<span class=\"number\">2.0</span>)&#123;</span><br><span class=\"line\">                res = nums[i];</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>简单题就不写py版本了</p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>map真好用。。真香</li><li>数据量特别大的时候，可以用hash_map</li><li>map的查找方式是二分查找，如果是100万条记录，最多也只要20次的string.compare的比较，200万条记录，也只要用21次的比较</li><li>如果想要在如此大的记录量下，只用一两次的string.compare就找到记录，那就要用hash_map</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://leetcode-cn.com/problems/majority-element/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong>[3,2,3]<br><strong>Output:</strong>3<br><strong>Input:</strong>[2,2,1,1,1,2,2]<br><strong>Output:</strong>2</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>找众数嘛，只要记录下来他们每个出现的次数就好了啊</li><li>用map存放每个数字出现的次数，然后遇到比n/2.0大的就return</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>时间复杂度<script type=\"math/tex\">O(n)</script>,用时32ms</p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; mymap;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mymap.count(nums[i])==<span class=\"number\">1</span>)</span><br><span class=\"line\">                mymap[nums[i]] = mymap[nums[i]]+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                mymap[nums[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mymap[nums[i]]&gt;n/<span class=\"number\">2.0</span>)&#123;</span><br><span class=\"line\">                res = nums[i];</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"Python-Codes\"><a href=\"#Python-Codes\" class=\"headerlink\" title=\"Python Codes\"></a>Python Codes</h2><p>简单题就不写py版本了</p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>map真好用。。真香</li><li>数据量特别大的时候，可以用hash_map</li><li>map的查找方式是二分查找，如果是100万条记录，最多也只要20次的string.compare的比较，200万条记录，也只要用21次的比较</li><li>如果想要在如此大的记录量下，只用一两次的string.compare就找到记录，那就要用hash_map</li></ul><hr><!-- rebuild by neat -->"},{"title":"NowCoder-IWannaGoHome","comments":1,"mathjax":false,"date":"2019-09-22T05:19:10.000Z","urlname":"I-Wanna-Go-Home","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/0160bab3ce5d4ae0bb99dc605601e971?tpId=40&tqId=21359&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\nThe country is facing a terrible civil war----cities in the country are divided into two parts supporting different leaders. As a merchant, Mr. M does not pay attention to politics but he actually knows the severe situation, and your task is to help him reach home as soon as possible.     \"For the sake of safety,\", said Mr.M, \"your route should contain at most 1 road which connects two cities of different camp.\"     Would you please tell Mr. M at least how long will it take to reach his sweet home?\n\nThe input contains multiple test cases.\n\nThe first line of each case is an integer N (2<=N<=600), representing the number of cities in the country.\nThe second line contains one integer M (0<=M<=10000), which is the number of roads.\n\nThe following M lines are the information of the roads. Each line contains three integers A, B and T, which means the road between city A and city B will cost time T. T is in the range of [1,500].\n\nNext part contains N integers, which are either 1 or 2. The i-th integer shows the supporting leader of city i.\n\nTo simplify the problem, we assume that Mr. M starts from city 1 and his target is city 2. City 1 always supports leader 1 while city 2 is at the same side of leader 2.\n\nNote that all roads are bidirectional and there is at most 1 road between two cities.\n\nInput is ended with a case of N=0.\n\nFor each test case, output one integer representing the minimum time to reach home.\n\nIf it is impossible to reach home according to Mr. M's demands, output -1 instead.\n\n### Examples:\n**Input:**\n> 2\n> 1\n> 1 2 100\n> 1 2\n> 3\n> 3\n> 1 2 100\n> 1 3 40\n> 2 3 50\n> 1 2 1\n> 5\n> 5\n> 3 1 200\n> 5 3 150\n> 2 5 160\n> 4 3 170\n> 4 2 170\n> 1 2 2 2 1\n> 0\n \n**Output:**\n> 100\n> 90\n> 540\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 单源最短路径问题，计算两次最短路，分别是计算阵营1里各点最短路径，和阵营2里各点最短路径，然后再遍历边界线上联通两个阵营的边，看哪个最短 \n\n\n## C++ Codes\n\n```C++\n#include <stdio.h>\n#include <limits.h>\n#define N 601\n \nint G[N][N];    //城市间的距离，用时间表示\nint camp[N];    //各个城市的阵营\nint n[3];       //n[0]: 城市数量; n[1]、n[2]: 两个阵营各自的城市数量\n \nint Add(int a, int b)\n{   \n    //两个数相加\n    if(a==INT_MAX||b==INT_MAX) return INT_MAX;\n    else return a+b;\n}\n \nint Add3(int a, int b, int c)\n{   \n    //三个数相加\n    if(a==INT_MAX||b==INT_MAX||c==INT_MAX)  return INT_MAX;\n    else return a+b+c;\n}\n \nint d1[N], d2[N];       //分别存储1、2到同阵营各点最小距离\nbool mark[N];           //标记点是否在集合里面\nvoid Dijkstra(int d[N], int from)\n{   \n    //dijkstra算法求某点到同阵营各点的最小距离\n    for(int i=0; i<=n[0]; i++)\n    {\n        //不是同阵营的先塞进集合里面\n        if(camp[i]==from) mark[i]=false;\n        else mark[i]=true;\n    }\n\n    //把起点塞进集合\n    mark[from]=true;\n    //初始化d[N]\n    for(int i=0; i<=n[0]; i++)\n    {\n        if(camp[i]==from) d[i]=G[from][i];\n    }\n\n    //把同阵营的点全都塞进集合\n    for(int i=0; i<n[camp[from]]-1; i++)\n    {\n        bool isFirst=true;\n        int near;\n\n        //挑一个d[?]最小的，下标为near\n        for(int i=1; i<=n[0]; i++)\n        {\n            if(mark[i]==false)\n            {\n                if(isFirst)\n                {\n                    near=i;\n                    isFirst=false;\n                }\n                else if(d[i]<d[near]) near=i;\n            }\n        }\n\n        mark[near]=true;        \n        //更新同阵营的点的d[i]信息\n        for(int i=1; i<=n[0]; i++)\n        {\n            if(camp[i]==from&&mark[i]==false)\n            {\n                int sum=Add(d[near], G[near][i]);\n                if(sum<d[i]) d[i]=sum;\n            }\n        }\n    }\n}\n \nint main()\n{\n    int m;\n    while(scanf(\"%d\", &n[0])!=EOF)\n    {\n        if(n[0]==0) break;\n        scanf(\"%d\", &m);\n\n        //初始化邻接矩阵\n        for(int i=0; i<=n[0]; i++)\n        {\n            for(int j=0; j<=n[0]; j++)\n            {\n                if(i==j) G[i][j]=0;\n                else G[i][j]=INT_MAX;\n            }\n        }\n        //读取边\n        while(m--)\n        {\n            int a, b, t;\n            scanf(\"%d%d%d\", &a, &b, &t);\n            if(t<G[a][b]) G[a][b]=G[b][a]=t;\n        }\n\n        n[1]=n[2]=0;                //两个阵营暂时都没城市\n        for(int i=1; i<=n[0]; i++)  //读取阵营信息\n        {\n            scanf(\"%d\", &camp[i]);\n            n[camp[i]]++;\n        }\n\n        Dijkstra(d1, 1);            //求出1到同阵营各点的最小距离\n        Dijkstra(d2, 2);            //求出2到同阵营各点的最小距离\n\n        int ans=INT_MAX;            //先假设最小距离是无穷大\n        //开始找穿越边境的路\n        for(int i=1; i<=n[0]; i++)\n        {\n            for(int j=i+1; j<=n[0]; j++)\n            {\n                //i是1阵营j是2阵营的话\n                if(camp[i]==1&&camp[j]==2)\n                {\n                    //看看从这条路过境是否更划算\n                    int sum=Add3(d1[i], d2[j], G[i][j]);\n                    if(sum<ans) ans=sum;\n                }\n                else if(camp[i]==2&&camp[j]==1)\n                {\n                    int sum=Add3(d2[i], d1[j], G[i][j]);\n                    if(sum<ans) ans=sum;\n                }\n            }\n        }\n\n        //输出结果\n        //最短总耗时是无穷，说明无路可走\n        if(ans!=INT_MAX) printf(\"%d\\n\", ans);\n        else printf(\"-1\\n\");\n    }\n    return 0;\n}\n```\n\n## 总结\n- 不是模板题，需要注意下两个阵营不能一起使用dijkstra，而是应该分阵营计算好，然后加上边界的值，得到最短路劲\n- dijkstra主要是两个for循环，最短路径，每次找距离源点最近的点加进去，维护的dis数组也是距离源点的数组\n\n------\n","source":"_posts/NowCoder/NowCoder-IWannaGoHome.md","raw":"---\ntitle: NowCoder-IWannaGoHome\ntags:\n  - NowCoder\n  - Algorithm\n  - Graph\n  - Dijkstra\n  - Hard\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-22 13:19:10\nurlname: I-Wanna-Go-Home\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/0160bab3ce5d4ae0bb99dc605601e971?tpId=40&tqId=21359&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\nThe country is facing a terrible civil war----cities in the country are divided into two parts supporting different leaders. As a merchant, Mr. M does not pay attention to politics but he actually knows the severe situation, and your task is to help him reach home as soon as possible.     \"For the sake of safety,\", said Mr.M, \"your route should contain at most 1 road which connects two cities of different camp.\"     Would you please tell Mr. M at least how long will it take to reach his sweet home?\n\nThe input contains multiple test cases.\n\nThe first line of each case is an integer N (2<=N<=600), representing the number of cities in the country.\nThe second line contains one integer M (0<=M<=10000), which is the number of roads.\n\nThe following M lines are the information of the roads. Each line contains three integers A, B and T, which means the road between city A and city B will cost time T. T is in the range of [1,500].\n\nNext part contains N integers, which are either 1 or 2. The i-th integer shows the supporting leader of city i.\n\nTo simplify the problem, we assume that Mr. M starts from city 1 and his target is city 2. City 1 always supports leader 1 while city 2 is at the same side of leader 2.\n\nNote that all roads are bidirectional and there is at most 1 road between two cities.\n\nInput is ended with a case of N=0.\n\nFor each test case, output one integer representing the minimum time to reach home.\n\nIf it is impossible to reach home according to Mr. M's demands, output -1 instead.\n\n### Examples:\n**Input:**\n> 2\n> 1\n> 1 2 100\n> 1 2\n> 3\n> 3\n> 1 2 100\n> 1 3 40\n> 2 3 50\n> 1 2 1\n> 5\n> 5\n> 3 1 200\n> 5 3 150\n> 2 5 160\n> 4 3 170\n> 4 2 170\n> 1 2 2 2 1\n> 0\n \n**Output:**\n> 100\n> 90\n> 540\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 单源最短路径问题，计算两次最短路，分别是计算阵营1里各点最短路径，和阵营2里各点最短路径，然后再遍历边界线上联通两个阵营的边，看哪个最短 \n\n\n## C++ Codes\n\n```C++\n#include <stdio.h>\n#include <limits.h>\n#define N 601\n \nint G[N][N];    //城市间的距离，用时间表示\nint camp[N];    //各个城市的阵营\nint n[3];       //n[0]: 城市数量; n[1]、n[2]: 两个阵营各自的城市数量\n \nint Add(int a, int b)\n{   \n    //两个数相加\n    if(a==INT_MAX||b==INT_MAX) return INT_MAX;\n    else return a+b;\n}\n \nint Add3(int a, int b, int c)\n{   \n    //三个数相加\n    if(a==INT_MAX||b==INT_MAX||c==INT_MAX)  return INT_MAX;\n    else return a+b+c;\n}\n \nint d1[N], d2[N];       //分别存储1、2到同阵营各点最小距离\nbool mark[N];           //标记点是否在集合里面\nvoid Dijkstra(int d[N], int from)\n{   \n    //dijkstra算法求某点到同阵营各点的最小距离\n    for(int i=0; i<=n[0]; i++)\n    {\n        //不是同阵营的先塞进集合里面\n        if(camp[i]==from) mark[i]=false;\n        else mark[i]=true;\n    }\n\n    //把起点塞进集合\n    mark[from]=true;\n    //初始化d[N]\n    for(int i=0; i<=n[0]; i++)\n    {\n        if(camp[i]==from) d[i]=G[from][i];\n    }\n\n    //把同阵营的点全都塞进集合\n    for(int i=0; i<n[camp[from]]-1; i++)\n    {\n        bool isFirst=true;\n        int near;\n\n        //挑一个d[?]最小的，下标为near\n        for(int i=1; i<=n[0]; i++)\n        {\n            if(mark[i]==false)\n            {\n                if(isFirst)\n                {\n                    near=i;\n                    isFirst=false;\n                }\n                else if(d[i]<d[near]) near=i;\n            }\n        }\n\n        mark[near]=true;        \n        //更新同阵营的点的d[i]信息\n        for(int i=1; i<=n[0]; i++)\n        {\n            if(camp[i]==from&&mark[i]==false)\n            {\n                int sum=Add(d[near], G[near][i]);\n                if(sum<d[i]) d[i]=sum;\n            }\n        }\n    }\n}\n \nint main()\n{\n    int m;\n    while(scanf(\"%d\", &n[0])!=EOF)\n    {\n        if(n[0]==0) break;\n        scanf(\"%d\", &m);\n\n        //初始化邻接矩阵\n        for(int i=0; i<=n[0]; i++)\n        {\n            for(int j=0; j<=n[0]; j++)\n            {\n                if(i==j) G[i][j]=0;\n                else G[i][j]=INT_MAX;\n            }\n        }\n        //读取边\n        while(m--)\n        {\n            int a, b, t;\n            scanf(\"%d%d%d\", &a, &b, &t);\n            if(t<G[a][b]) G[a][b]=G[b][a]=t;\n        }\n\n        n[1]=n[2]=0;                //两个阵营暂时都没城市\n        for(int i=1; i<=n[0]; i++)  //读取阵营信息\n        {\n            scanf(\"%d\", &camp[i]);\n            n[camp[i]]++;\n        }\n\n        Dijkstra(d1, 1);            //求出1到同阵营各点的最小距离\n        Dijkstra(d2, 2);            //求出2到同阵营各点的最小距离\n\n        int ans=INT_MAX;            //先假设最小距离是无穷大\n        //开始找穿越边境的路\n        for(int i=1; i<=n[0]; i++)\n        {\n            for(int j=i+1; j<=n[0]; j++)\n            {\n                //i是1阵营j是2阵营的话\n                if(camp[i]==1&&camp[j]==2)\n                {\n                    //看看从这条路过境是否更划算\n                    int sum=Add3(d1[i], d2[j], G[i][j]);\n                    if(sum<ans) ans=sum;\n                }\n                else if(camp[i]==2&&camp[j]==1)\n                {\n                    int sum=Add3(d2[i], d1[j], G[i][j]);\n                    if(sum<ans) ans=sum;\n                }\n            }\n        }\n\n        //输出结果\n        //最短总耗时是无穷，说明无路可走\n        if(ans!=INT_MAX) printf(\"%d\\n\", ans);\n        else printf(\"-1\\n\");\n    }\n    return 0;\n}\n```\n\n## 总结\n- 不是模板题，需要注意下两个阵营不能一起使用dijkstra，而是应该分阵营计算好，然后加上边界的值，得到最短路劲\n- dijkstra主要是两个for循环，最短路径，每次找距离源点最近的点加进去，维护的dis数组也是距离源点的数组\n\n------\n","slug":"NowCoder/NowCoder-IWannaGoHome","published":1,"updated":"2019-09-22T06:03:08.736Z","layout":"post","photos":[],"link":"","_id":"ck2424lug007wlksbrv4jw9t5","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/0160bab3ce5d4ae0bb99dc605601e971?tpId=40&amp;tqId=21359&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>The country is facing a terrible civil war——cities in the country are divided into two parts supporting different leaders. As a merchant, Mr. M does not pay attention to politics but he actually knows the severe situation, and your task is to help him reach home as soon as possible. “For the sake of safety,”, said Mr.M, “your route should contain at most 1 road which connects two cities of different camp.” Would you please tell Mr. M at least how long will it take to reach his sweet home?</p><p>The input contains multiple test cases.</p><p>The first line of each case is an integer N (2&lt;=N&lt;=600), representing the number of cities in the country.<br>The second line contains one integer M (0&lt;=M&lt;=10000), which is the number of roads.</p><p>The following M lines are the information of the roads. Each line contains three integers A, B and T, which means the road between city A and city B will cost time T. T is in the range of [1,500].</p><p>Next part contains N integers, which are either 1 or 2. The i-th integer shows the supporting leader of city i.</p><p>To simplify the problem, we assume that Mr. M starts from city 1 and his target is city 2. City 1 always supports leader 1 while city 2 is at the same side of leader 2.</p><p>Note that all roads are bidirectional and there is at most 1 road between two cities.</p><p>Input is ended with a case of N=0.</p><p>For each test case, output one integer representing the minimum time to reach home.</p><p>If it is impossible to reach home according to Mr. M’s demands, output -1 instead.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>2<br>1<br>1 2 100<br>1 2<br>3<br>3<br>1 2 100<br>1 3 40<br>2 3 50<br>1 2 1<br>5<br>5<br>3 1 200<br>5 3 150<br>2 5 160<br>4 3 170<br>4 2 170<br>1 2 2 2 1<br>0</p></blockquote><p><strong>Output:</strong></p><blockquote><p>100<br>90<br>540</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>单源最短路径问题，计算两次最短路，分别是计算阵营1里各点最短路径，和阵营2里各点最短路径，然后再遍历边界线上联通两个阵营的边，看哪个最短</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;limits.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 601</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> G[N][N];    <span class=\"comment\">//城市间的距离，用时间表示</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> camp[N];    <span class=\"comment\">//各个城市的阵营</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n[<span class=\"number\">3</span>];       <span class=\"comment\">//n[0]: 城市数量; n[1]、n[2]: 两个阵营各自的城市数量</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"comment\">//两个数相加</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a==INT_MAX||b==INT_MAX) <span class=\"keyword\">return</span> INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Add3</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"comment\">//三个数相加</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a==INT_MAX||b==INT_MAX||c==INT_MAX)  <span class=\"keyword\">return</span> INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> a+b+c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> d1[N], d2[N];       <span class=\"comment\">//分别存储1、2到同阵营各点最小距离</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> mark[N];           <span class=\"comment\">//标记点是否在集合里面</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> d[N], <span class=\"keyword\">int</span> from)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"comment\">//dijkstra算法求某点到同阵营各点的最小距离</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//不是同阵营的先塞进集合里面</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(camp[i]==from) mark[i]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> mark[i]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//把起点塞进集合</span></span><br><span class=\"line\">    mark[from]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">//初始化d[N]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(camp[i]==from) d[i]=G[from][i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//把同阵营的点全都塞进集合</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n[camp[from]]<span class=\"number\">-1</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> isFirst=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> near;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//挑一个d[?]最小的，下标为near</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mark[i]==<span class=\"literal\">false</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(isFirst)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    near=i;</span><br><span class=\"line\">                    isFirst=<span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(d[i]&lt;d[near]) near=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mark[near]=<span class=\"literal\">true</span>;        </span><br><span class=\"line\">        <span class=\"comment\">//更新同阵营的点的d[i]信息</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(camp[i]==from&amp;&amp;mark[i]==<span class=\"literal\">false</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> sum=Add(d[near], G[near][i]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(sum&lt;d[i]) d[i]=sum;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n[<span class=\"number\">0</span>])!=EOF)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n[<span class=\"number\">0</span>]==<span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;m);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//初始化邻接矩阵</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;=n[<span class=\"number\">0</span>]; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i==j) G[i][j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> G[i][j]=INT_MAX;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//读取边</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a, b, t;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>, &amp;a, &amp;b, &amp;t);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t&lt;G[a][b]) G[a][b]=G[b][a]=t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        n[<span class=\"number\">1</span>]=n[<span class=\"number\">2</span>]=<span class=\"number\">0</span>;                <span class=\"comment\">//两个阵营暂时都没城市</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)  <span class=\"comment\">//读取阵营信息</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;camp[i]);</span><br><span class=\"line\">            n[camp[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Dijkstra(d1, <span class=\"number\">1</span>);            <span class=\"comment\">//求出1到同阵营各点的最小距离</span></span><br><span class=\"line\">        Dijkstra(d2, <span class=\"number\">2</span>);            <span class=\"comment\">//求出2到同阵营各点的最小距离</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans=INT_MAX;            <span class=\"comment\">//先假设最小距离是无穷大</span></span><br><span class=\"line\">        <span class=\"comment\">//开始找穿越边境的路</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>; j&lt;=n[<span class=\"number\">0</span>]; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//i是1阵营j是2阵营的话</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(camp[i]==<span class=\"number\">1</span>&amp;&amp;camp[j]==<span class=\"number\">2</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//看看从这条路过境是否更划算</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum=Add3(d1[i], d2[j], G[i][j]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(sum&lt;ans) ans=sum;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(camp[i]==<span class=\"number\">2</span>&amp;&amp;camp[j]==<span class=\"number\">1</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum=Add3(d2[i], d1[j], G[i][j]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(sum&lt;ans) ans=sum;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">        <span class=\"comment\">//最短总耗时是无穷，说明无路可走</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans!=INT_MAX) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>不是模板题，需要注意下两个阵营不能一起使用dijkstra，而是应该分阵营计算好，然后加上边界的值，得到最短路劲</li><li>dijkstra主要是两个for循环，最短路径，每次找距离源点最近的点加进去，维护的dis数组也是距离源点的数组</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/0160bab3ce5d4ae0bb99dc605601e971?tpId=40&amp;tqId=21359&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>The country is facing a terrible civil war——cities in the country are divided into two parts supporting different leaders. As a merchant, Mr. M does not pay attention to politics but he actually knows the severe situation, and your task is to help him reach home as soon as possible. “For the sake of safety,”, said Mr.M, “your route should contain at most 1 road which connects two cities of different camp.” Would you please tell Mr. M at least how long will it take to reach his sweet home?</p><p>The input contains multiple test cases.</p><p>The first line of each case is an integer N (2&lt;=N&lt;=600), representing the number of cities in the country.<br>The second line contains one integer M (0&lt;=M&lt;=10000), which is the number of roads.</p><p>The following M lines are the information of the roads. Each line contains three integers A, B and T, which means the road between city A and city B will cost time T. T is in the range of [1,500].</p><p>Next part contains N integers, which are either 1 or 2. The i-th integer shows the supporting leader of city i.</p><p>To simplify the problem, we assume that Mr. M starts from city 1 and his target is city 2. City 1 always supports leader 1 while city 2 is at the same side of leader 2.</p><p>Note that all roads are bidirectional and there is at most 1 road between two cities.</p><p>Input is ended with a case of N=0.</p><p>For each test case, output one integer representing the minimum time to reach home.</p><p>If it is impossible to reach home according to Mr. M’s demands, output -1 instead.</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>2<br>1<br>1 2 100<br>1 2<br>3<br>3<br>1 2 100<br>1 3 40<br>2 3 50<br>1 2 1<br>5<br>5<br>3 1 200<br>5 3 150<br>2 5 160<br>4 3 170<br>4 2 170<br>1 2 2 2 1<br>0</p></blockquote><p><strong>Output:</strong></p><blockquote><p>100<br>90<br>540</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>单源最短路径问题，计算两次最短路，分别是计算阵营1里各点最短路径，和阵营2里各点最短路径，然后再遍历边界线上联通两个阵营的边，看哪个最短</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;limits.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 601</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> G[N][N];    <span class=\"comment\">//城市间的距离，用时间表示</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> camp[N];    <span class=\"comment\">//各个城市的阵营</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n[<span class=\"number\">3</span>];       <span class=\"comment\">//n[0]: 城市数量; n[1]、n[2]: 两个阵营各自的城市数量</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"comment\">//两个数相加</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a==INT_MAX||b==INT_MAX) <span class=\"keyword\">return</span> INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Add3</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"comment\">//三个数相加</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a==INT_MAX||b==INT_MAX||c==INT_MAX)  <span class=\"keyword\">return</span> INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> a+b+c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> d1[N], d2[N];       <span class=\"comment\">//分别存储1、2到同阵营各点最小距离</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> mark[N];           <span class=\"comment\">//标记点是否在集合里面</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> d[N], <span class=\"keyword\">int</span> from)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\">    <span class=\"comment\">//dijkstra算法求某点到同阵营各点的最小距离</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//不是同阵营的先塞进集合里面</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(camp[i]==from) mark[i]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> mark[i]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//把起点塞进集合</span></span><br><span class=\"line\">    mark[from]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">//初始化d[N]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(camp[i]==from) d[i]=G[from][i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//把同阵营的点全都塞进集合</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n[camp[from]]<span class=\"number\">-1</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> isFirst=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> near;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//挑一个d[?]最小的，下标为near</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mark[i]==<span class=\"literal\">false</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(isFirst)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    near=i;</span><br><span class=\"line\">                    isFirst=<span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(d[i]&lt;d[near]) near=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mark[near]=<span class=\"literal\">true</span>;        </span><br><span class=\"line\">        <span class=\"comment\">//更新同阵营的点的d[i]信息</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(camp[i]==from&amp;&amp;mark[i]==<span class=\"literal\">false</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> sum=Add(d[near], G[near][i]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(sum&lt;d[i]) d[i]=sum;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n[<span class=\"number\">0</span>])!=EOF)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n[<span class=\"number\">0</span>]==<span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;m);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//初始化邻接矩阵</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;=n[<span class=\"number\">0</span>]; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i==j) G[i][j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> G[i][j]=INT_MAX;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//读取边</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a, b, t;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>, &amp;a, &amp;b, &amp;t);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t&lt;G[a][b]) G[a][b]=G[b][a]=t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        n[<span class=\"number\">1</span>]=n[<span class=\"number\">2</span>]=<span class=\"number\">0</span>;                <span class=\"comment\">//两个阵营暂时都没城市</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)  <span class=\"comment\">//读取阵营信息</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;camp[i]);</span><br><span class=\"line\">            n[camp[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Dijkstra(d1, <span class=\"number\">1</span>);            <span class=\"comment\">//求出1到同阵营各点的最小距离</span></span><br><span class=\"line\">        Dijkstra(d2, <span class=\"number\">2</span>);            <span class=\"comment\">//求出2到同阵营各点的最小距离</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans=INT_MAX;            <span class=\"comment\">//先假设最小距离是无穷大</span></span><br><span class=\"line\">        <span class=\"comment\">//开始找穿越边境的路</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>; j&lt;=n[<span class=\"number\">0</span>]; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//i是1阵营j是2阵营的话</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(camp[i]==<span class=\"number\">1</span>&amp;&amp;camp[j]==<span class=\"number\">2</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//看看从这条路过境是否更划算</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum=Add3(d1[i], d2[j], G[i][j]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(sum&lt;ans) ans=sum;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(camp[i]==<span class=\"number\">2</span>&amp;&amp;camp[j]==<span class=\"number\">1</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum=Add3(d2[i], d1[j], G[i][j]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(sum&lt;ans) ans=sum;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">        <span class=\"comment\">//最短总耗时是无穷，说明无路可走</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans!=INT_MAX) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>不是模板题，需要注意下两个阵营不能一起使用dijkstra，而是应该分阵营计算好，然后加上边界的值，得到最短路劲</li><li>dijkstra主要是两个for循环，最短路径，每次找距离源点最近的点加进去，维护的dis数组也是距离源点的数组</li></ul><hr><!-- rebuild by neat -->"},{"title":"NowCoder-10进制和2进制","comments":1,"mathjax":false,"date":"2019-09-22T04:05:17.000Z","urlname":"dec-vs-bin","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/fd972d5d5cf04dd4bb4e5f027d4fc11e?tpId=40&tqId=21357&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们乘B为A的二进制逆序数。     例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。\n\n输入一个1000位(即10^999)以内的十进制数。\n输出十进制的二进制逆序数\n\n### Examples:\n**Input:**\n> 173\n \n**Output:**\n> 181\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 顺序很清楚，先转换成二进制，然后逆序，然后转换成十进制\n- 可以写一个通用的进制转换函数\n\n## C++ Codes\n\n```C++\n/*\n * 进制转换\n */\n\n#include \"stdio.h\"\n#include \"string.h\"\n \n//进制转换函数\nvoid convert(int m, char* original, int n, char* conversion){\n    int len = strlen(original),i,j,carry,k = 0;\n\n    //i是最高位，从最高位开始将每一位除以2，将余数传递给下一位\n    for(i = 0; i < len;){\n        carry = 0;\n\n        //这一块，数字和字符的处理没搞清楚,其中carry是参与运算的，应该作为数字。\n        //而original[j]则是保存当前的运算结果，应该是字符型的\n        //本质是模拟除法运算,类比手写的进制转换\n        for(j = i; j < len; j++){ \n            original[j] = original[j] - '0' + carry*m;\n            carry = (original[j]) % n ;\n            original[j] = (original[j]) / n + '0';\n        }\n        //最后的余数\n        conversion[k++] =(char) (carry + '0');\n\n        //精髓，在大进制转小进制时，\n        //当前的最高位orignal[i]可能无法循环一次就变成0\n        //小进制转大进制最高位可能一次循环就\n        //使得高几级位变成0\n        while(original[i] == '0')i++; \n    }\n    conversion[k] = '\\0';\n}\n \nint main(){\n    char dec[1001],bin[4000];\n    int i,j;\n    char temp;\n\n    while(scanf(\"%s\",dec) != EOF){\n        convert(10,dec,2,bin);\n        convert(2,bin,10,dec);\n\n        //将字符串反序\n        for(j = strlen(dec)-1,i=0;i<j;){\n                temp = dec[i];\n                dec[i++] = dec[j];\n                dec[j--] = temp;\n            }\n        printf(\"%s\",dec);\n    }\n    return 0;\n}\n```\n\n## 总结\n- 进制转换的方法大概都是模拟手写进制转换，只是写法可能有不同\n\n------\n","source":"_posts/NowCoder/NowCoder-10进制和2进制.md","raw":"---\ntitle: NowCoder-10进制和2进制\ntags:\n  - NowCoder\n  - Algorithm\n  - Scale\n  - Binary\n  - Medium\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-22 12:05:17\nurlname: dec-vs-bin\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/fd972d5d5cf04dd4bb4e5f027d4fc11e?tpId=40&tqId=21357&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们乘B为A的二进制逆序数。     例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。\n\n输入一个1000位(即10^999)以内的十进制数。\n输出十进制的二进制逆序数\n\n### Examples:\n**Input:**\n> 173\n \n**Output:**\n> 181\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 顺序很清楚，先转换成二进制，然后逆序，然后转换成十进制\n- 可以写一个通用的进制转换函数\n\n## C++ Codes\n\n```C++\n/*\n * 进制转换\n */\n\n#include \"stdio.h\"\n#include \"string.h\"\n \n//进制转换函数\nvoid convert(int m, char* original, int n, char* conversion){\n    int len = strlen(original),i,j,carry,k = 0;\n\n    //i是最高位，从最高位开始将每一位除以2，将余数传递给下一位\n    for(i = 0; i < len;){\n        carry = 0;\n\n        //这一块，数字和字符的处理没搞清楚,其中carry是参与运算的，应该作为数字。\n        //而original[j]则是保存当前的运算结果，应该是字符型的\n        //本质是模拟除法运算,类比手写的进制转换\n        for(j = i; j < len; j++){ \n            original[j] = original[j] - '0' + carry*m;\n            carry = (original[j]) % n ;\n            original[j] = (original[j]) / n + '0';\n        }\n        //最后的余数\n        conversion[k++] =(char) (carry + '0');\n\n        //精髓，在大进制转小进制时，\n        //当前的最高位orignal[i]可能无法循环一次就变成0\n        //小进制转大进制最高位可能一次循环就\n        //使得高几级位变成0\n        while(original[i] == '0')i++; \n    }\n    conversion[k] = '\\0';\n}\n \nint main(){\n    char dec[1001],bin[4000];\n    int i,j;\n    char temp;\n\n    while(scanf(\"%s\",dec) != EOF){\n        convert(10,dec,2,bin);\n        convert(2,bin,10,dec);\n\n        //将字符串反序\n        for(j = strlen(dec)-1,i=0;i<j;){\n                temp = dec[i];\n                dec[i++] = dec[j];\n                dec[j--] = temp;\n            }\n        printf(\"%s\",dec);\n    }\n    return 0;\n}\n```\n\n## 总结\n- 进制转换的方法大概都是模拟手写进制转换，只是写法可能有不同\n\n------\n","slug":"NowCoder/NowCoder-10进制和2进制","published":1,"updated":"2019-09-22T05:14:11.867Z","layout":"post","photos":[],"link":"","_id":"ck2424luh007zlksbuu7epaya","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/fd972d5d5cf04dd4bb4e5f027d4fc11e?tpId=40&amp;tqId=21357&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们乘B为A的二进制逆序数。 例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。</p><p>输入一个1000位(即10^999)以内的十进制数。<br>输出十进制的二进制逆序数</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>173</p></blockquote><p><strong>Output:</strong></p><blockquote><p>181</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>顺序很清楚，先转换成二进制，然后逆序，然后转换成十进制</li><li>可以写一个通用的进制转换函数</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 进制转换</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"string.h\"</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//进制转换函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">char</span>* original, <span class=\"keyword\">int</span> n, <span class=\"keyword\">char</span>* conversion)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(original),i,j,carry,k = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//i是最高位，从最高位开始将每一位除以2，将余数传递给下一位</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; len;)&#123;</span><br><span class=\"line\">        carry = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//这一块，数字和字符的处理没搞清楚,其中carry是参与运算的，应该作为数字。</span></span><br><span class=\"line\">        <span class=\"comment\">//而original[j]则是保存当前的运算结果，应该是字符型的</span></span><br><span class=\"line\">        <span class=\"comment\">//本质是模拟除法运算,类比手写的进制转换</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = i; j &lt; len; j++)&#123; </span><br><span class=\"line\">            original[j] = original[j] - <span class=\"string\">'0'</span> + carry*m;</span><br><span class=\"line\">            carry = (original[j]) % n ;</span><br><span class=\"line\">            original[j] = (original[j]) / n + <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//最后的余数</span></span><br><span class=\"line\">        conversion[k++] =(<span class=\"keyword\">char</span>) (carry + <span class=\"string\">'0'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//精髓，在大进制转小进制时，</span></span><br><span class=\"line\">        <span class=\"comment\">//当前的最高位orignal[i]可能无法循环一次就变成0</span></span><br><span class=\"line\">        <span class=\"comment\">//小进制转大进制最高位可能一次循环就</span></span><br><span class=\"line\">        <span class=\"comment\">//使得高几级位变成0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(original[i] == <span class=\"string\">'0'</span>)i++; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    conversion[k] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> dec[<span class=\"number\">1001</span>],bin[<span class=\"number\">4000</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,dec) != EOF)&#123;</span><br><span class=\"line\">        convert(<span class=\"number\">10</span>,dec,<span class=\"number\">2</span>,bin);</span><br><span class=\"line\">        convert(<span class=\"number\">2</span>,bin,<span class=\"number\">10</span>,dec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将字符串反序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"built_in\">strlen</span>(dec)<span class=\"number\">-1</span>,i=<span class=\"number\">0</span>;i&lt;j;)&#123;</span><br><span class=\"line\">                temp = dec[i];</span><br><span class=\"line\">                dec[i++] = dec[j];</span><br><span class=\"line\">                dec[j--] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,dec);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>进制转换的方法大概都是模拟手写进制转换，只是写法可能有不同</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/fd972d5d5cf04dd4bb4e5f027d4fc11e?tpId=40&amp;tqId=21357&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们乘B为A的二进制逆序数。 例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。</p><p>输入一个1000位(即10^999)以内的十进制数。<br>输出十进制的二进制逆序数</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>173</p></blockquote><p><strong>Output:</strong></p><blockquote><p>181</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>顺序很清楚，先转换成二进制，然后逆序，然后转换成十进制</li><li>可以写一个通用的进制转换函数</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 进制转换</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"string.h\"</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//进制转换函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">char</span>* original, <span class=\"keyword\">int</span> n, <span class=\"keyword\">char</span>* conversion)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(original),i,j,carry,k = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//i是最高位，从最高位开始将每一位除以2，将余数传递给下一位</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; len;)&#123;</span><br><span class=\"line\">        carry = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//这一块，数字和字符的处理没搞清楚,其中carry是参与运算的，应该作为数字。</span></span><br><span class=\"line\">        <span class=\"comment\">//而original[j]则是保存当前的运算结果，应该是字符型的</span></span><br><span class=\"line\">        <span class=\"comment\">//本质是模拟除法运算,类比手写的进制转换</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = i; j &lt; len; j++)&#123; </span><br><span class=\"line\">            original[j] = original[j] - <span class=\"string\">'0'</span> + carry*m;</span><br><span class=\"line\">            carry = (original[j]) % n ;</span><br><span class=\"line\">            original[j] = (original[j]) / n + <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//最后的余数</span></span><br><span class=\"line\">        conversion[k++] =(<span class=\"keyword\">char</span>) (carry + <span class=\"string\">'0'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//精髓，在大进制转小进制时，</span></span><br><span class=\"line\">        <span class=\"comment\">//当前的最高位orignal[i]可能无法循环一次就变成0</span></span><br><span class=\"line\">        <span class=\"comment\">//小进制转大进制最高位可能一次循环就</span></span><br><span class=\"line\">        <span class=\"comment\">//使得高几级位变成0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(original[i] == <span class=\"string\">'0'</span>)i++; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    conversion[k] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> dec[<span class=\"number\">1001</span>],bin[<span class=\"number\">4000</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,dec) != EOF)&#123;</span><br><span class=\"line\">        convert(<span class=\"number\">10</span>,dec,<span class=\"number\">2</span>,bin);</span><br><span class=\"line\">        convert(<span class=\"number\">2</span>,bin,<span class=\"number\">10</span>,dec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将字符串反序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"built_in\">strlen</span>(dec)<span class=\"number\">-1</span>,i=<span class=\"number\">0</span>;i&lt;j;)&#123;</span><br><span class=\"line\">                temp = dec[i];</span><br><span class=\"line\">                dec[i++] = dec[j];</span><br><span class=\"line\">                dec[j--] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,dec);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>进制转换的方法大概都是模拟手写进制转换，只是写法可能有不同</li></ul><hr><!-- rebuild by neat -->"},{"title":"NowCoder-二叉树遍历","comments":1,"mathjax":false,"date":"2019-09-17T12:36:03.000Z","urlname":"traversal-of-binary-tree","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=40&tqId=21342&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)   \n**补之前的**\n\n编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 例如如下的先序遍历字符串： ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。\n\n### Examples:\n**Input:**\n输入包括1行字符串，长度不超过100。\n**Output:**\n可能有多组测试数据，对于每组数据，\n输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。\n每个输出结果占一行。\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 按照先序遍历的原理，一个序列第一个肯定是根， 然后左子树。 这时候去掉了开头的第一个字符之后， 剩下的部分又相当于另一棵树\n- 遍历到#的时候再返回NULL\n- 关键代码是constructTree里面的递归\n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nstruct Node{\n  Node(char c):data(c), left(NULL), right(NULL){};\n  char data;\n  Node* left;\n  Node* right;\n};\n\nNode* constructTree(string order, int &index){\n  if(index<0 || index>=order.length() || order[index]=='#') return NULL;\n  Node *root = new Node(order[index]);\n\n  //这段递归很关键\n  Node *left = constructTree(order, ++index);\n  Node *right = constructTree(order, ++index);\n  root->left = left;\n  root->right = right;\n\n  return root;\n}\n\nstring travel(Node *root){\n  if(root==NULL) return \"\";\n  string res;\n  string l = travel(root->left);\n  string r = travel(root->right);\n  res = l+root->data+r;\n  return res;\n}\n\n\nint main(){\n  string tmp;\n  while(cin>>tmp){\n    int pos = 0;\n    Node *root = constructTree(tmp, pos);\n    string res = travel(root);\n    for(int i=0;i<res.length();i++){\n      cout<<res[i]<<\" \";\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n```\n\n------\n","source":"_posts/NowCoder/NowCoder-二叉树遍历.md","raw":"---\ntitle: NowCoder-二叉树遍历\ntags:\n  - NowCoder\n  - Algorithm\n  - Tree\n  - BinaryTree\n  - Recursive\n  - Medium\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-17 20:36:03\nurlname: traversal-of-binary-tree\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=40&tqId=21342&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)   \n**补之前的**\n\n编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 例如如下的先序遍历字符串： ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。\n\n### Examples:\n**Input:**\n输入包括1行字符串，长度不超过100。\n**Output:**\n可能有多组测试数据，对于每组数据，\n输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。\n每个输出结果占一行。\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 按照先序遍历的原理，一个序列第一个肯定是根， 然后左子树。 这时候去掉了开头的第一个字符之后， 剩下的部分又相当于另一棵树\n- 遍历到#的时候再返回NULL\n- 关键代码是constructTree里面的递归\n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\nstruct Node{\n  Node(char c):data(c), left(NULL), right(NULL){};\n  char data;\n  Node* left;\n  Node* right;\n};\n\nNode* constructTree(string order, int &index){\n  if(index<0 || index>=order.length() || order[index]=='#') return NULL;\n  Node *root = new Node(order[index]);\n\n  //这段递归很关键\n  Node *left = constructTree(order, ++index);\n  Node *right = constructTree(order, ++index);\n  root->left = left;\n  root->right = right;\n\n  return root;\n}\n\nstring travel(Node *root){\n  if(root==NULL) return \"\";\n  string res;\n  string l = travel(root->left);\n  string r = travel(root->right);\n  res = l+root->data+r;\n  return res;\n}\n\n\nint main(){\n  string tmp;\n  while(cin>>tmp){\n    int pos = 0;\n    Node *root = constructTree(tmp, pos);\n    string res = travel(root);\n    for(int i=0;i<res.length();i++){\n      cout<<res[i]<<\" \";\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n```\n\n------\n","slug":"NowCoder/NowCoder-二叉树遍历","published":1,"updated":"2019-09-21T07:29:33.183Z","layout":"post","photos":[],"link":"","_id":"ck2424luj0083lksb9b9q4vnc","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=40&amp;tqId=21342&amp;tPage=1&amp;rp=1&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p><strong>补之前的</strong></p><p>编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 例如如下的先序遍历字符串： ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>输入包括1行字符串，长度不超过100。<br><strong>Output:</strong><br>可能有多组测试数据，对于每组数据，<br>输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。<br>每个输出结果占一行。</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>按照先序遍历的原理，一个序列第一个肯定是根， 然后左子树。 这时候去掉了开头的第一个字符之后， 剩下的部分又相当于另一棵树</li><li>遍历到#的时候再返回NULL</li><li>关键代码是constructTree里面的递归</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">  Node(<span class=\"keyword\">char</span> c):data(c), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>)&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> data;</span><br><span class=\"line\">  Node* left;</span><br><span class=\"line\">  Node* right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">constructTree</span><span class=\"params\">(<span class=\"built_in\">string</span> order, <span class=\"keyword\">int</span> &amp;index)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(index&lt;<span class=\"number\">0</span> || index&gt;=order.length() || order[index]==<span class=\"string\">'#'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  Node *root = <span class=\"keyword\">new</span> Node(order[index]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//这段递归很关键</span></span><br><span class=\"line\">  Node *left = constructTree(order, ++index);</span><br><span class=\"line\">  Node *right = constructTree(order, ++index);</span><br><span class=\"line\">  root-&gt;left = left;</span><br><span class=\"line\">  root-&gt;right = right;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">travel</span><span class=\"params\">(Node *root)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> l = travel(root-&gt;left);</span><br><span class=\"line\">  <span class=\"built_in\">string</span> r = travel(root-&gt;right);</span><br><span class=\"line\">  res = l+root-&gt;data+r;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> tmp;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;tmp)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Node *root = constructTree(tmp, pos);</span><br><span class=\"line\">    <span class=\"built_in\">string</span> res = travel(root);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;res.length();i++)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span>&lt;&lt;res[i]&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=40&amp;tqId=21342&amp;tPage=1&amp;rp=1&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p><strong>补之前的</strong></p><p>编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 例如如下的先序遍历字符串： ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>输入包括1行字符串，长度不超过100。<br><strong>Output:</strong><br>可能有多组测试数据，对于每组数据，<br>输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。<br>每个输出结果占一行。</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>按照先序遍历的原理，一个序列第一个肯定是根， 然后左子树。 这时候去掉了开头的第一个字符之后， 剩下的部分又相当于另一棵树</li><li>遍历到#的时候再返回NULL</li><li>关键代码是constructTree里面的递归</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">  Node(<span class=\"keyword\">char</span> c):data(c), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>)&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> data;</span><br><span class=\"line\">  Node* left;</span><br><span class=\"line\">  Node* right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">constructTree</span><span class=\"params\">(<span class=\"built_in\">string</span> order, <span class=\"keyword\">int</span> &amp;index)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(index&lt;<span class=\"number\">0</span> || index&gt;=order.length() || order[index]==<span class=\"string\">'#'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  Node *root = <span class=\"keyword\">new</span> Node(order[index]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//这段递归很关键</span></span><br><span class=\"line\">  Node *left = constructTree(order, ++index);</span><br><span class=\"line\">  Node *right = constructTree(order, ++index);</span><br><span class=\"line\">  root-&gt;left = left;</span><br><span class=\"line\">  root-&gt;right = right;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">travel</span><span class=\"params\">(Node *root)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> l = travel(root-&gt;left);</span><br><span class=\"line\">  <span class=\"built_in\">string</span> r = travel(root-&gt;right);</span><br><span class=\"line\">  res = l+root-&gt;data+r;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> tmp;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;tmp)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Node *root = constructTree(tmp, pos);</span><br><span class=\"line\">    <span class=\"built_in\">string</span> res = travel(root);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;res.length();i++)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span>&lt;&lt;res[i]&lt;&lt;<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"NowCoder-代理服务器","comments":1,"mathjax":false,"date":"2019-09-12T11:15:36.000Z","urlname":null,"_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&tqId=21335&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。\n\n每个测试数据包括 n + m + 2 行。\n第 1 行只包含一个整数 n，表示代理服务器的个数。\n第 2行至第n + 1行每行是一个字符串，表示代理服务器的 IP地址。这n个 IP地址两两不相同。\n第 n + 2 行只包含一个整数 m，表示要访问的服务器的个数。\n第 n + 3 行至第 n + m + 2 行每行是一个字符串，表示要访问的服务器的 IP 地址，按照访问的顺序给出。\n每个字符串都是合法的IP地址，形式为“xxx.yyy.zzz.www”，其中任何一部分均是0–255之间的整数。输入数据的任何一行都不包含空格字符。\n 其中，1<=n<=1000，1<=m<=5000。\n### Examples:\n**Input:**   \n3\n166.111.4.100\n162.105.131.113\n202.112.128.69\n6\n72.14.235.104\n166.111.4.100\n207.46.19.190\n202.112.128.69\n162.105.131.113\n118.214.226.52\n\n**Output:**    \n1\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 用贪心的思想, 每一步都是找能走的最远的那个ip, 然后一直到结束, 记录切换次数就好了\n- 下面的for循环就是找一次的过程, n个ip都试一下, 找能连接最多的, 就是max个, 然后pos就设置为那个位置, 一直增加pos, 到所有的服务器被访问完\n\n\n## C++ Codes\n\n```C++\n/*\n * 代理服务器\n * 贪心\n */\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint greedy(vector<string> &agency, int n, vector<string> &server, int m){\n  //如果只有一个代理, 那找不全就返回-1了\n  if(n==1){\n    auto it = find(server.begin(), server.end(), agency[0]);\n    if(it!=server.end()) return -1;\n    else return 0;\n  }\n  \n  int pos = 0;\n  int res = 0;\n  int max = 0;\n  //while退出条件是找完\n  while(pos<m){\n    //每次for循环结束就是走一步\n    for(int i=0;i<n;i++){\n      //找下一个和代理服务器ip一样的服务器\n      auto it = find(server.begin()+pos, server.end(), agency[i]);\n      //如果没找到,就不用切换了, 直接返回结果\n      if(it==server.end()) return res;\n      else{\n        if((it-server.begin())>max) max = it-server.begin();\n      }\n    }\n    //设置下一次找的时候开始的地方\n    pos = max;\n    res++;\n  }\n\n  return res;\n}\n\nint main(){\n  int n, m;\n  while(cin>>n){\n    //保存代理服务器ip\n    vector<string> agency(n);\n    for(int i=0;i<n;i++) cin>>agency[i];\n    //保存目标服务器ip\n    cin>>m;\n    vector<string> server(m);\n    for(int i=0;i<m;i++) cin>>server[i];\n    //贪心\n    int res = greedy(agency, n, server, m);\n    cout<<res<<endl;\n  }\n  return 0;\n}\n```\n\n## 总结\n- 这道题刚开始以为贪心是没办法找全的, 后来看题解发现还是可以用贪心的, 每次最大匹配就完事了\n\n------\n","source":"_posts/NowCoder/NowCoder-代理服务器.md","raw":"---\ntitle: NowCoder-代理服务器\ntags:\n  - NowCoder\n  - Algorithm\n  - Greedy\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-12 19:15:36\nurlname:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&tqId=21335&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。\n\n每个测试数据包括 n + m + 2 行。\n第 1 行只包含一个整数 n，表示代理服务器的个数。\n第 2行至第n + 1行每行是一个字符串，表示代理服务器的 IP地址。这n个 IP地址两两不相同。\n第 n + 2 行只包含一个整数 m，表示要访问的服务器的个数。\n第 n + 3 行至第 n + m + 2 行每行是一个字符串，表示要访问的服务器的 IP 地址，按照访问的顺序给出。\n每个字符串都是合法的IP地址，形式为“xxx.yyy.zzz.www”，其中任何一部分均是0–255之间的整数。输入数据的任何一行都不包含空格字符。\n 其中，1<=n<=1000，1<=m<=5000。\n### Examples:\n**Input:**   \n3\n166.111.4.100\n162.105.131.113\n202.112.128.69\n6\n72.14.235.104\n166.111.4.100\n207.46.19.190\n202.112.128.69\n162.105.131.113\n118.214.226.52\n\n**Output:**    \n1\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 用贪心的思想, 每一步都是找能走的最远的那个ip, 然后一直到结束, 记录切换次数就好了\n- 下面的for循环就是找一次的过程, n个ip都试一下, 找能连接最多的, 就是max个, 然后pos就设置为那个位置, 一直增加pos, 到所有的服务器被访问完\n\n\n## C++ Codes\n\n```C++\n/*\n * 代理服务器\n * 贪心\n */\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint greedy(vector<string> &agency, int n, vector<string> &server, int m){\n  //如果只有一个代理, 那找不全就返回-1了\n  if(n==1){\n    auto it = find(server.begin(), server.end(), agency[0]);\n    if(it!=server.end()) return -1;\n    else return 0;\n  }\n  \n  int pos = 0;\n  int res = 0;\n  int max = 0;\n  //while退出条件是找完\n  while(pos<m){\n    //每次for循环结束就是走一步\n    for(int i=0;i<n;i++){\n      //找下一个和代理服务器ip一样的服务器\n      auto it = find(server.begin()+pos, server.end(), agency[i]);\n      //如果没找到,就不用切换了, 直接返回结果\n      if(it==server.end()) return res;\n      else{\n        if((it-server.begin())>max) max = it-server.begin();\n      }\n    }\n    //设置下一次找的时候开始的地方\n    pos = max;\n    res++;\n  }\n\n  return res;\n}\n\nint main(){\n  int n, m;\n  while(cin>>n){\n    //保存代理服务器ip\n    vector<string> agency(n);\n    for(int i=0;i<n;i++) cin>>agency[i];\n    //保存目标服务器ip\n    cin>>m;\n    vector<string> server(m);\n    for(int i=0;i<m;i++) cin>>server[i];\n    //贪心\n    int res = greedy(agency, n, server, m);\n    cout<<res<<endl;\n  }\n  return 0;\n}\n```\n\n## 总结\n- 这道题刚开始以为贪心是没办法找全的, 后来看题解发现还是可以用贪心的, 每次最大匹配就完事了\n\n------\n","slug":"NowCoder/NowCoder-代理服务器","published":1,"updated":"2019-09-12T12:53:32.113Z","layout":"post","photos":[],"link":"","_id":"ck2424luk0087lksb34bw7krt","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&amp;tqId=21335&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。</p><p>每个测试数据包括 n + m + 2 行。<br>第 1 行只包含一个整数 n，表示代理服务器的个数。<br>第 2行至第n + 1行每行是一个字符串，表示代理服务器的 IP地址。这n个 IP地址两两不相同。<br>第 n + 2 行只包含一个整数 m，表示要访问的服务器的个数。<br>第 n + 3 行至第 n + m + 2 行每行是一个字符串，表示要访问的服务器的 IP 地址，按照访问的顺序给出。<br>每个字符串都是合法的IP地址，形式为“xxx.yyy.zzz.www”，其中任何一部分均是0–255之间的整数。输入数据的任何一行都不包含空格字符。<br>其中，1&lt;=n&lt;=1000，1&lt;=m&lt;=5000。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>3<br>166.111.4.100<br>162.105.131.113<br>202.112.128.69<br>6<br>72.14.235.104<br>166.111.4.100<br>207.46.19.190<br>202.112.128.69<br>162.105.131.113<br>118.214.226.52</p><p><strong>Output:</strong><br>1</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>用贪心的思想, 每一步都是找能走的最远的那个ip, 然后一直到结束, 记录切换次数就好了</li><li>下面的for循环就是找一次的过程, n个ip都试一下, 找能连接最多的, 就是max个, 然后pos就设置为那个位置, 一直增加pos, 到所有的服务器被访问完</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 代理服务器</span></span><br><span class=\"line\"><span class=\"comment\"> * 贪心</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">greedy</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;agency, <span class=\"keyword\">int</span> n, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;server, <span class=\"keyword\">int</span> m)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//如果只有一个代理, 那找不全就返回-1了</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> it = find(server.begin(), server.end(), agency[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(it!=server.end()) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//while退出条件是找完</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(pos&lt;m)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//每次for循环结束就是走一步</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//找下一个和代理服务器ip一样的服务器</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> it = find(server.begin()+pos, server.end(), agency[i]);</span><br><span class=\"line\">      <span class=\"comment\">//如果没找到,就不用切换了, 直接返回结果</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(it==server.end()) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">      <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((it-server.begin())&gt;max) max = it-server.begin();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置下一次找的时候开始的地方</span></span><br><span class=\"line\">    pos = max;</span><br><span class=\"line\">    res++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//保存代理服务器ip</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; agency(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) <span class=\"built_in\">cin</span>&gt;&gt;agency[i];</span><br><span class=\"line\">    <span class=\"comment\">//保存目标服务器ip</span></span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; server(m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++) <span class=\"built_in\">cin</span>&gt;&gt;server[i];</span><br><span class=\"line\">    <span class=\"comment\">//贪心</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = greedy(agency, n, server, m);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>这道题刚开始以为贪心是没办法找全的, 后来看题解发现还是可以用贪心的, 每次最大匹配就完事了</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&amp;tqId=21335&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。</p><p>每个测试数据包括 n + m + 2 行。<br>第 1 行只包含一个整数 n，表示代理服务器的个数。<br>第 2行至第n + 1行每行是一个字符串，表示代理服务器的 IP地址。这n个 IP地址两两不相同。<br>第 n + 2 行只包含一个整数 m，表示要访问的服务器的个数。<br>第 n + 3 行至第 n + m + 2 行每行是一个字符串，表示要访问的服务器的 IP 地址，按照访问的顺序给出。<br>每个字符串都是合法的IP地址，形式为“xxx.yyy.zzz.www”，其中任何一部分均是0–255之间的整数。输入数据的任何一行都不包含空格字符。<br>其中，1&lt;=n&lt;=1000，1&lt;=m&lt;=5000。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>3<br>166.111.4.100<br>162.105.131.113<br>202.112.128.69<br>6<br>72.14.235.104<br>166.111.4.100<br>207.46.19.190<br>202.112.128.69<br>162.105.131.113<br>118.214.226.52</p><p><strong>Output:</strong><br>1</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>用贪心的思想, 每一步都是找能走的最远的那个ip, 然后一直到结束, 记录切换次数就好了</li><li>下面的for循环就是找一次的过程, n个ip都试一下, 找能连接最多的, 就是max个, 然后pos就设置为那个位置, 一直增加pos, 到所有的服务器被访问完</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 代理服务器</span></span><br><span class=\"line\"><span class=\"comment\"> * 贪心</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">greedy</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;agency, <span class=\"keyword\">int</span> n, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;server, <span class=\"keyword\">int</span> m)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//如果只有一个代理, 那找不全就返回-1了</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> it = find(server.begin(), server.end(), agency[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(it!=server.end()) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//while退出条件是找完</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(pos&lt;m)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//每次for循环结束就是走一步</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//找下一个和代理服务器ip一样的服务器</span></span><br><span class=\"line\">      <span class=\"keyword\">auto</span> it = find(server.begin()+pos, server.end(), agency[i]);</span><br><span class=\"line\">      <span class=\"comment\">//如果没找到,就不用切换了, 直接返回结果</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(it==server.end()) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">      <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((it-server.begin())&gt;max) max = it-server.begin();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置下一次找的时候开始的地方</span></span><br><span class=\"line\">    pos = max;</span><br><span class=\"line\">    res++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//保存代理服务器ip</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; agency(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) <span class=\"built_in\">cin</span>&gt;&gt;agency[i];</span><br><span class=\"line\">    <span class=\"comment\">//保存目标服务器ip</span></span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; server(m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++) <span class=\"built_in\">cin</span>&gt;&gt;server[i];</span><br><span class=\"line\">    <span class=\"comment\">//贪心</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = greedy(agency, n, server, m);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>这道题刚开始以为贪心是没办法找全的, 后来看题解发现还是可以用贪心的, 每次最大匹配就完事了</li></ul><hr><!-- rebuild by neat -->"},{"title":"NowCoder-剩下的树","comments":1,"mathjax":false,"date":"2019-09-22T03:07:15.000Z","urlname":"remaining-tree","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/f5787c69f5cf41499ba4706bc93700a2?tpId=40&tqId=21356&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n有一个长度为整数L(1<=L<=10000)的马路，可以想象成数轴上长度为L的一个线段，起点是坐标原点，在每个整数坐标点有一棵树，即在0,1,2，...，L共L+1个位置上有L+1棵树。     现在要移走一些树，移走的树的区间用一对数字表示，如 100 200表示移走从100到200之间（包括端点）所有的树。     可能有M(1<=M<=100)个区间，区间之间可能有重叠。现在要求移走所有区间的树之后剩下的树的个数。\n\n输入L和M，和M组数字\n\n### Examples:\n**Input:**\n> 500 3\n> 100 200\n> 150 300\n> 470 471\n \n**Output:**\n> 298 \n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 简单的开一个大数组，对每个位置标记就可以了\n\n\n## C++ Codes\n\n```C++\n#include<iostream>\nusing namespace std;\n\nint road[10001];\n\nint main(){\n    int L, M;\n    while(cin>>L>>M){\n        for(int i=0;i<=L;i++){\n            road[i]=1;\n        }\n        int from, to;\n        for(int i=0;i<M;i++){\n            cin>>from>>to;\n            for(int j=from;j<=to;j++){\n                road[j]=0;\n            }\n        }\n        int res = 0;\n        for(int i=0;i<=L;i++){\n            if(road[i]) res++;\n        }\n        cout<<res<<endl;\n    }\n}\n```\n\n\n------\n","source":"_posts/NowCoder/NowCoder-剩下的树.md","raw":"---\ntitle: NowCoder-剩下的树\ntags:\n  - NowCoder\n  - Algorithm\n  - Array\n  - Map\n  - Easy\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-22 11:07:15\nurlname: remaining-tree\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/f5787c69f5cf41499ba4706bc93700a2?tpId=40&tqId=21356&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n有一个长度为整数L(1<=L<=10000)的马路，可以想象成数轴上长度为L的一个线段，起点是坐标原点，在每个整数坐标点有一棵树，即在0,1,2，...，L共L+1个位置上有L+1棵树。     现在要移走一些树，移走的树的区间用一对数字表示，如 100 200表示移走从100到200之间（包括端点）所有的树。     可能有M(1<=M<=100)个区间，区间之间可能有重叠。现在要求移走所有区间的树之后剩下的树的个数。\n\n输入L和M，和M组数字\n\n### Examples:\n**Input:**\n> 500 3\n> 100 200\n> 150 300\n> 470 471\n \n**Output:**\n> 298 \n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 简单的开一个大数组，对每个位置标记就可以了\n\n\n## C++ Codes\n\n```C++\n#include<iostream>\nusing namespace std;\n\nint road[10001];\n\nint main(){\n    int L, M;\n    while(cin>>L>>M){\n        for(int i=0;i<=L;i++){\n            road[i]=1;\n        }\n        int from, to;\n        for(int i=0;i<M;i++){\n            cin>>from>>to;\n            for(int j=from;j<=to;j++){\n                road[j]=0;\n            }\n        }\n        int res = 0;\n        for(int i=0;i<=L;i++){\n            if(road[i]) res++;\n        }\n        cout<<res<<endl;\n    }\n}\n```\n\n\n------\n","slug":"NowCoder/NowCoder-剩下的树","published":1,"updated":"2019-09-22T04:55:16.661Z","layout":"post","photos":[],"link":"","_id":"ck2424lul008alksbvgoh3v5i","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/f5787c69f5cf41499ba4706bc93700a2?tpId=40&amp;tqId=21356&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>有一个长度为整数L(1&lt;=L&lt;=10000)的马路，可以想象成数轴上长度为L的一个线段，起点是坐标原点，在每个整数坐标点有一棵树，即在0,1,2，…，L共L+1个位置上有L+1棵树。 现在要移走一些树，移走的树的区间用一对数字表示，如 100 200表示移走从100到200之间（包括端点）所有的树。 可能有M(1&lt;=M&lt;=100)个区间，区间之间可能有重叠。现在要求移走所有区间的树之后剩下的树的个数。</p><p>输入L和M，和M组数字</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>500 3<br>100 200<br>150 300<br>470 471</p></blockquote><p><strong>Output:</strong></p><blockquote><p>298</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>简单的开一个大数组，对每个位置标记就可以了</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> road[<span class=\"number\">10001</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> L, M;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;L&gt;&gt;M)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=L;i++)&#123;</span><br><span class=\"line\">            road[i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> from, to;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;M;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;from&gt;&gt;to;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=from;j&lt;=to;j++)&#123;</span><br><span class=\"line\">                road[j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=L;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(road[i]) res++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/f5787c69f5cf41499ba4706bc93700a2?tpId=40&amp;tqId=21356&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>有一个长度为整数L(1&lt;=L&lt;=10000)的马路，可以想象成数轴上长度为L的一个线段，起点是坐标原点，在每个整数坐标点有一棵树，即在0,1,2，…，L共L+1个位置上有L+1棵树。 现在要移走一些树，移走的树的区间用一对数字表示，如 100 200表示移走从100到200之间（包括端点）所有的树。 可能有M(1&lt;=M&lt;=100)个区间，区间之间可能有重叠。现在要求移走所有区间的树之后剩下的树的个数。</p><p>输入L和M，和M组数字</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>500 3<br>100 200<br>150 300<br>470 471</p></blockquote><p><strong>Output:</strong></p><blockquote><p>298</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>简单的开一个大数组，对每个位置标记就可以了</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> road[<span class=\"number\">10001</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> L, M;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;L&gt;&gt;M)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=L;i++)&#123;</span><br><span class=\"line\">            road[i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> from, to;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;M;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;from&gt;&gt;to;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=from;j&lt;=to;j++)&#123;</span><br><span class=\"line\">                road[j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=L;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(road[i]) res++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"NowCoder-完数和盈数","comments":1,"mathjax":false,"date":"2019-09-21T14:42:36.000Z","urlname":"perfect-num-and-excess-num","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/ccc3d1e78014486fb7eed3c50e05c99d?tpId=40&tqId=21351&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n一个数如果恰好等于它的各因子(该数本身除外)子和，如：6=3+2+1。则称其为“完数”；若因子之和大于该数，则称其为“盈数”。 求出2到60之间所有“完数”和“盈数”。\n\n没有输入\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 暴力求解 \n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint getSum(int n){\n    int sq = sqrt(n);\n    int res = 1;\n    for(int i=2;i<=sq;i++){\n        if(n%i==0){\n            res = res+i+n/i;\n            if(i*i==n) res-=i;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int p[60], q[60];\n    int cntp=0, cntq=0;\n    for(int i=2;i<=60;i++){\n        int tmp = getSum(i);\n        if(tmp==i){\n            p[cntp++]=i;\n        }else if(tmp>i){\n            q[cntq++]=i;\n        }\n    }\n    cout<<\"E:\";\n    for(int i=0;i<cntp;i++) cout<<\" \"<<p[i];\n    cout<<\"\\nG:\";\n    for(int i=0;i<cntq;i++) cout<<\" \"<<q[i];\n    return 0;\n}\n```\n\n\n------\n","source":"_posts/NowCoder/NowCoder-完数和盈数.md","raw":"---\ntitle: NowCoder-完数和盈数\ntags:\n  - NowCoder\n  - Algorithm\n  - Math\n  - Easy\n  - Integer\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-21 22:42:36\nurlname: perfect-num-and-excess-num\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/ccc3d1e78014486fb7eed3c50e05c99d?tpId=40&tqId=21351&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n一个数如果恰好等于它的各因子(该数本身除外)子和，如：6=3+2+1。则称其为“完数”；若因子之和大于该数，则称其为“盈数”。 求出2到60之间所有“完数”和“盈数”。\n\n没有输入\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 暴力求解 \n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint getSum(int n){\n    int sq = sqrt(n);\n    int res = 1;\n    for(int i=2;i<=sq;i++){\n        if(n%i==0){\n            res = res+i+n/i;\n            if(i*i==n) res-=i;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int p[60], q[60];\n    int cntp=0, cntq=0;\n    for(int i=2;i<=60;i++){\n        int tmp = getSum(i);\n        if(tmp==i){\n            p[cntp++]=i;\n        }else if(tmp>i){\n            q[cntq++]=i;\n        }\n    }\n    cout<<\"E:\";\n    for(int i=0;i<cntp;i++) cout<<\" \"<<p[i];\n    cout<<\"\\nG:\";\n    for(int i=0;i<cntq;i++) cout<<\" \"<<q[i];\n    return 0;\n}\n```\n\n\n------\n","slug":"NowCoder/NowCoder-完数和盈数","published":1,"updated":"2019-09-21T14:47:52.144Z","layout":"post","photos":[],"link":"","_id":"ck2424lum008elksbx88jkq10","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/ccc3d1e78014486fb7eed3c50e05c99d?tpId=40&amp;tqId=21351&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>一个数如果恰好等于它的各因子(该数本身除外)子和，如：6=3+2+1。则称其为“完数”；若因子之和大于该数，则称其为“盈数”。 求出2到60之间所有“完数”和“盈数”。</p><p>没有输入</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>暴力求解</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sq = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=sq;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%i==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            res = res+i+n/i;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i*i==n) res-=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p[<span class=\"number\">60</span>], q[<span class=\"number\">60</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cntp=<span class=\"number\">0</span>, cntq=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=<span class=\"number\">60</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = getSum(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp==i)&#123;</span><br><span class=\"line\">            p[cntp++]=i;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp&gt;i)&#123;</span><br><span class=\"line\">            q[cntq++]=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"E:\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;cntp;i++) <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;p[i];</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"\\nG:\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;cntq;i++) <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;q[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/ccc3d1e78014486fb7eed3c50e05c99d?tpId=40&amp;tqId=21351&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>一个数如果恰好等于它的各因子(该数本身除外)子和，如：6=3+2+1。则称其为“完数”；若因子之和大于该数，则称其为“盈数”。 求出2到60之间所有“完数”和“盈数”。</p><p>没有输入</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>暴力求解</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sq = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=sq;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%i==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            res = res+i+n/i;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i*i==n) res-=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p[<span class=\"number\">60</span>], q[<span class=\"number\">60</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cntp=<span class=\"number\">0</span>, cntq=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=<span class=\"number\">60</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = getSum(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp==i)&#123;</span><br><span class=\"line\">            p[cntp++]=i;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp&gt;i)&#123;</span><br><span class=\"line\">            q[cntq++]=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"E:\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;cntp;i++) <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;p[i];</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"\\nG:\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;cntq;i++) <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;q[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"NowCoder-今年第几天","comments":1,"mathjax":false,"date":"2019-09-21T07:50:03.000Z","urlname":"day-of-the-year","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/ae7e58fe24b14d1386e13e7d70eaf04d?tpId=40&tqId=21350&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n输入年、月、日，计算该天是本年的第几天。\n输入包括三个整数年(1<=Y<=3000)、月(1<=M<=12)、日(1<=D<=31)。\n输出一个整数，代表Input中的年、月、日对应本年的第几天。\n\n### Examples:\n**Input:**\n1990 9 20\n2000 5 1\n**Output:**\n263\n122\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 用数组代替map表示每个月的天数，然后判断是否闰年，然后再累加天数\n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<cmath>\n#include<string>\nusing namespace std;\n\nbool judge(int year){\n    //判断闰年\n    if((year%4==0 && year%400!=0) || (year%4==0 && year%100==0)){\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    int year, mon, day;\n    int days[13]={0, 31,28, 31, 30, 31, 30, 31, 31,30, 31, 30, 31};\n    while(cin>>year>>mon>>day){\n        int res = 0;\n        if(judge(year)) days[2]=29;\n        else days[2]=28;\n        \n        for(int i=1;i<mon;i++){\n            res+=days[i];\n        }\n        res+=day;\n        cout<<res<<endl;\n    }\n    return 0;\n}\n```\n\n------\n","source":"_posts/NowCoder/NowCoder-今年第几天.md","raw":"---\ntitle: NowCoder-今年第几天\ntags:\n  - NowCoder\n  - Algorithm\n  - Map\n  - Easy\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-21 15:50:03\nurlname: day-of-the-year\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/ae7e58fe24b14d1386e13e7d70eaf04d?tpId=40&tqId=21350&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n输入年、月、日，计算该天是本年的第几天。\n输入包括三个整数年(1<=Y<=3000)、月(1<=M<=12)、日(1<=D<=31)。\n输出一个整数，代表Input中的年、月、日对应本年的第几天。\n\n### Examples:\n**Input:**\n1990 9 20\n2000 5 1\n**Output:**\n263\n122\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 用数组代替map表示每个月的天数，然后判断是否闰年，然后再累加天数\n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<cmath>\n#include<string>\nusing namespace std;\n\nbool judge(int year){\n    //判断闰年\n    if((year%4==0 && year%400!=0) || (year%4==0 && year%100==0)){\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    int year, mon, day;\n    int days[13]={0, 31,28, 31, 30, 31, 30, 31, 31,30, 31, 30, 31};\n    while(cin>>year>>mon>>day){\n        int res = 0;\n        if(judge(year)) days[2]=29;\n        else days[2]=28;\n        \n        for(int i=1;i<mon;i++){\n            res+=days[i];\n        }\n        res+=day;\n        cout<<res<<endl;\n    }\n    return 0;\n}\n```\n\n------\n","slug":"NowCoder/NowCoder-今年第几天","published":1,"updated":"2019-09-21T14:41:22.931Z","layout":"post","photos":[],"link":"","_id":"ck2424luo008hlksbhx29q12z","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/ae7e58fe24b14d1386e13e7d70eaf04d?tpId=40&amp;tqId=21350&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>输入年、月、日，计算该天是本年的第几天。<br>输入包括三个整数年(1&lt;=Y&lt;=3000)、月(1&lt;=M&lt;=12)、日(1&lt;=D&lt;=31)。<br>输出一个整数，代表Input中的年、月、日对应本年的第几天。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>1990 9 20<br>2000 5 1<br><strong>Output:</strong><br>263<br>122</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>用数组代替map表示每个月的天数，然后判断是否闰年，然后再累加天数</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">(<span class=\"keyword\">int</span> year)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断闰年</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((year%<span class=\"number\">4</span>==<span class=\"number\">0</span> &amp;&amp; year%<span class=\"number\">400</span>!=<span class=\"number\">0</span>) || (year%<span class=\"number\">4</span>==<span class=\"number\">0</span> &amp;&amp; year%<span class=\"number\">100</span>==<span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> year, mon, day;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> days[<span class=\"number\">13</span>]=&#123;<span class=\"number\">0</span>, <span class=\"number\">31</span>,<span class=\"number\">28</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">31</span>,<span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;year&gt;&gt;mon&gt;&gt;day)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(judge(year)) days[<span class=\"number\">2</span>]=<span class=\"number\">29</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> days[<span class=\"number\">2</span>]=<span class=\"number\">28</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;mon;i++)&#123;</span><br><span class=\"line\">            res+=days[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res+=day;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/ae7e58fe24b14d1386e13e7d70eaf04d?tpId=40&amp;tqId=21350&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>输入年、月、日，计算该天是本年的第几天。<br>输入包括三个整数年(1&lt;=Y&lt;=3000)、月(1&lt;=M&lt;=12)、日(1&lt;=D&lt;=31)。<br>输出一个整数，代表Input中的年、月、日对应本年的第几天。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>1990 9 20<br>2000 5 1<br><strong>Output:</strong><br>263<br>122</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>用数组代替map表示每个月的天数，然后判断是否闰年，然后再累加天数</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">(<span class=\"keyword\">int</span> year)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断闰年</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((year%<span class=\"number\">4</span>==<span class=\"number\">0</span> &amp;&amp; year%<span class=\"number\">400</span>!=<span class=\"number\">0</span>) || (year%<span class=\"number\">4</span>==<span class=\"number\">0</span> &amp;&amp; year%<span class=\"number\">100</span>==<span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> year, mon, day;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> days[<span class=\"number\">13</span>]=&#123;<span class=\"number\">0</span>, <span class=\"number\">31</span>,<span class=\"number\">28</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">31</span>,<span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;year&gt;&gt;mon&gt;&gt;day)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(judge(year)) days[<span class=\"number\">2</span>]=<span class=\"number\">29</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> days[<span class=\"number\">2</span>]=<span class=\"number\">28</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;mon;i++)&#123;</span><br><span class=\"line\">            res+=days[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res+=day;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"NowCoder-成绩排序","urlname":"nowcoder-score-sort","comments":1,"mathjax":false,"date":"2019-07-25T16:56:21.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 通知\n之前刷了很多算法题, 有[牛客网:NowCoder](https://www.nowcoder.com/ta/kaoyan?page=1)的, 也有LeetCode的, 现在开始慢慢将牛客网的题目记录下来, 也权当复习. LeetCode后面的题目暂时不更新, 等刷到那里再更, 不然这顺序很乱\n\n## [Problem](https://www.nowcoder.com/practice/0383714a1bb749499050d2e0610418b1?tpId=40&tqId=21333&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)   \n查找和排序\n题目：输入任意（用户，成绩）序列，可以获得成绩从高到低或从低到高的排列,相同成绩\n都按先录入排列在前的规则处理。 \n### Examples:\n**Input:** \n输入多行，先输入要排序的人的个数，然后输入排序方法0（降序）或者1（升序）再分别输入他们的名字和成绩，以一个空格隔开\n**Output:**\n按照指定方式输出名字和成绩，名字和成绩之间以一个空格隔开\n按先录入排列在前的规则处理。\n<!--more-->\n示例：\n> jack      70\n> peter     96\n> Tom       70\n> smith     67\n> \n> 从高到低  成绩\n> peter     96\n> jack      70\n> Tom       70\n> smith     67\n> \n> 从低到高\n> smith     67\n> jack      70\n> Tom      70\n> peter     96 \n{% endnote %}\n\n## Solutions\n- 冒泡排序是稳定排序, 不可以用快排, 快排不稳定\n- 直接调用STL的stable_sort()函数\n\n## C++ Codes\n直接调用\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint n, bs, score[500], r[500];\nbool cmp(int i,int j){\n    return score[i]<score[j];\n}\nbool cmp1(int i,int j){\n    return score[i]>score[j];\n}\nint main() {\n    string name[500];\n    int i,j,k;\n  while(cin >>n>>bs){\n    for(i=0;i<n;i++){\n        r[i]=i;\n        cin >>name[i]>>score[i];\n    }\n    if(bs==1)\n        stable_sort(r,r+n,cmp);\n    else\n        stable_sort(r,r+n,cmp1);\n    for(i=0;i<n;i++){\n        int t = r[i];\n        cout << name[t]<<' '<<score[t]<<endl;\n    }\n  }\nreturn 0;\n}\n```\n\n手写冒泡排序\n```C++\n#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n//升序\nvoid bubbleSort(int *A, vector<string> &name, int n){\n    int tmp;\n    string stmp;\n    for(int i=0;i<n-1;i++){//已经排序好的个数\n        bool flag = false;\n        for(int j=n-1;j>i;j--){//从最后向前找最小的\n            if(A[j]<A[j-1]){\n                flag = true;\n                tmp = A[j-1];\n                A[j-1]=A[j];\n                A[j]=tmp;\n                stmp = name[j-1];\n                name[j-1]=name[j];\n                name[j]=stmp;\n            }\n        }\n        if(!flag) break;\n    }\n}\n\n//降序\nvoid bubbleSort2(int *A, vector<string> &name, int n){\n    int tmp;\n    string stmp;\n    for(int i=0;i<n-1;i++){//已经排序好的个数\n        bool flag = false;\n        for(int j=n-1;j>i;j--){//从最后向前找最小的\n            if(A[j]>A[j-1]){\n                flag = true;\n                tmp = A[j-1];\n                A[j-1]=A[j];\n                A[j]=tmp;\n                stmp = name[j-1];\n                name[j-1]=name[j];\n                name[j]=stmp;\n            }\n        }\n        if(!flag) break;\n    }\n}\n\nint main(){\n    vector<string> names(1000);\n    int records[1000];\n    int n, tag;\n    while(cin>>n>>tag){\n        for(int i=0;i<n;i++){\n            cin>>names[i]>>records[i];\n        }\n\n        if(tag)\n            bubbleSort(records, names, n);\n        else\n            bubbleSort2(records, names, n);\n\n        for(int i=0;i<n;i++) \n            cout<<names[i]<<\" \"<<records[i]<<endl;\n    }\n}\n```\n\n------\n","source":"_posts/NowCoder/NowCoder-成绩排序.md","raw":"---\ntitle: NowCoder-成绩排序\ntags:\n  - NowCoder\n  - Algorithm\n  - Sort\n  - BubbleSort\ncategories: \n  - NowCoder\nurlname: nowcoder-score-sort\ncomments: true\nmathjax: false\ndate: 2019-07-26 00:56:21\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## 通知\n之前刷了很多算法题, 有[牛客网:NowCoder](https://www.nowcoder.com/ta/kaoyan?page=1)的, 也有LeetCode的, 现在开始慢慢将牛客网的题目记录下来, 也权当复习. LeetCode后面的题目暂时不更新, 等刷到那里再更, 不然这顺序很乱\n\n## [Problem](https://www.nowcoder.com/practice/0383714a1bb749499050d2e0610418b1?tpId=40&tqId=21333&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)   \n查找和排序\n题目：输入任意（用户，成绩）序列，可以获得成绩从高到低或从低到高的排列,相同成绩\n都按先录入排列在前的规则处理。 \n### Examples:\n**Input:** \n输入多行，先输入要排序的人的个数，然后输入排序方法0（降序）或者1（升序）再分别输入他们的名字和成绩，以一个空格隔开\n**Output:**\n按照指定方式输出名字和成绩，名字和成绩之间以一个空格隔开\n按先录入排列在前的规则处理。\n<!--more-->\n示例：\n> jack      70\n> peter     96\n> Tom       70\n> smith     67\n> \n> 从高到低  成绩\n> peter     96\n> jack      70\n> Tom       70\n> smith     67\n> \n> 从低到高\n> smith     67\n> jack      70\n> Tom      70\n> peter     96 \n{% endnote %}\n\n## Solutions\n- 冒泡排序是稳定排序, 不可以用快排, 快排不稳定\n- 直接调用STL的stable_sort()函数\n\n## C++ Codes\n直接调用\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint n, bs, score[500], r[500];\nbool cmp(int i,int j){\n    return score[i]<score[j];\n}\nbool cmp1(int i,int j){\n    return score[i]>score[j];\n}\nint main() {\n    string name[500];\n    int i,j,k;\n  while(cin >>n>>bs){\n    for(i=0;i<n;i++){\n        r[i]=i;\n        cin >>name[i]>>score[i];\n    }\n    if(bs==1)\n        stable_sort(r,r+n,cmp);\n    else\n        stable_sort(r,r+n,cmp1);\n    for(i=0;i<n;i++){\n        int t = r[i];\n        cout << name[t]<<' '<<score[t]<<endl;\n    }\n  }\nreturn 0;\n}\n```\n\n手写冒泡排序\n```C++\n#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n//升序\nvoid bubbleSort(int *A, vector<string> &name, int n){\n    int tmp;\n    string stmp;\n    for(int i=0;i<n-1;i++){//已经排序好的个数\n        bool flag = false;\n        for(int j=n-1;j>i;j--){//从最后向前找最小的\n            if(A[j]<A[j-1]){\n                flag = true;\n                tmp = A[j-1];\n                A[j-1]=A[j];\n                A[j]=tmp;\n                stmp = name[j-1];\n                name[j-1]=name[j];\n                name[j]=stmp;\n            }\n        }\n        if(!flag) break;\n    }\n}\n\n//降序\nvoid bubbleSort2(int *A, vector<string> &name, int n){\n    int tmp;\n    string stmp;\n    for(int i=0;i<n-1;i++){//已经排序好的个数\n        bool flag = false;\n        for(int j=n-1;j>i;j--){//从最后向前找最小的\n            if(A[j]>A[j-1]){\n                flag = true;\n                tmp = A[j-1];\n                A[j-1]=A[j];\n                A[j]=tmp;\n                stmp = name[j-1];\n                name[j-1]=name[j];\n                name[j]=stmp;\n            }\n        }\n        if(!flag) break;\n    }\n}\n\nint main(){\n    vector<string> names(1000);\n    int records[1000];\n    int n, tag;\n    while(cin>>n>>tag){\n        for(int i=0;i<n;i++){\n            cin>>names[i]>>records[i];\n        }\n\n        if(tag)\n            bubbleSort(records, names, n);\n        else\n            bubbleSort2(records, names, n);\n\n        for(int i=0;i<n;i++) \n            cout<<names[i]<<\" \"<<records[i]<<endl;\n    }\n}\n```\n\n------\n","slug":"NowCoder/NowCoder-成绩排序","published":1,"updated":"2019-08-30T16:01:34.118Z","layout":"post","photos":[],"link":"","_id":"ck2424luq008klksbku82yea9","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h2><p>之前刷了很多算法题, 有<a href=\"https://www.nowcoder.com/ta/kaoyan?page=1\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">牛客网:NowCoder</a>的, 也有LeetCode的, 现在开始慢慢将牛客网的题目记录下来, 也权当复习. LeetCode后面的题目暂时不更新, 等刷到那里再更, 不然这顺序很乱</p><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/0383714a1bb749499050d2e0610418b1?tpId=40&amp;tqId=21333&amp;tPage=1&amp;rp=1&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>查找和排序<br>题目：输入任意（用户，成绩）序列，可以获得成绩从高到低或从低到高的排列,相同成绩<br>都按先录入排列在前的规则处理。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>输入多行，先输入要排序的人的个数，然后输入排序方法0（降序）或者1（升序）再分别输入他们的名字和成绩，以一个空格隔开<br><strong>Output:</strong><br>按照指定方式输出名字和成绩，名字和成绩之间以一个空格隔开<br>按先录入排列在前的规则处理。<br><a id=\"more\"></a><br>示例：</p><blockquote><p>jack 70<br>peter 96<br>Tom 70<br>smith 67</p><p>从高到低 成绩<br>peter 96<br>jack 70<br>Tom 70<br>smith 67</p><p>从低到高<br>smith 67<br>jack 70<br>Tom 70<br>peter 96</p></blockquote></div><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>冒泡排序是稳定排序, 不可以用快排, 快排不稳定</li><li>直接调用STL的stable_sort()函数</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>直接调用<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, bs, score[<span class=\"number\">500</span>], r[<span class=\"number\">500</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> score[i]&lt;score[j];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp1</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> score[i]&gt;score[j];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name[<span class=\"number\">500</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j,k;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt;n&gt;&gt;bs)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        r[i]=i;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt;name[i]&gt;&gt;score[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(bs==<span class=\"number\">1</span>)</span><br><span class=\"line\">        stable_sort(r,r+n,cmp);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        stable_sort(r,r+n,cmp1);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = r[i];</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; name[t]&lt;&lt;<span class=\"string\">' '</span>&lt;&lt;score[t]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>手写冒泡排序<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//升序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span> *A, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;name, <span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> stmp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)&#123;<span class=\"comment\">//已经排序好的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=n<span class=\"number\">-1</span>;j&gt;i;j--)&#123;<span class=\"comment\">//从最后向前找最小的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(A[j]&lt;A[j<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                tmp = A[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">                A[j<span class=\"number\">-1</span>]=A[j];</span><br><span class=\"line\">                A[j]=tmp;</span><br><span class=\"line\">                stmp = name[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">                name[j<span class=\"number\">-1</span>]=name[j];</span><br><span class=\"line\">                name[j]=stmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//降序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubbleSort2</span><span class=\"params\">(<span class=\"keyword\">int</span> *A, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;name, <span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> stmp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)&#123;<span class=\"comment\">//已经排序好的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=n<span class=\"number\">-1</span>;j&gt;i;j--)&#123;<span class=\"comment\">//从最后向前找最小的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(A[j]&gt;A[j<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                tmp = A[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">                A[j<span class=\"number\">-1</span>]=A[j];</span><br><span class=\"line\">                A[j]=tmp;</span><br><span class=\"line\">                stmp = name[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">                name[j<span class=\"number\">-1</span>]=name[j];</span><br><span class=\"line\">                name[j]=stmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; names(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> records[<span class=\"number\">1000</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, tag;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n&gt;&gt;tag)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;names[i]&gt;&gt;records[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tag)</span><br><span class=\"line\">            bubbleSort(records, names, n);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            bubbleSort2(records, names, n);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) </span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;names[i]&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;records[i]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h2><p>之前刷了很多算法题, 有<a href=\"https://www.nowcoder.com/ta/kaoyan?page=1\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">牛客网:NowCoder</a>的, 也有LeetCode的, 现在开始慢慢将牛客网的题目记录下来, 也权当复习. LeetCode后面的题目暂时不更新, 等刷到那里再更, 不然这顺序很乱</p><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/0383714a1bb749499050d2e0610418b1?tpId=40&amp;tqId=21333&amp;tPage=1&amp;rp=1&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>查找和排序<br>题目：输入任意（用户，成绩）序列，可以获得成绩从高到低或从低到高的排列,相同成绩<br>都按先录入排列在前的规则处理。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>输入多行，先输入要排序的人的个数，然后输入排序方法0（降序）或者1（升序）再分别输入他们的名字和成绩，以一个空格隔开<br><strong>Output:</strong><br>按照指定方式输出名字和成绩，名字和成绩之间以一个空格隔开<br>按先录入排列在前的规则处理。<br>","more":"<br>示例：</p><blockquote><p>jack 70<br>peter 96<br>Tom 70<br>smith 67</p><p>从高到低 成绩<br>peter 96<br>jack 70<br>Tom 70<br>smith 67</p><p>从低到高<br>smith 67<br>jack 70<br>Tom 70<br>peter 96</p></blockquote></div><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>冒泡排序是稳定排序, 不可以用快排, 快排不稳定</li><li>直接调用STL的stable_sort()函数</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><p>直接调用<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, bs, score[<span class=\"number\">500</span>], r[<span class=\"number\">500</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> score[i]&lt;score[j];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp1</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> score[i]&gt;score[j];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name[<span class=\"number\">500</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j,k;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt;n&gt;&gt;bs)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        r[i]=i;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt;name[i]&gt;&gt;score[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(bs==<span class=\"number\">1</span>)</span><br><span class=\"line\">        stable_sort(r,r+n,cmp);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        stable_sort(r,r+n,cmp1);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = r[i];</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; name[t]&lt;&lt;<span class=\"string\">' '</span>&lt;&lt;score[t]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>手写冒泡排序<br></p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//升序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span> *A, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;name, <span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> stmp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)&#123;<span class=\"comment\">//已经排序好的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=n<span class=\"number\">-1</span>;j&gt;i;j--)&#123;<span class=\"comment\">//从最后向前找最小的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(A[j]&lt;A[j<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                tmp = A[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">                A[j<span class=\"number\">-1</span>]=A[j];</span><br><span class=\"line\">                A[j]=tmp;</span><br><span class=\"line\">                stmp = name[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">                name[j<span class=\"number\">-1</span>]=name[j];</span><br><span class=\"line\">                name[j]=stmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//降序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubbleSort2</span><span class=\"params\">(<span class=\"keyword\">int</span> *A, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;name, <span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> stmp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n<span class=\"number\">-1</span>;i++)&#123;<span class=\"comment\">//已经排序好的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=n<span class=\"number\">-1</span>;j&gt;i;j--)&#123;<span class=\"comment\">//从最后向前找最小的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(A[j]&gt;A[j<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                tmp = A[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">                A[j<span class=\"number\">-1</span>]=A[j];</span><br><span class=\"line\">                A[j]=tmp;</span><br><span class=\"line\">                stmp = name[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">                name[j<span class=\"number\">-1</span>]=name[j];</span><br><span class=\"line\">                name[j]=stmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; names(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> records[<span class=\"number\">1000</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, tag;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n&gt;&gt;tag)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;names[i]&gt;&gt;records[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tag)</span><br><span class=\"line\">            bubbleSort(records, names, n);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            bubbleSort2(records, names, n);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) </span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;names[i]&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;records[i]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><!-- rebuild by neat -->"},{"title":"NowCoder-手机键盘","comments":1,"mathjax":false,"date":"2019-09-12T12:59:22.000Z","urlname":"keyboard-of-phone","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/20082c12f1ec43b29cd27c805cd476cd?tpId=40&tqId=21337&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n按照手机键盘输入字母的方式，计算所花费的时间 如：a,b,c都在“1”键上，输入a只需要按一次，输入c需要连续按三次。 如果连续两个字符不在同一个按键上，则可直接按，如：ad需要按两下，kz需要按6下 如果连续两字符在同一个按键上，则两个按键之间需要等一段时间，如ac，在按了a之后，需要等一会儿才能按c。 现在假设每按一次需要花费一个时间段，等待时间需要花费两个时间段。 现在给出一串字符，需要计算出它所需要花费的时间。\n\n### Examples:\n**Input:**    \n一个长度不大于100的字符串，其中只有手机按键上有的小写字母\n**Output:**   \n输入可能包括多组数据，对于每组数据，输出按出Input所给字符串所需要的时间\n**Input:**  \nbob\nwww   \n**Output:**   \n7\n7\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 简单的用数组, 作为map使用, 下标就是key, 数组值就是value\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n    //十位代表按键数，各位代表按下次数\n    int mp[26]={11,12,13,21,22,23,31,32,33,41,42,43,51,52,53,61,62,63,64,71,72,73,81,82,83,84};\n    string tmp;\n    while(cin>>tmp){\n        int res = 0;\n        for(int i=0;i<tmp.length();i++){\n            if(i>0 && mp[tmp[i]-'a']/10==mp[tmp[i-1]-'a']/10){\n                res+=2;\n            }\n            res += mp[tmp[i]-'a']%10;\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}\n```\n\n## 总结\n- 用好map很关键\n\n------\n","source":"_posts/NowCoder/NowCoder-手机键盘.md","raw":"---\ntitle: NowCoder-手机键盘\ntags:\n  - NowCoder\n  - Algorithm\n  - Map\n  - Easy\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-12 20:59:22\nurlname: keyboard-of-phone\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/20082c12f1ec43b29cd27c805cd476cd?tpId=40&tqId=21337&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n按照手机键盘输入字母的方式，计算所花费的时间 如：a,b,c都在“1”键上，输入a只需要按一次，输入c需要连续按三次。 如果连续两个字符不在同一个按键上，则可直接按，如：ad需要按两下，kz需要按6下 如果连续两字符在同一个按键上，则两个按键之间需要等一段时间，如ac，在按了a之后，需要等一会儿才能按c。 现在假设每按一次需要花费一个时间段，等待时间需要花费两个时间段。 现在给出一串字符，需要计算出它所需要花费的时间。\n\n### Examples:\n**Input:**    \n一个长度不大于100的字符串，其中只有手机按键上有的小写字母\n**Output:**   \n输入可能包括多组数据，对于每组数据，输出按出Input所给字符串所需要的时间\n**Input:**  \nbob\nwww   \n**Output:**   \n7\n7\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 简单的用数组, 作为map使用, 下标就是key, 数组值就是value\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n    //十位代表按键数，各位代表按下次数\n    int mp[26]={11,12,13,21,22,23,31,32,33,41,42,43,51,52,53,61,62,63,64,71,72,73,81,82,83,84};\n    string tmp;\n    while(cin>>tmp){\n        int res = 0;\n        for(int i=0;i<tmp.length();i++){\n            if(i>0 && mp[tmp[i]-'a']/10==mp[tmp[i-1]-'a']/10){\n                res+=2;\n            }\n            res += mp[tmp[i]-'a']%10;\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}\n```\n\n## 总结\n- 用好map很关键\n\n------\n","slug":"NowCoder/NowCoder-手机键盘","published":1,"updated":"2019-09-17T02:18:25.130Z","layout":"post","photos":[],"link":"","_id":"ck2424lut008nlksbp1vgkiw1","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/20082c12f1ec43b29cd27c805cd476cd?tpId=40&amp;tqId=21337&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>按照手机键盘输入字母的方式，计算所花费的时间 如：a,b,c都在“1”键上，输入a只需要按一次，输入c需要连续按三次。 如果连续两个字符不在同一个按键上，则可直接按，如：ad需要按两下，kz需要按6下 如果连续两字符在同一个按键上，则两个按键之间需要等一段时间，如ac，在按了a之后，需要等一会儿才能按c。 现在假设每按一次需要花费一个时间段，等待时间需要花费两个时间段。 现在给出一串字符，需要计算出它所需要花费的时间。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>一个长度不大于100的字符串，其中只有手机按键上有的小写字母<br><strong>Output:</strong><br>输入可能包括多组数据，对于每组数据，输出按出Input所给字符串所需要的时间<br><strong>Input:</strong><br>bob<br>www<br><strong>Output:</strong><br>7<br>7</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>简单的用数组, 作为map使用, 下标就是key, 数组值就是value</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//十位代表按键数，各位代表按下次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mp[<span class=\"number\">26</span>]=&#123;<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>,<span class=\"number\">21</span>,<span class=\"number\">22</span>,<span class=\"number\">23</span>,<span class=\"number\">31</span>,<span class=\"number\">32</span>,<span class=\"number\">33</span>,<span class=\"number\">41</span>,<span class=\"number\">42</span>,<span class=\"number\">43</span>,<span class=\"number\">51</span>,<span class=\"number\">52</span>,<span class=\"number\">53</span>,<span class=\"number\">61</span>,<span class=\"number\">62</span>,<span class=\"number\">63</span>,<span class=\"number\">64</span>,<span class=\"number\">71</span>,<span class=\"number\">72</span>,<span class=\"number\">73</span>,<span class=\"number\">81</span>,<span class=\"number\">82</span>,<span class=\"number\">83</span>,<span class=\"number\">84</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> tmp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;tmp)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;tmp.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span> &amp;&amp; mp[tmp[i]-<span class=\"string\">'a'</span>]/<span class=\"number\">10</span>==mp[tmp[i<span class=\"number\">-1</span>]-<span class=\"string\">'a'</span>]/<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">                res+=<span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res += mp[tmp[i]-<span class=\"string\">'a'</span>]%<span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>用好map很关键</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/20082c12f1ec43b29cd27c805cd476cd?tpId=40&amp;tqId=21337&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>按照手机键盘输入字母的方式，计算所花费的时间 如：a,b,c都在“1”键上，输入a只需要按一次，输入c需要连续按三次。 如果连续两个字符不在同一个按键上，则可直接按，如：ad需要按两下，kz需要按6下 如果连续两字符在同一个按键上，则两个按键之间需要等一段时间，如ac，在按了a之后，需要等一会儿才能按c。 现在假设每按一次需要花费一个时间段，等待时间需要花费两个时间段。 现在给出一串字符，需要计算出它所需要花费的时间。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>一个长度不大于100的字符串，其中只有手机按键上有的小写字母<br><strong>Output:</strong><br>输入可能包括多组数据，对于每组数据，输出按出Input所给字符串所需要的时间<br><strong>Input:</strong><br>bob<br>www<br><strong>Output:</strong><br>7<br>7</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>简单的用数组, 作为map使用, 下标就是key, 数组值就是value</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//十位代表按键数，各位代表按下次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mp[<span class=\"number\">26</span>]=&#123;<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>,<span class=\"number\">21</span>,<span class=\"number\">22</span>,<span class=\"number\">23</span>,<span class=\"number\">31</span>,<span class=\"number\">32</span>,<span class=\"number\">33</span>,<span class=\"number\">41</span>,<span class=\"number\">42</span>,<span class=\"number\">43</span>,<span class=\"number\">51</span>,<span class=\"number\">52</span>,<span class=\"number\">53</span>,<span class=\"number\">61</span>,<span class=\"number\">62</span>,<span class=\"number\">63</span>,<span class=\"number\">64</span>,<span class=\"number\">71</span>,<span class=\"number\">72</span>,<span class=\"number\">73</span>,<span class=\"number\">81</span>,<span class=\"number\">82</span>,<span class=\"number\">83</span>,<span class=\"number\">84</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> tmp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;tmp)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;tmp.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span> &amp;&amp; mp[tmp[i]-<span class=\"string\">'a'</span>]/<span class=\"number\">10</span>==mp[tmp[i<span class=\"number\">-1</span>]-<span class=\"string\">'a'</span>]/<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">                res+=<span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res += mp[tmp[i]-<span class=\"string\">'a'</span>]%<span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>用好map很关键</li></ul><hr><!-- rebuild by neat -->"},{"title":"NowCoder-最小花费","comments":1,"mathjax":false,"date":"2019-09-21T15:27:27.000Z","urlname":"minimum-cost","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/e6df3e3005e34e2598b9b565cfe797c9?tpId=40&tqId=21354&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n在某条线路上有N个火车站，有三种距离的路程，L1，L2，L3,对应的价格为C1,C2,C3.其对应关系如下: 距离s票价 0\\<S<=L1: C1; L1\\<S\\<=L2, C2;  L2\\<S<=L3: C3 输入保证0\\<L1\\<L2\\<L3<10^9,0\\<C1\\<C2\\<C3\\<10^9。 \n\n每两个站之间的距离不超过L3。 当乘客要移动的两个站的距离大于L3的时候，可以选择从中间一个站下车，然后买票再上车，所以乘客整个过程中至少会买两张票。\n\n现在给你一个 L1，L2，L3，C1，C2,C3。然后是A B的值，其分别为乘客旅程的起始站和终点站。 然后输入N，N为该线路上的总的火车站数目，然后输入N-1个整数，分别代表从该线路上的第一个站，到第2个站，第3个站，……，第N个站的距离。\n\n根据输入，输出乘客从A到B站的最小花费。\n\n输入格式：  \nL1  L2  L3  C1  C2  C3\nA  B\nN\na[2]\na[3]\n……\na[N]\n\n根据输入，输出乘客从A到B站的最小花费。\n\n### Examples:\n**Input:**\n> 1 2 3 1 2 3\n> 1 2\n> 2\n> 2\n \n**Output:**\n> 2\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 动态规划问题，主要过程是没每往后移动一个站点， 就利用前面的站点信息来找到此站的最小花费，在距当前站L3范围内找，因为要找直达当前站的最近站点\n- 一直更新站点花费到B站点，结束\n- 状态转移方程：cost[i] = min(cost[i], getCost(dis,j,i)+cost[j])\n\n\n## C++ Codes\n\n```C++\n/*\n * 计算从A站点到B站点的最小花费\n * 中间有好多站，可能转车\n * 动态规划求解\n * 第i站最小花费 = min(到前面所有距i站L3以内站点j的最小花费 + j到i站的花费)\n * cost[i] = min(cost[i], tmp+cost[j]) and tmp=getCost(dis,j,i)\n * 相当于就是找个直达i的站点，也是找转车站点，在这个站点转车，直达i站点，在距离i站L3以内选\n */\n#include<iostream>\n#include<climits>\n#include<vector>\nusing namespace std;\n\nint L1, L2, L3;\nint C1, C2, C3;\nint A, B;\nint N;\n\n//获取不超过L3距离的花费\nint getCost(vector<int> &dis, int i, int j){\n  int len = dis[j]-dis[i];\n  if(len>L2 && len<=L3) return C3;\n  if(len>L1 && len<=L2) return C2;\n  return C1;\n}\n\nint main(){\n  while(cin>>L1>>L2>>L3>>C1>>C2>>C3>>A>>B>>N){\n    vector<int>dis(N+1);\n    dis[0]=dis[1]=0;\n    for(int i=2;i<=N;i++) cin>>dis[i];\n    vector<int>cost(N+1);\n    cost[A]=0;\n    //向后dp\n    for(int i=A+1;i<=B;i++){\n      //初始化这个站点要好多好多钱\n      cost[i]=INT_MAX;\n      //从i站前一个站点往前找站点，当然，距离在L3以内才能直达\n      for(int j=i-1;j>=1;j--){\n        if(dis[i]-dis[j]>L3) break;\n        int tmp = getCost(dis, j, i);\n        if(tmp+cost[j]<cost[i])\n          cost[i]=tmp+cost[j];\n      }\n    }\n    cout<<cost[B]<<endl;\n  }\n}\n```\n\n## 总结\n- 主要是用部分站点来更新当前站点，还有要用给的条件计算直达站点的cost\n- 题干很长，要耐心\n\n------\n","source":"_posts/NowCoder/NowCoder-最小花费.md","raw":"---\ntitle: NowCoder-最小花费\ntags:\n  - NowCoder\n  - Algorithm\n  - DP\n  - Hard\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-21 23:27:27\nurlname: minimum-cost\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/e6df3e3005e34e2598b9b565cfe797c9?tpId=40&tqId=21354&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n在某条线路上有N个火车站，有三种距离的路程，L1，L2，L3,对应的价格为C1,C2,C3.其对应关系如下: 距离s票价 0\\<S<=L1: C1; L1\\<S\\<=L2, C2;  L2\\<S<=L3: C3 输入保证0\\<L1\\<L2\\<L3<10^9,0\\<C1\\<C2\\<C3\\<10^9。 \n\n每两个站之间的距离不超过L3。 当乘客要移动的两个站的距离大于L3的时候，可以选择从中间一个站下车，然后买票再上车，所以乘客整个过程中至少会买两张票。\n\n现在给你一个 L1，L2，L3，C1，C2,C3。然后是A B的值，其分别为乘客旅程的起始站和终点站。 然后输入N，N为该线路上的总的火车站数目，然后输入N-1个整数，分别代表从该线路上的第一个站，到第2个站，第3个站，……，第N个站的距离。\n\n根据输入，输出乘客从A到B站的最小花费。\n\n输入格式：  \nL1  L2  L3  C1  C2  C3\nA  B\nN\na[2]\na[3]\n……\na[N]\n\n根据输入，输出乘客从A到B站的最小花费。\n\n### Examples:\n**Input:**\n> 1 2 3 1 2 3\n> 1 2\n> 2\n> 2\n \n**Output:**\n> 2\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 动态规划问题，主要过程是没每往后移动一个站点， 就利用前面的站点信息来找到此站的最小花费，在距当前站L3范围内找，因为要找直达当前站的最近站点\n- 一直更新站点花费到B站点，结束\n- 状态转移方程：cost[i] = min(cost[i], getCost(dis,j,i)+cost[j])\n\n\n## C++ Codes\n\n```C++\n/*\n * 计算从A站点到B站点的最小花费\n * 中间有好多站，可能转车\n * 动态规划求解\n * 第i站最小花费 = min(到前面所有距i站L3以内站点j的最小花费 + j到i站的花费)\n * cost[i] = min(cost[i], tmp+cost[j]) and tmp=getCost(dis,j,i)\n * 相当于就是找个直达i的站点，也是找转车站点，在这个站点转车，直达i站点，在距离i站L3以内选\n */\n#include<iostream>\n#include<climits>\n#include<vector>\nusing namespace std;\n\nint L1, L2, L3;\nint C1, C2, C3;\nint A, B;\nint N;\n\n//获取不超过L3距离的花费\nint getCost(vector<int> &dis, int i, int j){\n  int len = dis[j]-dis[i];\n  if(len>L2 && len<=L3) return C3;\n  if(len>L1 && len<=L2) return C2;\n  return C1;\n}\n\nint main(){\n  while(cin>>L1>>L2>>L3>>C1>>C2>>C3>>A>>B>>N){\n    vector<int>dis(N+1);\n    dis[0]=dis[1]=0;\n    for(int i=2;i<=N;i++) cin>>dis[i];\n    vector<int>cost(N+1);\n    cost[A]=0;\n    //向后dp\n    for(int i=A+1;i<=B;i++){\n      //初始化这个站点要好多好多钱\n      cost[i]=INT_MAX;\n      //从i站前一个站点往前找站点，当然，距离在L3以内才能直达\n      for(int j=i-1;j>=1;j--){\n        if(dis[i]-dis[j]>L3) break;\n        int tmp = getCost(dis, j, i);\n        if(tmp+cost[j]<cost[i])\n          cost[i]=tmp+cost[j];\n      }\n    }\n    cout<<cost[B]<<endl;\n  }\n}\n```\n\n## 总结\n- 主要是用部分站点来更新当前站点，还有要用给的条件计算直达站点的cost\n- 题干很长，要耐心\n\n------\n","slug":"NowCoder/NowCoder-最小花费","published":1,"updated":"2019-09-21T15:46:51.197Z","layout":"post","photos":[],"link":"","_id":"ck2424luu008plksbb5n9v9hf","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/e6df3e3005e34e2598b9b565cfe797c9?tpId=40&amp;tqId=21354&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>在某条线路上有N个火车站，有三种距离的路程，L1，L2，L3,对应的价格为C1,C2,C3.其对应关系如下: 距离s票价 0\\&lt;S&lt;=L1: C1; L1\\&lt;S\\&lt;=L2, C2; L2\\&lt;S&lt;=L3: C3 输入保证0\\&lt;L1\\&lt;L2\\&lt;L3&lt;10^9,0\\&lt;C1\\&lt;C2\\&lt;C3\\&lt;10^9。</p><p>每两个站之间的距离不超过L3。 当乘客要移动的两个站的距离大于L3的时候，可以选择从中间一个站下车，然后买票再上车，所以乘客整个过程中至少会买两张票。</p><p>现在给你一个 L1，L2，L3，C1，C2,C3。然后是A B的值，其分别为乘客旅程的起始站和终点站。 然后输入N，N为该线路上的总的火车站数目，然后输入N-1个整数，分别代表从该线路上的第一个站，到第2个站，第3个站，……，第N个站的距离。</p><p>根据输入，输出乘客从A到B站的最小花费。</p><p>输入格式：<br>L1 L2 L3 C1 C2 C3<br>A B<br>N<br>a[2]<br>a[3]<br>……<br>a[N]</p><p>根据输入，输出乘客从A到B站的最小花费。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>1 2 3 1 2 3<br>1 2<br>2<br>2</p></blockquote><p><strong>Output:</strong></p><blockquote><p>2</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>动态规划问题，主要过程是没每往后移动一个站点， 就利用前面的站点信息来找到此站的最小花费，在距当前站L3范围内找，因为要找直达当前站的最近站点</li><li>一直更新站点花费到B站点，结束</li><li>状态转移方程：cost[i] = min(cost[i], getCost(dis,j,i)+cost[j])</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 计算从A站点到B站点的最小花费</span></span><br><span class=\"line\"><span class=\"comment\"> * 中间有好多站，可能转车</span></span><br><span class=\"line\"><span class=\"comment\"> * 动态规划求解</span></span><br><span class=\"line\"><span class=\"comment\"> * 第i站最小花费 = min(到前面所有距i站L3以内站点j的最小花费 + j到i站的花费)</span></span><br><span class=\"line\"><span class=\"comment\"> * cost[i] = min(cost[i], tmp+cost[j]) and tmp=getCost(dis,j,i)</span></span><br><span class=\"line\"><span class=\"comment\"> * 相当于就是找个直达i的站点，也是找转车站点，在这个站点转车，直达i站点，在距离i站L3以内选</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;climits&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> L1, L2, L3;</span><br><span class=\"line\"><span class=\"keyword\">int</span> C1, C2, C3;</span><br><span class=\"line\"><span class=\"keyword\">int</span> A, B;</span><br><span class=\"line\"><span class=\"keyword\">int</span> N;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取不超过L3距离的花费</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getCost</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;dis, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> len = dis[j]-dis[i];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(len&gt;L2 &amp;&amp; len&lt;=L3) <span class=\"keyword\">return</span> C3;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(len&gt;L1 &amp;&amp; len&lt;=L2) <span class=\"keyword\">return</span> C2;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> C1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;L1&gt;&gt;L2&gt;&gt;L3&gt;&gt;C1&gt;&gt;C2&gt;&gt;C3&gt;&gt;A&gt;&gt;B&gt;&gt;N)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;dis(N+<span class=\"number\">1</span>);</span><br><span class=\"line\">    dis[<span class=\"number\">0</span>]=dis[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++) <span class=\"built_in\">cin</span>&gt;&gt;dis[i];</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;cost(N+<span class=\"number\">1</span>);</span><br><span class=\"line\">    cost[A]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//向后dp</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=A+<span class=\"number\">1</span>;i&lt;=B;i++)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//初始化这个站点要好多好多钱</span></span><br><span class=\"line\">      cost[i]=INT_MAX;</span><br><span class=\"line\">      <span class=\"comment\">//从i站前一个站点往前找站点，当然，距离在L3以内才能直达</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">1</span>;j--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dis[i]-dis[j]&gt;L3) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = getCost(dis, j, i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp+cost[j]&lt;cost[i])</span><br><span class=\"line\">          cost[i]=tmp+cost[j];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;cost[B]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>主要是用部分站点来更新当前站点，还有要用给的条件计算直达站点的cost</li><li>题干很长，要耐心</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/e6df3e3005e34e2598b9b565cfe797c9?tpId=40&amp;tqId=21354&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>在某条线路上有N个火车站，有三种距离的路程，L1，L2，L3,对应的价格为C1,C2,C3.其对应关系如下: 距离s票价 0\\&lt;S&lt;=L1: C1; L1\\&lt;S\\&lt;=L2, C2; L2\\&lt;S&lt;=L3: C3 输入保证0\\&lt;L1\\&lt;L2\\&lt;L3&lt;10^9,0\\&lt;C1\\&lt;C2\\&lt;C3\\&lt;10^9。</p><p>每两个站之间的距离不超过L3。 当乘客要移动的两个站的距离大于L3的时候，可以选择从中间一个站下车，然后买票再上车，所以乘客整个过程中至少会买两张票。</p><p>现在给你一个 L1，L2，L3，C1，C2,C3。然后是A B的值，其分别为乘客旅程的起始站和终点站。 然后输入N，N为该线路上的总的火车站数目，然后输入N-1个整数，分别代表从该线路上的第一个站，到第2个站，第3个站，……，第N个站的距离。</p><p>根据输入，输出乘客从A到B站的最小花费。</p><p>输入格式：<br>L1 L2 L3 C1 C2 C3<br>A B<br>N<br>a[2]<br>a[3]<br>……<br>a[N]</p><p>根据输入，输出乘客从A到B站的最小花费。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>1 2 3 1 2 3<br>1 2<br>2<br>2</p></blockquote><p><strong>Output:</strong></p><blockquote><p>2</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>动态规划问题，主要过程是没每往后移动一个站点， 就利用前面的站点信息来找到此站的最小花费，在距当前站L3范围内找，因为要找直达当前站的最近站点</li><li>一直更新站点花费到B站点，结束</li><li>状态转移方程：cost[i] = min(cost[i], getCost(dis,j,i)+cost[j])</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 计算从A站点到B站点的最小花费</span></span><br><span class=\"line\"><span class=\"comment\"> * 中间有好多站，可能转车</span></span><br><span class=\"line\"><span class=\"comment\"> * 动态规划求解</span></span><br><span class=\"line\"><span class=\"comment\"> * 第i站最小花费 = min(到前面所有距i站L3以内站点j的最小花费 + j到i站的花费)</span></span><br><span class=\"line\"><span class=\"comment\"> * cost[i] = min(cost[i], tmp+cost[j]) and tmp=getCost(dis,j,i)</span></span><br><span class=\"line\"><span class=\"comment\"> * 相当于就是找个直达i的站点，也是找转车站点，在这个站点转车，直达i站点，在距离i站L3以内选</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;climits&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> L1, L2, L3;</span><br><span class=\"line\"><span class=\"keyword\">int</span> C1, C2, C3;</span><br><span class=\"line\"><span class=\"keyword\">int</span> A, B;</span><br><span class=\"line\"><span class=\"keyword\">int</span> N;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取不超过L3距离的花费</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getCost</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;dis, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> len = dis[j]-dis[i];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(len&gt;L2 &amp;&amp; len&lt;=L3) <span class=\"keyword\">return</span> C3;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(len&gt;L1 &amp;&amp; len&lt;=L2) <span class=\"keyword\">return</span> C2;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> C1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;L1&gt;&gt;L2&gt;&gt;L3&gt;&gt;C1&gt;&gt;C2&gt;&gt;C3&gt;&gt;A&gt;&gt;B&gt;&gt;N)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;dis(N+<span class=\"number\">1</span>);</span><br><span class=\"line\">    dis[<span class=\"number\">0</span>]=dis[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++) <span class=\"built_in\">cin</span>&gt;&gt;dis[i];</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;cost(N+<span class=\"number\">1</span>);</span><br><span class=\"line\">    cost[A]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//向后dp</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=A+<span class=\"number\">1</span>;i&lt;=B;i++)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//初始化这个站点要好多好多钱</span></span><br><span class=\"line\">      cost[i]=INT_MAX;</span><br><span class=\"line\">      <span class=\"comment\">//从i站前一个站点往前找站点，当然，距离在L3以内才能直达</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">1</span>;j--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dis[i]-dis[j]&gt;L3) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = getCost(dis, j, i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp+cost[j]&lt;cost[i])</span><br><span class=\"line\">          cost[i]=tmp+cost[j];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;cost[B]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>主要是用部分站点来更新当前站点，还有要用给的条件计算直达站点的cost</li><li>题干很长，要耐心</li></ul><hr><!-- rebuild by neat -->"},{"title":"NowCoder-整数拆分","comments":1,"mathjax":false,"date":"2019-09-17T02:28:10.000Z","urlname":"integer-split","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/376537f4609a49d296901db5139639ec?tpId=40&tqId=21339&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n**补之前的**\n一个整数总可以拆分为2的幂的和，例如： 7=1+2+4 7=1+2+2+2 7=1+1+1+4 7=1+1+1+2+2 7=1+1+1+1+1+2 7=1+1+1+1+1+1+1 总共有六种不同的拆分方式。 再比如：4可以拆分成：4 = 4，4 = 1 + 1 + 1 + 1，4 = 2 + 2，4=1+1+2。 用f(n)表示n的不同拆分的种数，例如f(7)=6. 要求编写程序，读入n(不超过1000000)，输出f(n)%1000000000。\n\n### Examples:\n**Input:**\n每组输入包括一个整数：N(1<=N<=1000000)。\n**Output:**\n对于每组数据，输出f(n)%1000000000。\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 动态规划题目， 主要要能找到转移方程。\n- 具体看下面的代码\n\n\n\n## C++ Codes\n\n```C++\n/*\n * 整数拆分\n * 动态规划\n * f(2m)=f(2m-1)+f(m)\n * f(2m+1)=f(2m)\n */\n#include<iostream>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define ll long long\n#define MAXN 1000000\n\n  ll N;\n  ll dp[MAXN+1];\n  memset(dp, 0, sizeof(dp));\n  dp[1]=1;\n  dp[2]=2;\n  for(ll i=3;i<=MAXN;i++){\n    if(i%2) dp[i]=dp[i-1]%1000000000;\n    else dp[i]=(dp[i-1]+dp[i/2])%1000000000;\n  }\n  while(cin>>N){\n    cout<<dp[N]<<endl;\n  }\n  return 0;\n}\n```\n\n------\n","source":"_posts/NowCoder/NowCoder-整数拆分.md","raw":"---\ntitle: NowCoder-整数拆分\ntags:\n  - NowCoder\n  - Algorithm\n  - Medium\n  - DP\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-17 10:28:10\nurlname: integer-split\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/376537f4609a49d296901db5139639ec?tpId=40&tqId=21339&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n**补之前的**\n一个整数总可以拆分为2的幂的和，例如： 7=1+2+4 7=1+2+2+2 7=1+1+1+4 7=1+1+1+2+2 7=1+1+1+1+1+2 7=1+1+1+1+1+1+1 总共有六种不同的拆分方式。 再比如：4可以拆分成：4 = 4，4 = 1 + 1 + 1 + 1，4 = 2 + 2，4=1+1+2。 用f(n)表示n的不同拆分的种数，例如f(7)=6. 要求编写程序，读入n(不超过1000000)，输出f(n)%1000000000。\n\n### Examples:\n**Input:**\n每组输入包括一个整数：N(1<=N<=1000000)。\n**Output:**\n对于每组数据，输出f(n)%1000000000。\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 动态规划题目， 主要要能找到转移方程。\n- 具体看下面的代码\n\n\n\n## C++ Codes\n\n```C++\n/*\n * 整数拆分\n * 动态规划\n * f(2m)=f(2m-1)+f(m)\n * f(2m+1)=f(2m)\n */\n#include<iostream>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define ll long long\n#define MAXN 1000000\n\n  ll N;\n  ll dp[MAXN+1];\n  memset(dp, 0, sizeof(dp));\n  dp[1]=1;\n  dp[2]=2;\n  for(ll i=3;i<=MAXN;i++){\n    if(i%2) dp[i]=dp[i-1]%1000000000;\n    else dp[i]=(dp[i-1]+dp[i/2])%1000000000;\n  }\n  while(cin>>N){\n    cout<<dp[N]<<endl;\n  }\n  return 0;\n}\n```\n\n------\n","slug":"NowCoder/NowCoder-整数拆分","published":1,"updated":"2019-09-17T02:35:33.238Z","layout":"post","photos":[],"link":"","_id":"ck2424luw008slksbj6j3rgev","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/376537f4609a49d296901db5139639ec?tpId=40&amp;tqId=21339&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p><strong>补之前的</strong><br>一个整数总可以拆分为2的幂的和，例如： 7=1+2+4 7=1+2+2+2 7=1+1+1+4 7=1+1+1+2+2 7=1+1+1+1+1+2 7=1+1+1+1+1+1+1 总共有六种不同的拆分方式。 再比如：4可以拆分成：4 = 4，4 = 1 + 1 + 1 + 1，4 = 2 + 2，4=1+1+2。 用f(n)表示n的不同拆分的种数，例如f(7)=6. 要求编写程序，读入n(不超过1000000)，输出f(n)%1000000000。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>每组输入包括一个整数：N(1&lt;=N&lt;=1000000)。<br><strong>Output:</strong><br>对于每组数据，输出f(n)%1000000000。</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>动态规划题目， 主要要能找到转移方程。</li><li>具体看下面的代码</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 整数拆分</span></span><br><span class=\"line\"><span class=\"comment\"> * 动态规划</span></span><br><span class=\"line\"><span class=\"comment\"> * f(2m)=f(2m-1)+f(m)</span></span><br><span class=\"line\"><span class=\"comment\"> * f(2m+1)=f(2m)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 1000000</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ll N;</span><br><span class=\"line\">  ll dp[MAXN+<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</span><br><span class=\"line\">  dp[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">  dp[<span class=\"number\">2</span>]=<span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(ll i=<span class=\"number\">3</span>;i&lt;=MAXN;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>) dp[i]=dp[i<span class=\"number\">-1</span>]%<span class=\"number\">1000000000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> dp[i]=(dp[i<span class=\"number\">-1</span>]+dp[i/<span class=\"number\">2</span>])%<span class=\"number\">1000000000</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;N)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;dp[N]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/376537f4609a49d296901db5139639ec?tpId=40&amp;tqId=21339&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p><strong>补之前的</strong><br>一个整数总可以拆分为2的幂的和，例如： 7=1+2+4 7=1+2+2+2 7=1+1+1+4 7=1+1+1+2+2 7=1+1+1+1+1+2 7=1+1+1+1+1+1+1 总共有六种不同的拆分方式。 再比如：4可以拆分成：4 = 4，4 = 1 + 1 + 1 + 1，4 = 2 + 2，4=1+1+2。 用f(n)表示n的不同拆分的种数，例如f(7)=6. 要求编写程序，读入n(不超过1000000)，输出f(n)%1000000000。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>每组输入包括一个整数：N(1&lt;=N&lt;=1000000)。<br><strong>Output:</strong><br>对于每组数据，输出f(n)%1000000000。</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>动态规划题目， 主要要能找到转移方程。</li><li>具体看下面的代码</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 整数拆分</span></span><br><span class=\"line\"><span class=\"comment\"> * 动态规划</span></span><br><span class=\"line\"><span class=\"comment\"> * f(2m)=f(2m-1)+f(m)</span></span><br><span class=\"line\"><span class=\"comment\"> * f(2m+1)=f(2m)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 1000000</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ll N;</span><br><span class=\"line\">  ll dp[MAXN+<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dp));</span><br><span class=\"line\">  dp[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">  dp[<span class=\"number\">2</span>]=<span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(ll i=<span class=\"number\">3</span>;i&lt;=MAXN;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>) dp[i]=dp[i<span class=\"number\">-1</span>]%<span class=\"number\">1000000000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> dp[i]=(dp[i<span class=\"number\">-1</span>]+dp[i/<span class=\"number\">2</span>])%<span class=\"number\">1000000000</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;N)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;dp[N]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"NowCoder-特殊乘法","comments":1,"mathjax":false,"date":"2019-09-21T07:45:06.000Z","urlname":"special-multiplication","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/a5edebf0622045468436c74c3a34240f?tpId=40&tqId=21349&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n写个算法，对2个小于1000000000的输入，求结果。 特殊乘法举例：123 * 45 = 1\\*4 +1\\*5 +2\\*4 +2\\*5 +3\\*4+3\\*5\n\n输入可能有多组数据，对于每一组数据，输出Input中的两个数按照题目要求的方法进行运算后得到的结果。\n\n输入两个小于1000000000的数\n\n### Examples:\n**Input:** 123 45\n**Output:** 54\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 直接读入字符串，然后计算的时候字符转数字计算\n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n    string a, b;\n    while(cin>>a>>b){\n        int res = 0;\n        for(int i=0;i<a.length();i++){\n            for(int j=0;j<b.length();j++){\n                res += (a[i]-'0')*(b[j]-'0');\n            }\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}\n```\n\n------\n","source":"_posts/NowCoder/NowCoder-特殊乘法.md","raw":"---\ntitle: NowCoder-特殊乘法\ntags:\n  - NowCoder\n  - Algorithm\n  - Easy\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-21 15:45:06\nurlname: special-multiplication\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/a5edebf0622045468436c74c3a34240f?tpId=40&tqId=21349&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n写个算法，对2个小于1000000000的输入，求结果。 特殊乘法举例：123 * 45 = 1\\*4 +1\\*5 +2\\*4 +2\\*5 +3\\*4+3\\*5\n\n输入可能有多组数据，对于每一组数据，输出Input中的两个数按照题目要求的方法进行运算后得到的结果。\n\n输入两个小于1000000000的数\n\n### Examples:\n**Input:** 123 45\n**Output:** 54\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 直接读入字符串，然后计算的时候字符转数字计算\n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n    string a, b;\n    while(cin>>a>>b){\n        int res = 0;\n        for(int i=0;i<a.length();i++){\n            for(int j=0;j<b.length();j++){\n                res += (a[i]-'0')*(b[j]-'0');\n            }\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}\n```\n\n------\n","slug":"NowCoder/NowCoder-特殊乘法","published":1,"updated":"2019-09-21T07:49:39.082Z","layout":"post","photos":[],"link":"","_id":"ck2424lux008ulksbgwha9t5y","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/a5edebf0622045468436c74c3a34240f?tpId=40&amp;tqId=21349&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>写个算法，对2个小于1000000000的输入，求结果。 特殊乘法举例：123 <em>45 = 1\\</em>4 +1*5 +2*4 +2*5 +3*4+3*5</p><p>输入可能有多组数据，对于每一组数据，输出Input中的两个数按照题目要求的方法进行运算后得到的结果。</p><p>输入两个小于1000000000的数</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> 123 45<br><strong>Output:</strong> 54</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>直接读入字符串，然后计算的时候字符转数字计算</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> a, b;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;a.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;b.length();j++)&#123;</span><br><span class=\"line\">                res += (a[i]-<span class=\"string\">'0'</span>)*(b[j]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/a5edebf0622045468436c74c3a34240f?tpId=40&amp;tqId=21349&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>写个算法，对2个小于1000000000的输入，求结果。 特殊乘法举例：123 <em>45 = 1\\</em>4 +1*5 +2*4 +2*5 +3*4+3*5</p><p>输入可能有多组数据，对于每一组数据，输出Input中的两个数按照题目要求的方法进行运算后得到的结果。</p><p>输入两个小于1000000000的数</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong> 123 45<br><strong>Output:</strong> 54</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>直接读入字符串，然后计算的时候字符转数字计算</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> a, b;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;a.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;b.length();j++)&#123;</span><br><span class=\"line\">                res += (a[i]-<span class=\"string\">'0'</span>)*(b[j]-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"NowCoder-最小邮票数","comments":1,"mathjax":false,"date":"2019-09-21T07:22:41.000Z","urlname":"least-number-of-stamps","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/83800ae3292b4256b7349ded5f178dd1?tpId=40&tqId=21345&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。     如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。\n\n**输入描述：**   \n有多组数据，对于每组数据，首先是要求凑成的邮票总值M，M<100。然后是一个数N，N〈20，表示有N张邮票。接下来是N个正整数，分别表示这N张邮票的面值，且以升序排列。\n**输出描述：**    \n对于每组数据，能够凑成总值M的最少邮票张数。若无解，输出0。\n\n### Examples:\n**Input:**\n10\n5\n1 3 3 3 4\n**Output:**\n3\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 求的是最小的邮票张数，给的条件是总金额，以及每个邮票金额，所以很明显，一个背包问题，容量是总金额，体积是每个邮票面值，然后每个邮票价值是1,求最后最大容量的情况下，价值最少\n- 和正常的0-1背包还有点不一样，就是这个求的是最少，一般就是求最大。但是解决上差不多。区别在与初始化的时候，数组f每个都是N+1, 然后公式是min而不是max\n\n\n## C++ Codes\n\n```C++\n/*\n * 给出几张邮票，要求选几张凑成给定面值，如果凑不出输出0，凑出输出张数\n * 可以用动态规划的0-1背包试试\n */\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint C[21];      //这里相当于01背包中的所占容量\nint f[101];     //dp数组\n                //因为权重/价值都是1，所以不设置权重数组\n\nint main(){\n  int M,N;\n  while(cin>>M>>N){\n    for(int i=0;i<N;i++)\n      cin>>C[i];\n    for(int i=0;i<101;i++) \n      f[i]=N+1;\n    f[0]=0;\n    for(int i=0;i<N;i++){\n      //这里设置j>=C[i]是因为，总容量肯定要大于这个物品的空间才考虑放不放啊\n      for(int j=M;j>=C[i];j--){\n          f[j]=min(f[j], f[j-C[i]]+1);\n      }\n    }\n    if(f[M]<=N)\n      cout<<f[M]<<endl;\n    else\n      cout<<0<<endl;\n  }\n  return 0;\n}\n```\n\n## 总结\n- 0-1背包中求最大和最小的差别也就是初始值和动态规划方程,最大是max，最小是min\n- 注意上面的代码的写法，最外面for循环是物品编号，里层是从后往前的动态转移\n\n------\n","source":"_posts/NowCoder/NowCoder-最小邮票数.md","raw":"---\ntitle: NowCoder-最小邮票数\ntags:\n  - NowCoder\n  - Algorithm\n  - DP\n  - Medium\n  - Knapsack\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-21 15:22:41\nurlname: least-number-of-stamps\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/83800ae3292b4256b7349ded5f178dd1?tpId=40&tqId=21345&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。     如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。\n\n**输入描述：**   \n有多组数据，对于每组数据，首先是要求凑成的邮票总值M，M<100。然后是一个数N，N〈20，表示有N张邮票。接下来是N个正整数，分别表示这N张邮票的面值，且以升序排列。\n**输出描述：**    \n对于每组数据，能够凑成总值M的最少邮票张数。若无解，输出0。\n\n### Examples:\n**Input:**\n10\n5\n1 3 3 3 4\n**Output:**\n3\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 求的是最小的邮票张数，给的条件是总金额，以及每个邮票金额，所以很明显，一个背包问题，容量是总金额，体积是每个邮票面值，然后每个邮票价值是1,求最后最大容量的情况下，价值最少\n- 和正常的0-1背包还有点不一样，就是这个求的是最少，一般就是求最大。但是解决上差不多。区别在与初始化的时候，数组f每个都是N+1, 然后公式是min而不是max\n\n\n## C++ Codes\n\n```C++\n/*\n * 给出几张邮票，要求选几张凑成给定面值，如果凑不出输出0，凑出输出张数\n * 可以用动态规划的0-1背包试试\n */\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint C[21];      //这里相当于01背包中的所占容量\nint f[101];     //dp数组\n                //因为权重/价值都是1，所以不设置权重数组\n\nint main(){\n  int M,N;\n  while(cin>>M>>N){\n    for(int i=0;i<N;i++)\n      cin>>C[i];\n    for(int i=0;i<101;i++) \n      f[i]=N+1;\n    f[0]=0;\n    for(int i=0;i<N;i++){\n      //这里设置j>=C[i]是因为，总容量肯定要大于这个物品的空间才考虑放不放啊\n      for(int j=M;j>=C[i];j--){\n          f[j]=min(f[j], f[j-C[i]]+1);\n      }\n    }\n    if(f[M]<=N)\n      cout<<f[M]<<endl;\n    else\n      cout<<0<<endl;\n  }\n  return 0;\n}\n```\n\n## 总结\n- 0-1背包中求最大和最小的差别也就是初始值和动态规划方程,最大是max，最小是min\n- 注意上面的代码的写法，最外面for循环是物品编号，里层是从后往前的动态转移\n\n------\n","slug":"NowCoder/NowCoder-最小邮票数","published":1,"updated":"2019-09-21T07:40:05.465Z","layout":"post","photos":[],"link":"","_id":"ck2424luy008xlksbych894fh","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/83800ae3292b4256b7349ded5f178dd1?tpId=40&amp;tqId=21345&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。 如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。</p><p><strong>输入描述：</strong><br>有多组数据，对于每组数据，首先是要求凑成的邮票总值M，M&lt;100。然后是一个数N，N〈20，表示有N张邮票。接下来是N个正整数，分别表示这N张邮票的面值，且以升序排列。<br><strong>输出描述：</strong><br>对于每组数据，能够凑成总值M的最少邮票张数。若无解，输出0。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>10<br>5<br>1 3 3 3 4<br><strong>Output:</strong><br>3</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>求的是最小的邮票张数，给的条件是总金额，以及每个邮票金额，所以很明显，一个背包问题，容量是总金额，体积是每个邮票面值，然后每个邮票价值是1,求最后最大容量的情况下，价值最少</li><li>和正常的0-1背包还有点不一样，就是这个求的是最少，一般就是求最大。但是解决上差不多。区别在与初始化的时候，数组f每个都是N+1, 然后公式是min而不是max</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 给出几张邮票，要求选几张凑成给定面值，如果凑不出输出0，凑出输出张数</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以用动态规划的0-1背包试试</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> C[<span class=\"number\">21</span>];      <span class=\"comment\">//这里相当于01背包中的所占容量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> f[<span class=\"number\">101</span>];     <span class=\"comment\">//dp数组</span></span><br><span class=\"line\">                <span class=\"comment\">//因为权重/价值都是1，所以不设置权重数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> M,N;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;M&gt;&gt;N)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)</span><br><span class=\"line\">      <span class=\"built_in\">cin</span>&gt;&gt;C[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">101</span>;i++) </span><br><span class=\"line\">      f[i]=N+<span class=\"number\">1</span>;</span><br><span class=\"line\">    f[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//这里设置j&gt;=C[i]是因为，总容量肯定要大于这个物品的空间才考虑放不放啊</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=M;j&gt;=C[i];j--)&#123;</span><br><span class=\"line\">          f[j]=min(f[j], f[j-C[i]]+<span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(f[M]&lt;=N)</span><br><span class=\"line\">      <span class=\"built_in\">cout</span>&lt;&lt;f[M]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>0-1背包中求最大和最小的差别也就是初始值和动态规划方程,最大是max，最小是min</li><li>注意上面的代码的写法，最外面for循环是物品编号，里层是从后往前的动态转移</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/83800ae3292b4256b7349ded5f178dd1?tpId=40&amp;tqId=21345&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。 如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。</p><p><strong>输入描述：</strong><br>有多组数据，对于每组数据，首先是要求凑成的邮票总值M，M&lt;100。然后是一个数N，N〈20，表示有N张邮票。接下来是N个正整数，分别表示这N张邮票的面值，且以升序排列。<br><strong>输出描述：</strong><br>对于每组数据，能够凑成总值M的最少邮票张数。若无解，输出0。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>10<br>5<br>1 3 3 3 4<br><strong>Output:</strong><br>3</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>求的是最小的邮票张数，给的条件是总金额，以及每个邮票金额，所以很明显，一个背包问题，容量是总金额，体积是每个邮票面值，然后每个邮票价值是1,求最后最大容量的情况下，价值最少</li><li>和正常的0-1背包还有点不一样，就是这个求的是最少，一般就是求最大。但是解决上差不多。区别在与初始化的时候，数组f每个都是N+1, 然后公式是min而不是max</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 给出几张邮票，要求选几张凑成给定面值，如果凑不出输出0，凑出输出张数</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以用动态规划的0-1背包试试</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> C[<span class=\"number\">21</span>];      <span class=\"comment\">//这里相当于01背包中的所占容量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> f[<span class=\"number\">101</span>];     <span class=\"comment\">//dp数组</span></span><br><span class=\"line\">                <span class=\"comment\">//因为权重/价值都是1，所以不设置权重数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> M,N;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;M&gt;&gt;N)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)</span><br><span class=\"line\">      <span class=\"built_in\">cin</span>&gt;&gt;C[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">101</span>;i++) </span><br><span class=\"line\">      f[i]=N+<span class=\"number\">1</span>;</span><br><span class=\"line\">    f[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//这里设置j&gt;=C[i]是因为，总容量肯定要大于这个物品的空间才考虑放不放啊</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=M;j&gt;=C[i];j--)&#123;</span><br><span class=\"line\">          f[j]=min(f[j], f[j-C[i]]+<span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(f[M]&lt;=N)</span><br><span class=\"line\">      <span class=\"built_in\">cout</span>&lt;&lt;f[M]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>0-1背包中求最大和最小的差别也就是初始值和动态规划方程,最大是max，最小是min</li><li>注意上面的代码的写法，最外面for循环是物品编号，里层是从后往前的动态转移</li></ul><hr><!-- rebuild by neat -->"},{"title":"NowCoder-球的半径和体积","comments":1,"mathjax":false,"date":"2019-09-17T02:39:12.000Z","urlname":"Radius-and-volume-of-the-ball","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/4b733a850c364c32b368555c8c2ec96b?tpId=40&tqId=21341&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n输入球的中心点和球上某一点的坐标，计算球的半径和体积\n\n### Examples:\n**Input:**\n球的中心点和球上某一点的坐标，以如下形式输入：x0 y0 z0 x1 y1 z1\n**Output:**\n输入可能有多组，对于每组输入，输出球的半径和体积，并且结果保留三位小数\n为避免精度问题，PI值请使用arccos(-1)。\n\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 简单题，没有算法，直接算\n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint main(){\n    double x0, y0, z0, x1, y1, z1;\n    double pi = acos(-1); \n    while(cin>>x0>>y0>>z0>>x1>>y1>>z1){\n        double x = abs(x1-x0);\n        double y = abs(y1-y0);\n        double z = abs(z1-z0);\n        double r = sqrt(x*x + y*y + z*z);\n        double v =4.0/3.0*pi*r*r*r;\n        printf(\"%.3f %.3f\\n\", r, v);\n    }\n    return 0;\n}\n```\n\n\n------\n","source":"_posts/NowCoder/NowCoder-球的半径和体积.md","raw":"---\ntitle: NowCoder-球的半径和体积\ntags:\n  - NowCoder\n  - Algorithm\n  - Math\n  - Easy\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-17 10:39:12\nurlname: Radius-and-volume-of-the-ball\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/4b733a850c364c32b368555c8c2ec96b?tpId=40&tqId=21341&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n输入球的中心点和球上某一点的坐标，计算球的半径和体积\n\n### Examples:\n**Input:**\n球的中心点和球上某一点的坐标，以如下形式输入：x0 y0 z0 x1 y1 z1\n**Output:**\n输入可能有多组，对于每组输入，输出球的半径和体积，并且结果保留三位小数\n为避免精度问题，PI值请使用arccos(-1)。\n\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 简单题，没有算法，直接算\n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint main(){\n    double x0, y0, z0, x1, y1, z1;\n    double pi = acos(-1); \n    while(cin>>x0>>y0>>z0>>x1>>y1>>z1){\n        double x = abs(x1-x0);\n        double y = abs(y1-y0);\n        double z = abs(z1-z0);\n        double r = sqrt(x*x + y*y + z*z);\n        double v =4.0/3.0*pi*r*r*r;\n        printf(\"%.3f %.3f\\n\", r, v);\n    }\n    return 0;\n}\n```\n\n\n------\n","slug":"NowCoder/NowCoder-球的半径和体积","published":1,"updated":"2019-09-17T02:45:53.705Z","layout":"post","photos":[],"link":"","_id":"ck2424lv00090lksbc4l9vw90","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/4b733a850c364c32b368555c8c2ec96b?tpId=40&amp;tqId=21341&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>输入球的中心点和球上某一点的坐标，计算球的半径和体积</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>球的中心点和球上某一点的坐标，以如下形式输入：x0 y0 z0 x1 y1 z1<br><strong>Output:</strong><br>输入可能有多组，对于每组输入，输出球的半径和体积，并且结果保留三位小数<br>为避免精度问题，PI值请使用arccos(-1)。</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>简单题，没有算法，直接算</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x0, y0, z0, x1, y1, z1;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> pi = <span class=\"built_in\">acos</span>(<span class=\"number\">-1</span>); </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;x0&gt;&gt;y0&gt;&gt;z0&gt;&gt;x1&gt;&gt;y1&gt;&gt;z1)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> x = <span class=\"built_in\">abs</span>(x1-x0);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> y = <span class=\"built_in\">abs</span>(y1-y0);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> z = <span class=\"built_in\">abs</span>(z1-z0);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> r = <span class=\"built_in\">sqrt</span>(x*x + y*y + z*z);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> v =<span class=\"number\">4.0</span>/<span class=\"number\">3.0</span>*pi*r*r*r;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.3f %.3f\\n\"</span>, r, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/4b733a850c364c32b368555c8c2ec96b?tpId=40&amp;tqId=21341&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>输入球的中心点和球上某一点的坐标，计算球的半径和体积</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>球的中心点和球上某一点的坐标，以如下形式输入：x0 y0 z0 x1 y1 z1<br><strong>Output:</strong><br>输入可能有多组，对于每组输入，输出球的半径和体积，并且结果保留三位小数<br>为避免精度问题，PI值请使用arccos(-1)。</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>简单题，没有算法，直接算</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x0, y0, z0, x1, y1, z1;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> pi = <span class=\"built_in\">acos</span>(<span class=\"number\">-1</span>); </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;x0&gt;&gt;y0&gt;&gt;z0&gt;&gt;x1&gt;&gt;y1&gt;&gt;z1)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> x = <span class=\"built_in\">abs</span>(x1-x0);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> y = <span class=\"built_in\">abs</span>(y1-y0);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> z = <span class=\"built_in\">abs</span>(z1-z0);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> r = <span class=\"built_in\">sqrt</span>(x*x + y*y + z*z);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> v =<span class=\"number\">4.0</span>/<span class=\"number\">3.0</span>*pi*r*r*r;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.3f %.3f\\n\"</span>, r, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"NowCoder-玛雅人的密码","comments":1,"mathjax":false,"date":"2019-09-17T13:02:23.000Z","urlname":"maya-code","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/761fc1e2f03742c2aa929c19ba96dbb0?tpId=40&tqId=21343&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n玛雅人有一种密码，如果字符串中出现连续的2012四个数字就能解开密码。给一个长度为N的字符串，（2=\\<N\\<=13）该字符串中只含有0,1,2三种数字，问这个字符串要移位几次才能解开密码，每次只能移动相邻的两个数字。例如02120经过一次移位，可以得到20120,01220,02210,02102，其中20120符合要求，因此输出为1.如果无论移位多少次都解不开密码，输出-1。\n### Examples:\n**Input:**\n输入包含多组测试数据，每组测试数据由两行组成。\n第一行为一个整数N，代表字符串的长度（2<=N<=13）。\n第二行为一个仅由0、1、2组成的，长度为N的字符串。\n**Output:**\n对于每组测试数据，若可以解出密码，输出最少的移位次数；否则输出-1。\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 看到这种要求最少怎么怎么样，最低什么什么的，一般可以先考虑BFS\n- 可以用队列完成BFS\n\n\n## C++ Codes\n\n```C++\n/*\n * 玛雅人的密码，每次只能移动相邻的两个数字，问最低移动多少次才可以得到要的数字\n * 尝试1：BFS\n */\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint main(){\n  int N;\n  string code;\n  while(cin>>N>>code){\n    auto pos2 = code.find_first_of(\"2\");\n    auto pos22 = code.find_last_of(\"2\");\n    //条件判断\n    if(N<4 || pos2==-1 || pos22==-1 || pos2 == pos22 || code.find(\"0\")==-1 || code.find(\"1\")==-1) {\n      cout<<-1<<endl;\n      continue;\n    }\n\n    //使用队列完成BFS\n    queue<string> mq;\n    mq.push(code);\n    int res = 0;\n    bool flag = false;  //是否找到的标志\n    while(!mq.empty()){\n      int n = mq.size();\n      //这个for循环代表一次，经过几次完整的for循环，结果就是几\n      for(int i=0;i<n;i++){\n        string first = mq.front();\n        if(first.find(\"2012\")!=-1) {\n          //cout<<first<<endl;\n          cout<<res<<endl;\n          flag = true;\n          break;\n        }\n        mq.pop();\n\n        //只和后面元素交换，不和前面的交换，会重复\n        //把交换一次后的所有串，都添加到队列中，供下个for循环判断\n        for(int i=0;i<N-1;i++){\n          string strf=first;\n          strf[i]=first[i+1];\n          strf[i+1]=first[i];\n          mq.push(strf);\n        }\n      }\n      \n      if(flag) break;\n      res++;\n    }\n  }\n  return 0;\n}\n```\n\n\n------\n","source":"_posts/NowCoder/NowCoder-玛雅人的密码.md","raw":"---\ntitle: NowCoder-玛雅人的密码\ntags:\n  - NowCoder\n  - Algorithm\n  - BFS\n  - Recursive\n  - Medium\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-17 21:02:23\nurlname: maya-code\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/761fc1e2f03742c2aa929c19ba96dbb0?tpId=40&tqId=21343&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n玛雅人有一种密码，如果字符串中出现连续的2012四个数字就能解开密码。给一个长度为N的字符串，（2=\\<N\\<=13）该字符串中只含有0,1,2三种数字，问这个字符串要移位几次才能解开密码，每次只能移动相邻的两个数字。例如02120经过一次移位，可以得到20120,01220,02210,02102，其中20120符合要求，因此输出为1.如果无论移位多少次都解不开密码，输出-1。\n### Examples:\n**Input:**\n输入包含多组测试数据，每组测试数据由两行组成。\n第一行为一个整数N，代表字符串的长度（2<=N<=13）。\n第二行为一个仅由0、1、2组成的，长度为N的字符串。\n**Output:**\n对于每组测试数据，若可以解出密码，输出最少的移位次数；否则输出-1。\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 看到这种要求最少怎么怎么样，最低什么什么的，一般可以先考虑BFS\n- 可以用队列完成BFS\n\n\n## C++ Codes\n\n```C++\n/*\n * 玛雅人的密码，每次只能移动相邻的两个数字，问最低移动多少次才可以得到要的数字\n * 尝试1：BFS\n */\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint main(){\n  int N;\n  string code;\n  while(cin>>N>>code){\n    auto pos2 = code.find_first_of(\"2\");\n    auto pos22 = code.find_last_of(\"2\");\n    //条件判断\n    if(N<4 || pos2==-1 || pos22==-1 || pos2 == pos22 || code.find(\"0\")==-1 || code.find(\"1\")==-1) {\n      cout<<-1<<endl;\n      continue;\n    }\n\n    //使用队列完成BFS\n    queue<string> mq;\n    mq.push(code);\n    int res = 0;\n    bool flag = false;  //是否找到的标志\n    while(!mq.empty()){\n      int n = mq.size();\n      //这个for循环代表一次，经过几次完整的for循环，结果就是几\n      for(int i=0;i<n;i++){\n        string first = mq.front();\n        if(first.find(\"2012\")!=-1) {\n          //cout<<first<<endl;\n          cout<<res<<endl;\n          flag = true;\n          break;\n        }\n        mq.pop();\n\n        //只和后面元素交换，不和前面的交换，会重复\n        //把交换一次后的所有串，都添加到队列中，供下个for循环判断\n        for(int i=0;i<N-1;i++){\n          string strf=first;\n          strf[i]=first[i+1];\n          strf[i+1]=first[i];\n          mq.push(strf);\n        }\n      }\n      \n      if(flag) break;\n      res++;\n    }\n  }\n  return 0;\n}\n```\n\n\n------\n","slug":"NowCoder/NowCoder-玛雅人的密码","published":1,"updated":"2019-09-21T07:30:01.173Z","layout":"post","photos":[],"link":"","_id":"ck2424lv10094lksbwttuwkab","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/761fc1e2f03742c2aa929c19ba96dbb0?tpId=40&amp;tqId=21343&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>玛雅人有一种密码，如果字符串中出现连续的2012四个数字就能解开密码。给一个长度为N的字符串，（2=\\&lt;N\\&lt;=13）该字符串中只含有0,1,2三种数字，问这个字符串要移位几次才能解开密码，每次只能移动相邻的两个数字。例如02120经过一次移位，可以得到20120,01220,02210,02102，其中20120符合要求，因此输出为1.如果无论移位多少次都解不开密码，输出-1。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>输入包含多组测试数据，每组测试数据由两行组成。<br>第一行为一个整数N，代表字符串的长度（2&lt;=N&lt;=13）。<br>第二行为一个仅由0、1、2组成的，长度为N的字符串。<br><strong>Output:</strong><br>对于每组测试数据，若可以解出密码，输出最少的移位次数；否则输出-1。</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>看到这种要求最少怎么怎么样，最低什么什么的，一般可以先考虑BFS</li><li>可以用队列完成BFS</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 玛雅人的密码，每次只能移动相邻的两个数字，问最低移动多少次才可以得到要的数字</span></span><br><span class=\"line\"><span class=\"comment\"> * 尝试1：BFS</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> N;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> code;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;N&gt;&gt;code)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> pos2 = code.find_first_of(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> pos22 = code.find_last_of(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//条件判断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(N&lt;<span class=\"number\">4</span> || pos2==<span class=\"number\">-1</span> || pos22==<span class=\"number\">-1</span> || pos2 == pos22 || code.find(<span class=\"string\">\"0\"</span>)==<span class=\"number\">-1</span> || code.find(<span class=\"string\">\"1\"</span>)==<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用队列完成BFS</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"built_in\">string</span>&gt; mq;</span><br><span class=\"line\">    mq.push(code);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;  <span class=\"comment\">//是否找到的标志</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!mq.empty())&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> n = mq.size();</span><br><span class=\"line\">      <span class=\"comment\">//这个for循环代表一次，经过几次完整的for循环，结果就是几</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> first = mq.front();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first.find(<span class=\"string\">\"2012\"</span>)!=<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//cout&lt;&lt;first&lt;&lt;endl;</span></span><br><span class=\"line\">          <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">          flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mq.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//只和后面元素交换，不和前面的交换，会重复</span></span><br><span class=\"line\">        <span class=\"comment\">//把交换一次后的所有串，都添加到队列中，供下个for循环判断</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">          <span class=\"built_in\">string</span> strf=first;</span><br><span class=\"line\">          strf[i]=first[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">          strf[i+<span class=\"number\">1</span>]=first[i];</span><br><span class=\"line\">          mq.push(strf);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      res++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/761fc1e2f03742c2aa929c19ba96dbb0?tpId=40&amp;tqId=21343&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>玛雅人有一种密码，如果字符串中出现连续的2012四个数字就能解开密码。给一个长度为N的字符串，（2=\\&lt;N\\&lt;=13）该字符串中只含有0,1,2三种数字，问这个字符串要移位几次才能解开密码，每次只能移动相邻的两个数字。例如02120经过一次移位，可以得到20120,01220,02210,02102，其中20120符合要求，因此输出为1.如果无论移位多少次都解不开密码，输出-1。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>输入包含多组测试数据，每组测试数据由两行组成。<br>第一行为一个整数N，代表字符串的长度（2&lt;=N&lt;=13）。<br>第二行为一个仅由0、1、2组成的，长度为N的字符串。<br><strong>Output:</strong><br>对于每组测试数据，若可以解出密码，输出最少的移位次数；否则输出-1。</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>看到这种要求最少怎么怎么样，最低什么什么的，一般可以先考虑BFS</li><li>可以用队列完成BFS</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 玛雅人的密码，每次只能移动相邻的两个数字，问最低移动多少次才可以得到要的数字</span></span><br><span class=\"line\"><span class=\"comment\"> * 尝试1：BFS</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> N;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> code;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;N&gt;&gt;code)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> pos2 = code.find_first_of(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> pos22 = code.find_last_of(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//条件判断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(N&lt;<span class=\"number\">4</span> || pos2==<span class=\"number\">-1</span> || pos22==<span class=\"number\">-1</span> || pos2 == pos22 || code.find(<span class=\"string\">\"0\"</span>)==<span class=\"number\">-1</span> || code.find(<span class=\"string\">\"1\"</span>)==<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用队列完成BFS</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"built_in\">string</span>&gt; mq;</span><br><span class=\"line\">    mq.push(code);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;  <span class=\"comment\">//是否找到的标志</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!mq.empty())&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> n = mq.size();</span><br><span class=\"line\">      <span class=\"comment\">//这个for循环代表一次，经过几次完整的for循环，结果就是几</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> first = mq.front();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first.find(<span class=\"string\">\"2012\"</span>)!=<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//cout&lt;&lt;first&lt;&lt;endl;</span></span><br><span class=\"line\">          <span class=\"built_in\">cout</span>&lt;&lt;res&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">          flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mq.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//只和后面元素交换，不和前面的交换，会重复</span></span><br><span class=\"line\">        <span class=\"comment\">//把交换一次后的所有串，都添加到队列中，供下个for循环判断</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">          <span class=\"built_in\">string</span> strf=first;</span><br><span class=\"line\">          strf[i]=first[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">          strf[i+<span class=\"number\">1</span>]=first[i];</span><br><span class=\"line\">          mq.push(strf);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      res++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"NowCoder-大数阶乘","comments":1,"mathjax":false,"date":"2019-09-21T15:47:25.000Z","urlname":"factorial-of-bignumber","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/f54d8e6de61e4efb8cce3eebfd0e0daa?tpId=40&tqId=21355&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n输入一个正整数N，输出N的阶乘。0\\<=N\\<=1000\n\n### Examples:\n**Input:**\n> 4\n> 15\n \n**Output:**\n> 24\n> 1307674368000\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 因为数字太大可能超出long long表示范围，所以用大正数乘法做\n- 乘的过程有点不太一样，看代码\n\n\n## C++ Codes\n\n```C++\n#include<stdio.h>\n#define width 3000\n\nint main()\n{\n    //i,j: 循环变量\n    int i,j;\n\n    //k: 上一次进位,t: 最高位下标\n    int k,t;\n    int N;\n\n    //存放结果，从d[0]是个位，从低位开始存\n    int d[width];\n\n    //a*b，N是a，b是已经乘好的结果\n    while(scanf(\"%d\",&N)!=EOF)\n    {\n        t=0;                    //t是位数-1\n        //给数组初始化为零\n        for(i=0;i<width;i++)    \n            d[i]=0;\n        d[0]=1;                 //个位初始化为1\n\n        for(i=1;i<=N;i++)       //从1到N进行阶乘\n        {\n            k=0;\n            //这里直接用b的每位数和整个a相乘，而不是b的每位数和a相乘后再加\n            //从个位开始往高位运算\n            for(j=0;j<=t;j++)\n            {\n                int tmp = d[j]*i+k;     //第j位乘以i加上后一位运算得到的k作为tmp\n                k=tmp/10;               //tmp除以10得到k\n                d[j]=tmp%10;            //tmp取余得到运算后第j位的值\n            }\n\n            //由于是直接和a相乘，所以k可能比较大，不止一位\n            //k!=0说明要向高位进位\n            while(k!=0){\n                d[++t]=k%10;\n                k=k/10;\n            }\n        }\n\n        //从个位开始输出各位数字\n        for(i=t;i>=0;i--)   \n            printf(\"%d\",d[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n\n------\n","source":"_posts/NowCoder/NowCoder-大数阶乘.md","raw":"---\ntitle: NowCoder-大数阶乘\ntags:\n  - NowCoder\n  - Algorithm\n  - Hard\n  - BigNumber\n  - Factorial\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-21 23:47:25\nurlname: factorial-of-bignumber\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/f54d8e6de61e4efb8cce3eebfd0e0daa?tpId=40&tqId=21355&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n输入一个正整数N，输出N的阶乘。0\\<=N\\<=1000\n\n### Examples:\n**Input:**\n> 4\n> 15\n \n**Output:**\n> 24\n> 1307674368000\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 因为数字太大可能超出long long表示范围，所以用大正数乘法做\n- 乘的过程有点不太一样，看代码\n\n\n## C++ Codes\n\n```C++\n#include<stdio.h>\n#define width 3000\n\nint main()\n{\n    //i,j: 循环变量\n    int i,j;\n\n    //k: 上一次进位,t: 最高位下标\n    int k,t;\n    int N;\n\n    //存放结果，从d[0]是个位，从低位开始存\n    int d[width];\n\n    //a*b，N是a，b是已经乘好的结果\n    while(scanf(\"%d\",&N)!=EOF)\n    {\n        t=0;                    //t是位数-1\n        //给数组初始化为零\n        for(i=0;i<width;i++)    \n            d[i]=0;\n        d[0]=1;                 //个位初始化为1\n\n        for(i=1;i<=N;i++)       //从1到N进行阶乘\n        {\n            k=0;\n            //这里直接用b的每位数和整个a相乘，而不是b的每位数和a相乘后再加\n            //从个位开始往高位运算\n            for(j=0;j<=t;j++)\n            {\n                int tmp = d[j]*i+k;     //第j位乘以i加上后一位运算得到的k作为tmp\n                k=tmp/10;               //tmp除以10得到k\n                d[j]=tmp%10;            //tmp取余得到运算后第j位的值\n            }\n\n            //由于是直接和a相乘，所以k可能比较大，不止一位\n            //k!=0说明要向高位进位\n            while(k!=0){\n                d[++t]=k%10;\n                k=k/10;\n            }\n        }\n\n        //从个位开始输出各位数字\n        for(i=t;i>=0;i--)   \n            printf(\"%d\",d[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n\n------\n","slug":"NowCoder/NowCoder-大数阶乘","published":1,"updated":"2019-09-21T16:25:39.809Z","layout":"post","photos":[],"link":"","_id":"ck2424lv20097lksb0kupucym","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/f54d8e6de61e4efb8cce3eebfd0e0daa?tpId=40&amp;tqId=21355&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>输入一个正整数N，输出N的阶乘。0\\&lt;=N\\&lt;=1000</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>4<br>15</p></blockquote><p><strong>Output:</strong></p><blockquote><p>24<br>1307674368000</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>因为数字太大可能超出long long表示范围，所以用大正数乘法做</li><li>乘的过程有点不太一样，看代码</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> width 3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//i,j: 循环变量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//k: 上一次进位,t: 最高位下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k,t;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> N;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//存放结果，从d[0]是个位，从低位开始存</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> d[width];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//a*b，N是a，b是已经乘好的结果</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;N)!=EOF)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        t=<span class=\"number\">0</span>;                    <span class=\"comment\">//t是位数-1</span></span><br><span class=\"line\">        <span class=\"comment\">//给数组初始化为零</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;width;i++)    </span><br><span class=\"line\">            d[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        d[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;                 <span class=\"comment\">//个位初始化为1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=N;i++)       <span class=\"comment\">//从1到N进行阶乘</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            k=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">//这里直接用b的每位数和整个a相乘，而不是b的每位数和a相乘后再加</span></span><br><span class=\"line\">            <span class=\"comment\">//从个位开始往高位运算</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>;j&lt;=t;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp = d[j]*i+k;     <span class=\"comment\">//第j位乘以i加上后一位运算得到的k作为tmp</span></span><br><span class=\"line\">                k=tmp/<span class=\"number\">10</span>;               <span class=\"comment\">//tmp除以10得到k</span></span><br><span class=\"line\">                d[j]=tmp%<span class=\"number\">10</span>;            <span class=\"comment\">//tmp取余得到运算后第j位的值</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//由于是直接和a相乘，所以k可能比较大，不止一位</span></span><br><span class=\"line\">            <span class=\"comment\">//k!=0说明要向高位进位</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(k!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                d[++t]=k%<span class=\"number\">10</span>;</span><br><span class=\"line\">                k=k/<span class=\"number\">10</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//从个位开始输出各位数字</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=t;i&gt;=<span class=\"number\">0</span>;i--)   </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,d[i]);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/f54d8e6de61e4efb8cce3eebfd0e0daa?tpId=40&amp;tqId=21355&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>输入一个正整数N，输出N的阶乘。0\\&lt;=N\\&lt;=1000</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>4<br>15</p></blockquote><p><strong>Output:</strong></p><blockquote><p>24<br>1307674368000</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>因为数字太大可能超出long long表示范围，所以用大正数乘法做</li><li>乘的过程有点不太一样，看代码</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> width 3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//i,j: 循环变量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//k: 上一次进位,t: 最高位下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k,t;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> N;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//存放结果，从d[0]是个位，从低位开始存</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> d[width];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//a*b，N是a，b是已经乘好的结果</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;N)!=EOF)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        t=<span class=\"number\">0</span>;                    <span class=\"comment\">//t是位数-1</span></span><br><span class=\"line\">        <span class=\"comment\">//给数组初始化为零</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;width;i++)    </span><br><span class=\"line\">            d[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        d[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;                 <span class=\"comment\">//个位初始化为1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=N;i++)       <span class=\"comment\">//从1到N进行阶乘</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            k=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">//这里直接用b的每位数和整个a相乘，而不是b的每位数和a相乘后再加</span></span><br><span class=\"line\">            <span class=\"comment\">//从个位开始往高位运算</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>;j&lt;=t;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp = d[j]*i+k;     <span class=\"comment\">//第j位乘以i加上后一位运算得到的k作为tmp</span></span><br><span class=\"line\">                k=tmp/<span class=\"number\">10</span>;               <span class=\"comment\">//tmp除以10得到k</span></span><br><span class=\"line\">                d[j]=tmp%<span class=\"number\">10</span>;            <span class=\"comment\">//tmp取余得到运算后第j位的值</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//由于是直接和a相乘，所以k可能比较大，不止一位</span></span><br><span class=\"line\">            <span class=\"comment\">//k!=0说明要向高位进位</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(k!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                d[++t]=k%<span class=\"number\">10</span>;</span><br><span class=\"line\">                k=k/<span class=\"number\">10</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//从个位开始输出各位数字</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=t;i&gt;=<span class=\"number\">0</span>;i--)   </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,d[i]);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"NowCoder-约数个数","comments":1,"mathjax":false,"date":"2019-09-12T11:12:10.000Z","urlname":"nowcoder-gcd-numbers","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/04c8a5ea209d41798d23b59f053fa4d6?tpId=40&tqId=21334&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)   \n输入n个整数,依次输出每个数的约数的个数\n\n### Examples:\n**Input:**   \n输入的第一行为N，即数组的个数(N<=1000)\n接下来的1行包括N个整数，其中每个数的范围为(1<=Num<=1000000000)\n当N=0时输入结束。\n**Output:**  \n可能有多组输入数据，对于每组输入数据，\n输出N行，其中每一行对应上面的一个数的约数的个数。\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 直接求每个数的约数就完了\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint approNums(int num){\n  int res = 0;\n  int sq = sqrt(num);\n  for(int i=1;i<=sq;i++){\n    if(num/i*i==num){\n      res+=2;\n      if(i*i==num) res-=1;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  int nums[1000];\n  int res[1000];\n  while(cin>>N && N!=0){\n    for(int i=0;i<N;i++) cin>>nums[i];\n    for(int i=0;i<N;i++){\n      res[i]=approNums(nums[i]);\n    }\n    for(int i=0;i<N;i++)\n      cout<<res[i]<<endl;\n  }\n  return 0;\n```\n\n\n------\n","source":"_posts/NowCoder/NowCoder-约数个数.md","raw":"---\ntitle: NowCoder-约数个数\ntags:\n  - NowCoder\n  - Algorithm\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-12 19:12:10\nurlname: nowcoder-gcd-numbers\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/04c8a5ea209d41798d23b59f053fa4d6?tpId=40&tqId=21334&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)   \n输入n个整数,依次输出每个数的约数的个数\n\n### Examples:\n**Input:**   \n输入的第一行为N，即数组的个数(N<=1000)\n接下来的1行包括N个整数，其中每个数的范围为(1<=Num<=1000000000)\n当N=0时输入结束。\n**Output:**  \n可能有多组输入数据，对于每组输入数据，\n输出N行，其中每一行对应上面的一个数的约数的个数。\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 直接求每个数的约数就完了\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint approNums(int num){\n  int res = 0;\n  int sq = sqrt(num);\n  for(int i=1;i<=sq;i++){\n    if(num/i*i==num){\n      res+=2;\n      if(i*i==num) res-=1;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  int nums[1000];\n  int res[1000];\n  while(cin>>N && N!=0){\n    for(int i=0;i<N;i++) cin>>nums[i];\n    for(int i=0;i<N;i++){\n      res[i]=approNums(nums[i]);\n    }\n    for(int i=0;i<N;i++)\n      cout<<res[i]<<endl;\n  }\n  return 0;\n```\n\n\n------\n","slug":"NowCoder/NowCoder-约数个数","published":1,"updated":"2019-09-12T11:15:12.602Z","layout":"post","photos":[],"link":"","_id":"ck2424lv4009blksbr9m1l0ip","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/04c8a5ea209d41798d23b59f053fa4d6?tpId=40&amp;tqId=21334&amp;tPage=1&amp;rp=1&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>输入n个整数,依次输出每个数的约数的个数</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>输入的第一行为N，即数组的个数(N&lt;=1000)<br>接下来的1行包括N个整数，其中每个数的范围为(1&lt;=Num&lt;=1000000000)<br>当N=0时输入结束。<br><strong>Output:</strong><br>可能有多组输入数据，对于每组输入数据，<br>输出N行，其中每一行对应上面的一个数的约数的个数。</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>直接求每个数的约数就完了</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">approNums</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sq = <span class=\"built_in\">sqrt</span>(num);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=sq;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(num/i*i==num)&#123;</span><br><span class=\"line\">      res+=<span class=\"number\">2</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i*i==num) res-=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> N;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> nums[<span class=\"number\">1000</span>];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> res[<span class=\"number\">1000</span>];</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;N &amp;&amp; N!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++) <span class=\"built_in\">cin</span>&gt;&gt;nums[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">      res[i]=approNums(nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)</span><br><span class=\"line\">      <span class=\"built_in\">cout</span>&lt;&lt;res[i]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/04c8a5ea209d41798d23b59f053fa4d6?tpId=40&amp;tqId=21334&amp;tPage=1&amp;rp=1&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>输入n个整数,依次输出每个数的约数的个数</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>输入的第一行为N，即数组的个数(N&lt;=1000)<br>接下来的1行包括N个整数，其中每个数的范围为(1&lt;=Num&lt;=1000000000)<br>当N=0时输入结束。<br><strong>Output:</strong><br>可能有多组输入数据，对于每组输入数据，<br>输出N行，其中每一行对应上面的一个数的约数的个数。</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>直接求每个数的约数就完了</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">approNums</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sq = <span class=\"built_in\">sqrt</span>(num);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=sq;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(num/i*i==num)&#123;</span><br><span class=\"line\">      res+=<span class=\"number\">2</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i*i==num) res-=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> N;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> nums[<span class=\"number\">1000</span>];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> res[<span class=\"number\">1000</span>];</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;N &amp;&amp; N!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++) <span class=\"built_in\">cin</span>&gt;&gt;nums[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">      res[i]=approNums(nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)</span><br><span class=\"line\">      <span class=\"built_in\">cout</span>&lt;&lt;res[i]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"NowCoder-最大序列和","comments":1,"mathjax":false,"date":"2019-09-21T15:16:25.000Z","urlname":"max-sum-of-sequence","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/df219d60a7af4171a981ef56bd597f7b?tpId=40&tqId=21353&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n给出一个整数序列S，其中有N个数，定义其中一个非空连续子序列T中所有数的和为T的“序列和”。 对于S的所有非空连续子序列T，求最大的序列和。 变量条件：N为正整数，N≤1000000，结果序列和在范围（-2^63,2^63-1）以内。\n\n输入第一行为一个正整数N，第二行为N个整数，表示序列中的数。\n\n输入可能包括多组数据，对于每一组输入数据，\n仅输出一个数，表示最大序列和。\n\n### Examples:\n**Input:**\n> 5\n> 1 5 -3 2 4\n \n**Output:**\n> 9\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 经典的动态规划问题，状态转移方程是dp[i] = max(A[i], dp[i-1] + A[i])\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define ll long long\nll  S[1000002];\nll dp[1000002];\n\nint main(){\n    int N;\n    while(cin>>N){\n        for(int i=1;i<=N;i++){\n            cin>>S[i];\n        }\n        dp[0]=0;\n        for(int i=1;i<=N;i++){\n            if(dp[i-1]<=0){\n                dp[i]=S[i];\n            }else{\n                dp[i]=dp[i-1]+S[i];\n            }\n        }\n        ll maxs=dp[1];\n        for(int i=2;i<=N;i++){\n            if(dp[i]>maxs) maxs = dp[i];\n        }\n        cout<<maxs<<endl;\n    }\n    return 0;\n}\n\n```\n\n## 总结\n- dp[i-1]如果小于0, 那就从A[i]开始重新算序列和 \n- 延伸可以看最大子矩阵和\n\n------\n","source":"_posts/NowCoder/NowCoder-最大序列和.md","raw":"---\ntitle: NowCoder-最大序列和\ntags:\n  - NowCoder\n  - Algorithm\n  - DP\n  - Medium\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-21 23:16:25\nurlname: max-sum-of-sequence\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/df219d60a7af4171a981ef56bd597f7b?tpId=40&tqId=21353&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n给出一个整数序列S，其中有N个数，定义其中一个非空连续子序列T中所有数的和为T的“序列和”。 对于S的所有非空连续子序列T，求最大的序列和。 变量条件：N为正整数，N≤1000000，结果序列和在范围（-2^63,2^63-1）以内。\n\n输入第一行为一个正整数N，第二行为N个整数，表示序列中的数。\n\n输入可能包括多组数据，对于每一组输入数据，\n仅输出一个数，表示最大序列和。\n\n### Examples:\n**Input:**\n> 5\n> 1 5 -3 2 4\n \n**Output:**\n> 9\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 经典的动态规划问题，状态转移方程是dp[i] = max(A[i], dp[i-1] + A[i])\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define ll long long\nll  S[1000002];\nll dp[1000002];\n\nint main(){\n    int N;\n    while(cin>>N){\n        for(int i=1;i<=N;i++){\n            cin>>S[i];\n        }\n        dp[0]=0;\n        for(int i=1;i<=N;i++){\n            if(dp[i-1]<=0){\n                dp[i]=S[i];\n            }else{\n                dp[i]=dp[i-1]+S[i];\n            }\n        }\n        ll maxs=dp[1];\n        for(int i=2;i<=N;i++){\n            if(dp[i]>maxs) maxs = dp[i];\n        }\n        cout<<maxs<<endl;\n    }\n    return 0;\n}\n\n```\n\n## 总结\n- dp[i-1]如果小于0, 那就从A[i]开始重新算序列和 \n- 延伸可以看最大子矩阵和\n\n------\n","slug":"NowCoder/NowCoder-最大序列和","published":1,"updated":"2019-09-21T15:26:56.788Z","layout":"post","photos":[],"link":"","_id":"ck2424lv5009elksb9lf1wuul","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/df219d60a7af4171a981ef56bd597f7b?tpId=40&amp;tqId=21353&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>给出一个整数序列S，其中有N个数，定义其中一个非空连续子序列T中所有数的和为T的“序列和”。 对于S的所有非空连续子序列T，求最大的序列和。 变量条件：N为正整数，N≤1000000，结果序列和在范围（-2^63,2^63-1）以内。</p><p>输入第一行为一个正整数N，第二行为N个整数，表示序列中的数。</p><p>输入可能包括多组数据，对于每一组输入数据，<br>仅输出一个数，表示最大序列和。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>5<br>1 5 -3 2 4</p></blockquote><p><strong>Output:</strong></p><blockquote><p>9</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>经典的动态规划问题，状态转移方程是dp[i] = max(A[i], dp[i-1] + A[i])</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\">ll  S[<span class=\"number\">1000002</span>];</span><br><span class=\"line\">ll dp[<span class=\"number\">1000002</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> N;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;N)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;S[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dp[i<span class=\"number\">-1</span>]&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                dp[i]=S[i];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                dp[i]=dp[i<span class=\"number\">-1</span>]+S[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ll maxs=dp[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dp[i]&gt;maxs) maxs = dp[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;maxs&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>dp[i-1]如果小于0, 那就从A[i]开始重新算序列和</li><li>延伸可以看最大子矩阵和</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/df219d60a7af4171a981ef56bd597f7b?tpId=40&amp;tqId=21353&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>给出一个整数序列S，其中有N个数，定义其中一个非空连续子序列T中所有数的和为T的“序列和”。 对于S的所有非空连续子序列T，求最大的序列和。 变量条件：N为正整数，N≤1000000，结果序列和在范围（-2^63,2^63-1）以内。</p><p>输入第一行为一个正整数N，第二行为N个整数，表示序列中的数。</p><p>输入可能包括多组数据，对于每一组输入数据，<br>仅输出一个数，表示最大序列和。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>5<br>1 5 -3 2 4</p></blockquote><p><strong>Output:</strong></p><blockquote><p>9</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>经典的动态规划问题，状态转移方程是dp[i] = max(A[i], dp[i-1] + A[i])</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\">ll  S[<span class=\"number\">1000002</span>];</span><br><span class=\"line\">ll dp[<span class=\"number\">1000002</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> N;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;N)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;S[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dp[i<span class=\"number\">-1</span>]&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                dp[i]=S[i];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                dp[i]=dp[i<span class=\"number\">-1</span>]+S[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ll maxs=dp[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dp[i]&gt;maxs) maxs = dp[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;maxs&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>dp[i-1]如果小于0, 那就从A[i]开始重新算序列和</li><li>延伸可以看最大子矩阵和</li></ul><hr><!-- rebuild by neat -->"},{"title":"NowCoder-递推数列","comments":1,"mathjax":false,"date":"2019-09-21T14:49:29.000Z","urlname":"recursive-sequence","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/d0e751eac618463bb6ac447369e4aa25?tpId=40&tqId=21352&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n给定a0,a1,以及an=p\\*a(n-1) + q\\*a(n-2)中的p,q。这里n >= 2。 求第k个数对10000的模。\n\n输入包括5个整数：a0、a1、p、q、k。\n\n输出第k个数a(k)对10000的模。\n\n### Examples:\n**Input:**\n> 20 1 1 14 5\n\n**Output:**\n> 8359\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- \n\n\n## C++ Codes\n\n```C++\n\n```\n\n## 总结\n- \n\n------\n","source":"_posts/NowCoder/NowCoder-递推数列.md","raw":"---\ntitle: NowCoder-递推数列\ntags:\n  - NowCoder\n  - Algorithm\n  - Easy\n  - Array\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-21 22:49:29\nurlname: recursive-sequence\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/d0e751eac618463bb6ac447369e4aa25?tpId=40&tqId=21352&tPage=1&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n给定a0,a1,以及an=p\\*a(n-1) + q\\*a(n-2)中的p,q。这里n >= 2。 求第k个数对10000的模。\n\n输入包括5个整数：a0、a1、p、q、k。\n\n输出第k个数a(k)对10000的模。\n\n### Examples:\n**Input:**\n> 20 1 1 14 5\n\n**Output:**\n> 8359\n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- \n\n\n## C++ Codes\n\n```C++\n\n```\n\n## 总结\n- \n\n------\n","slug":"NowCoder/NowCoder-递推数列","published":1,"updated":"2019-09-21T15:13:56.419Z","layout":"post","photos":[],"link":"","_id":"ck2424lv7009glksb4e7orh1y","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/d0e751eac618463bb6ac447369e4aa25?tpId=40&amp;tqId=21352&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>给定a0,a1,以及an=p*a(n-1) + q*a(n-2)中的p,q。这里n &gt;= 2。 求第k个数对10000的模。</p><p>输入包括5个整数：a0、a1、p、q、k。</p><p>输出第k个数a(k)对10000的模。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>20 1 1 14 5</p></blockquote><p><strong>Output:</strong></p><blockquote><p>8359</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li></li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li></li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/d0e751eac618463bb6ac447369e4aa25?tpId=40&amp;tqId=21352&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>给定a0,a1,以及an=p*a(n-1) + q*a(n-2)中的p,q。这里n &gt;= 2。 求第k个数对10000的模。</p><p>输入包括5个整数：a0、a1、p、q、k。</p><p>输出第k个数a(k)对10000的模。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>20 1 1 14 5</p></blockquote><p><strong>Output:</strong></p><blockquote><p>8359</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li></li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li></li></ul><hr><!-- rebuild by neat -->"},{"title":"NowCoder-质因数个数","comments":1,"mathjax":false,"date":"2019-09-17T02:23:31.000Z","urlname":"number-prime-factor","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/20426b85f7fc4ba8b0844cc04807fbd9?tpId=40&tqId=21338&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)   \n补之前的\n\n求正整数N(N>1)的质因数的个数。 相同的质因数需要重复计算。如120=2*2*2*3*5，共有5个质因数。\n\n### Examples:\n**Input:**\n可能有多组测试数据，每组测试数据的输入是一个正整数N，(1\\<N\\<10^9)。\n**Output:**\n对于每组数据，输出N的质因数的个数。\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 先计算素数，然后找因数\n\n\n## C++ Codes\n\n```C++\n/*\n * 素数筛\n * 计算处sqrt(n)以内的素数\n * 最后的部分是一个比sqrt(n)大的素数，个数加1即可\n */\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define MAXN 100000\nint prime[MAXN];\nbool valid[MAXN];\n\n//素数筛，返回1-num以内素数个数并存在pr数组内\nint getPrime(int *pr, int num){\n  int res = 0;\n  memset(valid, true, sizeof(valid));\n  for(int i=2;i<=num;i++){\n    if(valid[i]) pr[res++]=i;\n\n    for(int j=0;j<res;j++){\n      //更新所有素数和当前数乘积为false\n      if(pr[j]*i>num)break;\n      valid[pr[j]*i]=false;\n\n      //如果是已知素数的倍数，就break；\n      if(i%pr[j]==0) break;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int sumCnt = getPrime(prime, MAXN);\n  int n;\n  while(cin>>n){\n    int cnt = 0;\n    int sq = sqrt(n);\n    for(int i=0;i<sumCnt;i++){\n      if(prime[i]>sq) break;\n      while(n%prime[i]==0){\n        cnt++;\n        n/=prime[i];\n      }\n    }\n    if(n>1) cnt++;\n    cout<<cnt<<endl;\n  }\n\n}\n```\n\n## 总结\n- 素数筛还是要会的，几种筛法 \n\n------\n","source":"_posts/NowCoder/NowCoder-质因数个数.md","raw":"---\ntitle: NowCoder-质因数个数\ntags:\n  - NowCoder\n  - Algorithm\n  - Easy\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-17 10:23:31\nurlname: number-prime-factor\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/20426b85f7fc4ba8b0844cc04807fbd9?tpId=40&tqId=21338&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)   \n补之前的\n\n求正整数N(N>1)的质因数的个数。 相同的质因数需要重复计算。如120=2*2*2*3*5，共有5个质因数。\n\n### Examples:\n**Input:**\n可能有多组测试数据，每组测试数据的输入是一个正整数N，(1\\<N\\<10^9)。\n**Output:**\n对于每组数据，输出N的质因数的个数。\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 先计算素数，然后找因数\n\n\n## C++ Codes\n\n```C++\n/*\n * 素数筛\n * 计算处sqrt(n)以内的素数\n * 最后的部分是一个比sqrt(n)大的素数，个数加1即可\n */\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define MAXN 100000\nint prime[MAXN];\nbool valid[MAXN];\n\n//素数筛，返回1-num以内素数个数并存在pr数组内\nint getPrime(int *pr, int num){\n  int res = 0;\n  memset(valid, true, sizeof(valid));\n  for(int i=2;i<=num;i++){\n    if(valid[i]) pr[res++]=i;\n\n    for(int j=0;j<res;j++){\n      //更新所有素数和当前数乘积为false\n      if(pr[j]*i>num)break;\n      valid[pr[j]*i]=false;\n\n      //如果是已知素数的倍数，就break；\n      if(i%pr[j]==0) break;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int sumCnt = getPrime(prime, MAXN);\n  int n;\n  while(cin>>n){\n    int cnt = 0;\n    int sq = sqrt(n);\n    for(int i=0;i<sumCnt;i++){\n      if(prime[i]>sq) break;\n      while(n%prime[i]==0){\n        cnt++;\n        n/=prime[i];\n      }\n    }\n    if(n>1) cnt++;\n    cout<<cnt<<endl;\n  }\n\n}\n```\n\n## 总结\n- 素数筛还是要会的，几种筛法 \n\n------\n","slug":"NowCoder/NowCoder-质因数个数","published":1,"updated":"2019-09-17T02:27:47.413Z","layout":"post","photos":[],"link":"","_id":"ck2424lv8009jlksbvykhhxyr","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/20426b85f7fc4ba8b0844cc04807fbd9?tpId=40&amp;tqId=21338&amp;tPage=1&amp;rp=1&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>求正整数N(N&gt;1)的质因数的个数。 相同的质因数需要重复计算。如120=2<em>2</em>2<em>3</em>5，共有5个质因数。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>可能有多组测试数据，每组测试数据的输入是一个正整数N，(1\\&lt;N\\&lt;10^9)。<br><strong>Output:</strong><br>对于每组数据，输出N的质因数的个数。</p></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>先计算素数，然后找因数</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 素数筛</span></span><br><span class=\"line\"><span class=\"comment\"> * 计算处sqrt(n)以内的素数</span></span><br><span class=\"line\"><span class=\"comment\"> * 最后的部分是一个比sqrt(n)大的素数，个数加1即可</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100000</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> prime[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> valid[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//素数筛，返回1-num以内素数个数并存在pr数组内</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> *pr, <span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(valid, <span class=\"literal\">true</span>, <span class=\"keyword\">sizeof</span>(valid));</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=num;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(valid[i]) pr[res++]=i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;res;j++)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//更新所有素数和当前数乘积为false</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(pr[j]*i&gt;num)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      valid[pr[j]*i]=<span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//如果是已知素数的倍数，就break；</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i%pr[j]==<span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sumCnt = getPrime(prime, MAXN);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sq = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;sumCnt;i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(prime[i]&gt;sq) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(n%prime[i]==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        n/=prime[i];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&gt;<span class=\"number\">1</span>) cnt++;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;cnt&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>素数筛还是要会的，几种筛法</li></ul><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/20426b85f7fc4ba8b0844cc04807fbd9?tpId=40&amp;tqId=21338&amp;tPage=1&amp;rp=1&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan/question-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>求正整数N(N&gt;1)的质因数的个数。 相同的质因数需要重复计算。如120=2<em>2</em>2<em>3</em>5，共有5个质因数。</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong><br>可能有多组测试数据，每组测试数据的输入是一个正整数N，(1\\&lt;N\\&lt;10^9)。<br><strong>Output:</strong><br>对于每组数据，输出N的质因数的个数。</p></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>先计算素数，然后找因数</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 素数筛</span></span><br><span class=\"line\"><span class=\"comment\"> * 计算处sqrt(n)以内的素数</span></span><br><span class=\"line\"><span class=\"comment\"> * 最后的部分是一个比sqrt(n)大的素数，个数加1即可</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100000</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> prime[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> valid[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//素数筛，返回1-num以内素数个数并存在pr数组内</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> *pr, <span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(valid, <span class=\"literal\">true</span>, <span class=\"keyword\">sizeof</span>(valid));</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=num;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(valid[i]) pr[res++]=i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;res;j++)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//更新所有素数和当前数乘积为false</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(pr[j]*i&gt;num)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      valid[pr[j]*i]=<span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//如果是已知素数的倍数，就break；</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i%pr[j]==<span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sumCnt = getPrime(prime, MAXN);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;n)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sq = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;sumCnt;i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(prime[i]&gt;sq) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(n%prime[i]==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        n/=prime[i];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&gt;<span class=\"number\">1</span>) cnt++;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;cnt&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul><li>素数筛还是要会的，几种筛法</li></ul><hr><!-- rebuild by neat -->"},{"title":"RNAi和siRNA设计基础","comments":1,"mathjax":false,"date":"2019-10-01T10:40:22.000Z","urlname":"basic-knowledge-of-RNAi","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n刚接触siRNA搜索、设计和评测这方面的研究，记录一下基本的概念和一些基础知识，还有自己的理解总结。\n{% endnote %}\n<!--more-->\n\n## 基础概念\n### 英文缩写\n1. RNAi：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RNA干扰\n1. siRNA：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小干扰RNA\n1. dsRNA：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Double-stranded RNA的缩写，是指双链核糖核酸\n1. [shRNA](https://baike.baidu.com/item/shRNA)：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是英文单词short hairpin RNA的缩写。翻译为“短发夹RNA”。shRNA包括两个短反向重复序列。克隆到shRNA表达载体中的shRNA包括两个短反向重复序列，中间由一茎环（loop）序列分隔的，组成发夹结构，由polⅢ启动子控制。随后再连上5-6个T作为RNA聚合酶Ⅲ的转录终止子。\n1. Argonaute (AGO)：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一类庞大的蛋白质家族，是组成RISCs复合物的主要成员。AGO蛋白质主要包含两个结构域：PAZ和PIWI两个结构域，但具体功能现在尚不清楚。\n1.  Dicer酶：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是RNAase Ⅲ家族中的一员，主要切割dsRNA或者茎环结构的RNA前体成为小RNAs分子。对应地，我们将这种小RNAs分子命名为siRNAs和miRNA。Dicer有着较多的结构域，最先在果蝇中发现，并且在不同的生物体上表现出很高的保守性。\n\n1. RISC：RISC诱导沉默复合体（全称：RNA-induced silencing complex）：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种由siRNA与Argonaute蛋白和Dicer酶复合形成的复合物。在RNAi中，利用siRNA的反义链切割靶mRNA，达到基因沉默。\n\n1. BLAST (Basic Local Alignment Search Tool)：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是一套在蛋白质数据库或DNA数据库中进行相似性比较的分析工具。BLAST程序能迅速与公开数据库进行相似性序列比较。BLAST结果中的得分是对一种对相似性的统计说明。\n\n1. rRNA（核糖体RNA）是核糖体的组成成分,它和蛋白质共同组成了核糖体.  \ntRNA（转运RNA）可以转运氨基酸.\nmRNA（信使RNA）是由细胞核内的DNA转录来的,相当于蛋白质的设计图纸.\n\n1. UTR：非翻译区\n\n1. [SD序列](http://www.baike.com/wiki/SD%E5%BA%8F%E5%88%97)：mRNA起始部位的碱基序列，为mRNA与核糖体的结合位点称SD序列.在DNA上相应的位点也称SD序列，一般位于操纵基因和第一个结构基因之间，部分序列与操纵基因重叠.\n\n\n### 名词概念\n1. 质粒：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小型环状DNA分子，包括三部分：遗传标记基因，复制区，目的基因.在所有的细菌类群中都可发现，它们是独立于细菌染色体外自我复制的DNA分子\n1. 质粒载体：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;质粒载体是在天然质粒的基础上为适应实验室操作而进行人工构建的质粒。与天然质粒相比，质粒载体通常带有一个或一个以上的选择性标记基因（如抗生素抗性基因）和一个人工合成的含有多个限制性内切酶识别位点的多克隆位点序列，并去掉了大部分非必需序列，使分子量尽可能减少，以便于基因工程操作\n\n1. 转染：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是真核细胞主动或被动导入外源DNA片段而获得新的表型的过程\n\n1. 细胞株：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过选择法或克隆形成法从原代培养物或细胞系中获得具有特殊性质或标志物的培养物称为细胞株。    \n细胞株是用单细胞分离培养或通过筛选的方法，由单细胞增殖形成的细胞群。细胞株的特殊性质或标志必须在整个培养期间始终存在。原代培养物经首次传代成功后即为细胞系(cell line)， 由原先存在于原代培养物中的细胞世系所组成。如果不能继续传代，或传代次数有限， 可称为有限细胞系(finite cell line)， 如可以连续培养， 则称为连续细胞系(continuous cell line)， 培养50代以上并无限培养下去。 所以细胞株是通过选择法或克隆形成法从原代培养物或细胞系中获得的具有特殊性质或标志的培养细胞。从培养代数来讲，可培养到40-50代。细胞株的特殊性质或标志必须在整个培养期间始终存在。对于人类肿瘤细胞，在体外培养半年以上，生长稳定，并连续传代的即可称为连续性株或系。\n\n1. 核酸酶：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能够将聚核苷酸链的磷酸二酯键切断的酶，称为核酸酶。 有些核酸酶只能作用于RNA，称为核糖核酸酶（RNase），有些核酸酶只能作用于DNA，称为脱氧核糖核酸酶（DNase），有些核酸酶专一性较低，既能作用于RNA也能作用于DNA，因此统称为核酸酶（nuclease）。根据核酸酶作用的位置不同，又可将核酸酶分为核酸外切酶（exonuclease）和核酸内切酶\n\n1. 逆转录病毒：[病毒的分类](https://www.zhihu.com/question/23745748)\n\n1. [DNA中的3'端和5'端](https://www.zhihu.com/question/21112790)\n\n1. 化学修饰：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凡通过化学基团的引入或除去，而使蛋白质或核酸共价结构发生改变的现象。它以引起酶分子共价键的变化、化学结构的改变而影响酶活性。酶的化学修饰是在另一种酶的催化下完成的，是体内快速调节的另一种重要方式。\n\n1. 正义链：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与转录出的mRNA序列相同的（DNA中的T在RNA中为U）那条DNA单链那条链为正义链，与之互补的为反义链。\n\n1. PCR扩增产物：可分为长产物片段和短产物片段两部分。短产物指数倍增加，长产物算术倍增加，所以重复多次后，可以忽略长产物，得到的是目的基因。\n反应体系由模板DNA、一对引物、dNTP、耐高温的DNA聚合酶、酶反应缓冲体系及必须的离子等所组成。PCR反应循环的第一步为加热变性，使双链模板DNA变性为单链；第二步为复性，每个引物将与互补的DNA序列杂交；第三步为延伸，在耐高温的DNA聚合酶作用下，以变性的单链DNA为模板，从引物3ˊ端开始按5ˊ→3ˊ方向合成DNA链。这样经过一个周期的变性——复性——延伸等三步反应就可以产生倍增的DNA，假设PCR的效率为100%,反复n周期后，理论上就能扩增2n倍。PCR反应一般30-40次循环，DNA片段可放大数百万倍。\n见[PCR的扩增产物是什么，怎么扩增出来的](https://zhidao.baidu.com/question/345141221.html)\n\n### 基本单位\n1. 碱基(A，G，C，T，U)：\n&nbsp;&nbsp;&nbsp;&nbsp;DNA有四种碱基对，即鸟嘌呤(G),腺嘌呤(A),胞嘧啶(C),胸腺嘧啶(T).其中G与C配对，A与T配对。RNA有A，G，C，U(尿嘧啶)这四种\n\n1. bp：\n&nbsp;&nbsp;&nbsp;&nbsp; 碱基对的数目单位,100bp即两条链上各有100个碱基.\n\n1. nt：\n&nbsp;&nbsp;&nbsp;&nbsp;核苷酸的单位，25nt RNA是指25个核苷酸碱基的小RNA\n\n\n## RNAi实验相关\n1. 四要素：\n  - 目标基因的dsRNA，看需求\n  - 转染或者将dsRNA送入细胞的方法，具体看下面的三种方法\n  - 对照\n  - 检测表达情况的方法，即检验RNAi效果\n2. 注意点\n  - siRNA长度的选择\n  - shRNA表达水平太高会导致细胞毒性或脱靶，要防止过表达\n3. 三种实现方法\n\n|适用类型| 导入材料|过程 |其他材料| 沉默类型|\n|:-:|:-:|:-:|:-:|:-:|\n|非哺乳生物|dsRNA| 导入dsRNA，使用Dicer酶切割dsRNA得到siRNAs，获得RISC诱导沉默复合体，切割靶mRNA| Dicer酶|瞬时基因沉默3-7天|\n|哺乳生物|siRNAs|直接导入siRNAs，获得RISC，切割靶mRNA|无|瞬时基因沉默3-7天|\n| | shRNA的DNA表达载体| 导入shRNA表达载体，使用Dicer酶切割shRNA，得到siRNAs，后续相同|Dicer酶|长效基因沉默|\n\n## siRNA设计\n### 结构和选择标准\n- 理想siRNA是23bp，双链部分是19bp，正义链和反义链为21bp，3‘端和5’端分别是两个突出核苷酸\n\n|    |5'端|1  | 2 | 3 | 4 | 5...10|11...14|15...18|19 |20|21...23 |3'端|\n| :-:|:-: |:-:|:-:|:-:|:-:|    :-:|:-:    |:-:|:-: |:-: |:-: |:-:|\n|理想状态|第一个核苷酸对沉默作用非必须 |A|A|-|-|-|-|-|-|T|T|UU/TT结尾，抵抗核糖核苷酸酶|\n|有效状态| |-|A|-|-|-|-|-|-|T|T| / |\n|有效状态| |-|A|-|-|-|-||--|-|-| / |\n|选择标准(正义链：3-23，21nt)| |/|/|5. 为A|-|6. 第十位为U |8. 第13位非G|2. 15-19位有3+个A/U碱基对|4. 为A; 7.不能为G/C|-|-| / |\n\n{% note info %}\n正义链：3-23，一般TT结尾\n反义链：1-21的互补链(A-T, C-G)，一般TT开头\n\n反义RNA和靶RNA互补配对，参与基因表达调控。分3类：\n1. 直接和靶mRNA的S-D序列或部分编码区结合，抑制翻译，或者结合成双链RNA被RNA酶Ⅲ降解\n2. 和非编码区结合，引起mRNA构象变化，抑制翻译\n3. 直接抑制mRNA转录\n{% endnote %}\n\n**选择标准：**\n1. G/C含量=30～52%\n1. 在第15 ～19位核苷酸的位置个或更多的A/U碱基对（正义链） \n1. 发夹结构预测（没有内部重或回文结构）Tm<20℃ \n1. 19位核苷酸为A（正义链） \n1. 3位核苷酸为A（正义链） \n1. 10位核苷酸为U（正义链）\n1. 19位核苷酸不能为G或C（正义链） \n1. 13位核苷酸不能为G（正义链）\n\n**符合条件小于6个的舍弃**\n\n{% note danger %}\n1. 如果靶序列开始的两个核苷酸不是AA，选择基因编码区的23个核苷酸来计算G-C的百分含量\n1. 大多数G-C含量为30%-52%的siRNA产生的沉默效应较高，但过高的G-C含量会降低沉默活性\n1. 避免超过3个G/C重复，以及4个A重复，多G/C可能干扰siRNA沉默机制，多A会提前终止转录干扰shRNA合成\n《小干扰RNA的合理设计》中，为2+个G/C降低RNA内在稳定性，3+个U/A可能终止RNA PolymeraseIII介导的转录\n1. 一定要从启动子第100个核苷酸之后开始搜索\n1. 3’-端可以是合适的靶序列，可特异性防止非必要保守基因的沉默\n{% endnote %}\n\n\n### 设计过程\n选择：\n1. 在所选基因的启动子`100个`碱基以后开始自5’-端开始\n2. 寻找基因序列中的23个碱基， 最好是5‘- AA（N19）TT -3’ （N是任何碱基）\n3. 如果找不到以上AA（N19）TT，则用 AA（N21）补足。\n4. 如果找不到以上AA（N21）， 则用 NA（N21）补足。\n5. 所选定序列中，G和C的数目的总和在总数（23）的35-55%.\n6. 满足以上1-5项要求的片段数目如果不足四个，将G和C的数目的总和放宽至总数（23）的30-70%\n\n确定RNA oligo：\n1. 找到正义链和反义链\n1. 将反义链从3‘-5’反转，变成5'-3'\n1. 将除了3‘末端的两个碱基外，所有的T改成U\n1. 使用BLAST确定唯一性\n\n{% note %}\n**注意点：**\n- GC含量为30-50% 的siRNA最有效\n- 应选2-4个靶点序列\n\n\n**需排除的siRNA：**\n- 有4个T/A\n- 基因组数据库比较，去除和其他序列有16-17同源碱基对的靶序列\n{% endnote %}\n\n\n### 设置对照\n所有的RNAi试验均应设立阴性对照，siRNA阴性对照序列的合理设计与siRNA序列的设计同样重要。\n因为有效的对照可以充分证明siRNA只对靶基因产生特异性基因沉默，从而增强实验的可信度。\n阴性对照siRNA包括碱基错配或混乱序列的siRNA。\n在实验中最好设计两条siRNA对照序列\n\n注：\n  多碱基错配比单碱基错配的siRNA阴性对照序列具有更高的实际应用价值\n\n设置对照：\n- 阴性对照siRNA：1）打乱原siRNA核苷酸顺序，且和靶mRNA无同源性; 2）碱基错配\n- 针对相同基因的其他siRNA：确保siRNA数据可靠的最佳方式\n\n### Tuschl法则\n原始法则：\n- 21bp + 3’两个碱基，最有效\n\n新法则：\n- NA -（A/G）-（N17）-（C/U）- NN  \n正义链和反义链（21nt）siRNA应该以嘌呤核苷酸(A)开头，这对于多聚酶Ⅲ启动子的表达是必须的。\n\n- （N4）- A -（N6）- T -（N2）-（A/T/C）-（N5）-（A）-（N2）\n\n## 构建shRNA表达载体\n\n### 优势\n1. 有抗生素标记，可建立稳定的长期基因沉默细胞株，并筛选细胞\n1. 通过病毒插入基因组得到稳定的基因沉默表达细胞株\n\n### 构建过程\n\n#### shRNA序列设计\nshRNA 由 siRNA 和环状连接序列组成。\n就是目标 siRNA 与其反向互补序列之间由特定的连接序列间隔，得到的 RNA 两端反向互补退火，与连接序列形成茎环结构，类似发夹。\n\n#### 启动子选择\n多数siRNA表达载体依赖三种RNA聚合酶III 启动子(pol III)中的一种，操纵一段小的发夹RNA在哺乳动物细胞中的表达，包括U6和H1。\n因为它可以在哺乳动物细胞中表达更多小分子RNA\n\n1. 表达产量取决于启动子强弱\n1. U6\\>H1，表达时间长，首选，但shRNA要避免3+个U/A，防提前转录\n1. RNA 聚合酶 II 类的启动子如CMV 启动子和 U1 启动子也比较常见\n1. shRNA 序列有连续的 U / T 时应该优先考虑 CMV 启动子载体\n\n#### 载体类型选择\n1. 质粒载体\n1. 病毒表达载体：感染细胞效率高\n常用的，哺乳动物细胞,病毒载体包括：\n&nbsp;&nbsp;&nbsp;&nbsp;逆转录病毒(Retrovirus)，腺病毒(Adenovirus)，腺相关病毒(Adeno-Associated Virus,AAV)，和慢病毒(Lentivirus)。\n其中逆转录病毒和慢病毒等载体，还可以用于构建，整合到染色体上的,稳定的,长期基因沉默细胞株\n\n具体见[病毒的分类](https://www.zhihu.com/question/23745748)\n研究长期基因沉默，选择逆转录病毒，逆转录病毒也是逆转录类型\n\n#### 抗生素筛选标记\n最好选一个抗性标记\n\n1. 非必选，但是可以得到稳定表达shRNA的细胞株，且可检测是否转染\n1. 促进shRNA表达，防止表达减弱影响沉默效果\n\n#### 构建、克隆和测序验证\n\n## 结果评测\n通常从两方面检测，首先是检测mRNA的表达，其次是蛋白表达。如果是移植到小鼠或其他载体上，可以再使用生物学方法检测效果。\n\n### mRNA的表达\n#### RT-PCR\n最常见的是在转染后24-48小时做定量RT-PCR（逆转录PCR）\n1. 纯化细胞\n1. 选取合适的RNA提取试剂盒和银光RT-PCR试剂盒\n1. 提取RNA，进行扩增\n1. 进行RT-PCR检测，按照说明书操作，配置反应体系，于PCR仪扩增实验\n1. 观察结果\n\n#### Northern blot杂交\n{% asset_img 1.png 肿瘤转移抑制基因 KAil 不同转移潜能癌细胞中的表达 %}\n\n#### 原位杂交\n它即可检测 mRNA 的表达，又可观察 mRNA 的定位，是研究细胞内基因表达及有关因素调控的有效工具Northern blot 分析和 RT-PCR 两种方法只用于检测某 特定的 RNA 片段，它们都只能证明细胞或组织中是否存在待测的核酸而不能证明核酸分子在细胞或组织中存在的部位，不具有定位性，也不能反映组织、细胞、器官的差异\n \n### 蛋白水平检测\n#### 免疫组化法(immunohistochemistry)\n- **原理：**免疫组化，免疫组化，是应用免疫学基本原理——抗原抗体反应，即抗原与抗体特异性结合的原理，通过化学反应使标记抗体的显色剂（荧光素、酶、金属离子、同位素）显色来确定组织细胞内抗原（多肽和蛋白质），对其进行定位、定性及定量的研究，称为免疫组织化学技术(immunohistochemistry)或免疫细胞化学技术(immunocytochemistry)。\n- **特点：**是融合了免疫学原理（抗原抗体特异性结合）和组织学技术（组织的取材、固定、包埋、切片、脱蜡、水化等），通过化学反应使标记抗体的显色剂(荧光素、酶、金属离子、同位素)显色，来对组织（细胞）内抗原进行定位、定性及定量的研究(主要是定位)。样本是细胞或组织，要在显微镜下观察结果，可能出现膜阳性、质阳性和核阳性。\n\n#### 蛋白免疫印迹( Western Blot) \n- **原理：**蛋白质印迹法是将电泳分离后的细胞或组织总蛋白质从凝胶转移到固相支持物NC膜或PVDF膜上，然后用特异性抗体检测某特定抗原的一种蛋白质检测技术。\n- **特点：**先要进行SDS-PAGE，然后将分离开的蛋白质样品用电转仪转移到固相载体上，而后利用抗原-抗体-标记物显色来检测样品，可以用于定性和半定量。\n\n#### ELISA检测 \n- **原理：**酶联免疫吸附剂测定法，简称酶联免疫法，或者ELISA法，它的中心就是让抗体与酶复合物结合，然后通过显色来检测。\n- **特点：**用到了免疫学原理和化学反应显色，待测的样品多是血清、血浆、尿液、细胞或组织培养上清液，因而没有用到组织包埋、切片等技术，这是与免疫组化的主要区别，操作上 开始需要将抗原或抗体结合到固相载体表面，从而使后来形成的抗原-抗体-酶-底物复合物粘附在载体上，这就是“吸附”的含义。\n\n#### 区别\n具体的还是参看[蛋白表达不同检测表达方式的比较和分析](https://wenku.baidu.com/view/67f81ad7d4bbfd0a79563c1ec5da50e2524dd102.html)\n{% asset_img 2.png  蛋白表达不同检测表达方式的比较和分析%}\n\n\n<!-- ## miRNA和tRNA -->\n<!-- ### miRNA -->\n## miRNA\nRNAi的重要工具\n\n这种内源性的非编码区小分子 RNA 针对 3’端非编码区，有着极高的保守性，并在组织中广泛表达，可在转录后以及翻译水平上调控基因表达，可能在不影响 mRNA 的水平下调控基因表达\n\n**和siRNA区别：**\n- 内源而非外源序列\n- 针对非编码区\n- 物种进化极为高度保守\n- 组织中广泛表达\n- miRNA 可能调控多种关键基因\n- 可在转录后以及翻译水平上调控基因表达，可能在不影响 mRNA 的水平下调控基因表达\n\n[//]:# (### tRNA)\n\n\n\n## 总结\n### 《小干扰RNA的合理设计》总结\n- RNAi主要是要通过siRNA和靶基因结合并使之降解，所以siRNA要和靶基因高度同源，但是不和其他基因同源。\n- 搜索siRNA时，靠近基因的3‘端的比较好\n- 有研究表明，5’UTR是一个高保守区，使之成为siRNA理想的靶点，RNAi作用于5‘UTR或3’UTR序列，也可以引起靶基因沉默\n- 27nt或者29nt的siRNA效果更好，27nt或29nt的siRNA与21ntsiRNA相比：\n> (1)其抑制活性可提高数倍以上；\n> (2)不易于诱导干扰素反应和激活PKR；\n> (3)一些基因对21ntsiRNA不敏感，但是可以被27ntsiRNA有效的抑制；\n> (4)与21ntSiRNA相比，27ntSiRNA对靶基因的最大抑制率可在相对低的浓度下得到\n- 每一个靶基因，应该设计4+条siRNA\n- 只能根据标准设计出理论较高沉默效应的siRNA，最终活性要用实验验证\n- 关于shRNA的发夹环长度，3-10nt都可以，Brummelkamp研究表明9nt的抑制率高，Siolas表明长度没有明显影响\n- 每个RNAi实验都要设置阴性对照。具体见上文\n\n### 《高效siRNA的设计分析》总结\n1. RNAi实验一般流程如下：\n  - 准备材料，包括目标基因，shRNA表达载体，限制性核酸内切酶等\n  - siRNA的设计和筛选\n  - 重组表达载体的构建\n  - 含靶基因的细胞的分离培养和转染\n  - RT-PCR的检测和靶基因的表达\n  - 分析结果并总结\n2. 一些结论\n  - 和siRNA结合的$$AG0_2$$蛋白主要识别5‘端为A的siRNA，因此5’端为A的siRNA对其进入RISC复合体及对靶mRNA的识别具有关键作用\n  - 正义链5’端具有更多的G/C对siRNA的功能提高非常重要，第19位为G/C也更具有RNAi活力\n  - 反义链的第19位G/C真的对siRNA的高功能性存在相关性有待验证\n  - 高效的siRNA反义链的第13位优先为 A／U，即不为G/C\n  - 反义链第10位为 U 作用强于A，优先考虑\n  - 综合考虑反义链第3,7,14,16,17位还是有必要的\n  - 对zfy基因来说，siRNA靶点在1000bp以内，即第3-6外显子上设计高效siRNA的可能性更大，最好位于150bp-800bp\n3. 这个论文主要是记录了一整个siRNA实验以及分析过程，可以作为以后siRNA实验的参考\n\n\n<!-- ## Question -->\n<!-- 1. 选择标准中的G-C含量在什么范围计算，如果不是23个核苷酸中，为什么选择标准注意点说开头不是AA才在23个里计算G-C含量 -->\n<!-- 1. 选择标准中，3‘端可以是合适的靶序列，什么意思 -->\n\n\n## 拓展阅读\n1. [生物医药大词典](http://dict.bioon.com/)\n1. [siRNA和shRNA:通过基因沉默抑制蛋白表达的工具](http://www.labome.cn/method/siRNAs-and-shRNAs-Tools-for-Protein-Knockdown-by-Gene-Silencing.html)\n1. [Argonaute蛋白结构与功能](https://wenku.baidu.com/view/b3571b7c192e45361066f5ca.html)\n1. [张美红，周克元.小干扰RNA的合理设计[J].肿瘤防治研究，2006， 33（11）：837-839](http://www.televector.com/9171223659.pdf)\n1. [秦炳燕，张永生，纪俊明等.高效siRNA的设计分析[B].黑龙江畜牧兽医，2017（1）：109-113，294](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFD&dbname=CJFDLAST2017&filename=HLJX201701028)\n1. [韩烨.基于机器学习的siRNA沉默效率预测方法研究[D].吉林省：吉林大学，2019](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&dbname=CDFDLAST2017&filename=1017152231.nh)\n1. [薛婷，王黎明，焦今文等.siRNA介导RRM2基因沉默治疗人卵巢癌裸鼠移植瘤[J].山东大学学报，2019，57（10）](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CAPJ&dbname=CAPJLAST&filename=SDYB20190926000)\n1. [李珊珊,任秀花,闫爱华,方伟岗.3种mRNA检测方法比较[J].河南医科大学学报，2000，35（2）：113-114](http://kns.cnki.net/KCMS/detail/detail.aspx?dbname=cjfd2000&filename=hnyk200002007)\n1. [蛋白表达不同检测表达方式的比较和分析](https://wenku.baidu.com/view/67f81ad7d4bbfd0a79563c1ec5da50e2524dd102.html)\n1. [李珊珊，方伟岗，钟销销，等 肿瘤转移抑制基因 KAil 不同转移潜能癌细胞中的表达．中华医学杂志，1999,(9): 708](http://kns.cnki.net//KXReader/Detail?TIMESTAMP=637062394829091250&DBCODE=CJFD&TABLEName=CJFD9899&FileName=ZHYX199909026&RESULT=1&SIGN=kvPorAe14Lw3IYsBq017HIfdCF4%3d)\n","source":"_posts/siRNA/siRNA设计基础.md","raw":"---\ntitle: RNAi和siRNA设计基础\ntags:\n  - RNAi\n  - siRNA\n  - Note\n  - Basic\n  - Summary\ncategories:\n  - Notes\ncomments: true\nmathjax: false\ndate: 2019-10-01 18:40:22\nurlname: basic-knowledge-of-RNAi\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n刚接触siRNA搜索、设计和评测这方面的研究，记录一下基本的概念和一些基础知识，还有自己的理解总结。\n{% endnote %}\n<!--more-->\n\n## 基础概念\n### 英文缩写\n1. RNAi：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RNA干扰\n1. siRNA：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小干扰RNA\n1. dsRNA：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Double-stranded RNA的缩写，是指双链核糖核酸\n1. [shRNA](https://baike.baidu.com/item/shRNA)：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是英文单词short hairpin RNA的缩写。翻译为“短发夹RNA”。shRNA包括两个短反向重复序列。克隆到shRNA表达载体中的shRNA包括两个短反向重复序列，中间由一茎环（loop）序列分隔的，组成发夹结构，由polⅢ启动子控制。随后再连上5-6个T作为RNA聚合酶Ⅲ的转录终止子。\n1. Argonaute (AGO)：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一类庞大的蛋白质家族，是组成RISCs复合物的主要成员。AGO蛋白质主要包含两个结构域：PAZ和PIWI两个结构域，但具体功能现在尚不清楚。\n1.  Dicer酶：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是RNAase Ⅲ家族中的一员，主要切割dsRNA或者茎环结构的RNA前体成为小RNAs分子。对应地，我们将这种小RNAs分子命名为siRNAs和miRNA。Dicer有着较多的结构域，最先在果蝇中发现，并且在不同的生物体上表现出很高的保守性。\n\n1. RISC：RISC诱导沉默复合体（全称：RNA-induced silencing complex）：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种由siRNA与Argonaute蛋白和Dicer酶复合形成的复合物。在RNAi中，利用siRNA的反义链切割靶mRNA，达到基因沉默。\n\n1. BLAST (Basic Local Alignment Search Tool)：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是一套在蛋白质数据库或DNA数据库中进行相似性比较的分析工具。BLAST程序能迅速与公开数据库进行相似性序列比较。BLAST结果中的得分是对一种对相似性的统计说明。\n\n1. rRNA（核糖体RNA）是核糖体的组成成分,它和蛋白质共同组成了核糖体.  \ntRNA（转运RNA）可以转运氨基酸.\nmRNA（信使RNA）是由细胞核内的DNA转录来的,相当于蛋白质的设计图纸.\n\n1. UTR：非翻译区\n\n1. [SD序列](http://www.baike.com/wiki/SD%E5%BA%8F%E5%88%97)：mRNA起始部位的碱基序列，为mRNA与核糖体的结合位点称SD序列.在DNA上相应的位点也称SD序列，一般位于操纵基因和第一个结构基因之间，部分序列与操纵基因重叠.\n\n\n### 名词概念\n1. 质粒：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小型环状DNA分子，包括三部分：遗传标记基因，复制区，目的基因.在所有的细菌类群中都可发现，它们是独立于细菌染色体外自我复制的DNA分子\n1. 质粒载体：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;质粒载体是在天然质粒的基础上为适应实验室操作而进行人工构建的质粒。与天然质粒相比，质粒载体通常带有一个或一个以上的选择性标记基因（如抗生素抗性基因）和一个人工合成的含有多个限制性内切酶识别位点的多克隆位点序列，并去掉了大部分非必需序列，使分子量尽可能减少，以便于基因工程操作\n\n1. 转染：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是真核细胞主动或被动导入外源DNA片段而获得新的表型的过程\n\n1. 细胞株：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过选择法或克隆形成法从原代培养物或细胞系中获得具有特殊性质或标志物的培养物称为细胞株。    \n细胞株是用单细胞分离培养或通过筛选的方法，由单细胞增殖形成的细胞群。细胞株的特殊性质或标志必须在整个培养期间始终存在。原代培养物经首次传代成功后即为细胞系(cell line)， 由原先存在于原代培养物中的细胞世系所组成。如果不能继续传代，或传代次数有限， 可称为有限细胞系(finite cell line)， 如可以连续培养， 则称为连续细胞系(continuous cell line)， 培养50代以上并无限培养下去。 所以细胞株是通过选择法或克隆形成法从原代培养物或细胞系中获得的具有特殊性质或标志的培养细胞。从培养代数来讲，可培养到40-50代。细胞株的特殊性质或标志必须在整个培养期间始终存在。对于人类肿瘤细胞，在体外培养半年以上，生长稳定，并连续传代的即可称为连续性株或系。\n\n1. 核酸酶：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能够将聚核苷酸链的磷酸二酯键切断的酶，称为核酸酶。 有些核酸酶只能作用于RNA，称为核糖核酸酶（RNase），有些核酸酶只能作用于DNA，称为脱氧核糖核酸酶（DNase），有些核酸酶专一性较低，既能作用于RNA也能作用于DNA，因此统称为核酸酶（nuclease）。根据核酸酶作用的位置不同，又可将核酸酶分为核酸外切酶（exonuclease）和核酸内切酶\n\n1. 逆转录病毒：[病毒的分类](https://www.zhihu.com/question/23745748)\n\n1. [DNA中的3'端和5'端](https://www.zhihu.com/question/21112790)\n\n1. 化学修饰：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凡通过化学基团的引入或除去，而使蛋白质或核酸共价结构发生改变的现象。它以引起酶分子共价键的变化、化学结构的改变而影响酶活性。酶的化学修饰是在另一种酶的催化下完成的，是体内快速调节的另一种重要方式。\n\n1. 正义链：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与转录出的mRNA序列相同的（DNA中的T在RNA中为U）那条DNA单链那条链为正义链，与之互补的为反义链。\n\n1. PCR扩增产物：可分为长产物片段和短产物片段两部分。短产物指数倍增加，长产物算术倍增加，所以重复多次后，可以忽略长产物，得到的是目的基因。\n反应体系由模板DNA、一对引物、dNTP、耐高温的DNA聚合酶、酶反应缓冲体系及必须的离子等所组成。PCR反应循环的第一步为加热变性，使双链模板DNA变性为单链；第二步为复性，每个引物将与互补的DNA序列杂交；第三步为延伸，在耐高温的DNA聚合酶作用下，以变性的单链DNA为模板，从引物3ˊ端开始按5ˊ→3ˊ方向合成DNA链。这样经过一个周期的变性——复性——延伸等三步反应就可以产生倍增的DNA，假设PCR的效率为100%,反复n周期后，理论上就能扩增2n倍。PCR反应一般30-40次循环，DNA片段可放大数百万倍。\n见[PCR的扩增产物是什么，怎么扩增出来的](https://zhidao.baidu.com/question/345141221.html)\n\n### 基本单位\n1. 碱基(A，G，C，T，U)：\n&nbsp;&nbsp;&nbsp;&nbsp;DNA有四种碱基对，即鸟嘌呤(G),腺嘌呤(A),胞嘧啶(C),胸腺嘧啶(T).其中G与C配对，A与T配对。RNA有A，G，C，U(尿嘧啶)这四种\n\n1. bp：\n&nbsp;&nbsp;&nbsp;&nbsp; 碱基对的数目单位,100bp即两条链上各有100个碱基.\n\n1. nt：\n&nbsp;&nbsp;&nbsp;&nbsp;核苷酸的单位，25nt RNA是指25个核苷酸碱基的小RNA\n\n\n## RNAi实验相关\n1. 四要素：\n  - 目标基因的dsRNA，看需求\n  - 转染或者将dsRNA送入细胞的方法，具体看下面的三种方法\n  - 对照\n  - 检测表达情况的方法，即检验RNAi效果\n2. 注意点\n  - siRNA长度的选择\n  - shRNA表达水平太高会导致细胞毒性或脱靶，要防止过表达\n3. 三种实现方法\n\n|适用类型| 导入材料|过程 |其他材料| 沉默类型|\n|:-:|:-:|:-:|:-:|:-:|\n|非哺乳生物|dsRNA| 导入dsRNA，使用Dicer酶切割dsRNA得到siRNAs，获得RISC诱导沉默复合体，切割靶mRNA| Dicer酶|瞬时基因沉默3-7天|\n|哺乳生物|siRNAs|直接导入siRNAs，获得RISC，切割靶mRNA|无|瞬时基因沉默3-7天|\n| | shRNA的DNA表达载体| 导入shRNA表达载体，使用Dicer酶切割shRNA，得到siRNAs，后续相同|Dicer酶|长效基因沉默|\n\n## siRNA设计\n### 结构和选择标准\n- 理想siRNA是23bp，双链部分是19bp，正义链和反义链为21bp，3‘端和5’端分别是两个突出核苷酸\n\n|    |5'端|1  | 2 | 3 | 4 | 5...10|11...14|15...18|19 |20|21...23 |3'端|\n| :-:|:-: |:-:|:-:|:-:|:-:|    :-:|:-:    |:-:|:-: |:-: |:-: |:-:|\n|理想状态|第一个核苷酸对沉默作用非必须 |A|A|-|-|-|-|-|-|T|T|UU/TT结尾，抵抗核糖核苷酸酶|\n|有效状态| |-|A|-|-|-|-|-|-|T|T| / |\n|有效状态| |-|A|-|-|-|-||--|-|-| / |\n|选择标准(正义链：3-23，21nt)| |/|/|5. 为A|-|6. 第十位为U |8. 第13位非G|2. 15-19位有3+个A/U碱基对|4. 为A; 7.不能为G/C|-|-| / |\n\n{% note info %}\n正义链：3-23，一般TT结尾\n反义链：1-21的互补链(A-T, C-G)，一般TT开头\n\n反义RNA和靶RNA互补配对，参与基因表达调控。分3类：\n1. 直接和靶mRNA的S-D序列或部分编码区结合，抑制翻译，或者结合成双链RNA被RNA酶Ⅲ降解\n2. 和非编码区结合，引起mRNA构象变化，抑制翻译\n3. 直接抑制mRNA转录\n{% endnote %}\n\n**选择标准：**\n1. G/C含量=30～52%\n1. 在第15 ～19位核苷酸的位置个或更多的A/U碱基对（正义链） \n1. 发夹结构预测（没有内部重或回文结构）Tm<20℃ \n1. 19位核苷酸为A（正义链） \n1. 3位核苷酸为A（正义链） \n1. 10位核苷酸为U（正义链）\n1. 19位核苷酸不能为G或C（正义链） \n1. 13位核苷酸不能为G（正义链）\n\n**符合条件小于6个的舍弃**\n\n{% note danger %}\n1. 如果靶序列开始的两个核苷酸不是AA，选择基因编码区的23个核苷酸来计算G-C的百分含量\n1. 大多数G-C含量为30%-52%的siRNA产生的沉默效应较高，但过高的G-C含量会降低沉默活性\n1. 避免超过3个G/C重复，以及4个A重复，多G/C可能干扰siRNA沉默机制，多A会提前终止转录干扰shRNA合成\n《小干扰RNA的合理设计》中，为2+个G/C降低RNA内在稳定性，3+个U/A可能终止RNA PolymeraseIII介导的转录\n1. 一定要从启动子第100个核苷酸之后开始搜索\n1. 3’-端可以是合适的靶序列，可特异性防止非必要保守基因的沉默\n{% endnote %}\n\n\n### 设计过程\n选择：\n1. 在所选基因的启动子`100个`碱基以后开始自5’-端开始\n2. 寻找基因序列中的23个碱基， 最好是5‘- AA（N19）TT -3’ （N是任何碱基）\n3. 如果找不到以上AA（N19）TT，则用 AA（N21）补足。\n4. 如果找不到以上AA（N21）， 则用 NA（N21）补足。\n5. 所选定序列中，G和C的数目的总和在总数（23）的35-55%.\n6. 满足以上1-5项要求的片段数目如果不足四个，将G和C的数目的总和放宽至总数（23）的30-70%\n\n确定RNA oligo：\n1. 找到正义链和反义链\n1. 将反义链从3‘-5’反转，变成5'-3'\n1. 将除了3‘末端的两个碱基外，所有的T改成U\n1. 使用BLAST确定唯一性\n\n{% note %}\n**注意点：**\n- GC含量为30-50% 的siRNA最有效\n- 应选2-4个靶点序列\n\n\n**需排除的siRNA：**\n- 有4个T/A\n- 基因组数据库比较，去除和其他序列有16-17同源碱基对的靶序列\n{% endnote %}\n\n\n### 设置对照\n所有的RNAi试验均应设立阴性对照，siRNA阴性对照序列的合理设计与siRNA序列的设计同样重要。\n因为有效的对照可以充分证明siRNA只对靶基因产生特异性基因沉默，从而增强实验的可信度。\n阴性对照siRNA包括碱基错配或混乱序列的siRNA。\n在实验中最好设计两条siRNA对照序列\n\n注：\n  多碱基错配比单碱基错配的siRNA阴性对照序列具有更高的实际应用价值\n\n设置对照：\n- 阴性对照siRNA：1）打乱原siRNA核苷酸顺序，且和靶mRNA无同源性; 2）碱基错配\n- 针对相同基因的其他siRNA：确保siRNA数据可靠的最佳方式\n\n### Tuschl法则\n原始法则：\n- 21bp + 3’两个碱基，最有效\n\n新法则：\n- NA -（A/G）-（N17）-（C/U）- NN  \n正义链和反义链（21nt）siRNA应该以嘌呤核苷酸(A)开头，这对于多聚酶Ⅲ启动子的表达是必须的。\n\n- （N4）- A -（N6）- T -（N2）-（A/T/C）-（N5）-（A）-（N2）\n\n## 构建shRNA表达载体\n\n### 优势\n1. 有抗生素标记，可建立稳定的长期基因沉默细胞株，并筛选细胞\n1. 通过病毒插入基因组得到稳定的基因沉默表达细胞株\n\n### 构建过程\n\n#### shRNA序列设计\nshRNA 由 siRNA 和环状连接序列组成。\n就是目标 siRNA 与其反向互补序列之间由特定的连接序列间隔，得到的 RNA 两端反向互补退火，与连接序列形成茎环结构，类似发夹。\n\n#### 启动子选择\n多数siRNA表达载体依赖三种RNA聚合酶III 启动子(pol III)中的一种，操纵一段小的发夹RNA在哺乳动物细胞中的表达，包括U6和H1。\n因为它可以在哺乳动物细胞中表达更多小分子RNA\n\n1. 表达产量取决于启动子强弱\n1. U6\\>H1，表达时间长，首选，但shRNA要避免3+个U/A，防提前转录\n1. RNA 聚合酶 II 类的启动子如CMV 启动子和 U1 启动子也比较常见\n1. shRNA 序列有连续的 U / T 时应该优先考虑 CMV 启动子载体\n\n#### 载体类型选择\n1. 质粒载体\n1. 病毒表达载体：感染细胞效率高\n常用的，哺乳动物细胞,病毒载体包括：\n&nbsp;&nbsp;&nbsp;&nbsp;逆转录病毒(Retrovirus)，腺病毒(Adenovirus)，腺相关病毒(Adeno-Associated Virus,AAV)，和慢病毒(Lentivirus)。\n其中逆转录病毒和慢病毒等载体，还可以用于构建，整合到染色体上的,稳定的,长期基因沉默细胞株\n\n具体见[病毒的分类](https://www.zhihu.com/question/23745748)\n研究长期基因沉默，选择逆转录病毒，逆转录病毒也是逆转录类型\n\n#### 抗生素筛选标记\n最好选一个抗性标记\n\n1. 非必选，但是可以得到稳定表达shRNA的细胞株，且可检测是否转染\n1. 促进shRNA表达，防止表达减弱影响沉默效果\n\n#### 构建、克隆和测序验证\n\n## 结果评测\n通常从两方面检测，首先是检测mRNA的表达，其次是蛋白表达。如果是移植到小鼠或其他载体上，可以再使用生物学方法检测效果。\n\n### mRNA的表达\n#### RT-PCR\n最常见的是在转染后24-48小时做定量RT-PCR（逆转录PCR）\n1. 纯化细胞\n1. 选取合适的RNA提取试剂盒和银光RT-PCR试剂盒\n1. 提取RNA，进行扩增\n1. 进行RT-PCR检测，按照说明书操作，配置反应体系，于PCR仪扩增实验\n1. 观察结果\n\n#### Northern blot杂交\n{% asset_img 1.png 肿瘤转移抑制基因 KAil 不同转移潜能癌细胞中的表达 %}\n\n#### 原位杂交\n它即可检测 mRNA 的表达，又可观察 mRNA 的定位，是研究细胞内基因表达及有关因素调控的有效工具Northern blot 分析和 RT-PCR 两种方法只用于检测某 特定的 RNA 片段，它们都只能证明细胞或组织中是否存在待测的核酸而不能证明核酸分子在细胞或组织中存在的部位，不具有定位性，也不能反映组织、细胞、器官的差异\n \n### 蛋白水平检测\n#### 免疫组化法(immunohistochemistry)\n- **原理：**免疫组化，免疫组化，是应用免疫学基本原理——抗原抗体反应，即抗原与抗体特异性结合的原理，通过化学反应使标记抗体的显色剂（荧光素、酶、金属离子、同位素）显色来确定组织细胞内抗原（多肽和蛋白质），对其进行定位、定性及定量的研究，称为免疫组织化学技术(immunohistochemistry)或免疫细胞化学技术(immunocytochemistry)。\n- **特点：**是融合了免疫学原理（抗原抗体特异性结合）和组织学技术（组织的取材、固定、包埋、切片、脱蜡、水化等），通过化学反应使标记抗体的显色剂(荧光素、酶、金属离子、同位素)显色，来对组织（细胞）内抗原进行定位、定性及定量的研究(主要是定位)。样本是细胞或组织，要在显微镜下观察结果，可能出现膜阳性、质阳性和核阳性。\n\n#### 蛋白免疫印迹( Western Blot) \n- **原理：**蛋白质印迹法是将电泳分离后的细胞或组织总蛋白质从凝胶转移到固相支持物NC膜或PVDF膜上，然后用特异性抗体检测某特定抗原的一种蛋白质检测技术。\n- **特点：**先要进行SDS-PAGE，然后将分离开的蛋白质样品用电转仪转移到固相载体上，而后利用抗原-抗体-标记物显色来检测样品，可以用于定性和半定量。\n\n#### ELISA检测 \n- **原理：**酶联免疫吸附剂测定法，简称酶联免疫法，或者ELISA法，它的中心就是让抗体与酶复合物结合，然后通过显色来检测。\n- **特点：**用到了免疫学原理和化学反应显色，待测的样品多是血清、血浆、尿液、细胞或组织培养上清液，因而没有用到组织包埋、切片等技术，这是与免疫组化的主要区别，操作上 开始需要将抗原或抗体结合到固相载体表面，从而使后来形成的抗原-抗体-酶-底物复合物粘附在载体上，这就是“吸附”的含义。\n\n#### 区别\n具体的还是参看[蛋白表达不同检测表达方式的比较和分析](https://wenku.baidu.com/view/67f81ad7d4bbfd0a79563c1ec5da50e2524dd102.html)\n{% asset_img 2.png  蛋白表达不同检测表达方式的比较和分析%}\n\n\n<!-- ## miRNA和tRNA -->\n<!-- ### miRNA -->\n## miRNA\nRNAi的重要工具\n\n这种内源性的非编码区小分子 RNA 针对 3’端非编码区，有着极高的保守性，并在组织中广泛表达，可在转录后以及翻译水平上调控基因表达，可能在不影响 mRNA 的水平下调控基因表达\n\n**和siRNA区别：**\n- 内源而非外源序列\n- 针对非编码区\n- 物种进化极为高度保守\n- 组织中广泛表达\n- miRNA 可能调控多种关键基因\n- 可在转录后以及翻译水平上调控基因表达，可能在不影响 mRNA 的水平下调控基因表达\n\n[//]:# (### tRNA)\n\n\n\n## 总结\n### 《小干扰RNA的合理设计》总结\n- RNAi主要是要通过siRNA和靶基因结合并使之降解，所以siRNA要和靶基因高度同源，但是不和其他基因同源。\n- 搜索siRNA时，靠近基因的3‘端的比较好\n- 有研究表明，5’UTR是一个高保守区，使之成为siRNA理想的靶点，RNAi作用于5‘UTR或3’UTR序列，也可以引起靶基因沉默\n- 27nt或者29nt的siRNA效果更好，27nt或29nt的siRNA与21ntsiRNA相比：\n> (1)其抑制活性可提高数倍以上；\n> (2)不易于诱导干扰素反应和激活PKR；\n> (3)一些基因对21ntsiRNA不敏感，但是可以被27ntsiRNA有效的抑制；\n> (4)与21ntSiRNA相比，27ntSiRNA对靶基因的最大抑制率可在相对低的浓度下得到\n- 每一个靶基因，应该设计4+条siRNA\n- 只能根据标准设计出理论较高沉默效应的siRNA，最终活性要用实验验证\n- 关于shRNA的发夹环长度，3-10nt都可以，Brummelkamp研究表明9nt的抑制率高，Siolas表明长度没有明显影响\n- 每个RNAi实验都要设置阴性对照。具体见上文\n\n### 《高效siRNA的设计分析》总结\n1. RNAi实验一般流程如下：\n  - 准备材料，包括目标基因，shRNA表达载体，限制性核酸内切酶等\n  - siRNA的设计和筛选\n  - 重组表达载体的构建\n  - 含靶基因的细胞的分离培养和转染\n  - RT-PCR的检测和靶基因的表达\n  - 分析结果并总结\n2. 一些结论\n  - 和siRNA结合的$$AG0_2$$蛋白主要识别5‘端为A的siRNA，因此5’端为A的siRNA对其进入RISC复合体及对靶mRNA的识别具有关键作用\n  - 正义链5’端具有更多的G/C对siRNA的功能提高非常重要，第19位为G/C也更具有RNAi活力\n  - 反义链的第19位G/C真的对siRNA的高功能性存在相关性有待验证\n  - 高效的siRNA反义链的第13位优先为 A／U，即不为G/C\n  - 反义链第10位为 U 作用强于A，优先考虑\n  - 综合考虑反义链第3,7,14,16,17位还是有必要的\n  - 对zfy基因来说，siRNA靶点在1000bp以内，即第3-6外显子上设计高效siRNA的可能性更大，最好位于150bp-800bp\n3. 这个论文主要是记录了一整个siRNA实验以及分析过程，可以作为以后siRNA实验的参考\n\n\n<!-- ## Question -->\n<!-- 1. 选择标准中的G-C含量在什么范围计算，如果不是23个核苷酸中，为什么选择标准注意点说开头不是AA才在23个里计算G-C含量 -->\n<!-- 1. 选择标准中，3‘端可以是合适的靶序列，什么意思 -->\n\n\n## 拓展阅读\n1. [生物医药大词典](http://dict.bioon.com/)\n1. [siRNA和shRNA:通过基因沉默抑制蛋白表达的工具](http://www.labome.cn/method/siRNAs-and-shRNAs-Tools-for-Protein-Knockdown-by-Gene-Silencing.html)\n1. [Argonaute蛋白结构与功能](https://wenku.baidu.com/view/b3571b7c192e45361066f5ca.html)\n1. [张美红，周克元.小干扰RNA的合理设计[J].肿瘤防治研究，2006， 33（11）：837-839](http://www.televector.com/9171223659.pdf)\n1. [秦炳燕，张永生，纪俊明等.高效siRNA的设计分析[B].黑龙江畜牧兽医，2017（1）：109-113，294](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFD&dbname=CJFDLAST2017&filename=HLJX201701028)\n1. [韩烨.基于机器学习的siRNA沉默效率预测方法研究[D].吉林省：吉林大学，2019](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&dbname=CDFDLAST2017&filename=1017152231.nh)\n1. [薛婷，王黎明，焦今文等.siRNA介导RRM2基因沉默治疗人卵巢癌裸鼠移植瘤[J].山东大学学报，2019，57（10）](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CAPJ&dbname=CAPJLAST&filename=SDYB20190926000)\n1. [李珊珊,任秀花,闫爱华,方伟岗.3种mRNA检测方法比较[J].河南医科大学学报，2000，35（2）：113-114](http://kns.cnki.net/KCMS/detail/detail.aspx?dbname=cjfd2000&filename=hnyk200002007)\n1. [蛋白表达不同检测表达方式的比较和分析](https://wenku.baidu.com/view/67f81ad7d4bbfd0a79563c1ec5da50e2524dd102.html)\n1. [李珊珊，方伟岗，钟销销，等 肿瘤转移抑制基因 KAil 不同转移潜能癌细胞中的表达．中华医学杂志，1999,(9): 708](http://kns.cnki.net//KXReader/Detail?TIMESTAMP=637062394829091250&DBCODE=CJFD&TABLEName=CJFD9899&FileName=ZHYX199909026&RESULT=1&SIGN=kvPorAe14Lw3IYsBq017HIfdCF4%3d)\n","slug":"siRNA/siRNA设计基础","published":1,"updated":"2019-10-09T13:47:51.374Z","layout":"post","photos":[],"link":"","_id":"ck2424lv9009llksbax2ilfx3","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>刚接触siRNA搜索、设计和评测这方面的研究，记录一下基本的概念和一些基础知识，还有自己的理解总结。</p></div><a id=\"more\"></a><h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><h3 id=\"英文缩写\"><a href=\"#英文缩写\" class=\"headerlink\" title=\"英文缩写\"></a>英文缩写</h3><ol><li>RNAi：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RNA干扰</li><li>siRNA：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小干扰RNA</li><li>dsRNA：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Double-stranded RNA的缩写，是指双链核糖核酸</li><li><a href=\"https://baike.baidu.com/item/shRNA\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">shRNA</a>：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是英文单词short hairpin RNA的缩写。翻译为“短发夹RNA”。shRNA包括两个短反向重复序列。克隆到shRNA表达载体中的shRNA包括两个短反向重复序列，中间由一茎环（loop）序列分隔的，组成发夹结构，由polⅢ启动子控制。随后再连上5-6个T作为RNA聚合酶Ⅲ的转录终止子。</li><li>Argonaute (AGO)：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一类庞大的蛋白质家族，是组成RISCs复合物的主要成员。AGO蛋白质主要包含两个结构域：PAZ和PIWI两个结构域，但具体功能现在尚不清楚。</li><li><p>Dicer酶：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是RNAase Ⅲ家族中的一员，主要切割dsRNA或者茎环结构的RNA前体成为小RNAs分子。对应地，我们将这种小RNAs分子命名为siRNAs和miRNA。Dicer有着较多的结构域，最先在果蝇中发现，并且在不同的生物体上表现出很高的保守性。</p></li><li><p>RISC：RISC诱导沉默复合体（全称：RNA-induced silencing complex）：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种由siRNA与Argonaute蛋白和Dicer酶复合形成的复合物。在RNAi中，利用siRNA的反义链切割靶mRNA，达到基因沉默。</p></li><li><p>BLAST (Basic Local Alignment Search Tool)：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是一套在蛋白质数据库或DNA数据库中进行相似性比较的分析工具。BLAST程序能迅速与公开数据库进行相似性序列比较。BLAST结果中的得分是对一种对相似性的统计说明。</p></li><li><p>rRNA（核糖体RNA）是核糖体的组成成分,它和蛋白质共同组成了核糖体.<br>tRNA（转运RNA）可以转运氨基酸.<br>mRNA（信使RNA）是由细胞核内的DNA转录来的,相当于蛋白质的设计图纸.</p></li><li><p>UTR：非翻译区</p></li><li><p><a href=\"http://www.baike.com/wiki/SD%E5%BA%8F%E5%88%97\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">SD序列</a>：mRNA起始部位的碱基序列，为mRNA与核糖体的结合位点称SD序列.在DNA上相应的位点也称SD序列，一般位于操纵基因和第一个结构基因之间，部分序列与操纵基因重叠.</p></li></ol><h3 id=\"名词概念\"><a href=\"#名词概念\" class=\"headerlink\" title=\"名词概念\"></a>名词概念</h3><ol><li>质粒：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小型环状DNA分子，包括三部分：遗传标记基因，复制区，目的基因.在所有的细菌类群中都可发现，它们是独立于细菌染色体外自我复制的DNA分子</li><li><p>质粒载体：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;质粒载体是在天然质粒的基础上为适应实验室操作而进行人工构建的质粒。与天然质粒相比，质粒载体通常带有一个或一个以上的选择性标记基因（如抗生素抗性基因）和一个人工合成的含有多个限制性内切酶识别位点的多克隆位点序列，并去掉了大部分非必需序列，使分子量尽可能减少，以便于基因工程操作</p></li><li><p>转染：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是真核细胞主动或被动导入外源DNA片段而获得新的表型的过程</p></li><li><p>细胞株：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过选择法或克隆形成法从原代培养物或细胞系中获得具有特殊性质或标志物的培养物称为细胞株。<br>细胞株是用单细胞分离培养或通过筛选的方法，由单细胞增殖形成的细胞群。细胞株的特殊性质或标志必须在整个培养期间始终存在。原代培养物经首次传代成功后即为细胞系(cell line)， 由原先存在于原代培养物中的细胞世系所组成。如果不能继续传代，或传代次数有限， 可称为有限细胞系(finite cell line)， 如可以连续培养， 则称为连续细胞系(continuous cell line)， 培养50代以上并无限培养下去。 所以细胞株是通过选择法或克隆形成法从原代培养物或细胞系中获得的具有特殊性质或标志的培养细胞。从培养代数来讲，可培养到40-50代。细胞株的特殊性质或标志必须在整个培养期间始终存在。对于人类肿瘤细胞，在体外培养半年以上，生长稳定，并连续传代的即可称为连续性株或系。</p></li><li><p>核酸酶：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能够将聚核苷酸链的磷酸二酯键切断的酶，称为核酸酶。 有些核酸酶只能作用于RNA，称为核糖核酸酶（RNase），有些核酸酶只能作用于DNA，称为脱氧核糖核酸酶（DNase），有些核酸酶专一性较低，既能作用于RNA也能作用于DNA，因此统称为核酸酶（nuclease）。根据核酸酶作用的位置不同，又可将核酸酶分为核酸外切酶（exonuclease）和核酸内切酶</p></li><li><p>逆转录病毒：<a href=\"https://www.zhihu.com/question/23745748\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">病毒的分类</a></p></li><li><p><a href=\"https://www.zhihu.com/question/21112790\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">DNA中的3’端和5’端</a></p></li><li><p>化学修饰：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凡通过化学基团的引入或除去，而使蛋白质或核酸共价结构发生改变的现象。它以引起酶分子共价键的变化、化学结构的改变而影响酶活性。酶的化学修饰是在另一种酶的催化下完成的，是体内快速调节的另一种重要方式。</p></li><li><p>正义链：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与转录出的mRNA序列相同的（DNA中的T在RNA中为U）那条DNA单链那条链为正义链，与之互补的为反义链。</p></li><li><p>PCR扩增产物：可分为长产物片段和短产物片段两部分。短产物指数倍增加，长产物算术倍增加，所以重复多次后，可以忽略长产物，得到的是目的基因。<br>反应体系由模板DNA、一对引物、dNTP、耐高温的DNA聚合酶、酶反应缓冲体系及必须的离子等所组成。PCR反应循环的第一步为加热变性，使双链模板DNA变性为单链；第二步为复性，每个引物将与互补的DNA序列杂交；第三步为延伸，在耐高温的DNA聚合酶作用下，以变性的单链DNA为模板，从引物3ˊ端开始按5ˊ→3ˊ方向合成DNA链。这样经过一个周期的变性——复性——延伸等三步反应就可以产生倍增的DNA，假设PCR的效率为100%,反复n周期后，理论上就能扩增2n倍。PCR反应一般30-40次循环，DNA片段可放大数百万倍。<br>见<a href=\"https://zhidao.baidu.com/question/345141221.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">PCR的扩增产物是什么，怎么扩增出来的</a></p></li></ol><h3 id=\"基本单位\"><a href=\"#基本单位\" class=\"headerlink\" title=\"基本单位\"></a>基本单位</h3><ol><li><p>碱基(A，G，C，T，U)：<br>&nbsp;&nbsp;&nbsp;&nbsp;DNA有四种碱基对，即鸟嘌呤(G),腺嘌呤(A),胞嘧啶(C),胸腺嘧啶(T).其中G与C配对，A与T配对。RNA有A，G，C，U(尿嘧啶)这四种</p></li><li><p>bp：<br>&nbsp;&nbsp;&nbsp;&nbsp; 碱基对的数目单位,100bp即两条链上各有100个碱基.</p></li><li><p>nt：<br>&nbsp;&nbsp;&nbsp;&nbsp;核苷酸的单位，25nt RNA是指25个核苷酸碱基的小RNA</p></li></ol><h2 id=\"RNAi实验相关\"><a href=\"#RNAi实验相关\" class=\"headerlink\" title=\"RNAi实验相关\"></a>RNAi实验相关</h2><ol><li>四要素：<ul><li>目标基因的dsRNA，看需求</li><li>转染或者将dsRNA送入细胞的方法，具体看下面的三种方法</li><li>对照</li><li>检测表达情况的方法，即检验RNAi效果</li></ul></li><li>注意点<ul><li>siRNA长度的选择</li><li>shRNA表达水平太高会导致细胞毒性或脱靶，要防止过表达</li></ul></li><li>三种实现方法</li></ol><div class=\"table-container\"><table><thead><tr><th style=\"text-align:center\">适用类型</th><th style=\"text-align:center\">导入材料</th><th style=\"text-align:center\">过程</th><th style=\"text-align:center\">其他材料</th><th style=\"text-align:center\">沉默类型</th></tr></thead><tbody><tr><td style=\"text-align:center\">非哺乳生物</td><td style=\"text-align:center\">dsRNA</td><td style=\"text-align:center\">导入dsRNA，使用Dicer酶切割dsRNA得到siRNAs，获得RISC诱导沉默复合体，切割靶mRNA</td><td style=\"text-align:center\">Dicer酶</td><td style=\"text-align:center\">瞬时基因沉默3-7天</td></tr><tr><td style=\"text-align:center\">哺乳生物</td><td style=\"text-align:center\">siRNAs</td><td style=\"text-align:center\">直接导入siRNAs，获得RISC，切割靶mRNA</td><td style=\"text-align:center\">无</td><td style=\"text-align:center\">瞬时基因沉默3-7天</td></tr><tr><td style=\"text-align:center\"></td><td style=\"text-align:center\">shRNA的DNA表达载体</td><td style=\"text-align:center\">导入shRNA表达载体，使用Dicer酶切割shRNA，得到siRNAs，后续相同</td><td style=\"text-align:center\">Dicer酶</td><td style=\"text-align:center\">长效基因沉默</td></tr></tbody></table></div><h2 id=\"siRNA设计\"><a href=\"#siRNA设计\" class=\"headerlink\" title=\"siRNA设计\"></a>siRNA设计</h2><h3 id=\"结构和选择标准\"><a href=\"#结构和选择标准\" class=\"headerlink\" title=\"结构和选择标准\"></a>结构和选择标准</h3><ul><li>理想siRNA是23bp，双链部分是19bp，正义链和反义链为21bp，3‘端和5’端分别是两个突出核苷酸</li></ul><div class=\"table-container\"><table><thead><tr><th style=\"text-align:center\"></th><th style=\"text-align:center\">5’端</th><th style=\"text-align:center\">1</th><th style=\"text-align:center\">2</th><th style=\"text-align:center\">3</th><th style=\"text-align:center\">4</th><th style=\"text-align:center\">5…10</th><th style=\"text-align:center\">11…14</th><th style=\"text-align:center\">15…18</th><th style=\"text-align:center\">19</th><th style=\"text-align:center\">20</th><th style=\"text-align:center\">21…23</th><th style=\"text-align:center\">3’端</th></tr></thead><tbody><tr><td style=\"text-align:center\">理想状态</td><td style=\"text-align:center\">第一个核苷酸对沉默作用非必须</td><td style=\"text-align:center\">A</td><td style=\"text-align:center\">A</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">T</td><td style=\"text-align:center\">T</td><td style=\"text-align:center\">UU/TT结尾，抵抗核糖核苷酸酶</td></tr><tr><td style=\"text-align:center\">有效状态</td><td style=\"text-align:center\"></td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">A</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">T</td><td style=\"text-align:center\">T</td><td style=\"text-align:center\">/</td></tr><tr><td style=\"text-align:center\">有效状态</td><td style=\"text-align:center\"></td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">A</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\"></td><td style=\"text-align:center\">—</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">/</td></tr><tr><td style=\"text-align:center\">选择标准(正义链：3-23，21nt)</td><td style=\"text-align:center\"></td><td style=\"text-align:center\">/</td><td style=\"text-align:center\">/</td><td style=\"text-align:center\">5. 为A</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">6. 第十位为U</td><td style=\"text-align:center\">8. 第13位非G</td><td style=\"text-align:center\">2. 15-19位有3+个A/U碱基对</td><td style=\"text-align:center\">4. 为A; 7.不能为G/C</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">/</td></tr></tbody></table></div><div class=\"note info\"><p>正义链：3-23，一般TT结尾<br>反义链：1-21的互补链(A-T, C-G)，一般TT开头</p><p>反义RNA和靶RNA互补配对，参与基因表达调控。分3类：</p><ol><li>直接和靶mRNA的S-D序列或部分编码区结合，抑制翻译，或者结合成双链RNA被RNA酶Ⅲ降解</li><li>和非编码区结合，引起mRNA构象变化，抑制翻译</li><li>直接抑制mRNA转录</li></ol></div><p><strong>选择标准：</strong></p><ol><li>G/C含量=30～52%</li><li>在第15 ～19位核苷酸的位置个或更多的A/U碱基对（正义链）</li><li>发夹结构预测（没有内部重或回文结构）Tm&lt;20℃</li><li>19位核苷酸为A（正义链）</li><li>3位核苷酸为A（正义链）</li><li>10位核苷酸为U（正义链）</li><li>19位核苷酸不能为G或C（正义链）</li><li>13位核苷酸不能为G（正义链）</li></ol><p><strong>符合条件小于6个的舍弃</strong></p><div class=\"note danger\"><ol><li>如果靶序列开始的两个核苷酸不是AA，选择基因编码区的23个核苷酸来计算G-C的百分含量</li><li>大多数G-C含量为30%-52%的siRNA产生的沉默效应较高，但过高的G-C含量会降低沉默活性</li><li>避免超过3个G/C重复，以及4个A重复，多G/C可能干扰siRNA沉默机制，多A会提前终止转录干扰shRNA合成<br>《小干扰RNA的合理设计》中，为2+个G/C降低RNA内在稳定性，3+个U/A可能终止RNA PolymeraseIII介导的转录</li><li>一定要从启动子第100个核苷酸之后开始搜索</li><li>3’-端可以是合适的靶序列，可特异性防止非必要保守基因的沉默</li></ol></div><h3 id=\"设计过程\"><a href=\"#设计过程\" class=\"headerlink\" title=\"设计过程\"></a>设计过程</h3><p>选择：</p><ol><li>在所选基因的启动子<code>100个</code>碱基以后开始自5’-端开始</li><li>寻找基因序列中的23个碱基， 最好是5‘- AA（N19）TT -3’ （N是任何碱基）</li><li>如果找不到以上AA（N19）TT，则用 AA（N21）补足。</li><li>如果找不到以上AA（N21）， 则用 NA（N21）补足。</li><li>所选定序列中，G和C的数目的总和在总数（23）的35-55%.</li><li>满足以上1-5项要求的片段数目如果不足四个，将G和C的数目的总和放宽至总数（23）的30-70%</li></ol><p>确定RNA oligo：</p><ol><li>找到正义链和反义链</li><li>将反义链从3‘-5’反转，变成5’-3’</li><li>将除了3‘末端的两个碱基外，所有的T改成U</li><li>使用BLAST确定唯一性</li></ol><div class=\"note\"><p><strong>注意点：</strong></p><ul><li>GC含量为30-50% 的siRNA最有效</li><li>应选2-4个靶点序列</li></ul><p><strong>需排除的siRNA：</strong></p><ul><li>有4个T/A</li><li>基因组数据库比较，去除和其他序列有16-17同源碱基对的靶序列</li></ul></div><h3 id=\"设置对照\"><a href=\"#设置对照\" class=\"headerlink\" title=\"设置对照\"></a>设置对照</h3><p>所有的RNAi试验均应设立阴性对照，siRNA阴性对照序列的合理设计与siRNA序列的设计同样重要。<br>因为有效的对照可以充分证明siRNA只对靶基因产生特异性基因沉默，从而增强实验的可信度。<br>阴性对照siRNA包括碱基错配或混乱序列的siRNA。<br>在实验中最好设计两条siRNA对照序列</p><p>注：<br>多碱基错配比单碱基错配的siRNA阴性对照序列具有更高的实际应用价值</p><p>设置对照：</p><ul><li>阴性对照siRNA：1）打乱原siRNA核苷酸顺序，且和靶mRNA无同源性; 2）碱基错配</li><li>针对相同基因的其他siRNA：确保siRNA数据可靠的最佳方式</li></ul><h3 id=\"Tuschl法则\"><a href=\"#Tuschl法则\" class=\"headerlink\" title=\"Tuschl法则\"></a>Tuschl法则</h3><p>原始法则：</p><ul><li>21bp + 3’两个碱基，最有效</li></ul><p>新法则：</p><ul><li><p>NA -（A/G）-（N17）-（C/U）- NN<br>正义链和反义链（21nt）siRNA应该以嘌呤核苷酸(A)开头，这对于多聚酶Ⅲ启动子的表达是必须的。</p></li><li><p>（N4）- A -（N6）- T -（N2）-（A/T/C）-（N5）-（A）-（N2）</p></li></ul><h2 id=\"构建shRNA表达载体\"><a href=\"#构建shRNA表达载体\" class=\"headerlink\" title=\"构建shRNA表达载体\"></a>构建shRNA表达载体</h2><h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ol><li>有抗生素标记，可建立稳定的长期基因沉默细胞株，并筛选细胞</li><li>通过病毒插入基因组得到稳定的基因沉默表达细胞株</li></ol><h3 id=\"构建过程\"><a href=\"#构建过程\" class=\"headerlink\" title=\"构建过程\"></a>构建过程</h3><h4 id=\"shRNA序列设计\"><a href=\"#shRNA序列设计\" class=\"headerlink\" title=\"shRNA序列设计\"></a>shRNA序列设计</h4><p>shRNA 由 siRNA 和环状连接序列组成。<br>就是目标 siRNA 与其反向互补序列之间由特定的连接序列间隔，得到的 RNA 两端反向互补退火，与连接序列形成茎环结构，类似发夹。</p><h4 id=\"启动子选择\"><a href=\"#启动子选择\" class=\"headerlink\" title=\"启动子选择\"></a>启动子选择</h4><p>多数siRNA表达载体依赖三种RNA聚合酶III 启动子(pol III)中的一种，操纵一段小的发夹RNA在哺乳动物细胞中的表达，包括U6和H1。<br>因为它可以在哺乳动物细胞中表达更多小分子RNA</p><ol><li>表达产量取决于启动子强弱</li><li>U6>H1，表达时间长，首选，但shRNA要避免3+个U/A，防提前转录</li><li>RNA 聚合酶 II 类的启动子如CMV 启动子和 U1 启动子也比较常见</li><li>shRNA 序列有连续的 U / T 时应该优先考虑 CMV 启动子载体</li></ol><h4 id=\"载体类型选择\"><a href=\"#载体类型选择\" class=\"headerlink\" title=\"载体类型选择\"></a>载体类型选择</h4><ol><li>质粒载体</li><li>病毒表达载体：感染细胞效率高<br>常用的，哺乳动物细胞,病毒载体包括：<br>&nbsp;&nbsp;&nbsp;&nbsp;逆转录病毒(Retrovirus)，腺病毒(Adenovirus)，腺相关病毒(Adeno-Associated Virus,AAV)，和慢病毒(Lentivirus)。<br>其中逆转录病毒和慢病毒等载体，还可以用于构建，整合到染色体上的,稳定的,长期基因沉默细胞株</li></ol><p>具体见<a href=\"https://www.zhihu.com/question/23745748\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">病毒的分类</a><br>研究长期基因沉默，选择逆转录病毒，逆转录病毒也是逆转录类型</p><h4 id=\"抗生素筛选标记\"><a href=\"#抗生素筛选标记\" class=\"headerlink\" title=\"抗生素筛选标记\"></a>抗生素筛选标记</h4><p>最好选一个抗性标记</p><ol><li>非必选，但是可以得到稳定表达shRNA的细胞株，且可检测是否转染</li><li>促进shRNA表达，防止表达减弱影响沉默效果</li></ol><h4 id=\"构建、克隆和测序验证\"><a href=\"#构建、克隆和测序验证\" class=\"headerlink\" title=\"构建、克隆和测序验证\"></a>构建、克隆和测序验证</h4><h2 id=\"结果评测\"><a href=\"#结果评测\" class=\"headerlink\" title=\"结果评测\"></a>结果评测</h2><p>通常从两方面检测，首先是检测mRNA的表达，其次是蛋白表达。如果是移植到小鼠或其他载体上，可以再使用生物学方法检测效果。</p><h3 id=\"mRNA的表达\"><a href=\"#mRNA的表达\" class=\"headerlink\" title=\"mRNA的表达\"></a>mRNA的表达</h3><h4 id=\"RT-PCR\"><a href=\"#RT-PCR\" class=\"headerlink\" title=\"RT-PCR\"></a>RT-PCR</h4><p>最常见的是在转染后24-48小时做定量RT-PCR（逆转录PCR）</p><ol><li>纯化细胞</li><li>选取合适的RNA提取试剂盒和银光RT-PCR试剂盒</li><li>提取RNA，进行扩增</li><li>进行RT-PCR检测，按照说明书操作，配置反应体系，于PCR仪扩增实验</li><li>观察结果</li></ol><h4 id=\"Northern-blot杂交\"><a href=\"#Northern-blot杂交\" class=\"headerlink\" title=\"Northern blot杂交\"></a>Northern blot杂交</h4><img src=\"/Notes/2019-10-01-basic-knowledge-of-RNAi/1.png\" title=\"肿瘤转移抑制基因 KAil 不同转移潜能癌细胞中的表达\"><h4 id=\"原位杂交\"><a href=\"#原位杂交\" class=\"headerlink\" title=\"原位杂交\"></a>原位杂交</h4><p>它即可检测 mRNA 的表达，又可观察 mRNA 的定位，是研究细胞内基因表达及有关因素调控的有效工具Northern blot 分析和 RT-PCR 两种方法只用于检测某 特定的 RNA 片段，它们都只能证明细胞或组织中是否存在待测的核酸而不能证明核酸分子在细胞或组织中存在的部位，不具有定位性，也不能反映组织、细胞、器官的差异</p><h3 id=\"蛋白水平检测\"><a href=\"#蛋白水平检测\" class=\"headerlink\" title=\"蛋白水平检测\"></a>蛋白水平检测</h3><h4 id=\"免疫组化法-immunohistochemistry\"><a href=\"#免疫组化法-immunohistochemistry\" class=\"headerlink\" title=\"免疫组化法(immunohistochemistry)\"></a>免疫组化法(immunohistochemistry)</h4><ul><li><strong>原理：</strong>免疫组化，免疫组化，是应用免疫学基本原理——抗原抗体反应，即抗原与抗体特异性结合的原理，通过化学反应使标记抗体的显色剂（荧光素、酶、金属离子、同位素）显色来确定组织细胞内抗原（多肽和蛋白质），对其进行定位、定性及定量的研究，称为免疫组织化学技术(immunohistochemistry)或免疫细胞化学技术(immunocytochemistry)。</li><li><strong>特点：</strong>是融合了免疫学原理（抗原抗体特异性结合）和组织学技术（组织的取材、固定、包埋、切片、脱蜡、水化等），通过化学反应使标记抗体的显色剂(荧光素、酶、金属离子、同位素)显色，来对组织（细胞）内抗原进行定位、定性及定量的研究(主要是定位)。样本是细胞或组织，要在显微镜下观察结果，可能出现膜阳性、质阳性和核阳性。</li></ul><h4 id=\"蛋白免疫印迹-Western-Blot\"><a href=\"#蛋白免疫印迹-Western-Blot\" class=\"headerlink\" title=\"蛋白免疫印迹( Western Blot)\"></a>蛋白免疫印迹( Western Blot)</h4><ul><li><strong>原理：</strong>蛋白质印迹法是将电泳分离后的细胞或组织总蛋白质从凝胶转移到固相支持物NC膜或PVDF膜上，然后用特异性抗体检测某特定抗原的一种蛋白质检测技术。</li><li><strong>特点：</strong>先要进行SDS-PAGE，然后将分离开的蛋白质样品用电转仪转移到固相载体上，而后利用抗原-抗体-标记物显色来检测样品，可以用于定性和半定量。</li></ul><h4 id=\"ELISA检测\"><a href=\"#ELISA检测\" class=\"headerlink\" title=\"ELISA检测\"></a>ELISA检测</h4><ul><li><strong>原理：</strong>酶联免疫吸附剂测定法，简称酶联免疫法，或者ELISA法，它的中心就是让抗体与酶复合物结合，然后通过显色来检测。</li><li><strong>特点：</strong>用到了免疫学原理和化学反应显色，待测的样品多是血清、血浆、尿液、细胞或组织培养上清液，因而没有用到组织包埋、切片等技术，这是与免疫组化的主要区别，操作上 开始需要将抗原或抗体结合到固相载体表面，从而使后来形成的抗原-抗体-酶-底物复合物粘附在载体上，这就是“吸附”的含义。</li></ul><h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><p>具体的还是参看<a href=\"https://wenku.baidu.com/view/67f81ad7d4bbfd0a79563c1ec5da50e2524dd102.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">蛋白表达不同检测表达方式的比较和分析</a><br><img src=\"/Notes/2019-10-01-basic-knowledge-of-RNAi/2.png\" title=\"蛋白表达不同检测表达方式的比较和分析\"></p><h2 id=\"miRNA\"><a href=\"#miRNA\" class=\"headerlink\" title=\"miRNA\"></a>miRNA</h2><p>RNAi的重要工具</p><p>这种内源性的非编码区小分子 RNA 针对 3’端非编码区，有着极高的保守性，并在组织中广泛表达，可在转录后以及翻译水平上调控基因表达，可能在不影响 mRNA 的水平下调控基因表达</p><p><strong>和siRNA区别：</strong></p><ul><li>内源而非外源序列</li><li>针对非编码区</li><li>物种进化极为高度保守</li><li>组织中广泛表达</li><li>miRNA 可能调控多种关键基因</li><li>可在转录后以及翻译水平上调控基因表达，可能在不影响 mRNA 的水平下调控基因表达</li></ul><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"《小干扰RNA的合理设计》总结\"><a href=\"#《小干扰RNA的合理设计》总结\" class=\"headerlink\" title=\"《小干扰RNA的合理设计》总结\"></a>《小干扰RNA的合理设计》总结</h3><ul><li>RNAi主要是要通过siRNA和靶基因结合并使之降解，所以siRNA要和靶基因高度同源，但是不和其他基因同源。</li><li>搜索siRNA时，靠近基因的3‘端的比较好</li><li>有研究表明，5’UTR是一个高保守区，使之成为siRNA理想的靶点，RNAi作用于5‘UTR或3’UTR序列，也可以引起靶基因沉默</li><li>27nt或者29nt的siRNA效果更好，27nt或29nt的siRNA与21ntsiRNA相比：<blockquote><p>(1)其抑制活性可提高数倍以上；<br>(2)不易于诱导干扰素反应和激活PKR；<br>(3)一些基因对21ntsiRNA不敏感，但是可以被27ntsiRNA有效的抑制；<br>(4)与21ntSiRNA相比，27ntSiRNA对靶基因的最大抑制率可在相对低的浓度下得到</p></blockquote></li><li>每一个靶基因，应该设计4+条siRNA</li><li>只能根据标准设计出理论较高沉默效应的siRNA，最终活性要用实验验证</li><li>关于shRNA的发夹环长度，3-10nt都可以，Brummelkamp研究表明9nt的抑制率高，Siolas表明长度没有明显影响</li><li>每个RNAi实验都要设置阴性对照。具体见上文</li></ul><h3 id=\"《高效siRNA的设计分析》总结\"><a href=\"#《高效siRNA的设计分析》总结\" class=\"headerlink\" title=\"《高效siRNA的设计分析》总结\"></a>《高效siRNA的设计分析》总结</h3><ol><li>RNAi实验一般流程如下：<ul><li>准备材料，包括目标基因，shRNA表达载体，限制性核酸内切酶等</li><li>siRNA的设计和筛选</li><li>重组表达载体的构建</li><li>含靶基因的细胞的分离培养和转染</li><li>RT-PCR的检测和靶基因的表达</li><li>分析结果并总结</li></ul></li><li>一些结论<ul><li>和siRNA结合的<script type=\"math/tex\">AG0_2</script>蛋白主要识别5‘端为A的siRNA，因此5’端为A的siRNA对其进入RISC复合体及对靶mRNA的识别具有关键作用</li><li>正义链5’端具有更多的G/C对siRNA的功能提高非常重要，第19位为G/C也更具有RNAi活力</li><li>反义链的第19位G/C真的对siRNA的高功能性存在相关性有待验证</li><li>高效的siRNA反义链的第13位优先为 A／U，即不为G/C</li><li>反义链第10位为 U 作用强于A，优先考虑</li><li>综合考虑反义链第3,7,14,16,17位还是有必要的</li><li>对zfy基因来说，siRNA靶点在1000bp以内，即第3-6外显子上设计高效siRNA的可能性更大，最好位于150bp-800bp</li></ul></li><li>这个论文主要是记录了一整个siRNA实验以及分析过程，可以作为以后siRNA实验的参考</li></ol><h2 id=\"拓展阅读\"><a href=\"#拓展阅读\" class=\"headerlink\" title=\"拓展阅读\"></a>拓展阅读</h2><ol><li><a href=\"http://dict.bioon.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">生物医药大词典</a></li><li><a href=\"http://www.labome.cn/method/siRNAs-and-shRNAs-Tools-for-Protein-Knockdown-by-Gene-Silencing.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">siRNA和shRNA:通过基因沉默抑制蛋白表达的工具</a></li><li><a href=\"https://wenku.baidu.com/view/b3571b7c192e45361066f5ca.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Argonaute蛋白结构与功能</a></li><li><a href=\"http://www.televector.com/9171223659.pdf\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">张美红，周克元.小干扰RNA的合理设计[J].肿瘤防治研究，2006， 33（11）：837-839</a></li><li><a href=\"https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2017&amp;filename=HLJX201701028\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">秦炳燕，张永生，纪俊明等.高效siRNA的设计分析[B].黑龙江畜牧兽医，2017（1）：109-113，294</a></li><li><a href=\"https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2017&amp;filename=1017152231.nh\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">韩烨.基于机器学习的siRNA沉默效率预测方法研究[D].吉林省：吉林大学，2019</a></li><li><a href=\"https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CAPJ&amp;dbname=CAPJLAST&amp;filename=SDYB20190926000\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">薛婷，王黎明，焦今文等.siRNA介导RRM2基因沉默治疗人卵巢癌裸鼠移植瘤[J].山东大学学报，2019，57（10）</a></li><li><a href=\"http://kns.cnki.net/KCMS/detail/detail.aspx?dbname=cjfd2000&amp;filename=hnyk200002007\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">李珊珊,任秀花,闫爱华,方伟岗.3种mRNA检测方法比较[J].河南医科大学学报，2000，35（2）：113-114</a></li><li><a href=\"https://wenku.baidu.com/view/67f81ad7d4bbfd0a79563c1ec5da50e2524dd102.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">蛋白表达不同检测表达方式的比较和分析</a></li><li><a href=\"http://kns.cnki.net//KXReader/Detail?TIMESTAMP=637062394829091250&amp;DBCODE=CJFD&amp;TABLEName=CJFD9899&amp;FileName=ZHYX199909026&amp;RESULT=1&amp;SIGN=kvPorAe14Lw3IYsBq017HIfdCF4%3d\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">李珊珊，方伟岗，钟销销，等 肿瘤转移抑制基因 KAil 不同转移潜能癌细胞中的表达．中华医学杂志，1999,(9): 708</a></li></ol><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>刚接触siRNA搜索、设计和评测这方面的研究，记录一下基本的概念和一些基础知识，还有自己的理解总结。</p></div>","more":"<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><h3 id=\"英文缩写\"><a href=\"#英文缩写\" class=\"headerlink\" title=\"英文缩写\"></a>英文缩写</h3><ol><li>RNAi：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RNA干扰</li><li>siRNA：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小干扰RNA</li><li>dsRNA：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Double-stranded RNA的缩写，是指双链核糖核酸</li><li><a href=\"https://baike.baidu.com/item/shRNA\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">shRNA</a>：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是英文单词short hairpin RNA的缩写。翻译为“短发夹RNA”。shRNA包括两个短反向重复序列。克隆到shRNA表达载体中的shRNA包括两个短反向重复序列，中间由一茎环（loop）序列分隔的，组成发夹结构，由polⅢ启动子控制。随后再连上5-6个T作为RNA聚合酶Ⅲ的转录终止子。</li><li>Argonaute (AGO)：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一类庞大的蛋白质家族，是组成RISCs复合物的主要成员。AGO蛋白质主要包含两个结构域：PAZ和PIWI两个结构域，但具体功能现在尚不清楚。</li><li><p>Dicer酶：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是RNAase Ⅲ家族中的一员，主要切割dsRNA或者茎环结构的RNA前体成为小RNAs分子。对应地，我们将这种小RNAs分子命名为siRNAs和miRNA。Dicer有着较多的结构域，最先在果蝇中发现，并且在不同的生物体上表现出很高的保守性。</p></li><li><p>RISC：RISC诱导沉默复合体（全称：RNA-induced silencing complex）：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种由siRNA与Argonaute蛋白和Dicer酶复合形成的复合物。在RNAi中，利用siRNA的反义链切割靶mRNA，达到基因沉默。</p></li><li><p>BLAST (Basic Local Alignment Search Tool)：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是一套在蛋白质数据库或DNA数据库中进行相似性比较的分析工具。BLAST程序能迅速与公开数据库进行相似性序列比较。BLAST结果中的得分是对一种对相似性的统计说明。</p></li><li><p>rRNA（核糖体RNA）是核糖体的组成成分,它和蛋白质共同组成了核糖体.<br>tRNA（转运RNA）可以转运氨基酸.<br>mRNA（信使RNA）是由细胞核内的DNA转录来的,相当于蛋白质的设计图纸.</p></li><li><p>UTR：非翻译区</p></li><li><p><a href=\"http://www.baike.com/wiki/SD%E5%BA%8F%E5%88%97\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">SD序列</a>：mRNA起始部位的碱基序列，为mRNA与核糖体的结合位点称SD序列.在DNA上相应的位点也称SD序列，一般位于操纵基因和第一个结构基因之间，部分序列与操纵基因重叠.</p></li></ol><h3 id=\"名词概念\"><a href=\"#名词概念\" class=\"headerlink\" title=\"名词概念\"></a>名词概念</h3><ol><li>质粒：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小型环状DNA分子，包括三部分：遗传标记基因，复制区，目的基因.在所有的细菌类群中都可发现，它们是独立于细菌染色体外自我复制的DNA分子</li><li><p>质粒载体：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;质粒载体是在天然质粒的基础上为适应实验室操作而进行人工构建的质粒。与天然质粒相比，质粒载体通常带有一个或一个以上的选择性标记基因（如抗生素抗性基因）和一个人工合成的含有多个限制性内切酶识别位点的多克隆位点序列，并去掉了大部分非必需序列，使分子量尽可能减少，以便于基因工程操作</p></li><li><p>转染：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是真核细胞主动或被动导入外源DNA片段而获得新的表型的过程</p></li><li><p>细胞株：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过选择法或克隆形成法从原代培养物或细胞系中获得具有特殊性质或标志物的培养物称为细胞株。<br>细胞株是用单细胞分离培养或通过筛选的方法，由单细胞增殖形成的细胞群。细胞株的特殊性质或标志必须在整个培养期间始终存在。原代培养物经首次传代成功后即为细胞系(cell line)， 由原先存在于原代培养物中的细胞世系所组成。如果不能继续传代，或传代次数有限， 可称为有限细胞系(finite cell line)， 如可以连续培养， 则称为连续细胞系(continuous cell line)， 培养50代以上并无限培养下去。 所以细胞株是通过选择法或克隆形成法从原代培养物或细胞系中获得的具有特殊性质或标志的培养细胞。从培养代数来讲，可培养到40-50代。细胞株的特殊性质或标志必须在整个培养期间始终存在。对于人类肿瘤细胞，在体外培养半年以上，生长稳定，并连续传代的即可称为连续性株或系。</p></li><li><p>核酸酶：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能够将聚核苷酸链的磷酸二酯键切断的酶，称为核酸酶。 有些核酸酶只能作用于RNA，称为核糖核酸酶（RNase），有些核酸酶只能作用于DNA，称为脱氧核糖核酸酶（DNase），有些核酸酶专一性较低，既能作用于RNA也能作用于DNA，因此统称为核酸酶（nuclease）。根据核酸酶作用的位置不同，又可将核酸酶分为核酸外切酶（exonuclease）和核酸内切酶</p></li><li><p>逆转录病毒：<a href=\"https://www.zhihu.com/question/23745748\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">病毒的分类</a></p></li><li><p><a href=\"https://www.zhihu.com/question/21112790\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">DNA中的3’端和5’端</a></p></li><li><p>化学修饰：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凡通过化学基团的引入或除去，而使蛋白质或核酸共价结构发生改变的现象。它以引起酶分子共价键的变化、化学结构的改变而影响酶活性。酶的化学修饰是在另一种酶的催化下完成的，是体内快速调节的另一种重要方式。</p></li><li><p>正义链：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与转录出的mRNA序列相同的（DNA中的T在RNA中为U）那条DNA单链那条链为正义链，与之互补的为反义链。</p></li><li><p>PCR扩增产物：可分为长产物片段和短产物片段两部分。短产物指数倍增加，长产物算术倍增加，所以重复多次后，可以忽略长产物，得到的是目的基因。<br>反应体系由模板DNA、一对引物、dNTP、耐高温的DNA聚合酶、酶反应缓冲体系及必须的离子等所组成。PCR反应循环的第一步为加热变性，使双链模板DNA变性为单链；第二步为复性，每个引物将与互补的DNA序列杂交；第三步为延伸，在耐高温的DNA聚合酶作用下，以变性的单链DNA为模板，从引物3ˊ端开始按5ˊ→3ˊ方向合成DNA链。这样经过一个周期的变性——复性——延伸等三步反应就可以产生倍增的DNA，假设PCR的效率为100%,反复n周期后，理论上就能扩增2n倍。PCR反应一般30-40次循环，DNA片段可放大数百万倍。<br>见<a href=\"https://zhidao.baidu.com/question/345141221.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">PCR的扩增产物是什么，怎么扩增出来的</a></p></li></ol><h3 id=\"基本单位\"><a href=\"#基本单位\" class=\"headerlink\" title=\"基本单位\"></a>基本单位</h3><ol><li><p>碱基(A，G，C，T，U)：<br>&nbsp;&nbsp;&nbsp;&nbsp;DNA有四种碱基对，即鸟嘌呤(G),腺嘌呤(A),胞嘧啶(C),胸腺嘧啶(T).其中G与C配对，A与T配对。RNA有A，G，C，U(尿嘧啶)这四种</p></li><li><p>bp：<br>&nbsp;&nbsp;&nbsp;&nbsp; 碱基对的数目单位,100bp即两条链上各有100个碱基.</p></li><li><p>nt：<br>&nbsp;&nbsp;&nbsp;&nbsp;核苷酸的单位，25nt RNA是指25个核苷酸碱基的小RNA</p></li></ol><h2 id=\"RNAi实验相关\"><a href=\"#RNAi实验相关\" class=\"headerlink\" title=\"RNAi实验相关\"></a>RNAi实验相关</h2><ol><li>四要素：<ul><li>目标基因的dsRNA，看需求</li><li>转染或者将dsRNA送入细胞的方法，具体看下面的三种方法</li><li>对照</li><li>检测表达情况的方法，即检验RNAi效果</li></ul></li><li>注意点<ul><li>siRNA长度的选择</li><li>shRNA表达水平太高会导致细胞毒性或脱靶，要防止过表达</li></ul></li><li>三种实现方法</li></ol><div class=\"table-container\"><table><thead><tr><th style=\"text-align:center\">适用类型</th><th style=\"text-align:center\">导入材料</th><th style=\"text-align:center\">过程</th><th style=\"text-align:center\">其他材料</th><th style=\"text-align:center\">沉默类型</th></tr></thead><tbody><tr><td style=\"text-align:center\">非哺乳生物</td><td style=\"text-align:center\">dsRNA</td><td style=\"text-align:center\">导入dsRNA，使用Dicer酶切割dsRNA得到siRNAs，获得RISC诱导沉默复合体，切割靶mRNA</td><td style=\"text-align:center\">Dicer酶</td><td style=\"text-align:center\">瞬时基因沉默3-7天</td></tr><tr><td style=\"text-align:center\">哺乳生物</td><td style=\"text-align:center\">siRNAs</td><td style=\"text-align:center\">直接导入siRNAs，获得RISC，切割靶mRNA</td><td style=\"text-align:center\">无</td><td style=\"text-align:center\">瞬时基因沉默3-7天</td></tr><tr><td style=\"text-align:center\"></td><td style=\"text-align:center\">shRNA的DNA表达载体</td><td style=\"text-align:center\">导入shRNA表达载体，使用Dicer酶切割shRNA，得到siRNAs，后续相同</td><td style=\"text-align:center\">Dicer酶</td><td style=\"text-align:center\">长效基因沉默</td></tr></tbody></table></div><h2 id=\"siRNA设计\"><a href=\"#siRNA设计\" class=\"headerlink\" title=\"siRNA设计\"></a>siRNA设计</h2><h3 id=\"结构和选择标准\"><a href=\"#结构和选择标准\" class=\"headerlink\" title=\"结构和选择标准\"></a>结构和选择标准</h3><ul><li>理想siRNA是23bp，双链部分是19bp，正义链和反义链为21bp，3‘端和5’端分别是两个突出核苷酸</li></ul><div class=\"table-container\"><table><thead><tr><th style=\"text-align:center\"></th><th style=\"text-align:center\">5’端</th><th style=\"text-align:center\">1</th><th style=\"text-align:center\">2</th><th style=\"text-align:center\">3</th><th style=\"text-align:center\">4</th><th style=\"text-align:center\">5…10</th><th style=\"text-align:center\">11…14</th><th style=\"text-align:center\">15…18</th><th style=\"text-align:center\">19</th><th style=\"text-align:center\">20</th><th style=\"text-align:center\">21…23</th><th style=\"text-align:center\">3’端</th></tr></thead><tbody><tr><td style=\"text-align:center\">理想状态</td><td style=\"text-align:center\">第一个核苷酸对沉默作用非必须</td><td style=\"text-align:center\">A</td><td style=\"text-align:center\">A</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">T</td><td style=\"text-align:center\">T</td><td style=\"text-align:center\">UU/TT结尾，抵抗核糖核苷酸酶</td></tr><tr><td style=\"text-align:center\">有效状态</td><td style=\"text-align:center\"></td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">A</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">T</td><td style=\"text-align:center\">T</td><td style=\"text-align:center\">/</td></tr><tr><td style=\"text-align:center\">有效状态</td><td style=\"text-align:center\"></td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">A</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\"></td><td style=\"text-align:center\">—</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">/</td></tr><tr><td style=\"text-align:center\">选择标准(正义链：3-23，21nt)</td><td style=\"text-align:center\"></td><td style=\"text-align:center\">/</td><td style=\"text-align:center\">/</td><td style=\"text-align:center\">5. 为A</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">6. 第十位为U</td><td style=\"text-align:center\">8. 第13位非G</td><td style=\"text-align:center\">2. 15-19位有3+个A/U碱基对</td><td style=\"text-align:center\">4. 为A; 7.不能为G/C</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">-</td><td style=\"text-align:center\">/</td></tr></tbody></table></div><div class=\"note info\"><p>正义链：3-23，一般TT结尾<br>反义链：1-21的互补链(A-T, C-G)，一般TT开头</p><p>反义RNA和靶RNA互补配对，参与基因表达调控。分3类：</p><ol><li>直接和靶mRNA的S-D序列或部分编码区结合，抑制翻译，或者结合成双链RNA被RNA酶Ⅲ降解</li><li>和非编码区结合，引起mRNA构象变化，抑制翻译</li><li>直接抑制mRNA转录</li></ol></div><p><strong>选择标准：</strong></p><ol><li>G/C含量=30～52%</li><li>在第15 ～19位核苷酸的位置个或更多的A/U碱基对（正义链）</li><li>发夹结构预测（没有内部重或回文结构）Tm&lt;20℃</li><li>19位核苷酸为A（正义链）</li><li>3位核苷酸为A（正义链）</li><li>10位核苷酸为U（正义链）</li><li>19位核苷酸不能为G或C（正义链）</li><li>13位核苷酸不能为G（正义链）</li></ol><p><strong>符合条件小于6个的舍弃</strong></p><div class=\"note danger\"><ol><li>如果靶序列开始的两个核苷酸不是AA，选择基因编码区的23个核苷酸来计算G-C的百分含量</li><li>大多数G-C含量为30%-52%的siRNA产生的沉默效应较高，但过高的G-C含量会降低沉默活性</li><li>避免超过3个G/C重复，以及4个A重复，多G/C可能干扰siRNA沉默机制，多A会提前终止转录干扰shRNA合成<br>《小干扰RNA的合理设计》中，为2+个G/C降低RNA内在稳定性，3+个U/A可能终止RNA PolymeraseIII介导的转录</li><li>一定要从启动子第100个核苷酸之后开始搜索</li><li>3’-端可以是合适的靶序列，可特异性防止非必要保守基因的沉默</li></ol></div><h3 id=\"设计过程\"><a href=\"#设计过程\" class=\"headerlink\" title=\"设计过程\"></a>设计过程</h3><p>选择：</p><ol><li>在所选基因的启动子<code>100个</code>碱基以后开始自5’-端开始</li><li>寻找基因序列中的23个碱基， 最好是5‘- AA（N19）TT -3’ （N是任何碱基）</li><li>如果找不到以上AA（N19）TT，则用 AA（N21）补足。</li><li>如果找不到以上AA（N21）， 则用 NA（N21）补足。</li><li>所选定序列中，G和C的数目的总和在总数（23）的35-55%.</li><li>满足以上1-5项要求的片段数目如果不足四个，将G和C的数目的总和放宽至总数（23）的30-70%</li></ol><p>确定RNA oligo：</p><ol><li>找到正义链和反义链</li><li>将反义链从3‘-5’反转，变成5’-3’</li><li>将除了3‘末端的两个碱基外，所有的T改成U</li><li>使用BLAST确定唯一性</li></ol><div class=\"note\"><p><strong>注意点：</strong></p><ul><li>GC含量为30-50% 的siRNA最有效</li><li>应选2-4个靶点序列</li></ul><p><strong>需排除的siRNA：</strong></p><ul><li>有4个T/A</li><li>基因组数据库比较，去除和其他序列有16-17同源碱基对的靶序列</li></ul></div><h3 id=\"设置对照\"><a href=\"#设置对照\" class=\"headerlink\" title=\"设置对照\"></a>设置对照</h3><p>所有的RNAi试验均应设立阴性对照，siRNA阴性对照序列的合理设计与siRNA序列的设计同样重要。<br>因为有效的对照可以充分证明siRNA只对靶基因产生特异性基因沉默，从而增强实验的可信度。<br>阴性对照siRNA包括碱基错配或混乱序列的siRNA。<br>在实验中最好设计两条siRNA对照序列</p><p>注：<br>多碱基错配比单碱基错配的siRNA阴性对照序列具有更高的实际应用价值</p><p>设置对照：</p><ul><li>阴性对照siRNA：1）打乱原siRNA核苷酸顺序，且和靶mRNA无同源性; 2）碱基错配</li><li>针对相同基因的其他siRNA：确保siRNA数据可靠的最佳方式</li></ul><h3 id=\"Tuschl法则\"><a href=\"#Tuschl法则\" class=\"headerlink\" title=\"Tuschl法则\"></a>Tuschl法则</h3><p>原始法则：</p><ul><li>21bp + 3’两个碱基，最有效</li></ul><p>新法则：</p><ul><li><p>NA -（A/G）-（N17）-（C/U）- NN<br>正义链和反义链（21nt）siRNA应该以嘌呤核苷酸(A)开头，这对于多聚酶Ⅲ启动子的表达是必须的。</p></li><li><p>（N4）- A -（N6）- T -（N2）-（A/T/C）-（N5）-（A）-（N2）</p></li></ul><h2 id=\"构建shRNA表达载体\"><a href=\"#构建shRNA表达载体\" class=\"headerlink\" title=\"构建shRNA表达载体\"></a>构建shRNA表达载体</h2><h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ol><li>有抗生素标记，可建立稳定的长期基因沉默细胞株，并筛选细胞</li><li>通过病毒插入基因组得到稳定的基因沉默表达细胞株</li></ol><h3 id=\"构建过程\"><a href=\"#构建过程\" class=\"headerlink\" title=\"构建过程\"></a>构建过程</h3><h4 id=\"shRNA序列设计\"><a href=\"#shRNA序列设计\" class=\"headerlink\" title=\"shRNA序列设计\"></a>shRNA序列设计</h4><p>shRNA 由 siRNA 和环状连接序列组成。<br>就是目标 siRNA 与其反向互补序列之间由特定的连接序列间隔，得到的 RNA 两端反向互补退火，与连接序列形成茎环结构，类似发夹。</p><h4 id=\"启动子选择\"><a href=\"#启动子选择\" class=\"headerlink\" title=\"启动子选择\"></a>启动子选择</h4><p>多数siRNA表达载体依赖三种RNA聚合酶III 启动子(pol III)中的一种，操纵一段小的发夹RNA在哺乳动物细胞中的表达，包括U6和H1。<br>因为它可以在哺乳动物细胞中表达更多小分子RNA</p><ol><li>表达产量取决于启动子强弱</li><li>U6>H1，表达时间长，首选，但shRNA要避免3+个U/A，防提前转录</li><li>RNA 聚合酶 II 类的启动子如CMV 启动子和 U1 启动子也比较常见</li><li>shRNA 序列有连续的 U / T 时应该优先考虑 CMV 启动子载体</li></ol><h4 id=\"载体类型选择\"><a href=\"#载体类型选择\" class=\"headerlink\" title=\"载体类型选择\"></a>载体类型选择</h4><ol><li>质粒载体</li><li>病毒表达载体：感染细胞效率高<br>常用的，哺乳动物细胞,病毒载体包括：<br>&nbsp;&nbsp;&nbsp;&nbsp;逆转录病毒(Retrovirus)，腺病毒(Adenovirus)，腺相关病毒(Adeno-Associated Virus,AAV)，和慢病毒(Lentivirus)。<br>其中逆转录病毒和慢病毒等载体，还可以用于构建，整合到染色体上的,稳定的,长期基因沉默细胞株</li></ol><p>具体见<a href=\"https://www.zhihu.com/question/23745748\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">病毒的分类</a><br>研究长期基因沉默，选择逆转录病毒，逆转录病毒也是逆转录类型</p><h4 id=\"抗生素筛选标记\"><a href=\"#抗生素筛选标记\" class=\"headerlink\" title=\"抗生素筛选标记\"></a>抗生素筛选标记</h4><p>最好选一个抗性标记</p><ol><li>非必选，但是可以得到稳定表达shRNA的细胞株，且可检测是否转染</li><li>促进shRNA表达，防止表达减弱影响沉默效果</li></ol><h4 id=\"构建、克隆和测序验证\"><a href=\"#构建、克隆和测序验证\" class=\"headerlink\" title=\"构建、克隆和测序验证\"></a>构建、克隆和测序验证</h4><h2 id=\"结果评测\"><a href=\"#结果评测\" class=\"headerlink\" title=\"结果评测\"></a>结果评测</h2><p>通常从两方面检测，首先是检测mRNA的表达，其次是蛋白表达。如果是移植到小鼠或其他载体上，可以再使用生物学方法检测效果。</p><h3 id=\"mRNA的表达\"><a href=\"#mRNA的表达\" class=\"headerlink\" title=\"mRNA的表达\"></a>mRNA的表达</h3><h4 id=\"RT-PCR\"><a href=\"#RT-PCR\" class=\"headerlink\" title=\"RT-PCR\"></a>RT-PCR</h4><p>最常见的是在转染后24-48小时做定量RT-PCR（逆转录PCR）</p><ol><li>纯化细胞</li><li>选取合适的RNA提取试剂盒和银光RT-PCR试剂盒</li><li>提取RNA，进行扩增</li><li>进行RT-PCR检测，按照说明书操作，配置反应体系，于PCR仪扩增实验</li><li>观察结果</li></ol><h4 id=\"Northern-blot杂交\"><a href=\"#Northern-blot杂交\" class=\"headerlink\" title=\"Northern blot杂交\"></a>Northern blot杂交</h4><img src=\"/Notes/2019-10-01-basic-knowledge-of-RNAi/1.png\" title=\"肿瘤转移抑制基因 KAil 不同转移潜能癌细胞中的表达\"><h4 id=\"原位杂交\"><a href=\"#原位杂交\" class=\"headerlink\" title=\"原位杂交\"></a>原位杂交</h4><p>它即可检测 mRNA 的表达，又可观察 mRNA 的定位，是研究细胞内基因表达及有关因素调控的有效工具Northern blot 分析和 RT-PCR 两种方法只用于检测某 特定的 RNA 片段，它们都只能证明细胞或组织中是否存在待测的核酸而不能证明核酸分子在细胞或组织中存在的部位，不具有定位性，也不能反映组织、细胞、器官的差异</p><h3 id=\"蛋白水平检测\"><a href=\"#蛋白水平检测\" class=\"headerlink\" title=\"蛋白水平检测\"></a>蛋白水平检测</h3><h4 id=\"免疫组化法-immunohistochemistry\"><a href=\"#免疫组化法-immunohistochemistry\" class=\"headerlink\" title=\"免疫组化法(immunohistochemistry)\"></a>免疫组化法(immunohistochemistry)</h4><ul><li><strong>原理：</strong>免疫组化，免疫组化，是应用免疫学基本原理——抗原抗体反应，即抗原与抗体特异性结合的原理，通过化学反应使标记抗体的显色剂（荧光素、酶、金属离子、同位素）显色来确定组织细胞内抗原（多肽和蛋白质），对其进行定位、定性及定量的研究，称为免疫组织化学技术(immunohistochemistry)或免疫细胞化学技术(immunocytochemistry)。</li><li><strong>特点：</strong>是融合了免疫学原理（抗原抗体特异性结合）和组织学技术（组织的取材、固定、包埋、切片、脱蜡、水化等），通过化学反应使标记抗体的显色剂(荧光素、酶、金属离子、同位素)显色，来对组织（细胞）内抗原进行定位、定性及定量的研究(主要是定位)。样本是细胞或组织，要在显微镜下观察结果，可能出现膜阳性、质阳性和核阳性。</li></ul><h4 id=\"蛋白免疫印迹-Western-Blot\"><a href=\"#蛋白免疫印迹-Western-Blot\" class=\"headerlink\" title=\"蛋白免疫印迹( Western Blot)\"></a>蛋白免疫印迹( Western Blot)</h4><ul><li><strong>原理：</strong>蛋白质印迹法是将电泳分离后的细胞或组织总蛋白质从凝胶转移到固相支持物NC膜或PVDF膜上，然后用特异性抗体检测某特定抗原的一种蛋白质检测技术。</li><li><strong>特点：</strong>先要进行SDS-PAGE，然后将分离开的蛋白质样品用电转仪转移到固相载体上，而后利用抗原-抗体-标记物显色来检测样品，可以用于定性和半定量。</li></ul><h4 id=\"ELISA检测\"><a href=\"#ELISA检测\" class=\"headerlink\" title=\"ELISA检测\"></a>ELISA检测</h4><ul><li><strong>原理：</strong>酶联免疫吸附剂测定法，简称酶联免疫法，或者ELISA法，它的中心就是让抗体与酶复合物结合，然后通过显色来检测。</li><li><strong>特点：</strong>用到了免疫学原理和化学反应显色，待测的样品多是血清、血浆、尿液、细胞或组织培养上清液，因而没有用到组织包埋、切片等技术，这是与免疫组化的主要区别，操作上 开始需要将抗原或抗体结合到固相载体表面，从而使后来形成的抗原-抗体-酶-底物复合物粘附在载体上，这就是“吸附”的含义。</li></ul><h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><p>具体的还是参看<a href=\"https://wenku.baidu.com/view/67f81ad7d4bbfd0a79563c1ec5da50e2524dd102.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">蛋白表达不同检测表达方式的比较和分析</a><br><img src=\"/Notes/2019-10-01-basic-knowledge-of-RNAi/2.png\" title=\"蛋白表达不同检测表达方式的比较和分析\"></p><h2 id=\"miRNA\"><a href=\"#miRNA\" class=\"headerlink\" title=\"miRNA\"></a>miRNA</h2><p>RNAi的重要工具</p><p>这种内源性的非编码区小分子 RNA 针对 3’端非编码区，有着极高的保守性，并在组织中广泛表达，可在转录后以及翻译水平上调控基因表达，可能在不影响 mRNA 的水平下调控基因表达</p><p><strong>和siRNA区别：</strong></p><ul><li>内源而非外源序列</li><li>针对非编码区</li><li>物种进化极为高度保守</li><li>组织中广泛表达</li><li>miRNA 可能调控多种关键基因</li><li>可在转录后以及翻译水平上调控基因表达，可能在不影响 mRNA 的水平下调控基因表达</li></ul><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"《小干扰RNA的合理设计》总结\"><a href=\"#《小干扰RNA的合理设计》总结\" class=\"headerlink\" title=\"《小干扰RNA的合理设计》总结\"></a>《小干扰RNA的合理设计》总结</h3><ul><li>RNAi主要是要通过siRNA和靶基因结合并使之降解，所以siRNA要和靶基因高度同源，但是不和其他基因同源。</li><li>搜索siRNA时，靠近基因的3‘端的比较好</li><li>有研究表明，5’UTR是一个高保守区，使之成为siRNA理想的靶点，RNAi作用于5‘UTR或3’UTR序列，也可以引起靶基因沉默</li><li>27nt或者29nt的siRNA效果更好，27nt或29nt的siRNA与21ntsiRNA相比：<blockquote><p>(1)其抑制活性可提高数倍以上；<br>(2)不易于诱导干扰素反应和激活PKR；<br>(3)一些基因对21ntsiRNA不敏感，但是可以被27ntsiRNA有效的抑制；<br>(4)与21ntSiRNA相比，27ntSiRNA对靶基因的最大抑制率可在相对低的浓度下得到</p></blockquote></li><li>每一个靶基因，应该设计4+条siRNA</li><li>只能根据标准设计出理论较高沉默效应的siRNA，最终活性要用实验验证</li><li>关于shRNA的发夹环长度，3-10nt都可以，Brummelkamp研究表明9nt的抑制率高，Siolas表明长度没有明显影响</li><li>每个RNAi实验都要设置阴性对照。具体见上文</li></ul><h3 id=\"《高效siRNA的设计分析》总结\"><a href=\"#《高效siRNA的设计分析》总结\" class=\"headerlink\" title=\"《高效siRNA的设计分析》总结\"></a>《高效siRNA的设计分析》总结</h3><ol><li>RNAi实验一般流程如下：<ul><li>准备材料，包括目标基因，shRNA表达载体，限制性核酸内切酶等</li><li>siRNA的设计和筛选</li><li>重组表达载体的构建</li><li>含靶基因的细胞的分离培养和转染</li><li>RT-PCR的检测和靶基因的表达</li><li>分析结果并总结</li></ul></li><li>一些结论<ul><li>和siRNA结合的<script type=\"math/tex\">AG0_2</script>蛋白主要识别5‘端为A的siRNA，因此5’端为A的siRNA对其进入RISC复合体及对靶mRNA的识别具有关键作用</li><li>正义链5’端具有更多的G/C对siRNA的功能提高非常重要，第19位为G/C也更具有RNAi活力</li><li>反义链的第19位G/C真的对siRNA的高功能性存在相关性有待验证</li><li>高效的siRNA反义链的第13位优先为 A／U，即不为G/C</li><li>反义链第10位为 U 作用强于A，优先考虑</li><li>综合考虑反义链第3,7,14,16,17位还是有必要的</li><li>对zfy基因来说，siRNA靶点在1000bp以内，即第3-6外显子上设计高效siRNA的可能性更大，最好位于150bp-800bp</li></ul></li><li>这个论文主要是记录了一整个siRNA实验以及分析过程，可以作为以后siRNA实验的参考</li></ol><h2 id=\"拓展阅读\"><a href=\"#拓展阅读\" class=\"headerlink\" title=\"拓展阅读\"></a>拓展阅读</h2><ol><li><a href=\"http://dict.bioon.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">生物医药大词典</a></li><li><a href=\"http://www.labome.cn/method/siRNAs-and-shRNAs-Tools-for-Protein-Knockdown-by-Gene-Silencing.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">siRNA和shRNA:通过基因沉默抑制蛋白表达的工具</a></li><li><a href=\"https://wenku.baidu.com/view/b3571b7c192e45361066f5ca.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Argonaute蛋白结构与功能</a></li><li><a href=\"http://www.televector.com/9171223659.pdf\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">张美红，周克元.小干扰RNA的合理设计[J].肿瘤防治研究，2006， 33（11）：837-839</a></li><li><a href=\"https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2017&amp;filename=HLJX201701028\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">秦炳燕，张永生，纪俊明等.高效siRNA的设计分析[B].黑龙江畜牧兽医，2017（1）：109-113，294</a></li><li><a href=\"https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2017&amp;filename=1017152231.nh\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">韩烨.基于机器学习的siRNA沉默效率预测方法研究[D].吉林省：吉林大学，2019</a></li><li><a href=\"https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CAPJ&amp;dbname=CAPJLAST&amp;filename=SDYB20190926000\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">薛婷，王黎明，焦今文等.siRNA介导RRM2基因沉默治疗人卵巢癌裸鼠移植瘤[J].山东大学学报，2019，57（10）</a></li><li><a href=\"http://kns.cnki.net/KCMS/detail/detail.aspx?dbname=cjfd2000&amp;filename=hnyk200002007\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">李珊珊,任秀花,闫爱华,方伟岗.3种mRNA检测方法比较[J].河南医科大学学报，2000，35（2）：113-114</a></li><li><a href=\"https://wenku.baidu.com/view/67f81ad7d4bbfd0a79563c1ec5da50e2524dd102.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">蛋白表达不同检测表达方式的比较和分析</a></li><li><a href=\"http://kns.cnki.net//KXReader/Detail?TIMESTAMP=637062394829091250&amp;DBCODE=CJFD&amp;TABLEName=CJFD9899&amp;FileName=ZHYX199909026&amp;RESULT=1&amp;SIGN=kvPorAe14Lw3IYsBq017HIfdCF4%3d\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">李珊珊，方伟岗，钟销销，等 肿瘤转移抑制基因 KAil 不同转移潜能癌细胞中的表达．中华医学杂志，1999,(9): 708</a></li></ol><!-- rebuild by neat -->"},{"title":"论文笔记 | 基于机器学习的siRNA沉默效率预测方法研究","comments":1,"mathjax":false,"date":"2019-10-17T02:56:51.000Z","urlname":"Paper-note-Research-on-prediction-method-of-siRNA-silencing-efficiency-based-on-machine-learning","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n最近在看[基于机器学习的siRNA沉默效率预测方法研究](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&dbname=CDFDLAST2017&filename=1017152231.nh)这篇论文，论文一共98页，实在太长，不得不单独一篇笔记用于记录要点。\n\n这篇论文在使用机器学习方法研究siRNA沉默效率这方面讲的还是很清楚的，用以入门。\n{% endnote %}\n<!--more-->\n\n# 绪论\n## 研究意义\n这里主要讲述了RNAi的起源、作用机制和应用，可以参考上一篇文章[RNAi和siRNA设计基础](https://hanielxx.com/Notes/2019-10-01-basic-knowledge-of-RNAi.html)，这里就不记录了。\n\n## 国内外研究动态\n### 基于规则的第一代 siRNA 沉默效率预测方法\n早期主要是用统计学方法寻找siRNA不同沉默效率的规则，因此沉默效率不能量化，只能分高效和低效siRNA\n\n主要是在siRNA不同位置上的规则约束，这部分可以用一张表总结。\n{% asset_img 1-1.png siRNA序列打分规则 %}\n\n其次需要考虑siRNA热力学稳定性，主要是下面两种规则：\n{% asset_img 1-2.png siRNA热力学稳定性规则 %}\n\n**缺点是：**\n1. 样本量太少\n1. 规则不够具体\n1. 没有设置权重区分规则重要性\n1. 具有数据偏向性\n### 基于机器学习的第二代 siRNA 沉默效率预测方法\n\n#### 数据集方面\n主要是使用Huesken数据集，Huesken 数据集到目前为止同样实验条件下提出的数量最多的数据集。\n\n其他一些包括化学修饰的数据集可以有需要再去论文中查看。\n\n### 特征方面\n1. 碱基组成\n1. 1-3mer的motif频率和位置特征\n\n1. 热力学参数，包括siRNA 双链的G ，siRNA 反义链的内部分子结构稳定性，局部靶标的 mRNA 稳定性以及 siRNA 双链中每相邻两个碱基对的稳定性等等\n1. 反义链的二级结构\n1. 与mRNA有区别的结构特征\n1. 靶mRNA的二级结构\n1. 靶mRNA内多个反义链结合位点的能量\n\n1. siRNA的3n+1位碱基组成，也意味着siRNA的绑定蛋白和效率有关\n1. siRNA上下游碱基，可能是上下游特定的motif可能影响效率\n\n\n#### 算法方面\n统计如下：\n1. GP算法\n1. GSK和SVM\n1. 神经网络\n1. 线性回归\n1. 决策树\n1. 随机森林\\>SVM\n1. 后缀树\n1. 规则矩阵，利用已知规则设置权重，结合半监督的回归算法\n\n# 机器学习在siRNA沉默效率预测中的应用\n\n## siRNA样本收集\n此需要选择具有代表性、数量充足的样本集合。生物信息学使用的数据还需要注意数据是否存在冗余\n\n\n","source":"_posts/siRNA/论文笔记-基于机器学习的siRNA沉默效率预测方法研究.md","raw":"---\ntitle: 论文笔记 | 基于机器学习的siRNA沉默效率预测方法研究\ntags:\n  - Notes\n  - siRNA\n  - MachineLearning\n  - Paper\ncategories:\n  - Notes\ncomments: true\nmathjax: false\ndate: 2019-10-17 10:56:51\nurlname: Paper-note-Research-on-prediction-method-of-siRNA-silencing-efficiency-based-on-machine-learning\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n最近在看[基于机器学习的siRNA沉默效率预测方法研究](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&dbname=CDFDLAST2017&filename=1017152231.nh)这篇论文，论文一共98页，实在太长，不得不单独一篇笔记用于记录要点。\n\n这篇论文在使用机器学习方法研究siRNA沉默效率这方面讲的还是很清楚的，用以入门。\n{% endnote %}\n<!--more-->\n\n# 绪论\n## 研究意义\n这里主要讲述了RNAi的起源、作用机制和应用，可以参考上一篇文章[RNAi和siRNA设计基础](https://hanielxx.com/Notes/2019-10-01-basic-knowledge-of-RNAi.html)，这里就不记录了。\n\n## 国内外研究动态\n### 基于规则的第一代 siRNA 沉默效率预测方法\n早期主要是用统计学方法寻找siRNA不同沉默效率的规则，因此沉默效率不能量化，只能分高效和低效siRNA\n\n主要是在siRNA不同位置上的规则约束，这部分可以用一张表总结。\n{% asset_img 1-1.png siRNA序列打分规则 %}\n\n其次需要考虑siRNA热力学稳定性，主要是下面两种规则：\n{% asset_img 1-2.png siRNA热力学稳定性规则 %}\n\n**缺点是：**\n1. 样本量太少\n1. 规则不够具体\n1. 没有设置权重区分规则重要性\n1. 具有数据偏向性\n### 基于机器学习的第二代 siRNA 沉默效率预测方法\n\n#### 数据集方面\n主要是使用Huesken数据集，Huesken 数据集到目前为止同样实验条件下提出的数量最多的数据集。\n\n其他一些包括化学修饰的数据集可以有需要再去论文中查看。\n\n### 特征方面\n1. 碱基组成\n1. 1-3mer的motif频率和位置特征\n\n1. 热力学参数，包括siRNA 双链的G ，siRNA 反义链的内部分子结构稳定性，局部靶标的 mRNA 稳定性以及 siRNA 双链中每相邻两个碱基对的稳定性等等\n1. 反义链的二级结构\n1. 与mRNA有区别的结构特征\n1. 靶mRNA的二级结构\n1. 靶mRNA内多个反义链结合位点的能量\n\n1. siRNA的3n+1位碱基组成，也意味着siRNA的绑定蛋白和效率有关\n1. siRNA上下游碱基，可能是上下游特定的motif可能影响效率\n\n\n#### 算法方面\n统计如下：\n1. GP算法\n1. GSK和SVM\n1. 神经网络\n1. 线性回归\n1. 决策树\n1. 随机森林\\>SVM\n1. 后缀树\n1. 规则矩阵，利用已知规则设置权重，结合半监督的回归算法\n\n# 机器学习在siRNA沉默效率预测中的应用\n\n## siRNA样本收集\n此需要选择具有代表性、数量充足的样本集合。生物信息学使用的数据还需要注意数据是否存在冗余\n\n\n","slug":"siRNA/论文笔记-基于机器学习的siRNA沉默效率预测方法研究","published":1,"updated":"2019-10-18T06:56:00.428Z","layout":"post","photos":[],"link":"","_id":"ck2424lva009olksbv1hqal6h","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>最近在看<a href=\"https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2017&amp;filename=1017152231.nh\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">基于机器学习的siRNA沉默效率预测方法研究</a>这篇论文，论文一共98页，实在太长，不得不单独一篇笔记用于记录要点。</p><p>这篇论文在使用机器学习方法研究siRNA沉默效率这方面讲的还是很清楚的，用以入门。</p></div><a id=\"more\"></a><h1 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h1><h2 id=\"研究意义\"><a href=\"#研究意义\" class=\"headerlink\" title=\"研究意义\"></a>研究意义</h2><p>这里主要讲述了RNAi的起源、作用机制和应用，可以参考上一篇文章<a href=\"https://hanielxx.com/Notes/2019-10-01-basic-knowledge-of-RNAi.html\">RNAi和siRNA设计基础</a>，这里就不记录了。</p><h2 id=\"国内外研究动态\"><a href=\"#国内外研究动态\" class=\"headerlink\" title=\"国内外研究动态\"></a>国内外研究动态</h2><h3 id=\"基于规则的第一代-siRNA-沉默效率预测方法\"><a href=\"#基于规则的第一代-siRNA-沉默效率预测方法\" class=\"headerlink\" title=\"基于规则的第一代 siRNA 沉默效率预测方法\"></a>基于规则的第一代 siRNA 沉默效率预测方法</h3><p>早期主要是用统计学方法寻找siRNA不同沉默效率的规则，因此沉默效率不能量化，只能分高效和低效siRNA</p><p>主要是在siRNA不同位置上的规则约束，这部分可以用一张表总结。<br><img src=\"/Notes/2019-10-17-Paper-note-Research-on-prediction-method-of-siRNA-silencing-efficiency-based-on-machine-learning/1-1.png\" title=\"siRNA序列打分规则\"></p><p>其次需要考虑siRNA热力学稳定性，主要是下面两种规则：<br><img src=\"/Notes/2019-10-17-Paper-note-Research-on-prediction-method-of-siRNA-silencing-efficiency-based-on-machine-learning/1-2.png\" title=\"siRNA热力学稳定性规则\"></p><p><strong>缺点是：</strong></p><ol><li>样本量太少</li><li>规则不够具体</li><li>没有设置权重区分规则重要性</li><li>具有数据偏向性<h3 id=\"基于机器学习的第二代-siRNA-沉默效率预测方法\"><a href=\"#基于机器学习的第二代-siRNA-沉默效率预测方法\" class=\"headerlink\" title=\"基于机器学习的第二代 siRNA 沉默效率预测方法\"></a>基于机器学习的第二代 siRNA 沉默效率预测方法</h3></li></ol><h4 id=\"数据集方面\"><a href=\"#数据集方面\" class=\"headerlink\" title=\"数据集方面\"></a>数据集方面</h4><p>主要是使用Huesken数据集，Huesken 数据集到目前为止同样实验条件下提出的数量最多的数据集。</p><p>其他一些包括化学修饰的数据集可以有需要再去论文中查看。</p><h3 id=\"特征方面\"><a href=\"#特征方面\" class=\"headerlink\" title=\"特征方面\"></a>特征方面</h3><ol><li>碱基组成</li><li><p>1-3mer的motif频率和位置特征</p></li><li><p>热力学参数，包括siRNA 双链的G ，siRNA 反义链的内部分子结构稳定性，局部靶标的 mRNA 稳定性以及 siRNA 双链中每相邻两个碱基对的稳定性等等</p></li><li>反义链的二级结构</li><li>与mRNA有区别的结构特征</li><li>靶mRNA的二级结构</li><li><p>靶mRNA内多个反义链结合位点的能量</p></li><li><p>siRNA的3n+1位碱基组成，也意味着siRNA的绑定蛋白和效率有关</p></li><li>siRNA上下游碱基，可能是上下游特定的motif可能影响效率</li></ol><h4 id=\"算法方面\"><a href=\"#算法方面\" class=\"headerlink\" title=\"算法方面\"></a>算法方面</h4><p>统计如下：</p><ol><li>GP算法</li><li>GSK和SVM</li><li>神经网络</li><li>线性回归</li><li>决策树</li><li>随机森林>SVM</li><li>后缀树</li><li>规则矩阵，利用已知规则设置权重，结合半监督的回归算法</li></ol><h1 id=\"机器学习在siRNA沉默效率预测中的应用\"><a href=\"#机器学习在siRNA沉默效率预测中的应用\" class=\"headerlink\" title=\"机器学习在siRNA沉默效率预测中的应用\"></a>机器学习在siRNA沉默效率预测中的应用</h1><h2 id=\"siRNA样本收集\"><a href=\"#siRNA样本收集\" class=\"headerlink\" title=\"siRNA样本收集\"></a>siRNA样本收集</h2><p>此需要选择具有代表性、数量充足的样本集合。生物信息学使用的数据还需要注意数据是否存在冗余</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>最近在看<a href=\"https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2017&amp;filename=1017152231.nh\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">基于机器学习的siRNA沉默效率预测方法研究</a>这篇论文，论文一共98页，实在太长，不得不单独一篇笔记用于记录要点。</p><p>这篇论文在使用机器学习方法研究siRNA沉默效率这方面讲的还是很清楚的，用以入门。</p></div>","more":"<h1 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h1><h2 id=\"研究意义\"><a href=\"#研究意义\" class=\"headerlink\" title=\"研究意义\"></a>研究意义</h2><p>这里主要讲述了RNAi的起源、作用机制和应用，可以参考上一篇文章<a href=\"https://hanielxx.com/Notes/2019-10-01-basic-knowledge-of-RNAi.html\">RNAi和siRNA设计基础</a>，这里就不记录了。</p><h2 id=\"国内外研究动态\"><a href=\"#国内外研究动态\" class=\"headerlink\" title=\"国内外研究动态\"></a>国内外研究动态</h2><h3 id=\"基于规则的第一代-siRNA-沉默效率预测方法\"><a href=\"#基于规则的第一代-siRNA-沉默效率预测方法\" class=\"headerlink\" title=\"基于规则的第一代 siRNA 沉默效率预测方法\"></a>基于规则的第一代 siRNA 沉默效率预测方法</h3><p>早期主要是用统计学方法寻找siRNA不同沉默效率的规则，因此沉默效率不能量化，只能分高效和低效siRNA</p><p>主要是在siRNA不同位置上的规则约束，这部分可以用一张表总结。<br><img src=\"/Notes/2019-10-17-Paper-note-Research-on-prediction-method-of-siRNA-silencing-efficiency-based-on-machine-learning/1-1.png\" title=\"siRNA序列打分规则\"></p><p>其次需要考虑siRNA热力学稳定性，主要是下面两种规则：<br><img src=\"/Notes/2019-10-17-Paper-note-Research-on-prediction-method-of-siRNA-silencing-efficiency-based-on-machine-learning/1-2.png\" title=\"siRNA热力学稳定性规则\"></p><p><strong>缺点是：</strong></p><ol><li>样本量太少</li><li>规则不够具体</li><li>没有设置权重区分规则重要性</li><li>具有数据偏向性<h3 id=\"基于机器学习的第二代-siRNA-沉默效率预测方法\"><a href=\"#基于机器学习的第二代-siRNA-沉默效率预测方法\" class=\"headerlink\" title=\"基于机器学习的第二代 siRNA 沉默效率预测方法\"></a>基于机器学习的第二代 siRNA 沉默效率预测方法</h3></li></ol><h4 id=\"数据集方面\"><a href=\"#数据集方面\" class=\"headerlink\" title=\"数据集方面\"></a>数据集方面</h4><p>主要是使用Huesken数据集，Huesken 数据集到目前为止同样实验条件下提出的数量最多的数据集。</p><p>其他一些包括化学修饰的数据集可以有需要再去论文中查看。</p><h3 id=\"特征方面\"><a href=\"#特征方面\" class=\"headerlink\" title=\"特征方面\"></a>特征方面</h3><ol><li>碱基组成</li><li><p>1-3mer的motif频率和位置特征</p></li><li><p>热力学参数，包括siRNA 双链的G ，siRNA 反义链的内部分子结构稳定性，局部靶标的 mRNA 稳定性以及 siRNA 双链中每相邻两个碱基对的稳定性等等</p></li><li>反义链的二级结构</li><li>与mRNA有区别的结构特征</li><li>靶mRNA的二级结构</li><li><p>靶mRNA内多个反义链结合位点的能量</p></li><li><p>siRNA的3n+1位碱基组成，也意味着siRNA的绑定蛋白和效率有关</p></li><li>siRNA上下游碱基，可能是上下游特定的motif可能影响效率</li></ol><h4 id=\"算法方面\"><a href=\"#算法方面\" class=\"headerlink\" title=\"算法方面\"></a>算法方面</h4><p>统计如下：</p><ol><li>GP算法</li><li>GSK和SVM</li><li>神经网络</li><li>线性回归</li><li>决策树</li><li>随机森林>SVM</li><li>后缀树</li><li>规则矩阵，利用已知规则设置权重，结合半监督的回归算法</li></ol><h1 id=\"机器学习在siRNA沉默效率预测中的应用\"><a href=\"#机器学习在siRNA沉默效率预测中的应用\" class=\"headerlink\" title=\"机器学习在siRNA沉默效率预测中的应用\"></a>机器学习在siRNA沉默效率预测中的应用</h1><h2 id=\"siRNA样本收集\"><a href=\"#siRNA样本收集\" class=\"headerlink\" title=\"siRNA样本收集\"></a>siRNA样本收集</h2><p>此需要选择具有代表性、数量充足的样本集合。生物信息学使用的数据还需要注意数据是否存在冗余</p><!-- rebuild by neat -->"},{"title":"NowCoder-查找学生信息","comments":1,"mathjax":false,"date":"2019-09-22T05:16:09.000Z","urlname":"find-information-of-stu","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/fe8bff0750c8448081759f3ee0d86bb4?tpId=40&tqId=21358&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n输入N个学生的信息，然后进行查询。\n\n输入描述:\n输入的第一行为N，即学生的个数(N<=1000)\n接下来的N行包括N个学生的信息，信息格式如下：\n01 李江 男 21\n02 刘唐 男 23\n03 张军 男 19\n04 王娜 女 19\n然后输入一个M(M<=10000),接下来会有M行，代表M次查询，每行输入一个学号，格式如下：\n02\n03\n01\n04\n\n输出M行，每行包括一个对应于查询的学生的信息。\n如果没有对应的学生信息，则输出“No Answer!”\n\n### Examples:\n**Input:**\n> 4\n> 01 李江 男 21\n> 02 刘唐 男 23\n> 03 张军 男 19\n> 04 王娜 女 19\n> 5\n> 02\n> 03\n> 01\n> 04\n> 03\n \n**Output:**\n> 02 刘唐 男 23\n> 03 张军 男 19\n> 01 李江 男 21\n> 04 王娜 女 19\n> 03 张军 男 19 \n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 使用结构体保存每个学生信息，然后找学号，找到就输出，找不到就No Answer \n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nstruct st{\n    st(string sid=\"0\", string sname=\"\", string ssex=\"男\", int sage=0):id(sid), name(sname),sex(ssex),age(sage) {};\n    string id;\n    string name;\n    string sex;\n    int age;\n};\n\nint main(){\n    int N, M;\n    while(cin>>N){\n        vector<st> stu(N);\n        for(int i=0;i<N;i++){\n            cin>>stu[i].id>>stu[i].name>>stu[i].sex>>stu[i].age;\n        }\n        cin>>M;\n        for(int i=0;i<M;i++){\n            string target;\n            cin>>target;\n            int pos = -1;\n            for(int j=0;j<N;j++){\n                if(stu[j].id==target){\n                    pos=j;\n                    break;\n                }\n            }\n            if(pos!=-1) cout<<stu[pos].id<<\" \"<<stu[pos].name<<\" \"<<stu[pos].sex<<\" \"<<stu[pos].age<<endl;\n            else cout<<\"No Answer!\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n------\n","source":"_posts/NowCoder/NowCoder-查找学生信息.md","raw":"---\ntitle: NowCoder-查找学生信息\ntags:\n  - NowCoder\n  - Algorithm\n  - Search\n  - Struct\n  - Easy\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-22 13:16:09\nurlname: find-information-of-stu\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/fe8bff0750c8448081759f3ee0d86bb4?tpId=40&tqId=21358&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n补之前的\n\n输入N个学生的信息，然后进行查询。\n\n输入描述:\n输入的第一行为N，即学生的个数(N<=1000)\n接下来的N行包括N个学生的信息，信息格式如下：\n01 李江 男 21\n02 刘唐 男 23\n03 张军 男 19\n04 王娜 女 19\n然后输入一个M(M<=10000),接下来会有M行，代表M次查询，每行输入一个学号，格式如下：\n02\n03\n01\n04\n\n输出M行，每行包括一个对应于查询的学生的信息。\n如果没有对应的学生信息，则输出“No Answer!”\n\n### Examples:\n**Input:**\n> 4\n> 01 李江 男 21\n> 02 刘唐 男 23\n> 03 张军 男 19\n> 04 王娜 女 19\n> 5\n> 02\n> 03\n> 01\n> 04\n> 03\n \n**Output:**\n> 02 刘唐 男 23\n> 03 张军 男 19\n> 01 李江 男 21\n> 04 王娜 女 19\n> 03 张军 男 19 \n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 使用结构体保存每个学生信息，然后找学号，找到就输出，找不到就No Answer \n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nstruct st{\n    st(string sid=\"0\", string sname=\"\", string ssex=\"男\", int sage=0):id(sid), name(sname),sex(ssex),age(sage) {};\n    string id;\n    string name;\n    string sex;\n    int age;\n};\n\nint main(){\n    int N, M;\n    while(cin>>N){\n        vector<st> stu(N);\n        for(int i=0;i<N;i++){\n            cin>>stu[i].id>>stu[i].name>>stu[i].sex>>stu[i].age;\n        }\n        cin>>M;\n        for(int i=0;i<M;i++){\n            string target;\n            cin>>target;\n            int pos = -1;\n            for(int j=0;j<N;j++){\n                if(stu[j].id==target){\n                    pos=j;\n                    break;\n                }\n            }\n            if(pos!=-1) cout<<stu[pos].id<<\" \"<<stu[pos].name<<\" \"<<stu[pos].sex<<\" \"<<stu[pos].age<<endl;\n            else cout<<\"No Answer!\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n------\n","slug":"NowCoder/NowCoder-查找学生信息","published":1,"updated":"2019-09-22T05:18:47.556Z","layout":"post","photos":[],"link":"","_id":"ck2424lvc009qlksbozcglg8l","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/fe8bff0750c8448081759f3ee0d86bb4?tpId=40&amp;tqId=21358&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>输入N个学生的信息，然后进行查询。</p><p>输入描述:<br>输入的第一行为N，即学生的个数(N&lt;=1000)<br>接下来的N行包括N个学生的信息，信息格式如下：<br>01 李江 男 21<br>02 刘唐 男 23<br>03 张军 男 19<br>04 王娜 女 19<br>然后输入一个M(M&lt;=10000),接下来会有M行，代表M次查询，每行输入一个学号，格式如下：<br>02<br>03<br>01<br>04</p><p>输出M行，每行包括一个对应于查询的学生的信息。<br>如果没有对应的学生信息，则输出“No Answer!”</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>4<br>01 李江 男 21<br>02 刘唐 男 23<br>03 张军 男 19<br>04 王娜 女 19<br>5<br>02<br>03<br>01<br>04<br>03</p></blockquote><p><strong>Output:</strong></p><blockquote><p>02 刘唐 男 23<br>03 张军 男 19<br>01 李江 男 21<br>04 王娜 女 19<br>03 张军 男 19</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>使用结构体保存每个学生信息，然后找学号，找到就输出，找不到就No Answer</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st</span>&#123;</span></span><br><span class=\"line\">    st(<span class=\"built_in\">string</span> sid=<span class=\"string\">\"0\"</span>, <span class=\"built_in\">string</span> sname=<span class=\"string\">\"\"</span>, <span class=\"built_in\">string</span> ssex=<span class=\"string\">\"男\"</span>, <span class=\"keyword\">int</span> sage=<span class=\"number\">0</span>):id(sid), name(sname),sex(ssex),age(sage) &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> id;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> sex;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> N, M;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;N)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;st&gt; stu(N);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;stu[i].id&gt;&gt;stu[i].name&gt;&gt;stu[i].sex&gt;&gt;stu[i].age;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;M;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;M;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> target;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;target;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> pos = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;N;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(stu[j].id==target)&#123;</span><br><span class=\"line\">                    pos=j;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pos!=<span class=\"number\">-1</span>) <span class=\"built_in\">cout</span>&lt;&lt;stu[pos].id&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;stu[pos].name&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;stu[pos].sex&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;stu[pos].age&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"No Answer!\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/fe8bff0750c8448081759f3ee0d86bb4?tpId=40&amp;tqId=21358&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>补之前的</p><p>输入N个学生的信息，然后进行查询。</p><p>输入描述:<br>输入的第一行为N，即学生的个数(N&lt;=1000)<br>接下来的N行包括N个学生的信息，信息格式如下：<br>01 李江 男 21<br>02 刘唐 男 23<br>03 张军 男 19<br>04 王娜 女 19<br>然后输入一个M(M&lt;=10000),接下来会有M行，代表M次查询，每行输入一个学号，格式如下：<br>02<br>03<br>01<br>04</p><p>输出M行，每行包括一个对应于查询的学生的信息。<br>如果没有对应的学生信息，则输出“No Answer!”</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>4<br>01 李江 男 21<br>02 刘唐 男 23<br>03 张军 男 19<br>04 王娜 女 19<br>5<br>02<br>03<br>01<br>04<br>03</p></blockquote><p><strong>Output:</strong></p><blockquote><p>02 刘唐 男 23<br>03 张军 男 19<br>01 李江 男 21<br>04 王娜 女 19<br>03 张军 男 19</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>使用结构体保存每个学生信息，然后找学号，找到就输出，找不到就No Answer</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st</span>&#123;</span></span><br><span class=\"line\">    st(<span class=\"built_in\">string</span> sid=<span class=\"string\">\"0\"</span>, <span class=\"built_in\">string</span> sname=<span class=\"string\">\"\"</span>, <span class=\"built_in\">string</span> ssex=<span class=\"string\">\"男\"</span>, <span class=\"keyword\">int</span> sage=<span class=\"number\">0</span>):id(sid), name(sname),sex(ssex),age(sage) &#123;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> id;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> sex;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> N, M;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;N)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;st&gt; stu(N);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;stu[i].id&gt;&gt;stu[i].name&gt;&gt;stu[i].sex&gt;&gt;stu[i].age;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;M;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;M;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> target;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>&gt;&gt;target;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> pos = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;N;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(stu[j].id==target)&#123;</span><br><span class=\"line\">                    pos=j;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pos!=<span class=\"number\">-1</span>) <span class=\"built_in\">cout</span>&lt;&lt;stu[pos].id&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;stu[pos].name&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;stu[pos].sex&lt;&lt;<span class=\"string\">\" \"</span>&lt;&lt;stu[pos].age&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"No Answer!\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"NowCoder-谁是你的潜在朋友","comments":1,"mathjax":false,"date":"2019-09-22T06:03:58.000Z","urlname":"who-is-your-friend","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/0177394fb25b42b48657bc2b1c6f9fcc?tpId=40&tqId=21360&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n“臭味相投”——这是我们描述朋友时喜欢用的词汇。两个人是朋友通常意味着他们存在着许多共同的兴趣。然而作为一个宅男，你发现自己与他人相互了解的机会并不太多。幸运的是，你意外得到了一份北大图书馆的图书借阅记录，于是你挑灯熬夜地编程，想从中发现潜在的朋友。     \n\n首先你对借阅记录进行了一番整理，把N个读者依次编号为1,2,…,N，把M本书依次编号为1,2,…,M。同时，按照“臭味相投”的原则，和你喜欢读同一本书的人，就是你的潜在朋友。你现在的任务是从这份借阅记录中计算出每个人有几个潜在朋友。\n\n每个案例第一行两个整数N,M，2 <= N ，M<= 200。接下来有N行，第i(i = 1,2,…,N)行每一行有一个数，表示读者i-1最喜欢的图书的编号P(1<=P<=M)\n\n每个案例包括N行，每行一个数，第i行的数表示读者i有几个潜在朋友。如果i和任何人都没有共同喜欢的书，则输出“BeiJu”（即悲剧，^ ^）\n### Examples:\n**Input:**\n> 4  5\n> 2\n> 3\n> 2\n> 1 \n \n**Output:**\n> 1\n> BeiJu\n> 1\n> BeiJu \n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 用二维数组表示对应关系，遍历每本书的喜欢的人，就是潜在朋友 \n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint main(){\n  int N,M;\n  while(cin>>N>>M){\n    vector<vector<int> > mp(N, vector<int>(M+1,0));\n    vector<int> friends(N,0);\n    int p;\n    for(int i=0;i<N;i++){\n      cin>>p;\n      mp[i][p]=1;\n    }\n    for(int i=1;i<=M;i++){\n      vector<int> tmp;\n      for(int j=0;j<N;j++)\n        if(mp[j][i]==1) \n          tmp.push_back(j);\n      for(int k=0;k<tmp.size();k++) friends[tmp[k]]=tmp.size()-1;\n    }\n    for(int i=0;i<N;i++){\n      if(friends[i]==0) cout<<\"BeiJu\"<<endl;\n      else cout<<friends[i]<<endl;\n    }\n  }\n  return 0;\n}\n```\n\n------\n","source":"_posts/NowCoder/NowCoder-谁是你的潜在朋友.md","raw":"---\ntitle: NowCoder-谁是你的潜在朋友\ntags:\n  - NowCoder\n  - Algorithm\n  - Array\n  - Easy\ncategories:\n  - NowCoder\ncomments: true\nmathjax: false\ndate: 2019-09-22 14:03:58\nurlname: who-is-your-friend\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n## [Problem](https://www.nowcoder.com/practice/0177394fb25b42b48657bc2b1c6f9fcc?tpId=40&tqId=21360&tPage=2&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking)   \n“臭味相投”——这是我们描述朋友时喜欢用的词汇。两个人是朋友通常意味着他们存在着许多共同的兴趣。然而作为一个宅男，你发现自己与他人相互了解的机会并不太多。幸运的是，你意外得到了一份北大图书馆的图书借阅记录，于是你挑灯熬夜地编程，想从中发现潜在的朋友。     \n\n首先你对借阅记录进行了一番整理，把N个读者依次编号为1,2,…,N，把M本书依次编号为1,2,…,M。同时，按照“臭味相投”的原则，和你喜欢读同一本书的人，就是你的潜在朋友。你现在的任务是从这份借阅记录中计算出每个人有几个潜在朋友。\n\n每个案例第一行两个整数N,M，2 <= N ，M<= 200。接下来有N行，第i(i = 1,2,…,N)行每一行有一个数，表示读者i-1最喜欢的图书的编号P(1<=P<=M)\n\n每个案例包括N行，每行一个数，第i行的数表示读者i有几个潜在朋友。如果i和任何人都没有共同喜欢的书，则输出“BeiJu”（即悲剧，^ ^）\n### Examples:\n**Input:**\n> 4  5\n> 2\n> 3\n> 2\n> 1 \n \n**Output:**\n> 1\n> BeiJu\n> 1\n> BeiJu \n\n{% endnote %}\n<!--more-->\n\n## Solutions\n- 用二维数组表示对应关系，遍历每本书的喜欢的人，就是潜在朋友 \n\n\n## C++ Codes\n\n```C++\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint main(){\n  int N,M;\n  while(cin>>N>>M){\n    vector<vector<int> > mp(N, vector<int>(M+1,0));\n    vector<int> friends(N,0);\n    int p;\n    for(int i=0;i<N;i++){\n      cin>>p;\n      mp[i][p]=1;\n    }\n    for(int i=1;i<=M;i++){\n      vector<int> tmp;\n      for(int j=0;j<N;j++)\n        if(mp[j][i]==1) \n          tmp.push_back(j);\n      for(int k=0;k<tmp.size();k++) friends[tmp[k]]=tmp.size()-1;\n    }\n    for(int i=0;i<N;i++){\n      if(friends[i]==0) cout<<\"BeiJu\"<<endl;\n      else cout<<friends[i]<<endl;\n    }\n  }\n  return 0;\n}\n```\n\n------\n","slug":"NowCoder/NowCoder-谁是你的潜在朋友","published":1,"updated":"2019-09-22T06:31:52.637Z","layout":"post","photos":[],"link":"","_id":"ck2424m0s00ntlksbuguwba6s","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/0177394fb25b42b48657bc2b1c6f9fcc?tpId=40&amp;tqId=21360&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>“臭味相投”——这是我们描述朋友时喜欢用的词汇。两个人是朋友通常意味着他们存在着许多共同的兴趣。然而作为一个宅男，你发现自己与他人相互了解的机会并不太多。幸运的是，你意外得到了一份北大图书馆的图书借阅记录，于是你挑灯熬夜地编程，想从中发现潜在的朋友。</p><p>首先你对借阅记录进行了一番整理，把N个读者依次编号为1,2,…,N，把M本书依次编号为1,2,…,M。同时，按照“臭味相投”的原则，和你喜欢读同一本书的人，就是你的潜在朋友。你现在的任务是从这份借阅记录中计算出每个人有几个潜在朋友。</p><p>每个案例第一行两个整数N,M，2 &lt;= N ，M&lt;= 200。接下来有N行，第i(i = 1,2,…,N)行每一行有一个数，表示读者i-1最喜欢的图书的编号P(1&lt;=P&lt;=M)</p><p>每个案例包括N行，每行一个数，第i行的数表示读者i有几个潜在朋友。如果i和任何人都没有共同喜欢的书，则输出“BeiJu”（即悲剧，^ ^）</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>4 5<br>2<br>3<br>2<br>1</p></blockquote><p><strong>Output:</strong></p><blockquote><p>1<br>BeiJu<br>1<br>BeiJu</p></blockquote></div><a id=\"more\"></a><h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>用二维数组表示对应关系，遍历每本书的喜欢的人，就是潜在朋友</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> N,M;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;N&gt;&gt;M)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; mp(N, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(M+<span class=\"number\">1</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; friends(N,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">cin</span>&gt;&gt;p;</span><br><span class=\"line\">      mp[i][p]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=M;i++)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;N;j++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp[j][i]==<span class=\"number\">1</span>) </span><br><span class=\"line\">          tmp.push_back(j);</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;tmp.size();k++) friends[tmp[k]]=tmp.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(friends[i]==<span class=\"number\">0</span>) <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"BeiJu\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span>&lt;&lt;friends[i]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a><a href=\"https://www.nowcoder.com/practice/0177394fb25b42b48657bc2b1c6f9fcc?tpId=40&amp;tqId=21360&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Problem</a></h2><p>“臭味相投”——这是我们描述朋友时喜欢用的词汇。两个人是朋友通常意味着他们存在着许多共同的兴趣。然而作为一个宅男，你发现自己与他人相互了解的机会并不太多。幸运的是，你意外得到了一份北大图书馆的图书借阅记录，于是你挑灯熬夜地编程，想从中发现潜在的朋友。</p><p>首先你对借阅记录进行了一番整理，把N个读者依次编号为1,2,…,N，把M本书依次编号为1,2,…,M。同时，按照“臭味相投”的原则，和你喜欢读同一本书的人，就是你的潜在朋友。你现在的任务是从这份借阅记录中计算出每个人有几个潜在朋友。</p><p>每个案例第一行两个整数N,M，2 &lt;= N ，M&lt;= 200。接下来有N行，第i(i = 1,2,…,N)行每一行有一个数，表示读者i-1最喜欢的图书的编号P(1&lt;=P&lt;=M)</p><p>每个案例包括N行，每行一个数，第i行的数表示读者i有几个潜在朋友。如果i和任何人都没有共同喜欢的书，则输出“BeiJu”（即悲剧，^ ^）</p><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples:\"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>4 5<br>2<br>3<br>2<br>1</p></blockquote><p><strong>Output:</strong></p><blockquote><p>1<br>BeiJu<br>1<br>BeiJu</p></blockquote></div>","more":"<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><ul><li>用二维数组表示对应关系，遍历每本书的喜欢的人，就是潜在朋友</li></ul><h2 id=\"C-Codes\"><a href=\"#C-Codes\" class=\"headerlink\" title=\"C++ Codes\"></a>C++ Codes</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> N,M;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;N&gt;&gt;M)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; mp(N, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(M+<span class=\"number\">1</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; friends(N,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">cin</span>&gt;&gt;p;</span><br><span class=\"line\">      mp[i][p]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=M;i++)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;N;j++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp[j][i]==<span class=\"number\">1</span>) </span><br><span class=\"line\">          tmp.push_back(j);</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;tmp.size();k++) friends[tmp[k]]=tmp.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(friends[i]==<span class=\"number\">0</span>) <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"BeiJu\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span>&lt;&lt;friends[i]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->"},{"title":"机器学习基石--PLA算法","comments":1,"mathjax":true,"date":"2019-04-07T04:36:48.000Z","urlname":"machinelearning-pla","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n《机器学习基石》第二讲 **Learning to Answer Yes/NO** 课程笔记。这一讲主要介绍了机器学习基本概念和感知机，以及其训练算法PLA。\n{% endnote %}\n<!--more-->\n\n## 基本概念\n- $$\\mathcal f$$: 未知的目标函数\n- $$\\mathcal D$$: 训练样本，数据集\n- $$\\mathcal A$$: 学习算法\n- $$\\mathcal H$$: 假设集\n- $$\\mathcal g$$: 最终的假设，是\\mathcalf的一个近似函数\n\n课件上很清楚的描绘了机器学习的一个过程\n{% asset_img pla1.png 基本过程 %}\n\n## 感知机\n感知机是神经网络的基础，与线性回归（Linear Regression），逻辑回归（Logistics Regression）等模型也非常类似，是一种非常典型的线性模型。\n\n原始的感知机算法用于解决二分类问题，其思想如下：假设样本有 d 个特征，但是每个特征的重要性不一样，因此各个特征的权重也不一样，对其进行加权后得到的总和假如大于某个阈值则认为归为其中一类，反之归为另一类。如在信用卡的例子中，通过感知机有如下的结果\n{% asset_img pla2.png 推导过程 %}\n\n然后可以将threshold化为常数项作为$$w_0$$,简化为下图：\n{% asset_img pla3.png 简化过程%}\n上面的$$w$$和$$x$$均为一个列向量，即$$w$$转置后成为行向量\n\n## PLA\n感知机要通过学习才能对样本进行正确的分类，这个学习的过程就是PLA(Perceptron Learning Algorithm).\n\n**过程如下**：\n1. 随机初始化参数$$w$$\n2. 利用参数$$w$$预测每个样本点的值并与其实际的值比较，对于分类错误的样本点(xn,yn),利用公式$$w=w+ynxn$$更新参数$$w$$的值\n3. 重复上面的过程直到所有的样本点都能够被参数$$w$$正确预测。\n\n对于某个被预测错误的样本点，参数$$ w $$更新过程如下：\n{% asset_img pla4.png w的更新 %}\n\n注意上面的算法的前提是所有的样本点都必须线性可分，假如样本点线性不可分，那么PLA按照上面的规则会陷入死循环中。如下是线性可分与线性不可分的例子)\n{% asset_img pla5.png 线性不可分的例子 %}\n\n## 收敛性证明\n上面提到只有当所有的样本均为线性可分时，PLA才能将所有的样本点正确分类后再停下了，但是这仅仅是定性的说明而已，并没有严格的数学正面来支撑其收敛性，下面要讲的便是通过数学证明来说明 PLA 算法的收敛性。\n\n课程中用两次递进的证明来说明收敛性\n{% asset_img pla6.png 简单证明 %}\n\n上面讲的是随着参数$$ w $$的更新,$$ w^T_fw_t+1 $$的值越来越大，也就是两者越来越相似\n衡量两个向量相似性的一种方法就是考虑他们的内积，值越大，代表两者约接近，但是这里还没对向量归一化，所以证明并不严格，但是已经说明了两者具有这个趋势，下面是更严格的过程\n{% asset_img pla7.png 严格证明 %}\n\n上面似乎只是说明了经过 T 次的纠错，wt 的值会限制在一个范围内，但是并没有给出最终结论\n$$ {w_f \\over ||w_f||}{w_T \\over ||w_T||} \\ge \\sqrt{T} * constant $$\n的证明过程，因此在这里进行推导过程的描述\n(注：这里的$$ w_f $$是不变的，因此$$ w_f $$与$$ w^T_f $$是一样的)\n\n假设经过了 T 次纠错，那由第一张PPT可知\n$$ w^T_fw_T \\ge w_f^Tw_{T-1} + \\min_{n}y_nw_f^Tx_n $$\n而由第二章张ppt可知\n$$ ||w_T||^2 \\le ||w_{T-1}||^2 + \\max_n||x_n||^2 \\le T\\max_n||x_n||^2 $$\n即：$$ ||w_T|| \\le \\sqrt{T}\\max_n||x_n|| $$\n\n综合上面两个式子有\n$$ {w_f^T \\over ||w_f^T||}{w_T \\over ||w_T||} \\ge {T\\min_ny_n^Tw^T_fx_n \\over ||w_f^T||\\sqrt{T}\\max_n||x_n||} = \\sqrt{T}{\\min_ny_n{w_f^T \\over ||w_f^T||}x_n \\over \\max_n||x_n||} = \\sqrt{T} * constant $$\n\n因此上面的命题得证。至此，已经可知道犯错误的次数 T 是受到某个上限的约束的。下面会给出这个具体的上限是多少。\n\n又因为\n$$ 1 \\ge {w_f^T \\over ||w_f^T||}{w_T\\over||w_T||} \\ge \\sqrt{T} * constant $$\n$$ {1\\over constant^2 } \\ge T$$\n即犯错的次数上限是${1 \\over constant^2}$,假设令\n$$ \\max_n||x||^2 = R^2, \\rho = \\min_ny_n{w_f^T \\over ||w_f^T||}x_n $$\n则有\n$$ T \\le {R^2 \\over \\rho^2} $$\n这也说明了PLA会在有限步内收敛，这个证明也是后面的练习答案\n\n## 优缺点和优化\nPLA 的优点和缺点都非常明显，其中优点是简单，易于实现\n\n缺点是假设了数据是线性可分的，然而事先并无法知道数据是否线性可分的。正如上面提到的一样，假如将PLA 用在线性不可分的数据中时，会导致PLA永远都无法对样本进行正确分类从而陷入到死循环中。\n\n为了避免上面的情况，将 PLA 的条件放宽一点，不再要求所有的样本都能正确地分开，而是要求犯错的的样本尽可能的少，即将问题变为了\n$$ arg\\min_w\\sum_{n=0}^N1\\{y_n \\neq sign(w^Tx_n)\\} $$\n\n这个最优化问题是个 NP-hard 问题，无法求得其最优解，因此只能求尽可能接近其最优解的近似解。讲义中提出的一种求解其近似解的算法`Pocket Algorithm`。  \n\n其思想就是每次保留当前最好的$$ w $$, 当遇到错误的样本点对$$ w $$进行修正后，比较修正后的$$ w $$与原来最好的$$ w $$在整个样本点上的总体效果再决定保留哪一个，重复迭代足够多的次数后返回当前得到的最好的$$ w $$。\n\n","source":"_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法.md","raw":"---\ntitle: 机器学习基石--PLA算法\ncomments: true\nmathjax: true\ndate: 2019-04-07 12:36:48\ntags: [机器学习基石,MachineLearning,PLA]\ncategories: [MachineLearning,机器学习基石,]\nurlname: machinelearning-pla\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n《机器学习基石》第二讲 **Learning to Answer Yes/NO** 课程笔记。这一讲主要介绍了机器学习基本概念和感知机，以及其训练算法PLA。\n{% endnote %}\n<!--more-->\n\n## 基本概念\n- $$\\mathcal f$$: 未知的目标函数\n- $$\\mathcal D$$: 训练样本，数据集\n- $$\\mathcal A$$: 学习算法\n- $$\\mathcal H$$: 假设集\n- $$\\mathcal g$$: 最终的假设，是\\mathcalf的一个近似函数\n\n课件上很清楚的描绘了机器学习的一个过程\n{% asset_img pla1.png 基本过程 %}\n\n## 感知机\n感知机是神经网络的基础，与线性回归（Linear Regression），逻辑回归（Logistics Regression）等模型也非常类似，是一种非常典型的线性模型。\n\n原始的感知机算法用于解决二分类问题，其思想如下：假设样本有 d 个特征，但是每个特征的重要性不一样，因此各个特征的权重也不一样，对其进行加权后得到的总和假如大于某个阈值则认为归为其中一类，反之归为另一类。如在信用卡的例子中，通过感知机有如下的结果\n{% asset_img pla2.png 推导过程 %}\n\n然后可以将threshold化为常数项作为$$w_0$$,简化为下图：\n{% asset_img pla3.png 简化过程%}\n上面的$$w$$和$$x$$均为一个列向量，即$$w$$转置后成为行向量\n\n## PLA\n感知机要通过学习才能对样本进行正确的分类，这个学习的过程就是PLA(Perceptron Learning Algorithm).\n\n**过程如下**：\n1. 随机初始化参数$$w$$\n2. 利用参数$$w$$预测每个样本点的值并与其实际的值比较，对于分类错误的样本点(xn,yn),利用公式$$w=w+ynxn$$更新参数$$w$$的值\n3. 重复上面的过程直到所有的样本点都能够被参数$$w$$正确预测。\n\n对于某个被预测错误的样本点，参数$$ w $$更新过程如下：\n{% asset_img pla4.png w的更新 %}\n\n注意上面的算法的前提是所有的样本点都必须线性可分，假如样本点线性不可分，那么PLA按照上面的规则会陷入死循环中。如下是线性可分与线性不可分的例子)\n{% asset_img pla5.png 线性不可分的例子 %}\n\n## 收敛性证明\n上面提到只有当所有的样本均为线性可分时，PLA才能将所有的样本点正确分类后再停下了，但是这仅仅是定性的说明而已，并没有严格的数学正面来支撑其收敛性，下面要讲的便是通过数学证明来说明 PLA 算法的收敛性。\n\n课程中用两次递进的证明来说明收敛性\n{% asset_img pla6.png 简单证明 %}\n\n上面讲的是随着参数$$ w $$的更新,$$ w^T_fw_t+1 $$的值越来越大，也就是两者越来越相似\n衡量两个向量相似性的一种方法就是考虑他们的内积，值越大，代表两者约接近，但是这里还没对向量归一化，所以证明并不严格，但是已经说明了两者具有这个趋势，下面是更严格的过程\n{% asset_img pla7.png 严格证明 %}\n\n上面似乎只是说明了经过 T 次的纠错，wt 的值会限制在一个范围内，但是并没有给出最终结论\n$$ {w_f \\over ||w_f||}{w_T \\over ||w_T||} \\ge \\sqrt{T} * constant $$\n的证明过程，因此在这里进行推导过程的描述\n(注：这里的$$ w_f $$是不变的，因此$$ w_f $$与$$ w^T_f $$是一样的)\n\n假设经过了 T 次纠错，那由第一张PPT可知\n$$ w^T_fw_T \\ge w_f^Tw_{T-1} + \\min_{n}y_nw_f^Tx_n $$\n而由第二章张ppt可知\n$$ ||w_T||^2 \\le ||w_{T-1}||^2 + \\max_n||x_n||^2 \\le T\\max_n||x_n||^2 $$\n即：$$ ||w_T|| \\le \\sqrt{T}\\max_n||x_n|| $$\n\n综合上面两个式子有\n$$ {w_f^T \\over ||w_f^T||}{w_T \\over ||w_T||} \\ge {T\\min_ny_n^Tw^T_fx_n \\over ||w_f^T||\\sqrt{T}\\max_n||x_n||} = \\sqrt{T}{\\min_ny_n{w_f^T \\over ||w_f^T||}x_n \\over \\max_n||x_n||} = \\sqrt{T} * constant $$\n\n因此上面的命题得证。至此，已经可知道犯错误的次数 T 是受到某个上限的约束的。下面会给出这个具体的上限是多少。\n\n又因为\n$$ 1 \\ge {w_f^T \\over ||w_f^T||}{w_T\\over||w_T||} \\ge \\sqrt{T} * constant $$\n$$ {1\\over constant^2 } \\ge T$$\n即犯错的次数上限是${1 \\over constant^2}$,假设令\n$$ \\max_n||x||^2 = R^2, \\rho = \\min_ny_n{w_f^T \\over ||w_f^T||}x_n $$\n则有\n$$ T \\le {R^2 \\over \\rho^2} $$\n这也说明了PLA会在有限步内收敛，这个证明也是后面的练习答案\n\n## 优缺点和优化\nPLA 的优点和缺点都非常明显，其中优点是简单，易于实现\n\n缺点是假设了数据是线性可分的，然而事先并无法知道数据是否线性可分的。正如上面提到的一样，假如将PLA 用在线性不可分的数据中时，会导致PLA永远都无法对样本进行正确分类从而陷入到死循环中。\n\n为了避免上面的情况，将 PLA 的条件放宽一点，不再要求所有的样本都能正确地分开，而是要求犯错的的样本尽可能的少，即将问题变为了\n$$ arg\\min_w\\sum_{n=0}^N1\\{y_n \\neq sign(w^Tx_n)\\} $$\n\n这个最优化问题是个 NP-hard 问题，无法求得其最优解，因此只能求尽可能接近其最优解的近似解。讲义中提出的一种求解其近似解的算法`Pocket Algorithm`。  \n\n其思想就是每次保留当前最好的$$ w $$, 当遇到错误的样本点对$$ w $$进行修正后，比较修正后的$$ w $$与原来最好的$$ w $$在整个样本点上的总体效果再决定保留哪一个，重复迭代足够多的次数后返回当前得到的最好的$$ w $$。\n\n","slug":"MachineLearning/机器学习基石/机器学习基石-PLA算法","published":1,"updated":"2019-07-25T18:36:04.679Z","layout":"post","photos":[],"link":"","_id":"ck2424m3p00nzlksb8dku8w3k","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>《机器学习基石》第二讲 <strong>Learning to Answer Yes/NO</strong> 课程笔记。这一讲主要介绍了机器学习基本概念和感知机，以及其训练算法PLA。</p></div><a id=\"more\"></a><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul><li><script type=\"math/tex\">\\mathcal f</script>: 未知的目标函数</li><li><script type=\"math/tex\">\\mathcal D</script>: 训练样本，数据集</li><li><script type=\"math/tex\">\\mathcal A</script>: 学习算法</li><li><script type=\"math/tex\">\\mathcal H</script>: 假设集</li><li><script type=\"math/tex\">\\mathcal g</script>: 最终的假设，是\\mathcalf的一个近似函数</li></ul><p>课件上很清楚的描绘了机器学习的一个过程<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla1.png\" title=\"基本过程\"></p><h2 id=\"感知机\"><a href=\"#感知机\" class=\"headerlink\" title=\"感知机\"></a>感知机</h2><p>感知机是神经网络的基础，与线性回归（Linear Regression），逻辑回归（Logistics Regression）等模型也非常类似，是一种非常典型的线性模型。</p><p>原始的感知机算法用于解决二分类问题，其思想如下：假设样本有 d 个特征，但是每个特征的重要性不一样，因此各个特征的权重也不一样，对其进行加权后得到的总和假如大于某个阈值则认为归为其中一类，反之归为另一类。如在信用卡的例子中，通过感知机有如下的结果<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla2.png\" title=\"推导过程\"></p><p>然后可以将threshold化为常数项作为<script type=\"math/tex\">w_0</script>,简化为下图：<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla3.png\" title=\"简化过程\"><br>上面的<script type=\"math/tex\">w</script>和<script type=\"math/tex\">x</script>均为一个列向量，即<script type=\"math/tex\">w</script>转置后成为行向量</p><h2 id=\"PLA\"><a href=\"#PLA\" class=\"headerlink\" title=\"PLA\"></a>PLA</h2><p>感知机要通过学习才能对样本进行正确的分类，这个学习的过程就是PLA(Perceptron Learning Algorithm).</p><p><strong>过程如下</strong>：</p><ol><li>随机初始化参数<script type=\"math/tex\">w</script></li><li>利用参数<script type=\"math/tex\">w</script>预测每个样本点的值并与其实际的值比较，对于分类错误的样本点(xn,yn),利用公式<script type=\"math/tex\">w=w+ynxn</script>更新参数<script type=\"math/tex\">w</script>的值</li><li>重复上面的过程直到所有的样本点都能够被参数<script type=\"math/tex\">w</script>正确预测。</li></ol><p>对于某个被预测错误的样本点，参数<script type=\"math/tex\">w</script>更新过程如下：<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla4.png\" title=\"w的更新\"></p><p>注意上面的算法的前提是所有的样本点都必须线性可分，假如样本点线性不可分，那么PLA按照上面的规则会陷入死循环中。如下是线性可分与线性不可分的例子)<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla5.png\" title=\"线性不可分的例子\"></p><h2 id=\"收敛性证明\"><a href=\"#收敛性证明\" class=\"headerlink\" title=\"收敛性证明\"></a>收敛性证明</h2><p>上面提到只有当所有的样本均为线性可分时，PLA才能将所有的样本点正确分类后再停下了，但是这仅仅是定性的说明而已，并没有严格的数学正面来支撑其收敛性，下面要讲的便是通过数学证明来说明 PLA 算法的收敛性。</p><p>课程中用两次递进的证明来说明收敛性<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla6.png\" title=\"简单证明\"></p><p>上面讲的是随着参数<script type=\"math/tex\">w</script>的更新,<script type=\"math/tex\">w^T_fw_t+1</script>的值越来越大，也就是两者越来越相似<br>衡量两个向量相似性的一种方法就是考虑他们的内积，值越大，代表两者约接近，但是这里还没对向量归一化，所以证明并不严格，但是已经说明了两者具有这个趋势，下面是更严格的过程<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla7.png\" title=\"严格证明\"></p><p>上面似乎只是说明了经过 T 次的纠错，wt 的值会限制在一个范围内，但是并没有给出最终结论</p><script type=\"math/tex;mode=display\">{w_f \\over ||w_f||}{w_T \\over ||w_T||} \\ge \\sqrt{T} * constant</script><p>的证明过程，因此在这里进行推导过程的描述<br>(注：这里的<script type=\"math/tex\">w_f</script>是不变的，因此<script type=\"math/tex\">w_f</script>与<script type=\"math/tex\">w^T_f</script>是一样的)</p><p>假设经过了 T 次纠错，那由第一张PPT可知</p><script type=\"math/tex;mode=display\">w^T_fw_T \\ge w_f^Tw_{T-1} + \\min_{n}y_nw_f^Tx_n</script><p>而由第二章张ppt可知</p><script type=\"math/tex;mode=display\">||w_T||^2 \\le ||w_{T-1}||^2 + \\max_n||x_n||^2 \\le T\\max_n||x_n||^2</script><p>即：<script type=\"math/tex\">||w_T|| \\le \\sqrt{T}\\max_n||x_n||</script></p><p>综合上面两个式子有</p><script type=\"math/tex;mode=display\">{w_f^T \\over ||w_f^T||}{w_T \\over ||w_T||} \\ge {T\\min_ny_n^Tw^T_fx_n \\over ||w_f^T||\\sqrt{T}\\max_n||x_n||} = \\sqrt{T}{\\min_ny_n{w_f^T \\over ||w_f^T||}x_n \\over \\max_n||x_n||} = \\sqrt{T} * constant</script><p>因此上面的命题得证。至此，已经可知道犯错误的次数 T 是受到某个上限的约束的。下面会给出这个具体的上限是多少。</p><p>又因为</p><script type=\"math/tex;mode=display\">1 \\ge {w_f^T \\over ||w_f^T||}{w_T\\over||w_T||} \\ge \\sqrt{T} * constant</script><script type=\"math/tex;mode=display\">{1\\over constant^2 } \\ge T</script><p>即犯错的次数上限是${1 \\over constant^2}$,假设令</p><script type=\"math/tex;mode=display\">\\max_n||x||^2 = R^2, \\rho = \\min_ny_n{w_f^T \\over ||w_f^T||}x_n</script><p>则有</p><script type=\"math/tex;mode=display\">T \\le {R^2 \\over \\rho^2}</script><p>这也说明了PLA会在有限步内收敛，这个证明也是后面的练习答案</p><h2 id=\"优缺点和优化\"><a href=\"#优缺点和优化\" class=\"headerlink\" title=\"优缺点和优化\"></a>优缺点和优化</h2><p>PLA 的优点和缺点都非常明显，其中优点是简单，易于实现</p><p>缺点是假设了数据是线性可分的，然而事先并无法知道数据是否线性可分的。正如上面提到的一样，假如将PLA 用在线性不可分的数据中时，会导致PLA永远都无法对样本进行正确分类从而陷入到死循环中。</p><p>为了避免上面的情况，将 PLA 的条件放宽一点，不再要求所有的样本都能正确地分开，而是要求犯错的的样本尽可能的少，即将问题变为了</p><script type=\"math/tex;mode=display\">arg\\min_w\\sum_{n=0}^N1\\{y_n \\neq sign(w^Tx_n)\\}</script><p>这个最优化问题是个 NP-hard 问题，无法求得其最优解，因此只能求尽可能接近其最优解的近似解。讲义中提出的一种求解其近似解的算法<code>Pocket Algorithm</code>。</p><p>其思想就是每次保留当前最好的<script type=\"math/tex\">w</script>, 当遇到错误的样本点对<script type=\"math/tex\">w</script>进行修正后，比较修正后的<script type=\"math/tex\">w</script>与原来最好的<script type=\"math/tex\">w</script>在整个样本点上的总体效果再决定保留哪一个，重复迭代足够多的次数后返回当前得到的最好的<script type=\"math/tex\">w</script>。</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>《机器学习基石》第二讲 <strong>Learning to Answer Yes/NO</strong> 课程笔记。这一讲主要介绍了机器学习基本概念和感知机，以及其训练算法PLA。</p></div>","more":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul><li><script type=\"math/tex\">\\mathcal f</script>: 未知的目标函数</li><li><script type=\"math/tex\">\\mathcal D</script>: 训练样本，数据集</li><li><script type=\"math/tex\">\\mathcal A</script>: 学习算法</li><li><script type=\"math/tex\">\\mathcal H</script>: 假设集</li><li><script type=\"math/tex\">\\mathcal g</script>: 最终的假设，是\\mathcalf的一个近似函数</li></ul><p>课件上很清楚的描绘了机器学习的一个过程<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla1.png\" title=\"基本过程\"></p><h2 id=\"感知机\"><a href=\"#感知机\" class=\"headerlink\" title=\"感知机\"></a>感知机</h2><p>感知机是神经网络的基础，与线性回归（Linear Regression），逻辑回归（Logistics Regression）等模型也非常类似，是一种非常典型的线性模型。</p><p>原始的感知机算法用于解决二分类问题，其思想如下：假设样本有 d 个特征，但是每个特征的重要性不一样，因此各个特征的权重也不一样，对其进行加权后得到的总和假如大于某个阈值则认为归为其中一类，反之归为另一类。如在信用卡的例子中，通过感知机有如下的结果<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla2.png\" title=\"推导过程\"></p><p>然后可以将threshold化为常数项作为<script type=\"math/tex\">w_0</script>,简化为下图：<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla3.png\" title=\"简化过程\"><br>上面的<script type=\"math/tex\">w</script>和<script type=\"math/tex\">x</script>均为一个列向量，即<script type=\"math/tex\">w</script>转置后成为行向量</p><h2 id=\"PLA\"><a href=\"#PLA\" class=\"headerlink\" title=\"PLA\"></a>PLA</h2><p>感知机要通过学习才能对样本进行正确的分类，这个学习的过程就是PLA(Perceptron Learning Algorithm).</p><p><strong>过程如下</strong>：</p><ol><li>随机初始化参数<script type=\"math/tex\">w</script></li><li>利用参数<script type=\"math/tex\">w</script>预测每个样本点的值并与其实际的值比较，对于分类错误的样本点(xn,yn),利用公式<script type=\"math/tex\">w=w+ynxn</script>更新参数<script type=\"math/tex\">w</script>的值</li><li>重复上面的过程直到所有的样本点都能够被参数<script type=\"math/tex\">w</script>正确预测。</li></ol><p>对于某个被预测错误的样本点，参数<script type=\"math/tex\">w</script>更新过程如下：<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla4.png\" title=\"w的更新\"></p><p>注意上面的算法的前提是所有的样本点都必须线性可分，假如样本点线性不可分，那么PLA按照上面的规则会陷入死循环中。如下是线性可分与线性不可分的例子)<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla5.png\" title=\"线性不可分的例子\"></p><h2 id=\"收敛性证明\"><a href=\"#收敛性证明\" class=\"headerlink\" title=\"收敛性证明\"></a>收敛性证明</h2><p>上面提到只有当所有的样本均为线性可分时，PLA才能将所有的样本点正确分类后再停下了，但是这仅仅是定性的说明而已，并没有严格的数学正面来支撑其收敛性，下面要讲的便是通过数学证明来说明 PLA 算法的收敛性。</p><p>课程中用两次递进的证明来说明收敛性<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla6.png\" title=\"简单证明\"></p><p>上面讲的是随着参数<script type=\"math/tex\">w</script>的更新,<script type=\"math/tex\">w^T_fw_t+1</script>的值越来越大，也就是两者越来越相似<br>衡量两个向量相似性的一种方法就是考虑他们的内积，值越大，代表两者约接近，但是这里还没对向量归一化，所以证明并不严格，但是已经说明了两者具有这个趋势，下面是更严格的过程<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-pla/pla7.png\" title=\"严格证明\"></p><p>上面似乎只是说明了经过 T 次的纠错，wt 的值会限制在一个范围内，但是并没有给出最终结论</p><script type=\"math/tex;mode=display\">{w_f \\over ||w_f||}{w_T \\over ||w_T||} \\ge \\sqrt{T} * constant</script><p>的证明过程，因此在这里进行推导过程的描述<br>(注：这里的<script type=\"math/tex\">w_f</script>是不变的，因此<script type=\"math/tex\">w_f</script>与<script type=\"math/tex\">w^T_f</script>是一样的)</p><p>假设经过了 T 次纠错，那由第一张PPT可知</p><script type=\"math/tex;mode=display\">w^T_fw_T \\ge w_f^Tw_{T-1} + \\min_{n}y_nw_f^Tx_n</script><p>而由第二章张ppt可知</p><script type=\"math/tex;mode=display\">||w_T||^2 \\le ||w_{T-1}||^2 + \\max_n||x_n||^2 \\le T\\max_n||x_n||^2</script><p>即：<script type=\"math/tex\">||w_T|| \\le \\sqrt{T}\\max_n||x_n||</script></p><p>综合上面两个式子有</p><script type=\"math/tex;mode=display\">{w_f^T \\over ||w_f^T||}{w_T \\over ||w_T||} \\ge {T\\min_ny_n^Tw^T_fx_n \\over ||w_f^T||\\sqrt{T}\\max_n||x_n||} = \\sqrt{T}{\\min_ny_n{w_f^T \\over ||w_f^T||}x_n \\over \\max_n||x_n||} = \\sqrt{T} * constant</script><p>因此上面的命题得证。至此，已经可知道犯错误的次数 T 是受到某个上限的约束的。下面会给出这个具体的上限是多少。</p><p>又因为</p><script type=\"math/tex;mode=display\">1 \\ge {w_f^T \\over ||w_f^T||}{w_T\\over||w_T||} \\ge \\sqrt{T} * constant</script><script type=\"math/tex;mode=display\">{1\\over constant^2 } \\ge T</script><p>即犯错的次数上限是${1 \\over constant^2}$,假设令</p><script type=\"math/tex;mode=display\">\\max_n||x||^2 = R^2, \\rho = \\min_ny_n{w_f^T \\over ||w_f^T||}x_n</script><p>则有</p><script type=\"math/tex;mode=display\">T \\le {R^2 \\over \\rho^2}</script><p>这也说明了PLA会在有限步内收敛，这个证明也是后面的练习答案</p><h2 id=\"优缺点和优化\"><a href=\"#优缺点和优化\" class=\"headerlink\" title=\"优缺点和优化\"></a>优缺点和优化</h2><p>PLA 的优点和缺点都非常明显，其中优点是简单，易于实现</p><p>缺点是假设了数据是线性可分的，然而事先并无法知道数据是否线性可分的。正如上面提到的一样，假如将PLA 用在线性不可分的数据中时，会导致PLA永远都无法对样本进行正确分类从而陷入到死循环中。</p><p>为了避免上面的情况，将 PLA 的条件放宽一点，不再要求所有的样本都能正确地分开，而是要求犯错的的样本尽可能的少，即将问题变为了</p><script type=\"math/tex;mode=display\">arg\\min_w\\sum_{n=0}^N1\\{y_n \\neq sign(w^Tx_n)\\}</script><p>这个最优化问题是个 NP-hard 问题，无法求得其最优解，因此只能求尽可能接近其最优解的近似解。讲义中提出的一种求解其近似解的算法<code>Pocket Algorithm</code>。</p><p>其思想就是每次保留当前最好的<script type=\"math/tex\">w</script>, 当遇到错误的样本点对<script type=\"math/tex\">w</script>进行修正后，比较修正后的<script type=\"math/tex\">w</script>与原来最好的<script type=\"math/tex\">w</script>在整个样本点上的总体效果再决定保留哪一个，重复迭代足够多的次数后返回当前得到的最好的<script type=\"math/tex\">w</script>。</p><!-- rebuild by neat -->"},{"title":"机器学习基石--Types of Learning","comments":1,"mathjax":true,"date":"2019-04-07T12:54:44.000Z","urlname":"machinelearning-types-of-learning","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n《机器学习基石》第三讲**Types of Learning**的笔记。主要介绍了机器学习的集中分类标准和具体分类。\n{% endnote %}\n<!--more-->\n\n# 不同的输出空间\n\n## 二元分类: binary classification\n很基本的分类问题，输出只有两种. 通俗的理解就是简单的是非题，要么是，要么不是。\n\n## 多元分类: multiclass classification\n很简单的例子就是对硬币的分类，课程中使用了美元的分类，1c, 5c, 10c, 25c 这样。\n\n输出可以不只两种，上述硬币的分类输出为四，输出可以是K种。\n\n二元分类是特殊的多元分类，即K=2的情况。\n\n**应用场景**:主要是视觉或听觉的辨识\n- 数字识别\n- 图片内容分类\n- 邮件的分类\n\n## 回归问题: Regression\n\n$ y=R $ or $y = [lower, upper] \\setminus R (bounded regression)$\n\n**特点是**输出是一个实数\n\n**应用**\n- 股票价格\n- 温度预测\n\n## 结构化学习: Structed Learning\n理解起来就是多元分类的扩展，有很多很多的类别，但是类别和类别之间有着某种潜在结构，我们要输出的就是这种结构。\n\n比如一个句子，可以是主谓宾、主谓等等，但是不可能是谓语谓语谓语这样。我们如果对一个句子进行语法判断，输出空间就是这些结构，而不是一个个的类别。\n\n**应用**:输出空间有着某种结构\n- 蛋白质的结构\n- 自然语言处理中语言的parse tree\n\n总的可以看下图：\n{% asset_img tol1.png Learning with Different Output Space %}\n\n\n# 不同程度标记的样本\n## 监督学习: Supervised Learning\n给了一堆样本，然后还对每个样本进行了标记是什么，即每个$$ x_n $$对应一个$$ y_n $$\n\n## 非监督学习: Unsupervised Learning\n给了一对样本，但是不给样本的正确标记(without yn), 让机器自己去把样本分成几类。\n\n**聚类**就相当于是**非监督的多分类问题**\n- 把一些文章按照不同的topic分类\n- 按照消费者的资料把消费者分类,针对不同的人群进行促销。\n\n**密度预测**相当于是**Unsupervised bounded regression**\n- 交通车流量分析,按照位置分\n\n**异常监测**相当于是**Unsupervised binary classification**\n- 网络流量分析\n\n{% note info %}\n聚类通常比较有用，但是评定聚类的好坏通常比较困难。\n{% endnote %}\n\n## 半监督式学习: Semi-supervised Learning\n比如硬币识别，但是只给了一部分$$ y_n $$，和其他没有标记的样本混在一起\n\n**应用**\n- 人脸识别，只有少量标记的面部照片\n- 药物效果预测，只有少量的药物有标签\n\n## 强化学习\n一种非常不同的，但是很自然的学习方式。不直接告诉它你要做什么，但是可以通过一定的行为反应，惩罚错误的结果，奖励正确的结果。\n\n比如训练狗狗，做得对就奖励，做的错就惩罚，没办法直接说给他听。\n\n**应用**\n- 广告系统输入的是顾客资料，顾客点击或者不点击，推荐\n\n## 总结\n{% asset_img tol2.png \"Learning with Different Data Label yn\" %}\n\n# 不同的训练方式\n## batch Supervised multiclass classification\n成批的将数据喂给机器学习的算法，算法从所有已知的data中学习，得到假设$$ g $$\n**应用**\n- 数据是email，得到邮件分类器\n- 数据是cancer资料，得到cancer分类器\n\n{% note info %}\n根据数据是否一次送入模型中训练分为batch learning和online learning.\n\nbatch learning像是填鸭式，online learning像是教书，一条一条教.\n{% endnote %}\n\n## online learning \n指每次有新样本的时候就用来训练更新 hypothesis，每一轮$$ g $$会更好, 常见的比如说有垃圾邮件分类系统.\n\n增强学习和PLA常常比较接近online learning\n\n## active learning\n希望是机器能够主动的问选择的$$ x_n $$对应的$$ y_n $$，可以通过这种方式用很少的labels来提高$$ g $$\n\n# 不同的输入空间\n根据输入的样本的特征来分也可以分为下面三类（虽然这种分类方法并不常见）：concrete features，raw features 和 abstract features。\n\n## concrete features\n指输入的样本已经标注好了各种特征，如信用卡例子中顾客的各种资料\n\n## raw features\n一般指图像或音频中的图像或声波，这些信息是原始的信号，需要进行一些转换才能使用。\n\n比如手写数字识别，16x16的像素格，可以将16x16=256个像素变成一个256维的向量输入。\n\n## abstract features\n课程中用了KDDCup的例子，给出每个用户和他们喜欢听的音乐，要预测这个用户对一个新歌曲的评分是多少。\n输入的是，用户id，歌曲的id，输出是评分数字\n\n但是输入的特征并不是很直接，需要一方面人来提示，还有是机器自己从每个人喜欢听的歌里面得到特征，从每首歌的曲风等特征里面总结出特征，然后再用这些特征训练，得到结果。\n\n这种按照输入样本的 features 进行分类的方法在实际中并不常用，因为输入的样本往往是各种 features交杂在一起的，不同问题需要与其相应的 features 才能得到好的效果，features 对结果的影响比较大。因此机器学习中也产生了 feature engineering 一说。\n\n## 总结\n{% asset_img tol3.png \"Learning with Different input Space\" %}\n\n\n\n\n","source":"_posts/MachineLearning/机器学习基石/机器学习基石-Types-of-Learning.md","raw":"---\ntitle: 机器学习基石--Types of Learning\ncomments: true\nmathjax: true\ndate: 2019-04-07 20:54:44\ntags: [机器学习基石,MachineLearning]\ncategories: [MachineLearning,机器学习基石,]\nurlname: machinelearning-types-of-learning\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n《机器学习基石》第三讲**Types of Learning**的笔记。主要介绍了机器学习的集中分类标准和具体分类。\n{% endnote %}\n<!--more-->\n\n# 不同的输出空间\n\n## 二元分类: binary classification\n很基本的分类问题，输出只有两种. 通俗的理解就是简单的是非题，要么是，要么不是。\n\n## 多元分类: multiclass classification\n很简单的例子就是对硬币的分类，课程中使用了美元的分类，1c, 5c, 10c, 25c 这样。\n\n输出可以不只两种，上述硬币的分类输出为四，输出可以是K种。\n\n二元分类是特殊的多元分类，即K=2的情况。\n\n**应用场景**:主要是视觉或听觉的辨识\n- 数字识别\n- 图片内容分类\n- 邮件的分类\n\n## 回归问题: Regression\n\n$ y=R $ or $y = [lower, upper] \\setminus R (bounded regression)$\n\n**特点是**输出是一个实数\n\n**应用**\n- 股票价格\n- 温度预测\n\n## 结构化学习: Structed Learning\n理解起来就是多元分类的扩展，有很多很多的类别，但是类别和类别之间有着某种潜在结构，我们要输出的就是这种结构。\n\n比如一个句子，可以是主谓宾、主谓等等，但是不可能是谓语谓语谓语这样。我们如果对一个句子进行语法判断，输出空间就是这些结构，而不是一个个的类别。\n\n**应用**:输出空间有着某种结构\n- 蛋白质的结构\n- 自然语言处理中语言的parse tree\n\n总的可以看下图：\n{% asset_img tol1.png Learning with Different Output Space %}\n\n\n# 不同程度标记的样本\n## 监督学习: Supervised Learning\n给了一堆样本，然后还对每个样本进行了标记是什么，即每个$$ x_n $$对应一个$$ y_n $$\n\n## 非监督学习: Unsupervised Learning\n给了一对样本，但是不给样本的正确标记(without yn), 让机器自己去把样本分成几类。\n\n**聚类**就相当于是**非监督的多分类问题**\n- 把一些文章按照不同的topic分类\n- 按照消费者的资料把消费者分类,针对不同的人群进行促销。\n\n**密度预测**相当于是**Unsupervised bounded regression**\n- 交通车流量分析,按照位置分\n\n**异常监测**相当于是**Unsupervised binary classification**\n- 网络流量分析\n\n{% note info %}\n聚类通常比较有用，但是评定聚类的好坏通常比较困难。\n{% endnote %}\n\n## 半监督式学习: Semi-supervised Learning\n比如硬币识别，但是只给了一部分$$ y_n $$，和其他没有标记的样本混在一起\n\n**应用**\n- 人脸识别，只有少量标记的面部照片\n- 药物效果预测，只有少量的药物有标签\n\n## 强化学习\n一种非常不同的，但是很自然的学习方式。不直接告诉它你要做什么，但是可以通过一定的行为反应，惩罚错误的结果，奖励正确的结果。\n\n比如训练狗狗，做得对就奖励，做的错就惩罚，没办法直接说给他听。\n\n**应用**\n- 广告系统输入的是顾客资料，顾客点击或者不点击，推荐\n\n## 总结\n{% asset_img tol2.png \"Learning with Different Data Label yn\" %}\n\n# 不同的训练方式\n## batch Supervised multiclass classification\n成批的将数据喂给机器学习的算法，算法从所有已知的data中学习，得到假设$$ g $$\n**应用**\n- 数据是email，得到邮件分类器\n- 数据是cancer资料，得到cancer分类器\n\n{% note info %}\n根据数据是否一次送入模型中训练分为batch learning和online learning.\n\nbatch learning像是填鸭式，online learning像是教书，一条一条教.\n{% endnote %}\n\n## online learning \n指每次有新样本的时候就用来训练更新 hypothesis，每一轮$$ g $$会更好, 常见的比如说有垃圾邮件分类系统.\n\n增强学习和PLA常常比较接近online learning\n\n## active learning\n希望是机器能够主动的问选择的$$ x_n $$对应的$$ y_n $$，可以通过这种方式用很少的labels来提高$$ g $$\n\n# 不同的输入空间\n根据输入的样本的特征来分也可以分为下面三类（虽然这种分类方法并不常见）：concrete features，raw features 和 abstract features。\n\n## concrete features\n指输入的样本已经标注好了各种特征，如信用卡例子中顾客的各种资料\n\n## raw features\n一般指图像或音频中的图像或声波，这些信息是原始的信号，需要进行一些转换才能使用。\n\n比如手写数字识别，16x16的像素格，可以将16x16=256个像素变成一个256维的向量输入。\n\n## abstract features\n课程中用了KDDCup的例子，给出每个用户和他们喜欢听的音乐，要预测这个用户对一个新歌曲的评分是多少。\n输入的是，用户id，歌曲的id，输出是评分数字\n\n但是输入的特征并不是很直接，需要一方面人来提示，还有是机器自己从每个人喜欢听的歌里面得到特征，从每首歌的曲风等特征里面总结出特征，然后再用这些特征训练，得到结果。\n\n这种按照输入样本的 features 进行分类的方法在实际中并不常用，因为输入的样本往往是各种 features交杂在一起的，不同问题需要与其相应的 features 才能得到好的效果，features 对结果的影响比较大。因此机器学习中也产生了 feature engineering 一说。\n\n## 总结\n{% asset_img tol3.png \"Learning with Different input Space\" %}\n\n\n\n\n","slug":"MachineLearning/机器学习基石/机器学习基石-Types-of-Learning","published":1,"updated":"2019-07-25T18:36:17.700Z","layout":"post","photos":[],"link":"","_id":"ck2424m3q00o0lksbmdj3ax24","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>《机器学习基石》第三讲<strong>Types of Learning</strong>的笔记。主要介绍了机器学习的集中分类标准和具体分类。</p></div><a id=\"more\"></a><h1 id=\"不同的输出空间\"><a href=\"#不同的输出空间\" class=\"headerlink\" title=\"不同的输出空间\"></a>不同的输出空间</h1><h2 id=\"二元分类-binary-classification\"><a href=\"#二元分类-binary-classification\" class=\"headerlink\" title=\"二元分类: binary classification\"></a>二元分类: binary classification</h2><p>很基本的分类问题，输出只有两种. 通俗的理解就是简单的是非题，要么是，要么不是。</p><h2 id=\"多元分类-multiclass-classification\"><a href=\"#多元分类-multiclass-classification\" class=\"headerlink\" title=\"多元分类: multiclass classification\"></a>多元分类: multiclass classification</h2><p>很简单的例子就是对硬币的分类，课程中使用了美元的分类，1c, 5c, 10c, 25c 这样。</p><p>输出可以不只两种，上述硬币的分类输出为四，输出可以是K种。</p><p>二元分类是特殊的多元分类，即K=2的情况。</p><p><strong>应用场景</strong>:主要是视觉或听觉的辨识</p><ul><li>数字识别</li><li>图片内容分类</li><li>邮件的分类</li></ul><h2 id=\"回归问题-Regression\"><a href=\"#回归问题-Regression\" class=\"headerlink\" title=\"回归问题: Regression\"></a>回归问题: Regression</h2><p>$ y=R $ or $y = [lower, upper] \\setminus R (bounded regression)$</p><p><strong>特点是</strong>输出是一个实数</p><p><strong>应用</strong></p><ul><li>股票价格</li><li>温度预测</li></ul><h2 id=\"结构化学习-Structed-Learning\"><a href=\"#结构化学习-Structed-Learning\" class=\"headerlink\" title=\"结构化学习: Structed Learning\"></a>结构化学习: Structed Learning</h2><p>理解起来就是多元分类的扩展，有很多很多的类别，但是类别和类别之间有着某种潜在结构，我们要输出的就是这种结构。</p><p>比如一个句子，可以是主谓宾、主谓等等，但是不可能是谓语谓语谓语这样。我们如果对一个句子进行语法判断，输出空间就是这些结构，而不是一个个的类别。</p><p><strong>应用</strong>:输出空间有着某种结构</p><ul><li>蛋白质的结构</li><li>自然语言处理中语言的parse tree</li></ul><p>总的可以看下图：<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-types-of-learning/tol1.png\" title=\"Learning with Different Output Space\"></p><h1 id=\"不同程度标记的样本\"><a href=\"#不同程度标记的样本\" class=\"headerlink\" title=\"不同程度标记的样本\"></a>不同程度标记的样本</h1><h2 id=\"监督学习-Supervised-Learning\"><a href=\"#监督学习-Supervised-Learning\" class=\"headerlink\" title=\"监督学习: Supervised Learning\"></a>监督学习: Supervised Learning</h2><p>给了一堆样本，然后还对每个样本进行了标记是什么，即每个<script type=\"math/tex\">x_n</script>对应一个<script type=\"math/tex\">y_n</script></p><h2 id=\"非监督学习-Unsupervised-Learning\"><a href=\"#非监督学习-Unsupervised-Learning\" class=\"headerlink\" title=\"非监督学习: Unsupervised Learning\"></a>非监督学习: Unsupervised Learning</h2><p>给了一对样本，但是不给样本的正确标记(without yn), 让机器自己去把样本分成几类。</p><p><strong>聚类</strong>就相当于是<strong>非监督的多分类问题</strong></p><ul><li>把一些文章按照不同的topic分类</li><li>按照消费者的资料把消费者分类,针对不同的人群进行促销。</li></ul><p><strong>密度预测</strong>相当于是<strong>Unsupervised bounded regression</strong></p><ul><li>交通车流量分析,按照位置分</li></ul><p><strong>异常监测</strong>相当于是<strong>Unsupervised binary classification</strong></p><ul><li>网络流量分析</li></ul><div class=\"note info\"><p>聚类通常比较有用，但是评定聚类的好坏通常比较困难。</p></div><h2 id=\"半监督式学习-Semi-supervised-Learning\"><a href=\"#半监督式学习-Semi-supervised-Learning\" class=\"headerlink\" title=\"半监督式学习: Semi-supervised Learning\"></a>半监督式学习: Semi-supervised Learning</h2><p>比如硬币识别，但是只给了一部分<script type=\"math/tex\">y_n</script>，和其他没有标记的样本混在一起</p><p><strong>应用</strong></p><ul><li>人脸识别，只有少量标记的面部照片</li><li>药物效果预测，只有少量的药物有标签</li></ul><h2 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h2><p>一种非常不同的，但是很自然的学习方式。不直接告诉它你要做什么，但是可以通过一定的行为反应，惩罚错误的结果，奖励正确的结果。</p><p>比如训练狗狗，做得对就奖励，做的错就惩罚，没办法直接说给他听。</p><p><strong>应用</strong></p><ul><li>广告系统输入的是顾客资料，顾客点击或者不点击，推荐</li></ul><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-types-of-learning/tol2.png\" title=\"Learning with Different Data Label yn\"><h1 id=\"不同的训练方式\"><a href=\"#不同的训练方式\" class=\"headerlink\" title=\"不同的训练方式\"></a>不同的训练方式</h1><h2 id=\"batch-Supervised-multiclass-classification\"><a href=\"#batch-Supervised-multiclass-classification\" class=\"headerlink\" title=\"batch Supervised multiclass classification\"></a>batch Supervised multiclass classification</h2><p>成批的将数据喂给机器学习的算法，算法从所有已知的data中学习，得到假设<script type=\"math/tex\">g</script><br><strong>应用</strong></p><ul><li>数据是email，得到邮件分类器</li><li>数据是cancer资料，得到cancer分类器</li></ul><div class=\"note info\"><p>根据数据是否一次送入模型中训练分为batch learning和online learning.</p><p>batch learning像是填鸭式，online learning像是教书，一条一条教.</p></div><h2 id=\"online-learning\"><a href=\"#online-learning\" class=\"headerlink\" title=\"online learning\"></a>online learning</h2><p>指每次有新样本的时候就用来训练更新 hypothesis，每一轮<script type=\"math/tex\">g</script>会更好, 常见的比如说有垃圾邮件分类系统.</p><p>增强学习和PLA常常比较接近online learning</p><h2 id=\"active-learning\"><a href=\"#active-learning\" class=\"headerlink\" title=\"active learning\"></a>active learning</h2><p>希望是机器能够主动的问选择的<script type=\"math/tex\">x_n</script>对应的<script type=\"math/tex\">y_n</script>，可以通过这种方式用很少的labels来提高<script type=\"math/tex\">g</script></p><h1 id=\"不同的输入空间\"><a href=\"#不同的输入空间\" class=\"headerlink\" title=\"不同的输入空间\"></a>不同的输入空间</h1><p>根据输入的样本的特征来分也可以分为下面三类（虽然这种分类方法并不常见）：concrete features，raw features 和 abstract features。</p><h2 id=\"concrete-features\"><a href=\"#concrete-features\" class=\"headerlink\" title=\"concrete features\"></a>concrete features</h2><p>指输入的样本已经标注好了各种特征，如信用卡例子中顾客的各种资料</p><h2 id=\"raw-features\"><a href=\"#raw-features\" class=\"headerlink\" title=\"raw features\"></a>raw features</h2><p>一般指图像或音频中的图像或声波，这些信息是原始的信号，需要进行一些转换才能使用。</p><p>比如手写数字识别，16x16的像素格，可以将16x16=256个像素变成一个256维的向量输入。</p><h2 id=\"abstract-features\"><a href=\"#abstract-features\" class=\"headerlink\" title=\"abstract features\"></a>abstract features</h2><p>课程中用了KDDCup的例子，给出每个用户和他们喜欢听的音乐，要预测这个用户对一个新歌曲的评分是多少。<br>输入的是，用户id，歌曲的id，输出是评分数字</p><p>但是输入的特征并不是很直接，需要一方面人来提示，还有是机器自己从每个人喜欢听的歌里面得到特征，从每首歌的曲风等特征里面总结出特征，然后再用这些特征训练，得到结果。</p><p>这种按照输入样本的 features 进行分类的方法在实际中并不常用，因为输入的样本往往是各种 features交杂在一起的，不同问题需要与其相应的 features 才能得到好的效果，features 对结果的影响比较大。因此机器学习中也产生了 feature engineering 一说。</p><h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-types-of-learning/tol3.png\" title=\"Learning with Different input Space\"><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>《机器学习基石》第三讲<strong>Types of Learning</strong>的笔记。主要介绍了机器学习的集中分类标准和具体分类。</p></div>","more":"<h1 id=\"不同的输出空间\"><a href=\"#不同的输出空间\" class=\"headerlink\" title=\"不同的输出空间\"></a>不同的输出空间</h1><h2 id=\"二元分类-binary-classification\"><a href=\"#二元分类-binary-classification\" class=\"headerlink\" title=\"二元分类: binary classification\"></a>二元分类: binary classification</h2><p>很基本的分类问题，输出只有两种. 通俗的理解就是简单的是非题，要么是，要么不是。</p><h2 id=\"多元分类-multiclass-classification\"><a href=\"#多元分类-multiclass-classification\" class=\"headerlink\" title=\"多元分类: multiclass classification\"></a>多元分类: multiclass classification</h2><p>很简单的例子就是对硬币的分类，课程中使用了美元的分类，1c, 5c, 10c, 25c 这样。</p><p>输出可以不只两种，上述硬币的分类输出为四，输出可以是K种。</p><p>二元分类是特殊的多元分类，即K=2的情况。</p><p><strong>应用场景</strong>:主要是视觉或听觉的辨识</p><ul><li>数字识别</li><li>图片内容分类</li><li>邮件的分类</li></ul><h2 id=\"回归问题-Regression\"><a href=\"#回归问题-Regression\" class=\"headerlink\" title=\"回归问题: Regression\"></a>回归问题: Regression</h2><p>$ y=R $ or $y = [lower, upper] \\setminus R (bounded regression)$</p><p><strong>特点是</strong>输出是一个实数</p><p><strong>应用</strong></p><ul><li>股票价格</li><li>温度预测</li></ul><h2 id=\"结构化学习-Structed-Learning\"><a href=\"#结构化学习-Structed-Learning\" class=\"headerlink\" title=\"结构化学习: Structed Learning\"></a>结构化学习: Structed Learning</h2><p>理解起来就是多元分类的扩展，有很多很多的类别，但是类别和类别之间有着某种潜在结构，我们要输出的就是这种结构。</p><p>比如一个句子，可以是主谓宾、主谓等等，但是不可能是谓语谓语谓语这样。我们如果对一个句子进行语法判断，输出空间就是这些结构，而不是一个个的类别。</p><p><strong>应用</strong>:输出空间有着某种结构</p><ul><li>蛋白质的结构</li><li>自然语言处理中语言的parse tree</li></ul><p>总的可以看下图：<br><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-types-of-learning/tol1.png\" title=\"Learning with Different Output Space\"></p><h1 id=\"不同程度标记的样本\"><a href=\"#不同程度标记的样本\" class=\"headerlink\" title=\"不同程度标记的样本\"></a>不同程度标记的样本</h1><h2 id=\"监督学习-Supervised-Learning\"><a href=\"#监督学习-Supervised-Learning\" class=\"headerlink\" title=\"监督学习: Supervised Learning\"></a>监督学习: Supervised Learning</h2><p>给了一堆样本，然后还对每个样本进行了标记是什么，即每个<script type=\"math/tex\">x_n</script>对应一个<script type=\"math/tex\">y_n</script></p><h2 id=\"非监督学习-Unsupervised-Learning\"><a href=\"#非监督学习-Unsupervised-Learning\" class=\"headerlink\" title=\"非监督学习: Unsupervised Learning\"></a>非监督学习: Unsupervised Learning</h2><p>给了一对样本，但是不给样本的正确标记(without yn), 让机器自己去把样本分成几类。</p><p><strong>聚类</strong>就相当于是<strong>非监督的多分类问题</strong></p><ul><li>把一些文章按照不同的topic分类</li><li>按照消费者的资料把消费者分类,针对不同的人群进行促销。</li></ul><p><strong>密度预测</strong>相当于是<strong>Unsupervised bounded regression</strong></p><ul><li>交通车流量分析,按照位置分</li></ul><p><strong>异常监测</strong>相当于是<strong>Unsupervised binary classification</strong></p><ul><li>网络流量分析</li></ul><div class=\"note info\"><p>聚类通常比较有用，但是评定聚类的好坏通常比较困难。</p></div><h2 id=\"半监督式学习-Semi-supervised-Learning\"><a href=\"#半监督式学习-Semi-supervised-Learning\" class=\"headerlink\" title=\"半监督式学习: Semi-supervised Learning\"></a>半监督式学习: Semi-supervised Learning</h2><p>比如硬币识别，但是只给了一部分<script type=\"math/tex\">y_n</script>，和其他没有标记的样本混在一起</p><p><strong>应用</strong></p><ul><li>人脸识别，只有少量标记的面部照片</li><li>药物效果预测，只有少量的药物有标签</li></ul><h2 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h2><p>一种非常不同的，但是很自然的学习方式。不直接告诉它你要做什么，但是可以通过一定的行为反应，惩罚错误的结果，奖励正确的结果。</p><p>比如训练狗狗，做得对就奖励，做的错就惩罚，没办法直接说给他听。</p><p><strong>应用</strong></p><ul><li>广告系统输入的是顾客资料，顾客点击或者不点击，推荐</li></ul><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-types-of-learning/tol2.png\" title=\"Learning with Different Data Label yn\"><h1 id=\"不同的训练方式\"><a href=\"#不同的训练方式\" class=\"headerlink\" title=\"不同的训练方式\"></a>不同的训练方式</h1><h2 id=\"batch-Supervised-multiclass-classification\"><a href=\"#batch-Supervised-multiclass-classification\" class=\"headerlink\" title=\"batch Supervised multiclass classification\"></a>batch Supervised multiclass classification</h2><p>成批的将数据喂给机器学习的算法，算法从所有已知的data中学习，得到假设<script type=\"math/tex\">g</script><br><strong>应用</strong></p><ul><li>数据是email，得到邮件分类器</li><li>数据是cancer资料，得到cancer分类器</li></ul><div class=\"note info\"><p>根据数据是否一次送入模型中训练分为batch learning和online learning.</p><p>batch learning像是填鸭式，online learning像是教书，一条一条教.</p></div><h2 id=\"online-learning\"><a href=\"#online-learning\" class=\"headerlink\" title=\"online learning\"></a>online learning</h2><p>指每次有新样本的时候就用来训练更新 hypothesis，每一轮<script type=\"math/tex\">g</script>会更好, 常见的比如说有垃圾邮件分类系统.</p><p>增强学习和PLA常常比较接近online learning</p><h2 id=\"active-learning\"><a href=\"#active-learning\" class=\"headerlink\" title=\"active learning\"></a>active learning</h2><p>希望是机器能够主动的问选择的<script type=\"math/tex\">x_n</script>对应的<script type=\"math/tex\">y_n</script>，可以通过这种方式用很少的labels来提高<script type=\"math/tex\">g</script></p><h1 id=\"不同的输入空间\"><a href=\"#不同的输入空间\" class=\"headerlink\" title=\"不同的输入空间\"></a>不同的输入空间</h1><p>根据输入的样本的特征来分也可以分为下面三类（虽然这种分类方法并不常见）：concrete features，raw features 和 abstract features。</p><h2 id=\"concrete-features\"><a href=\"#concrete-features\" class=\"headerlink\" title=\"concrete features\"></a>concrete features</h2><p>指输入的样本已经标注好了各种特征，如信用卡例子中顾客的各种资料</p><h2 id=\"raw-features\"><a href=\"#raw-features\" class=\"headerlink\" title=\"raw features\"></a>raw features</h2><p>一般指图像或音频中的图像或声波，这些信息是原始的信号，需要进行一些转换才能使用。</p><p>比如手写数字识别，16x16的像素格，可以将16x16=256个像素变成一个256维的向量输入。</p><h2 id=\"abstract-features\"><a href=\"#abstract-features\" class=\"headerlink\" title=\"abstract features\"></a>abstract features</h2><p>课程中用了KDDCup的例子，给出每个用户和他们喜欢听的音乐，要预测这个用户对一个新歌曲的评分是多少。<br>输入的是，用户id，歌曲的id，输出是评分数字</p><p>但是输入的特征并不是很直接，需要一方面人来提示，还有是机器自己从每个人喜欢听的歌里面得到特征，从每首歌的曲风等特征里面总结出特征，然后再用这些特征训练，得到结果。</p><p>这种按照输入样本的 features 进行分类的方法在实际中并不常用，因为输入的样本往往是各种 features交杂在一起的，不同问题需要与其相应的 features 才能得到好的效果，features 对结果的影响比较大。因此机器学习中也产生了 feature engineering 一说。</p><h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><img src=\"/MachineLearning/机器学习基石/2019-04-07-machinelearning-types-of-learning/tol3.png\" title=\"Learning with Different input Space\"><!-- rebuild by neat -->"},{"title":"机器学习基石--Feasibility of Learning","comments":1,"mathjax":false,"date":"2019-04-08T09:38:49.000Z","urlname":"machinelearning-feasibility-of-learning","_content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n《机器学习基石》第四讲**Feasibility of Learning**的课程笔记。主要介绍了机器学习的可行性。\n{% endnote %}\n<!--more-->\n\n机器学习很多时候，如果不加限制，常常会因为标准的不同，而有很多的不一样的结果。\n\n并且，在训练集内得到的结果拟合的很好，但是在测试集甚至所有的可能来看，可能就是错误的，可能就是不确定的\n\n# Learning is impossiable\n\n## No Free Lunch\n> 即: 天下没有免费的午餐\n> 用于比较两种优化算法之间的关系，即如何确定一种算法比另外一种算法好\n\nNFL定理的前提是，所有问题出现的机会相等、或所有问题都是同等重要。\n\n而实际情形往往并不是这样。一般我们只需要关注自己正要解决的问题即可。而对于我们的解决方案在另一个问题上的表现是否同等出色，我们并不关心。\n\n> 因此，脱离具体问题而空谈“什么算法最好”之类的讨论毫无意义. \n>  因为若考虑所有潜在的问题，那么所有的模型、算法都一样好——这也是我们通过NFL定理得出的。\n> 要比较模型的相对优劣，则必须建立在与之对应的学习问题之上。\n\n# Probability to the Rescue\n\n## Hoeffding's Inequality\n> Hoeffding 不等式\n\n大概意思就是不知道很大的样本中的概率，但是我们可以通过很多次的抽样，得到的概率来推测真正的概率。\n\n想到以前数学家证明硬币一面朝上的概率，通过很多很多很多次的抛硬币来统计每面朝上的概率，最后证明就是1/2，并且抛的次数越多，概率越接近。\n\n{% asset_img fol1.png \"Hoeffding Inequality 1/2\" %}\n{% asset_img fol2.png \"Hoeffding Inequality 2/2\" %}\n\n# Connection to Learning\n\n$$ E_in(h) $$代表我们抽的样本中的不一致概率\n\n$$ E_out(h) $$代表总的样本中的不一致的概率\n\n可以推断说N足够大时，$$ E_in(h) \\sim E_out(h) $$\n\n如果$$ E_in(h) \\sim E_out(h) $$，并且$$ E_in(h) $$很小，我们就可以推断，$$ E_out(h) $$很小，并且，$$ h \\sim f with respect to P $$\n\n{% asset_img fol3.png \"Added Componentss\" %}\n{% asset_img fol4.png \"The Formal Guarantee\" %}\n\n{% note danger %}\n**real learning** is: $$ A $$ shall **make choices $$ \\in H $$** (like PLA)\nrather than *being forced to pick one h*\n{% endnote %}\n\n{% note info %}\n可以使用历史数据(data)来验证一个假设的表现到底好不好, 可以理解为验证集\n{% endnote %}\n\n# Connection to Real Learning\n提出了问题：如果我们在一堆假设中看到了一个假设，在我们选出的样本上全对，我们要不要选择这个假设？举例子就是每个人都抛硬币，抛五次，可能有一个人会五次全都朝上，我们要不要说这个硬币会有点特殊？\n\nHoeffding说的是取样的和真实的大部分情况下是符合的，只有小部分是不好的\n\n事实上当你有选择的时候，比如这里抛五次硬币实验150次的时候,150次试验里出现一次五个硬币同时朝上的概率就是$$ 1 - {(31 \\over 32)^150} > 99% $$\n\n因此不好的样本，在有选择的时候，出现的概率会恶化。\n**不好的Data** == $$ A $$不可以自由做选择，可能会踩雷 == 存在$$ h $$使$$ E_out(h) $$和$$ E_in(h) $$\n差得很大\n\nHoeffding说的是在一个Data里面，抽一堆和大部分符合\n\n这里说的其实是一堆Data里，出现不好的Data的概率是：\n{% asset_img fol5.png \"Bound of BAD Data\" %}\n\n所以如果假设数量有限，即M有限，并且每个Data样本N足够大，那么不管$$ A $$怎么选，$$ E_out(g) \\sim E_in(g)$$，即可以放心选，这样就说明了有限数量的h情况下，机器学习是可行的\n\n\n\n","source":"_posts/MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning.md","raw":"---\ntitle: 机器学习基石--Feasibility of Learning\ncomments: true\nmathjax: false\ndate: 2019-04-08 17:38:49\ntags: [机器学习基石,MachineLearning]\ncategories: [MachineLearning,机器学习基石,]\nurlname: machinelearning-feasibility-of-learning\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n{% note info %}\n《机器学习基石》第四讲**Feasibility of Learning**的课程笔记。主要介绍了机器学习的可行性。\n{% endnote %}\n<!--more-->\n\n机器学习很多时候，如果不加限制，常常会因为标准的不同，而有很多的不一样的结果。\n\n并且，在训练集内得到的结果拟合的很好，但是在测试集甚至所有的可能来看，可能就是错误的，可能就是不确定的\n\n# Learning is impossiable\n\n## No Free Lunch\n> 即: 天下没有免费的午餐\n> 用于比较两种优化算法之间的关系，即如何确定一种算法比另外一种算法好\n\nNFL定理的前提是，所有问题出现的机会相等、或所有问题都是同等重要。\n\n而实际情形往往并不是这样。一般我们只需要关注自己正要解决的问题即可。而对于我们的解决方案在另一个问题上的表现是否同等出色，我们并不关心。\n\n> 因此，脱离具体问题而空谈“什么算法最好”之类的讨论毫无意义. \n>  因为若考虑所有潜在的问题，那么所有的模型、算法都一样好——这也是我们通过NFL定理得出的。\n> 要比较模型的相对优劣，则必须建立在与之对应的学习问题之上。\n\n# Probability to the Rescue\n\n## Hoeffding's Inequality\n> Hoeffding 不等式\n\n大概意思就是不知道很大的样本中的概率，但是我们可以通过很多次的抽样，得到的概率来推测真正的概率。\n\n想到以前数学家证明硬币一面朝上的概率，通过很多很多很多次的抛硬币来统计每面朝上的概率，最后证明就是1/2，并且抛的次数越多，概率越接近。\n\n{% asset_img fol1.png \"Hoeffding Inequality 1/2\" %}\n{% asset_img fol2.png \"Hoeffding Inequality 2/2\" %}\n\n# Connection to Learning\n\n$$ E_in(h) $$代表我们抽的样本中的不一致概率\n\n$$ E_out(h) $$代表总的样本中的不一致的概率\n\n可以推断说N足够大时，$$ E_in(h) \\sim E_out(h) $$\n\n如果$$ E_in(h) \\sim E_out(h) $$，并且$$ E_in(h) $$很小，我们就可以推断，$$ E_out(h) $$很小，并且，$$ h \\sim f with respect to P $$\n\n{% asset_img fol3.png \"Added Componentss\" %}\n{% asset_img fol4.png \"The Formal Guarantee\" %}\n\n{% note danger %}\n**real learning** is: $$ A $$ shall **make choices $$ \\in H $$** (like PLA)\nrather than *being forced to pick one h*\n{% endnote %}\n\n{% note info %}\n可以使用历史数据(data)来验证一个假设的表现到底好不好, 可以理解为验证集\n{% endnote %}\n\n# Connection to Real Learning\n提出了问题：如果我们在一堆假设中看到了一个假设，在我们选出的样本上全对，我们要不要选择这个假设？举例子就是每个人都抛硬币，抛五次，可能有一个人会五次全都朝上，我们要不要说这个硬币会有点特殊？\n\nHoeffding说的是取样的和真实的大部分情况下是符合的，只有小部分是不好的\n\n事实上当你有选择的时候，比如这里抛五次硬币实验150次的时候,150次试验里出现一次五个硬币同时朝上的概率就是$$ 1 - {(31 \\over 32)^150} > 99% $$\n\n因此不好的样本，在有选择的时候，出现的概率会恶化。\n**不好的Data** == $$ A $$不可以自由做选择，可能会踩雷 == 存在$$ h $$使$$ E_out(h) $$和$$ E_in(h) $$\n差得很大\n\nHoeffding说的是在一个Data里面，抽一堆和大部分符合\n\n这里说的其实是一堆Data里，出现不好的Data的概率是：\n{% asset_img fol5.png \"Bound of BAD Data\" %}\n\n所以如果假设数量有限，即M有限，并且每个Data样本N足够大，那么不管$$ A $$怎么选，$$ E_out(g) \\sim E_in(g)$$，即可以放心选，这样就说明了有限数量的h情况下，机器学习是可行的\n\n\n\n","slug":"MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning","published":1,"updated":"2019-07-25T18:35:53.226Z","layout":"post","photos":[],"link":"","_id":"ck2424m5u00oflksb0py5nenc","content":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>《机器学习基石》第四讲<strong>Feasibility of Learning</strong>的课程笔记。主要介绍了机器学习的可行性。</p></div><a id=\"more\"></a><p>机器学习很多时候，如果不加限制，常常会因为标准的不同，而有很多的不一样的结果。</p><p>并且，在训练集内得到的结果拟合的很好，但是在测试集甚至所有的可能来看，可能就是错误的，可能就是不确定的</p><h1 id=\"Learning-is-impossiable\"><a href=\"#Learning-is-impossiable\" class=\"headerlink\" title=\"Learning is impossiable\"></a>Learning is impossiable</h1><h2 id=\"No-Free-Lunch\"><a href=\"#No-Free-Lunch\" class=\"headerlink\" title=\"No Free Lunch\"></a>No Free Lunch</h2><blockquote><p>即: 天下没有免费的午餐<br>用于比较两种优化算法之间的关系，即如何确定一种算法比另外一种算法好</p></blockquote><p>NFL定理的前提是，所有问题出现的机会相等、或所有问题都是同等重要。</p><p>而实际情形往往并不是这样。一般我们只需要关注自己正要解决的问题即可。而对于我们的解决方案在另一个问题上的表现是否同等出色，我们并不关心。</p><blockquote><p>因此，脱离具体问题而空谈“什么算法最好”之类的讨论毫无意义.<br>因为若考虑所有潜在的问题，那么所有的模型、算法都一样好——这也是我们通过NFL定理得出的。<br>要比较模型的相对优劣，则必须建立在与之对应的学习问题之上。</p></blockquote><h1 id=\"Probability-to-the-Rescue\"><a href=\"#Probability-to-the-Rescue\" class=\"headerlink\" title=\"Probability to the Rescue\"></a>Probability to the Rescue</h1><h2 id=\"Hoeffding’s-Inequality\"><a href=\"#Hoeffding’s-Inequality\" class=\"headerlink\" title=\"Hoeffding’s Inequality\"></a>Hoeffding’s Inequality</h2><blockquote><p>Hoeffding 不等式</p></blockquote><p>大概意思就是不知道很大的样本中的概率，但是我们可以通过很多次的抽样，得到的概率来推测真正的概率。</p><p>想到以前数学家证明硬币一面朝上的概率，通过很多很多很多次的抛硬币来统计每面朝上的概率，最后证明就是1/2，并且抛的次数越多，概率越接近。</p><img src=\"/MachineLearning/机器学习基石/2019-04-08-machinelearning-feasibility-of-learning/fol1.png\" title=\"Hoeffding Inequality 1/2\"> <img src=\"/MachineLearning/机器学习基石/2019-04-08-machinelearning-feasibility-of-learning/fol2.png\" title=\"Hoeffding Inequality 2/2\"><h1 id=\"Connection-to-Learning\"><a href=\"#Connection-to-Learning\" class=\"headerlink\" title=\"Connection to Learning\"></a>Connection to Learning</h1><script type=\"math/tex;mode=display\">E_in(h) $$代表我们抽的样本中的不一致概率\n\n$$ E_out(h) $$代表总的样本中的不一致的概率\n\n可以推断说N足够大时，$$ E_in(h) \\sim E_out(h)</script><p>如果<script type=\"math/tex\">E_in(h) \\sim E_out(h)</script>，并且<script type=\"math/tex\">E_in(h)</script>很小，我们就可以推断，<script type=\"math/tex\">E_out(h)</script>很小，并且，<script type=\"math/tex\">h \\sim f with respect to P</script></p><img src=\"/MachineLearning/机器学习基石/2019-04-08-machinelearning-feasibility-of-learning/fol3.png\" title=\"Added Componentss\"> <img src=\"/MachineLearning/机器学习基石/2019-04-08-machinelearning-feasibility-of-learning/fol4.png\" title=\"The Formal Guarantee\"><div class=\"note danger\"><p><strong>real learning</strong> is:<script type=\"math/tex\">A</script>shall <strong>make choices<script type=\"math/tex\">\\in H</script></strong>(like PLA)<br>rather than <em>being forced to pick one h</em></p></div><div class=\"note info\"><p>可以使用历史数据(data)来验证一个假设的表现到底好不好, 可以理解为验证集</p></div><h1 id=\"Connection-to-Real-Learning\"><a href=\"#Connection-to-Real-Learning\" class=\"headerlink\" title=\"Connection to Real Learning\"></a>Connection to Real Learning</h1><p>提出了问题：如果我们在一堆假设中看到了一个假设，在我们选出的样本上全对，我们要不要选择这个假设？举例子就是每个人都抛硬币，抛五次，可能有一个人会五次全都朝上，我们要不要说这个硬币会有点特殊？</p><p>Hoeffding说的是取样的和真实的大部分情况下是符合的，只有小部分是不好的</p><p>事实上当你有选择的时候，比如这里抛五次硬币实验150次的时候,150次试验里出现一次五个硬币同时朝上的概率就是<script type=\"math/tex\">1 - {(31 \\over 32)^150} > 99%</script></p><p>因此不好的样本，在有选择的时候，出现的概率会恶化。<br><strong>不好的Data</strong> ==<script type=\"math/tex\">A</script>不可以自由做选择，可能会踩雷 == 存在<script type=\"math/tex\">h</script>使<script type=\"math/tex\">E_out(h)</script>和<script type=\"math/tex\">E_in(h)</script><br>差得很大</p><p>Hoeffding说的是在一个Data里面，抽一堆和大部分符合</p><p>这里说的其实是一堆Data里，出现不好的Data的概率是：<br><img src=\"/MachineLearning/机器学习基石/2019-04-08-machinelearning-feasibility-of-learning/fol5.png\" title=\"Bound of BAD Data\"></p><p>所以如果假设数量有限，即M有限，并且每个Data样本N足够大，那么不管<script type=\"math/tex\">A</script>怎么选，<script type=\"math/tex\">E_out(g) \\sim E_in(g)</script>，即可以放心选，这样就说明了有限数量的h情况下，机器学习是可行的</p><!-- rebuild by neat -->","site":{"data":{"next":{"title":"Catch Your Dream","subtitle":null,"description":"Hanielxx | Blog","keywords":null,"author":"Hanielxx","language":"en","timezone":null,"url":"https://hanielxx.com","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"line_number":true,"auto_detect":false,"tab_replace":null},"index_generator":{"path":"","per_page":10,"order_by":"-date"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"paginatio_dir":"page","theme":"next-geek","deploy":[{"type":"git","repo":{"github":"git@github.com:HanielF/HanielF.github.io.git","coding":"git@git.coding.net:Haniel/Haniel.git"},"branch":"master"},{"type":"baidu_url_submitter"}],"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"baidu_url_submit":{"count":10,"host":"hanielxx.com","token":"gT0Hs3z4GUjVcTUv","path":"baidu_urls.txt"},"favicon":"/favicon.ico","rss":null,"authoricon":"heart","copyright":true,"canonical":true,"seo":false,"index_with_subtitle":false,"menu":{"home":"/","categories":"/categories/","archives":"/archives/","tags":"/tags/","algorithm":"/tags/Algorithm/"},"menu_icons":{"enable":true,"home":"home","about":"user","categories":"th","schedule":"calendar","tags":"tags","archives":"archive","sitemap":"sitemap","commonweal":"heartbeat","algorithm":"code"},"scheme":"Mala","social":{"GitHub":"https://github.com/HanielF","E-Mail":"mailto:hanielxx@outlook.com"},"social_icons":{"enable":true,"icons_only":false,"transition":false,"GitHub":"github","E-Mail":"envelope","Google":"google","Twitter":"twitter","FB Page":"facebook","VK Group":"vk","Skype":"skype","YouTube":"youtube","Instagram":"instagram","StackOverflow":"stack-overflow","Weibo":"weibo"},"avatar":"/uploads/avatar.jpg","toc":{"enable":true,"number":true,"wrap":true},"sidebar":{"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},"scroll_to_more":true,"save_scroll":true,"excerpt_description":true,"auto_excerpt":{"enable":false,"length":150},"post_meta":{"item_text":true,"created_at":true,"updated_at":false,"categories":true},"post_wordcount":{"item_text":true,"wordcount":true,"min2read":true,"totalcount":true,"separated_meta":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":{"enabled":false,"image":null},"highlight_theme":"night eighties","font":{"enable":true,"host":null,"global":{"external":true,"family":"Lato"},"headings":{"external":true,"family":null},"posts":{"external":true,"family":null},"logo":{"external":true,"family":null,"size":null},"codes":{"external":true,"family":null,"size":null}},"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"},"han":false,"disqus":{"enable":false,"shortname":null,"count":true},"changyan":{"enable":false,"appid":null,"appkey":null},"suprise":{"ball":true},"valine":{"enable":true,"appid":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","appkey":"dLWVYMk366NEnW44SaBr3FdL","notify":false,"verify":false,"placeholder":"Comment in your way!","avatar":"retro","guest_info":"nick,mail,link","pageSize":10},"duoshuo_info":{"ua_enable":true,"admin_enable":false,"user_id":0},"facebook_sdk":{"enable":false,"app_id":null,"fb_admin":null,"like_button":null,"webmaster":null},"facebook_comments_plugin":{"enable":false,"num_of_posts":10,"width":"100%","scheme":"light"},"vkontakte_api":{"enable":false,"app_id":null,"like":true,"comments":true,"num_of_posts":10},"rating":{"enable":false,"id":null,"color":"fc6423"},"leancloud_visitors":{"enable":true,"app_id":"h26w2GPeIju4o37JSWro2OKv-gzGzoHsz","app_key":"dLWVYMk366NEnW44SaBr3FdL"},"busuanzi_count":{"enable":false,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":false,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"baidu_push":true,"calendar":{"enable":false,"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"timeZone":null,"showDeleted":false,"singleEvents":true,"maxResults":250},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":true,"trigger":"auto","top_n_per_article":1},"exturl":false,"note":{"style":"simple","icons":false,"border_radius":3,"light_bg_offset":0},"label":true,"tabs":{"enable":true,"transition":{"tabs":false,"labels":true},"border_radius":0},"use_motion":true,"fancybox":true,"pace":true,"pace_theme":"pace-theme-minimal","canvas_nest":false,"three_waves":false,"canvas_lines":true,"canvas_sphere":false,"canvas_ribbon":false,"vendors":{"_internal":"lib","jquery":null,"fancybox":null,"fancybox_css":null,"fastclick":null,"lazyload":null,"velocity":null,"velocity_ui":null,"ua_parser":null,"fontawesome":null,"algolia_instant_js":null,"algolia_instant_css":null,"pace":null,"pace_css":null,"canvas_nest":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null,"han":null},"css":"css","js":"js","images":"images","version":"5.1.2"}}},"excerpt":"<!-- build time:Thu Oct 24 2019 09:58:07 GMT+0800 (China Standard Time) --><meta name=\"referrer\" content=\"no-referrer\"><div class=\"note info\"><p>《机器学习基石》第四讲<strong>Feasibility of Learning</strong>的课程笔记。主要介绍了机器学习的可行性。</p></div>","more":"<p>机器学习很多时候，如果不加限制，常常会因为标准的不同，而有很多的不一样的结果。</p><p>并且，在训练集内得到的结果拟合的很好，但是在测试集甚至所有的可能来看，可能就是错误的，可能就是不确定的</p><h1 id=\"Learning-is-impossiable\"><a href=\"#Learning-is-impossiable\" class=\"headerlink\" title=\"Learning is impossiable\"></a>Learning is impossiable</h1><h2 id=\"No-Free-Lunch\"><a href=\"#No-Free-Lunch\" class=\"headerlink\" title=\"No Free Lunch\"></a>No Free Lunch</h2><blockquote><p>即: 天下没有免费的午餐<br>用于比较两种优化算法之间的关系，即如何确定一种算法比另外一种算法好</p></blockquote><p>NFL定理的前提是，所有问题出现的机会相等、或所有问题都是同等重要。</p><p>而实际情形往往并不是这样。一般我们只需要关注自己正要解决的问题即可。而对于我们的解决方案在另一个问题上的表现是否同等出色，我们并不关心。</p><blockquote><p>因此，脱离具体问题而空谈“什么算法最好”之类的讨论毫无意义.<br>因为若考虑所有潜在的问题，那么所有的模型、算法都一样好——这也是我们通过NFL定理得出的。<br>要比较模型的相对优劣，则必须建立在与之对应的学习问题之上。</p></blockquote><h1 id=\"Probability-to-the-Rescue\"><a href=\"#Probability-to-the-Rescue\" class=\"headerlink\" title=\"Probability to the Rescue\"></a>Probability to the Rescue</h1><h2 id=\"Hoeffding’s-Inequality\"><a href=\"#Hoeffding’s-Inequality\" class=\"headerlink\" title=\"Hoeffding’s Inequality\"></a>Hoeffding’s Inequality</h2><blockquote><p>Hoeffding 不等式</p></blockquote><p>大概意思就是不知道很大的样本中的概率，但是我们可以通过很多次的抽样，得到的概率来推测真正的概率。</p><p>想到以前数学家证明硬币一面朝上的概率，通过很多很多很多次的抛硬币来统计每面朝上的概率，最后证明就是1/2，并且抛的次数越多，概率越接近。</p><img src=\"/MachineLearning/机器学习基石/2019-04-08-machinelearning-feasibility-of-learning/fol1.png\" title=\"Hoeffding Inequality 1/2\"> <img src=\"/MachineLearning/机器学习基石/2019-04-08-machinelearning-feasibility-of-learning/fol2.png\" title=\"Hoeffding Inequality 2/2\"><h1 id=\"Connection-to-Learning\"><a href=\"#Connection-to-Learning\" class=\"headerlink\" title=\"Connection to Learning\"></a>Connection to Learning</h1><script type=\"math/tex;mode=display\">E_in(h) $$代表我们抽的样本中的不一致概率\n\n$$ E_out(h) $$代表总的样本中的不一致的概率\n\n可以推断说N足够大时，$$ E_in(h) \\sim E_out(h)</script><p>如果<script type=\"math/tex\">E_in(h) \\sim E_out(h)</script>，并且<script type=\"math/tex\">E_in(h)</script>很小，我们就可以推断，<script type=\"math/tex\">E_out(h)</script>很小，并且，<script type=\"math/tex\">h \\sim f with respect to P</script></p><img src=\"/MachineLearning/机器学习基石/2019-04-08-machinelearning-feasibility-of-learning/fol3.png\" title=\"Added Componentss\"> <img src=\"/MachineLearning/机器学习基石/2019-04-08-machinelearning-feasibility-of-learning/fol4.png\" title=\"The Formal Guarantee\"><div class=\"note danger\"><p><strong>real learning</strong> is:<script type=\"math/tex\">A</script>shall <strong>make choices<script type=\"math/tex\">\\in H</script></strong>(like PLA)<br>rather than <em>being forced to pick one h</em></p></div><div class=\"note info\"><p>可以使用历史数据(data)来验证一个假设的表现到底好不好, 可以理解为验证集</p></div><h1 id=\"Connection-to-Real-Learning\"><a href=\"#Connection-to-Real-Learning\" class=\"headerlink\" title=\"Connection to Real Learning\"></a>Connection to Real Learning</h1><p>提出了问题：如果我们在一堆假设中看到了一个假设，在我们选出的样本上全对，我们要不要选择这个假设？举例子就是每个人都抛硬币，抛五次，可能有一个人会五次全都朝上，我们要不要说这个硬币会有点特殊？</p><p>Hoeffding说的是取样的和真实的大部分情况下是符合的，只有小部分是不好的</p><p>事实上当你有选择的时候，比如这里抛五次硬币实验150次的时候,150次试验里出现一次五个硬币同时朝上的概率就是<script type=\"math/tex\">1 - {(31 \\over 32)^150} > 99%</script></p><p>因此不好的样本，在有选择的时候，出现的概率会恶化。<br><strong>不好的Data</strong> ==<script type=\"math/tex\">A</script>不可以自由做选择，可能会踩雷 == 存在<script type=\"math/tex\">h</script>使<script type=\"math/tex\">E_out(h)</script>和<script type=\"math/tex\">E_in(h)</script><br>差得很大</p><p>Hoeffding说的是在一个Data里面，抽一堆和大部分符合</p><p>这里说的其实是一堆Data里，出现不好的Data的概率是：<br><img src=\"/MachineLearning/机器学习基石/2019-04-08-machinelearning-feasibility-of-learning/fol5.png\" title=\"Bound of BAD Data\"></p><p>所以如果假设数量有限，即M有限，并且每个Data样本N足够大，那么不管<script type=\"math/tex\">A</script>怎么选，<script type=\"math/tex\">E_out(g) \\sim E_in(g)</script>，即可以放心选，这样就说明了有限数量的h情况下，机器学习是可行的</p><!-- rebuild by neat -->"}],"PostAsset":[{"_id":"source/_posts/动态规划套路详解/4.png","slug":"4.png","post":"ck2424lm10035lksbybhdcdcc","modified":1,"renderable":0},{"_id":"source/_posts/siRNA/论文笔记-基于机器学习的siRNA沉默效率预测方法研究/1-2.png","slug":"1-2.png","post":"ck2424lva009olksbv1hqal6h","modified":1,"renderable":0},{"_id":"source/_posts/siRNA/siRNA设计基础/1.png","slug":"1.png","post":"ck2424lv9009llksbax2ilfx3","modified":1,"renderable":0},{"_id":"source/_posts/siRNA/siRNA设计基础/2.png","slug":"2.png","post":"ck2424lv9009llksbax2ilfx3","modified":1,"renderable":0},{"_id":"source/_posts/MachineLearning/MNIST入门-手写数字识别/sof1.png","slug":"sof1.png","post":"ck2424lsk004ylksbwzg6mp8j","modified":1,"renderable":0},{"_id":"source/_posts/动态规划套路详解/1.png","slug":"1.png","post":"ck2424lm10035lksbybhdcdcc","modified":1,"renderable":0},{"_id":"source/_posts/动态规划套路详解/2.png","slug":"2.png","post":"ck2424lm10035lksbybhdcdcc","modified":1,"renderable":0},{"_id":"source/_posts/动态规划套路详解/3.png","slug":"3.png","post":"ck2424lm10035lksbybhdcdcc","modified":1,"renderable":0},{"_id":"source/_posts/动态规划套路详解/5.png","slug":"5.png","post":"ck2424lm10035lksbybhdcdcc","modified":1,"renderable":0},{"_id":"source/_posts/动态规划套路详解/6.png","slug":"6.png","post":"ck2424lm10035lksbybhdcdcc","modified":1,"renderable":0},{"_id":"source/_posts/动态规划套路详解/7.png","slug":"7.png","post":"ck2424lm10035lksbybhdcdcc","modified":1,"renderable":0},{"_id":"source/_posts/LeetCode/LeetCode-011-Container-With-Most-Water/011.png","post":"ck2424ltc005mlksb6t2uhjkk","slug":"011.png","modified":1,"renderable":1},{"_id":"source/_posts/siRNA/论文笔记-基于机器学习的siRNA沉默效率预测方法研究/1-1.png","post":"ck2424lva009olksbv1hqal6h","slug":"1-1.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/超平面、函数间隔和几何间隔/distance.png","post":"ck2424lsu0053lksbrb6lf4gy","slug":"distance.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/超平面、函数间隔和几何间隔/faxiangliang.png","post":"ck2424lsu0053lksbrb6lf4gy","slug":"faxiangliang.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/超平面、函数间隔和几何间隔/tuhanshu.png","post":"ck2424lsu0053lksbrb6lf4gy","slug":"tuhanshu.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning/fol2.png","slug":"fol2.png","post":"ck2424m5u00oflksb0py5nenc","modified":1,"renderable":0},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning/fol1.png","slug":"fol1.png","post":"ck2424m5u00oflksb0py5nenc","modified":1,"renderable":0},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Types-of-Learning/tol1.png","slug":"tol1.png","post":"ck2424m3q00o0lksbmdj3ax24","modified":1,"renderable":0},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Types-of-Learning/tol2.png","slug":"tol2.png","post":"ck2424m3q00o0lksbmdj3ax24","modified":1,"renderable":0},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Types-of-Learning/tol3.png","post":"ck2424m3q00o0lksbmdj3ax24","slug":"tol3.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla1.png","post":"ck2424m3p00nzlksb8dku8w3k","slug":"pla1.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla2.png","post":"ck2424m3p00nzlksb8dku8w3k","slug":"pla2.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla3.png","post":"ck2424m3p00nzlksb8dku8w3k","slug":"pla3.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla4.png","post":"ck2424m3p00nzlksb8dku8w3k","slug":"pla4.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla5.png","post":"ck2424m3p00nzlksb8dku8w3k","slug":"pla5.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla6.png","post":"ck2424m3p00nzlksb8dku8w3k","slug":"pla6.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-PLA算法/pla7.png","post":"ck2424m3p00nzlksb8dku8w3k","slug":"pla7.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning/fol3.png","post":"ck2424m5u00oflksb0py5nenc","slug":"fol3.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning/fol4.png","post":"ck2424m5u00oflksb0py5nenc","slug":"fol4.png","modified":1,"renderable":1},{"_id":"source/_posts/MachineLearning/机器学习基石/机器学习基石-Feasibility-of-Learning/fol5.png","post":"ck2424m5u00oflksb0py5nenc","slug":"fol5.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck2424ljs0000lksbk89s2vct","category_id":"ck2424lk00003lksb55xyudi0","_id":"ck2424lki000clksbuedqka6q"},{"post_id":"ck2424ljy0002lksbl7wddtcz","category_id":"ck2424lk90008lksbvvtywjo5","_id":"ck2424lkm000hlksb73ec1k71"},{"post_id":"ck2424lkj000flksb57dr8b7i","category_id":"ck2424lk90008lksbvvtywjo5","_id":"ck2424lkq000llksbck52wf7m"},{"post_id":"ck2424lk20005lksbdsw4s1p8","category_id":"ck2424lki000dlksbuwhzzz0q","_id":"ck2424lkr000olksblyz4whqb"},{"post_id":"ck2424lkk000glksbhru1peui","category_id":"ck2424lk90008lksbvvtywjo5","_id":"ck2424lkr000qlksbozigxyzl"},{"post_id":"ck2424lko000klksb4ib0c3oc","category_id":"ck2424lk90008lksbvvtywjo5","_id":"ck2424lks000tlksblvhqrodb"},{"post_id":"ck2424lk40006lksba8n4dxv7","category_id":"ck2424lki000dlksbuwhzzz0q","_id":"ck2424lks000wlksbpmukuo92"},{"post_id":"ck2424lk70007lksb669xzz3e","category_id":"ck2424lki000dlksbuwhzzz0q","_id":"ck2424lkt000zlksbhhq6sli8"},{"post_id":"ck2424lke000alksb9hizgy3b","category_id":"ck2424lki000dlksbuwhzzz0q","_id":"ck2424lkt0011lksbteajutpn"},{"post_id":"ck2424lkh000blksbyg7elqg6","category_id":"ck2424lki000dlksbuwhzzz0q","_id":"ck2424lku0013lksbse9d78n9"},{"post_id":"ck2424llp002nlksbzwo4he1m","category_id":"ck2424lk90008lksbvvtywjo5","_id":"ck2424llv002ulksbh0a9zexq"},{"post_id":"ck2424llr002plksbej35ub5d","category_id":"ck2424lk90008lksbvvtywjo5","_id":"ck2424llw002wlksbfk7l9ri0"},{"post_id":"ck2424llt002slksb2d4tkywt","category_id":"ck2424lki000dlksbuwhzzz0q","_id":"ck2424lly002zlksbr7qi49ed"},{"post_id":"ck2424llu002tlksb1bty1clb","category_id":"ck2424lki000dlksbuwhzzz0q","_id":"ck2424llz0032lksb1902126w"},{"post_id":"ck2424llx002ylksbob4dzxo1","category_id":"ck2424lk90008lksbvvtywjo5","_id":"ck2424lm10036lksbsf85gw8k"},{"post_id":"ck2424lly0031lksbxk4sbnof","category_id":"ck2424lk90008lksbvvtywjo5","_id":"ck2424lm90039lksbdbdhdei5"},{"post_id":"ck2424llz0034lksb5x3gciw6","category_id":"ck2424lk90008lksbvvtywjo5","_id":"ck2424lmf003clksbg07gtfen"},{"post_id":"ck2424llw002vlksbv0cgs1et","category_id":"ck2424lly0030lksbimc7hwlc","_id":"ck2424lmg003flksbx1kmtn3l"},{"post_id":"ck2424lm10035lksbybhdcdcc","category_id":"ck2424lk90008lksbvvtywjo5","_id":"ck2424lmh003hlksbtpqlotrl"},{"post_id":"ck2424lm80038lksb68wxm9cb","category_id":"ck2424lk00003lksb55xyudi0","_id":"ck2424lmh003jlksbu4smh7dd"},{"post_id":"ck2424lme003blksbjgss5z17","category_id":"ck2424lk00003lksb55xyudi0","_id":"ck2424lmh003llksbdvzlmr86"},{"post_id":"ck2424lsc004tlksb721myvg9","category_id":"ck2424lly0030lksbimc7hwlc","_id":"ck2424lsl004zlksbn7eeh4r7"},{"post_id":"ck2424lsd004ulksbhgxz59m1","category_id":"ck2424lly0030lksbimc7hwlc","_id":"ck2424lsq0051lksbe3zgz9km"},{"post_id":"ck2424lsf004wlksbz384871l","category_id":"ck2424lly0030lksbimc7hwlc","_id":"ck2424lsv0054lksbfbn0m5ue"},{"post_id":"ck2424lsk004ylksbwzg6mp8j","category_id":"ck2424lly0030lksbimc7hwlc","_id":"ck2424lt20056lksbk7flfiz6"},{"post_id":"ck2424lsp0050lksbcbx1wje8","category_id":"ck2424lly0030lksbimc7hwlc","_id":"ck2424lt30059lksbawetbvu2"},{"post_id":"ck2424lsu0053lksbrb6lf4gy","category_id":"ck2424lly0030lksbimc7hwlc","_id":"ck2424lt5005clksb2o49ldrh"},{"post_id":"ck2424lt5005elksbilmu2wvg","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424ltb005klksb19wsy8oy"},{"post_id":"ck2424lt00055lksbbgjgj94u","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424ltc005nlksb6g76h314"},{"post_id":"ck2424lt6005flksb6wiq7iwv","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lte005rlksbx9a3f489"},{"post_id":"ck2424lt8005ilksb0b3hxlki","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424ltg005ulksbe0yvcyxb"},{"post_id":"ck2424lt20058lksbo5iifdnd","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lth005ylksb6zxo9n9k"},{"post_id":"ck2424lta005jlksbmbsn54ac","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lti0061lksb9b90vodf"},{"post_id":"ck2424ltc005mlksb6t2uhjkk","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424ltk0065lksbo4vfpx5w"},{"post_id":"ck2424lt4005blksbo7wjd8bz","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424ltm0068lksbq8fvn0ch"},{"post_id":"ck2424ltd005qlksb9zqqb9sj","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lto006clksbdwxx5xom"},{"post_id":"ck2424ltf005tlksb97jo22xc","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424ltq006flksb3v0rhnph"},{"post_id":"ck2424ltg005xlksbsvn1znr7","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424ltr006jlksb8vysn66a"},{"post_id":"ck2424lti0060lksbhnsiyrfv","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lts006mlksb1zr6d0zr"},{"post_id":"ck2424ltj0064lksblqwquhk6","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424ltu006plksby4vdbkur"},{"post_id":"ck2424ltm0067lksbah9dubn1","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424ltv006tlksbfuu5wccp"},{"post_id":"ck2424ltn006blksbxbu257ti","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424ltw006wlksb28wn9tiv"},{"post_id":"ck2424ltp006elksbw4pbytrn","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424ltx0070lksbplbb6zth"},{"post_id":"ck2424ltq006ilksbtvzq8593","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424ltz0072lksbmlhuku8i"},{"post_id":"ck2424lts006llksbd02qcx81","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lu10075lksbwphog84m"},{"post_id":"ck2424ltt006olksbf6kcf3ce","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lu20077lksbxms5hj68"},{"post_id":"ck2424ltu006slksbyjdo1il4","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lu3007alksb7lw8xbi2"},{"post_id":"ck2424ltv006vlksb374gv5v8","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lu4007dlksbniidiebx"},{"post_id":"ck2424ltx006zlksb7paxbkt5","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lu5007glksbuao8dvwm"},{"post_id":"ck2424lty0071lksbhon558xs","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lu7007klksbl5lsobub"},{"post_id":"ck2424lu00074lksbt8wxnjd1","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lua007nlksbgz5nj6tf"},{"post_id":"ck2424lu10076lksb7o6nwoqu","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424luc007qlksbqyh2k6xs"},{"post_id":"ck2424lu20079lksb06ya682c","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lue007slksbftmd2cht"},{"post_id":"ck2424lu4007clksb0bv5bxfj","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lug007vlksb61c6stmi"},{"post_id":"ck2424lu5007flksbov6tzn2d","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424luh007xlksbjkmqhb2e"},{"post_id":"ck2424lu6007jlksbds0bqjgo","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lui0080lksb5hxzrcm2"},{"post_id":"ck2424lu7007mlksbe569uyni","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424luj0084lksb6hqmdg77"},{"post_id":"ck2424lub007plksbmci3id9e","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lul0088lksbq0cp16xm"},{"post_id":"ck2424luc007rlksbftn3gwyp","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lum008clksbvdfegxvy"},{"post_id":"ck2424lue007ulksbbz7bunk8","category_id":"ck2424lt3005alksbp4rhykr0","_id":"ck2424lun008flksbk4nd67mv"},{"post_id":"ck2424luk0087lksb34bw7krt","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lup008jlksbue32bd3a"},{"post_id":"ck2424lug007wlksbrv4jw9t5","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lur008llksbjjpr60jn"},{"post_id":"ck2424lul008alksbvgoh3v5i","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lut008olksbfzcnbjfs"},{"post_id":"ck2424lum008elksbx88jkq10","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424luv008qlksbjg2r7pl8"},{"post_id":"ck2424luh007zlksbuu7epaya","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424luw008tlksb203bv08f"},{"post_id":"ck2424luo008hlksbhx29q12z","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lux008vlksbnttxpm28"},{"post_id":"ck2424luq008klksbku82yea9","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424luz008ylksb2xpau7fz"},{"post_id":"ck2424luj0083lksb9b9q4vnc","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lv00091lksb8197zc26"},{"post_id":"ck2424lut008nlksbp1vgkiw1","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lv20095lksbwfvpg3z9"},{"post_id":"ck2424luu008plksbb5n9v9hf","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lv30098lksbnckxgnxi"},{"post_id":"ck2424luw008slksbj6j3rgev","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lv5009clksbw3vbf3e6"},{"post_id":"ck2424lux008ulksbgwha9t5y","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lv6009flksbemvm6lc1"},{"post_id":"ck2424luy008xlksbych894fh","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lv7009hlksby1ojz5k6"},{"post_id":"ck2424lv00090lksbc4l9vw90","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lv9009klksb4v7udzqm"},{"post_id":"ck2424lv10094lksbwttuwkab","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lva009mlksbx91ocu46"},{"post_id":"ck2424lv20097lksb0kupucym","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lvb009plksb88o8w3fi"},{"post_id":"ck2424lv4009blksbr9m1l0ip","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lvd009rlksb5rufa413"},{"post_id":"ck2424lv5009elksb9lf1wuul","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lvd009tlksb4xcnm50t"},{"post_id":"ck2424lv7009glksb4e7orh1y","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lve009ulksba0c3f6sd"},{"post_id":"ck2424lv8009jlksbvykhhxyr","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lvf009wlksbxp4y1eox"},{"post_id":"ck2424lv9009llksbax2ilfx3","category_id":"ck2424lk90008lksbvvtywjo5","_id":"ck2424lvf009ylksbd8iec2ae"},{"post_id":"ck2424lva009olksbv1hqal6h","category_id":"ck2424lk90008lksbvvtywjo5","_id":"ck2424lvg00a1lksbfl0bjli4"},{"post_id":"ck2424lvc009qlksbozcglg8l","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424lvg00a3lksba2d3y0pe"},{"post_id":"ck2424m0s00ntlksbuguwba6s","category_id":"ck2424lui0082lksbzeorbnli","_id":"ck2424m0v00nwlksbxrb0dnk8"},{"post_id":"ck2424m3p00nzlksb8dku8w3k","category_id":"ck2424lly0030lksbimc7hwlc","_id":"ck2424m3v00o5lksbcaqubgoc"},{"post_id":"ck2424m3p00nzlksb8dku8w3k","category_id":"ck2424m3s00o2lksbv571a9wy","_id":"ck2424m3x00o8lksbjwbx0t8a"},{"post_id":"ck2424m3q00o0lksbmdj3ax24","category_id":"ck2424lly0030lksbimc7hwlc","_id":"ck2424m3x00oalksbz8ltbhkq"},{"post_id":"ck2424m3q00o0lksbmdj3ax24","category_id":"ck2424m3s00o2lksbv571a9wy","_id":"ck2424m3y00oclksbn59cvs5i"},{"post_id":"ck2424m5u00oflksb0py5nenc","category_id":"ck2424lly0030lksbimc7hwlc","_id":"ck2424m5y00oilksbkrupba2k"},{"post_id":"ck2424m5u00oflksb0py5nenc","category_id":"ck2424m3s00o2lksbv571a9wy","_id":"ck2424m5z00ojlksbku714ubd"}],"PostTag":[{"post_id":"ck2424ljs0000lksbk89s2vct","tag_id":"ck2424lk20004lksbijwenhfk","_id":"ck2424lkr000plksbjhskr2q2"},{"post_id":"ck2424ljs0000lksbk89s2vct","tag_id":"ck2424lk90009lksbfw3qcei1","_id":"ck2424lkr000slksbsnarphtz"},{"post_id":"ck2424ljs0000lksbk89s2vct","tag_id":"ck2424lki000elksbc36mrksk","_id":"ck2424lks000vlksb3jdf87ke"},{"post_id":"ck2424ljs0000lksbk89s2vct","tag_id":"ck2424lkn000jlksbkjuud4wc","_id":"ck2424lkt000ylksb8g8wiako"},{"post_id":"ck2424ljy0002lksbl7wddtcz","tag_id":"ck2424lkr000nlksb69i40jk0","_id":"ck2424lku0015lksb8cp7wnfk"},{"post_id":"ck2424ljy0002lksbl7wddtcz","tag_id":"ck2424lks000ulksb1yneapb4","_id":"ck2424lku0016lksbl31ynwbo"},{"post_id":"ck2424ljy0002lksbl7wddtcz","tag_id":"ck2424lkt0010lksbws1pjbzp","_id":"ck2424lku0018lksbr1cf46j4"},{"post_id":"ck2424ljy0002lksbl7wddtcz","tag_id":"ck2424lku0012lksb8ed7ojns","_id":"ck2424lku0019lksb4ffr69gc"},{"post_id":"ck2424lk20005lksbdsw4s1p8","tag_id":"ck2424lku0014lksbc5a1b02h","_id":"ck2424lkv001dlksbu7mo12r7"},{"post_id":"ck2424lk20005lksbdsw4s1p8","tag_id":"ck2424lku0017lksb5m89pgli","_id":"ck2424lkv001elksbywwalyz5"},{"post_id":"ck2424lk20005lksbdsw4s1p8","tag_id":"ck2424lkv001alksbf3rvf5o0","_id":"ck2424lkw001glksbomf64621"},{"post_id":"ck2424lk20005lksbdsw4s1p8","tag_id":"ck2424lkv001blksbb5pwong2","_id":"ck2424lkw001hlksbwie63t8x"},{"post_id":"ck2424lk40006lksba8n4dxv7","tag_id":"ck2424lku0017lksb5m89pgli","_id":"ck2424lkw001jlksb7rhcupiz"},{"post_id":"ck2424lk40006lksba8n4dxv7","tag_id":"ck2424lks000ulksb1yneapb4","_id":"ck2424lkw001klksbwtk4hz3s"},{"post_id":"ck2424lk70007lksb669xzz3e","tag_id":"ck2424lkw001ilksb8iqkgeg5","_id":"ck2424lkx001nlksb5u8lkfpu"},{"post_id":"ck2424lk70007lksb669xzz3e","tag_id":"ck2424lku0017lksb5m89pgli","_id":"ck2424lkx001olksbz6tsiwm7"},{"post_id":"ck2424lke000alksb9hizgy3b","tag_id":"ck2424lkw001ilksb8iqkgeg5","_id":"ck2424lky001rlksbxk897k1u"},{"post_id":"ck2424lke000alksb9hizgy3b","tag_id":"ck2424lku0017lksb5m89pgli","_id":"ck2424lky001slksb2uwxfwzd"},{"post_id":"ck2424lkh000blksbyg7elqg6","tag_id":"ck2424lky001qlksbuxzydupq","_id":"ck2424lkz001wlksbvr98fqv7"},{"post_id":"ck2424lkh000blksbyg7elqg6","tag_id":"ck2424lky001tlksbzd5ihse6","_id":"ck2424ll0001xlksbwq1hkj6q"},{"post_id":"ck2424lkh000blksbyg7elqg6","tag_id":"ck2424lk20004lksbijwenhfk","_id":"ck2424ll0001zlksbj1ckcvn0"},{"post_id":"ck2424lkh000blksbyg7elqg6","tag_id":"ck2424lku0017lksb5m89pgli","_id":"ck2424ll00020lksb17vtcta1"},{"post_id":"ck2424lkj000flksb57dr8b7i","tag_id":"ck2424lkz001vlksbpgnzhwz6","_id":"ck2424ll10024lksbqvkotat5"},{"post_id":"ck2424lkj000flksb57dr8b7i","tag_id":"ck2424ll0001ylksbwirrxgjc","_id":"ck2424ll10025lksbvodxn6dk"},{"post_id":"ck2424lkj000flksb57dr8b7i","tag_id":"ck2424ll00021lksb42bhpkur","_id":"ck2424ll10027lksbgl71n2ga"},{"post_id":"ck2424lkj000flksb57dr8b7i","tag_id":"ck2424lku0012lksb8ed7ojns","_id":"ck2424ll10028lksbnmb7097k"},{"post_id":"ck2424lkk000glksbhru1peui","tag_id":"ck2424lks000ulksb1yneapb4","_id":"ck2424ll2002blksbv2mnuq4s"},{"post_id":"ck2424lkk000glksbhru1peui","tag_id":"ck2424ll10026lksb1km5nz4q","_id":"ck2424ll2002clksbux66hyey"},{"post_id":"ck2424lkk000glksbhru1peui","tag_id":"ck2424lku0012lksb8ed7ojns","_id":"ck2424ll3002elksb6bvi7yv2"},{"post_id":"ck2424lko000klksb4ib0c3oc","tag_id":"ck2424ll2002alksbq8zocx7d","_id":"ck2424ll4002ilksbz3941zx2"},{"post_id":"ck2424lko000klksb4ib0c3oc","tag_id":"ck2424ll2002dlksbjui0syzz","_id":"ck2424ll4002jlksbts3ijjgb"},{"post_id":"ck2424lko000klksb4ib0c3oc","tag_id":"ck2424ll3002flksb54xvqz8u","_id":"ck2424ll4002klksbyt4t1l3r"},{"post_id":"ck2424lko000klksb4ib0c3oc","tag_id":"ck2424lks000ulksb1yneapb4","_id":"ck2424ll4002llksbdiabe79s"},{"post_id":"ck2424lko000klksb4ib0c3oc","tag_id":"ck2424lku0012lksb8ed7ojns","_id":"ck2424ll4002mlksbecpklwgg"},{"post_id":"ck2424llp002nlksbzwo4he1m","tag_id":"ck2424llt002rlksbw7hzg4nh","_id":"ck2424lm9003alksbhhhpxpvk"},{"post_id":"ck2424llp002nlksbzwo4he1m","tag_id":"ck2424llw002xlksbnv6zuq7c","_id":"ck2424lmf003dlksbdn3pj314"},{"post_id":"ck2424llp002nlksbzwo4he1m","tag_id":"ck2424llz0033lksbm0hvvgm5","_id":"ck2424lmg003glksbeuklav8e"},{"post_id":"ck2424llr002plksbej35ub5d","tag_id":"ck2424llt002rlksbw7hzg4nh","_id":"ck2424lmh003klksbwrpmrog7"},{"post_id":"ck2424llr002plksbej35ub5d","tag_id":"ck2424llz0033lksbm0hvvgm5","_id":"ck2424lmh003mlksb8q0d8zyt"},{"post_id":"ck2424llt002slksb2d4tkywt","tag_id":"ck2424lku0014lksbc5a1b02h","_id":"ck2424lmj003rlksb6yjlqn53"},{"post_id":"ck2424llt002slksb2d4tkywt","tag_id":"ck2424lkv001alksbf3rvf5o0","_id":"ck2424lmj003slksbsb7yhyb0"},{"post_id":"ck2424llt002slksb2d4tkywt","tag_id":"ck2424lmh003ilksbh5tuzwg4","_id":"ck2424lml003ulksbxic991bv"},{"post_id":"ck2424llt002slksb2d4tkywt","tag_id":"ck2424lmh003nlksb9o83srtp","_id":"ck2424lml003vlksbav0gh8gt"},{"post_id":"ck2424llt002slksb2d4tkywt","tag_id":"ck2424lmi003olksb802dkzxh","_id":"ck2424lmm003xlksbcmty8o4i"},{"post_id":"ck2424llt002slksb2d4tkywt","tag_id":"ck2424lmi003plksb9rs5q1uk","_id":"ck2424lmn003ylksbkduy2wnq"},{"post_id":"ck2424llu002tlksb1bty1clb","tag_id":"ck2424lmi003qlksbyons9he9","_id":"ck2424lmn0040lksbvwyhof8n"},{"post_id":"ck2424llu002tlksb1bty1clb","tag_id":"ck2424lku0017lksb5m89pgli","_id":"ck2424lmo0041lksbhxhw6vdi"},{"post_id":"ck2424llw002vlksbv0cgs1et","tag_id":"ck2424llt002rlksbw7hzg4nh","_id":"ck2424lmo0042lksbozg8k2gl"},{"post_id":"ck2424llw002vlksbv0cgs1et","tag_id":"ck2424lmj003tlksbgslxt2mr","_id":"ck2424lmp0044lksb9vwdp4s5"},{"post_id":"ck2424llw002vlksbv0cgs1et","tag_id":"ck2424lml003wlksbwck7bl7x","_id":"ck2424lmp0045lksbgh3i9ack"},{"post_id":"ck2424llx002ylksbob4dzxo1","tag_id":"ck2424llt002rlksbw7hzg4nh","_id":"ck2424lmq0047lksbanmutu5q"},{"post_id":"ck2424llx002ylksbob4dzxo1","tag_id":"ck2424lmn003zlksbi9vtshdm","_id":"ck2424lmq0048lksb8mn3zsr3"},{"post_id":"ck2424llx002ylksbob4dzxo1","tag_id":"ck2424lku0012lksb8ed7ojns","_id":"ck2424lmr004alksb73qboxcs"},{"post_id":"ck2424lly0031lksbxk4sbnof","tag_id":"ck2424lmo0043lksbrr2ju0lg","_id":"ck2424lmr004blksbltqeo1zk"},{"post_id":"ck2424lly0031lksbxk4sbnof","tag_id":"ck2424ll10026lksb1km5nz4q","_id":"ck2424lmr004dlksbt40wyu3q"},{"post_id":"ck2424lly0031lksbxk4sbnof","tag_id":"ck2424lku0012lksb8ed7ojns","_id":"ck2424lmr004elksb5mk4fywf"},{"post_id":"ck2424lm10035lksbybhdcdcc","tag_id":"ck2424lkt0010lksbws1pjbzp","_id":"ck2424lmr004flksbztmaixrc"},{"post_id":"ck2424lm10035lksbybhdcdcc","tag_id":"ck2424lks000ulksb1yneapb4","_id":"ck2424lmr004hlksbfirzp3bk"},{"post_id":"ck2424lm10035lksbybhdcdcc","tag_id":"ck2424lku0012lksb8ed7ojns","_id":"ck2424lmr004ilksb8e58nn8p"},{"post_id":"ck2424lm10035lksbybhdcdcc","tag_id":"ck2424lmp0046lksbqy1ahoam","_id":"ck2424lms004klksb0o9xx0pq"},{"post_id":"ck2424lm80038lksb68wxm9cb","tag_id":"ck2424lmq0049lksbwasg0q16","_id":"ck2424lms004llksbf8lupu7q"},{"post_id":"ck2424lm80038lksb68wxm9cb","tag_id":"ck2424lmr004clksb4t7751b6","_id":"ck2424lmt004nlksbmclhmjrb"},{"post_id":"ck2424lm80038lksb68wxm9cb","tag_id":"ck2424lmr004glksb8u5npliz","_id":"ck2424lmt004olksb1q3djb6v"},{"post_id":"ck2424lme003blksbjgss5z17","tag_id":"ck2424lmr004glksb8u5npliz","_id":"ck2424lmt004plksbfxys3lsq"},{"post_id":"ck2424lme003blksbjgss5z17","tag_id":"ck2424lms004mlksblrlp3aj3","_id":"ck2424lmt004qlksbd9is47uq"},{"post_id":"ck2424lsd004ulksbhgxz59m1","tag_id":"ck2424lml003wlksbwck7bl7x","_id":"ck2424lsk004xlksbqjpu8hca"},{"post_id":"ck2424lsc004tlksb721myvg9","tag_id":"ck2424lmr004glksb8u5npliz","_id":"ck2424ltd005plksb03yo44k5"},{"post_id":"ck2424lsc004tlksb721myvg9","tag_id":"ck2424lse004vlksbp0yupq33","_id":"ck2424ltf005slksb2z2heu1c"},{"post_id":"ck2424lsc004tlksb721myvg9","tag_id":"ck2424lsq0052lksby0ztctgy","_id":"ck2424ltg005wlksbiqq4w7kg"},{"post_id":"ck2424lsc004tlksb721myvg9","tag_id":"ck2424lt20057lksbf3rhlefc","_id":"ck2424lth005zlksbany6m2l9"},{"post_id":"ck2424lsc004tlksb721myvg9","tag_id":"ck2424lt5005dlksb3cfz3o8g","_id":"ck2424ltj0063lksb2rtuwhiq"},{"post_id":"ck2424lsc004tlksb721myvg9","tag_id":"ck2424lt8005hlksb7semngxc","_id":"ck2424ltl0066lksbiucxx85h"},{"post_id":"ck2424lsf004wlksbz384871l","tag_id":"ck2424llt002rlksbw7hzg4nh","_id":"ck2424ltn006alksbnzozs3wx"},{"post_id":"ck2424lsf004wlksbz384871l","tag_id":"ck2424lml003wlksbwck7bl7x","_id":"ck2424lto006dlksby6gudgta"},{"post_id":"ck2424lsf004wlksbz384871l","tag_id":"ck2424ltc005olksbj19f5lel","_id":"ck2424ltq006hlksby9us6qde"},{"post_id":"ck2424lsf004wlksbz384871l","tag_id":"ck2424ltg005vlksbx0p6597k","_id":"ck2424lts006klksb0m6lv3li"},{"post_id":"ck2424lsf004wlksbz384871l","tag_id":"ck2424lks000ulksb1yneapb4","_id":"ck2424ltt006nlksbdvf7f0hm"},{"post_id":"ck2424lsk004ylksbwzg6mp8j","tag_id":"ck2424ltj0062lksb0m47dl46","_id":"ck2424ltu006rlksb5yf22ruy"},{"post_id":"ck2424lsk004ylksbwzg6mp8j","tag_id":"ck2424lt8005hlksb7semngxc","_id":"ck2424ltv006ulksb77aw7597"},{"post_id":"ck2424lsk004ylksbwzg6mp8j","tag_id":"ck2424lse004vlksbp0yupq33","_id":"ck2424ltx006ylksb7kpmp8x3"},{"post_id":"ck2424lsp0050lksbcbx1wje8","tag_id":"ck2424ltq006glksb6onzgrhj","_id":"ck2424lu3007blksb98j03ntl"},{"post_id":"ck2424lsp0050lksbcbx1wje8","tag_id":"ck2424ltu006qlksbiuossj1n","_id":"ck2424lu5007elksby48jikh4"},{"post_id":"ck2424lsp0050lksbcbx1wje8","tag_id":"ck2424ltw006xlksbszvp2jp9","_id":"ck2424lu6007ilksbfhutpbzb"},{"post_id":"ck2424lsp0050lksbcbx1wje8","tag_id":"ck2424lu00073lksbnkxaxb00","_id":"ck2424lu7007llksbff8idfr1"},{"post_id":"ck2424lsu0053lksbrb6lf4gy","tag_id":"ck2424lu20078lksbgbehtuq6","_id":"ck2424lui0081lksbkw5bdnaf"},{"post_id":"ck2424lsu0053lksbrb6lf4gy","tag_id":"ck2424lu5007hlksb8a3evgaz","_id":"ck2424luk0085lksb8r0lnef7"},{"post_id":"ck2424lsu0053lksbrb6lf4gy","tag_id":"ck2424lub007olksb8rkc2744","_id":"ck2424lul0089lksbccd9qreg"},{"post_id":"ck2424lsu0053lksbrb6lf4gy","tag_id":"ck2424lu00073lksbnkxaxb00","_id":"ck2424lum008dlksbyc34oc0r"},{"post_id":"ck2424lt00055lksbbgjgj94u","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lv0008zlksbgby2gbsd"},{"post_id":"ck2424lt00055lksbbgjgj94u","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lv10092lksbmtxi1jyh"},{"post_id":"ck2424lt00055lksbbgjgj94u","tag_id":"ck2424lun008glksbp3coz9qr","_id":"ck2424lv20096lksb8uo1ldut"},{"post_id":"ck2424lt00055lksbbgjgj94u","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lv40099lksbr86khmlz"},{"post_id":"ck2424lt00055lksbbgjgj94u","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lv5009dlksb40shgc0t"},{"post_id":"ck2424lt20058lksbo5iifdnd","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lvf009xlksbagektd7k"},{"post_id":"ck2424lt20058lksbo5iifdnd","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lvf009zlksbhpgqj7kx"},{"post_id":"ck2424lt20058lksbo5iifdnd","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lvg00a2lksbjzcdkq13"},{"post_id":"ck2424lt20058lksbo5iifdnd","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lvg00a4lksbzrtbvv9d"},{"post_id":"ck2424lt20058lksbo5iifdnd","tag_id":"ck2424lva009nlksblx5l3vvc","_id":"ck2424lvg00a6lksbilfsu8m2"},{"post_id":"ck2424lt20058lksbo5iifdnd","tag_id":"ck2424lvd009slksblqav0ehi","_id":"ck2424lvg00a7lksbi2u06cit"},{"post_id":"ck2424lt4005blksbo7wjd8bz","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lvi00aclksbtlg6gkzx"},{"post_id":"ck2424lt4005blksbo7wjd8bz","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lvi00adlksbjcazx9eu"},{"post_id":"ck2424lt4005blksbo7wjd8bz","tag_id":"ck2424lvg00a5lksbg9uxbjhq","_id":"ck2424lvj00aflksbezm6w0lr"},{"post_id":"ck2424lt4005blksbo7wjd8bz","tag_id":"ck2424lvg00a8lksbpp07gtjz","_id":"ck2424lvj00aglksbm8lmoxev"},{"post_id":"ck2424lt4005blksbo7wjd8bz","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lvj00ailksbf52pawnl"},{"post_id":"ck2424lt4005blksbo7wjd8bz","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lvj00ajlksbxgn4kao2"},{"post_id":"ck2424lt5005elksbilmu2wvg","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lvl00aolksbyhucjllk"},{"post_id":"ck2424lt5005elksbilmu2wvg","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lvl00aplksbr3jhtspq"},{"post_id":"ck2424lt5005elksbilmu2wvg","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lvl00arlksbirwa7o2k"},{"post_id":"ck2424lt5005elksbilmu2wvg","tag_id":"ck2424lvj00aklksbr0uoclzy","_id":"ck2424lvl00aslksb6eke6hl7"},{"post_id":"ck2424lt5005elksbilmu2wvg","tag_id":"ck2424lvj00allksbf2v8ykmm","_id":"ck2424lvm00aulksbk28mrmop"},{"post_id":"ck2424lt5005elksbilmu2wvg","tag_id":"ck2424lva009nlksblx5l3vvc","_id":"ck2424lvm00avlksboyez3j6n"},{"post_id":"ck2424lt6005flksb6wiq7iwv","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lvm00axlksbl214sl5p"},{"post_id":"ck2424lt6005flksb6wiq7iwv","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lvm00aylksbjiqt0g2s"},{"post_id":"ck2424lt6005flksb6wiq7iwv","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lvn00b0lksbed8vjn07"},{"post_id":"ck2424lt8005ilksb0b3hxlki","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lvo00b5lksbsbkr6pxq"},{"post_id":"ck2424lt8005ilksb0b3hxlki","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lvo00b6lksbekoejb1b"},{"post_id":"ck2424lt8005ilksb0b3hxlki","tag_id":"ck2424lkt0010lksbws1pjbzp","_id":"ck2424lvp00b8lksbyul0wu0x"},{"post_id":"ck2424lt8005ilksb0b3hxlki","tag_id":"ck2424lva009nlksblx5l3vvc","_id":"ck2424lvp00b9lksbmix0wqcz"},{"post_id":"ck2424lt8005ilksb0b3hxlki","tag_id":"ck2424lvn00b2lksbktfsp35h","_id":"ck2424lvp00bblksb9u6md1ao"},{"post_id":"ck2424lt8005ilksb0b3hxlki","tag_id":"ck2424lvn00b3lksbf8uzrmqx","_id":"ck2424lvp00bclksbu4v68bsb"},{"post_id":"ck2424lta005jlksbmbsn54ac","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lvr00bglksb9lhb8ett"},{"post_id":"ck2424lta005jlksbmbsn54ac","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lvr00bhlksbci6j4ik8"},{"post_id":"ck2424lta005jlksbmbsn54ac","tag_id":"ck2424lva009nlksblx5l3vvc","_id":"ck2424lvr00bjlksb9ao18tcp"},{"post_id":"ck2424lta005jlksbmbsn54ac","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lvr00bklksb7shhkpyk"},{"post_id":"ck2424lta005jlksbmbsn54ac","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lvs00bmlksbrws673lr"},{"post_id":"ck2424ltc005mlksb6t2uhjkk","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lvu00bqlksbvmvrul3g"},{"post_id":"ck2424ltc005mlksb6t2uhjkk","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lvu00brlksbvv84d17q"},{"post_id":"ck2424ltc005mlksb6t2uhjkk","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lvu00btlksbddwzkuiq"},{"post_id":"ck2424ltc005mlksb6t2uhjkk","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lvu00bulksbx6ubtd56"},{"post_id":"ck2424ltc005mlksb6t2uhjkk","tag_id":"ck2424lvt00bolksb29jgp7fl","_id":"ck2424lvu00bwlksboqmjdfqe"},{"post_id":"ck2424ltd005qlksb9zqqb9sj","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lvw00c1lksbjvom6pha"},{"post_id":"ck2424ltd005qlksb9zqqb9sj","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lvw00c2lksb2rqa733b"},{"post_id":"ck2424ltd005qlksb9zqqb9sj","tag_id":"ck2424lvu00bvlksbhpumsc5w","_id":"ck2424lvx00c4lksbqb8ocl1a"},{"post_id":"ck2424ltd005qlksb9zqqb9sj","tag_id":"ck2424lvu00bxlksbc4tg4dwb","_id":"ck2424lvx00c5lksbxnrkemym"},{"post_id":"ck2424ltd005qlksb9zqqb9sj","tag_id":"ck2424lva009nlksblx5l3vvc","_id":"ck2424lvx00c7lksbc62mhnnl"},{"post_id":"ck2424ltd005qlksb9zqqb9sj","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lvx00c8lksbbsd5psbr"},{"post_id":"ck2424ltf005tlksb97jo22xc","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lvz00cdlksbhl4mthvo"},{"post_id":"ck2424ltf005tlksb97jo22xc","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lvz00celksbk3pk3ttq"},{"post_id":"ck2424ltf005tlksb97jo22xc","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lvz00cglksbijcohqta"},{"post_id":"ck2424ltf005tlksb97jo22xc","tag_id":"ck2424lvx00c9lksbnoke133t","_id":"ck2424lvz00chlksbrmorc63o"},{"post_id":"ck2424ltf005tlksb97jo22xc","tag_id":"ck2424lvy00calksby7owfrty","_id":"ck2424lw000cjlksbodgh70cl"},{"post_id":"ck2424ltf005tlksb97jo22xc","tag_id":"ck2424lvn00b3lksbf8uzrmqx","_id":"ck2424lw000cklksbbcu43i9f"},{"post_id":"ck2424ltg005xlksbsvn1znr7","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lw200cplksbjpxc8iye"},{"post_id":"ck2424ltg005xlksbsvn1znr7","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lw200cqlksb5ad4kbra"},{"post_id":"ck2424ltg005xlksbsvn1znr7","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lw200cslksbhufhrmvg"},{"post_id":"ck2424ltg005xlksbsvn1znr7","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lw300ctlksbeg9uc09y"},{"post_id":"ck2424ltg005xlksbsvn1znr7","tag_id":"ck2424lva009nlksblx5l3vvc","_id":"ck2424lw300cvlksbh937geur"},{"post_id":"ck2424ltg005xlksbsvn1znr7","tag_id":"ck2424lw100cnlksbl664yrsi","_id":"ck2424lw300cwlksbhfmqs9jc"},{"post_id":"ck2424ltg005xlksbsvn1znr7","tag_id":"ck2424lkt0010lksbws1pjbzp","_id":"ck2424lw400cylksb649k1uye"},{"post_id":"ck2424lti0060lksbhnsiyrfv","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lw500d2lksb2ejl42yc"},{"post_id":"ck2424lti0060lksbhnsiyrfv","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lw500d3lksb90bu83j7"},{"post_id":"ck2424lti0060lksbhnsiyrfv","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lw600d5lksbhiwdiwye"},{"post_id":"ck2424lti0060lksbhnsiyrfv","tag_id":"ck2424lva009nlksblx5l3vvc","_id":"ck2424lw600d6lksbolfprp5b"},{"post_id":"ck2424lti0060lksbhnsiyrfv","tag_id":"ck2424lvu00bxlksbc4tg4dwb","_id":"ck2424lw600d8lksbx5ocs1t6"},{"post_id":"ck2424lti0060lksbhnsiyrfv","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lw600d9lksbjs3cdi3o"},{"post_id":"ck2424ltj0064lksblqwquhk6","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lw800ddlksbw40rx2s9"},{"post_id":"ck2424ltj0064lksblqwquhk6","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lw800delksb34svgmyn"},{"post_id":"ck2424ltj0064lksblqwquhk6","tag_id":"ck2424lw600d7lksbty9y01x5","_id":"ck2424lw800dglksb5neldpuo"},{"post_id":"ck2424ltj0064lksblqwquhk6","tag_id":"ck2424lva009nlksblx5l3vvc","_id":"ck2424lw800dhlksbv2kmi6u2"},{"post_id":"ck2424ltj0064lksblqwquhk6","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lw900djlksbk5aumnhj"},{"post_id":"ck2424ltm0067lksbah9dubn1","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lwa00dnlksb0d4jikyn"},{"post_id":"ck2424ltm0067lksbah9dubn1","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lwa00dolksbog4nzqvd"},{"post_id":"ck2424ltm0067lksbah9dubn1","tag_id":"ck2424lw800dilksbuzd535o1","_id":"ck2424lwb00dqlksbg7d7el37"},{"post_id":"ck2424ltm0067lksbah9dubn1","tag_id":"ck2424lw900dklksb8dsou03f","_id":"ck2424lwb00drlksbcselka8t"},{"post_id":"ck2424ltm0067lksbah9dubn1","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lwb00dtlksbhyqoicjp"},{"post_id":"ck2424ltn006blksbxbu257ti","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lwd00dxlksbahba8bjk"},{"post_id":"ck2424ltn006blksbxbu257ti","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lwd00dylksbrng9hhi2"},{"post_id":"ck2424ltn006blksbxbu257ti","tag_id":"ck2424lwb00dslksb0wvu9rh3","_id":"ck2424lwd00e0lksbkrih73qw"},{"post_id":"ck2424ltn006blksbxbu257ti","tag_id":"ck2424lva009nlksblx5l3vvc","_id":"ck2424lwe00e1lksbuklz9wcb"},{"post_id":"ck2424ltn006blksbxbu257ti","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lwe00e3lksbdd7jafsa"},{"post_id":"ck2424ltp006elksbw4pbytrn","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lwf00e5lksb8asgtlib"},{"post_id":"ck2424ltp006elksbw4pbytrn","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lwf00e6lksbfn09zzz3"},{"post_id":"ck2424ltp006elksbw4pbytrn","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lwf00e8lksbrcfj2198"},{"post_id":"ck2424ltq006ilksbtvzq8593","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lwh00edlksbpceuzki1"},{"post_id":"ck2424ltq006ilksbtvzq8593","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lwh00eelksbwekhmfpd"},{"post_id":"ck2424ltq006ilksbtvzq8593","tag_id":"ck2424lwf00e9lksb00ptkfia","_id":"ck2424lwi00eglksbd6l6pj36"},{"post_id":"ck2424ltq006ilksbtvzq8593","tag_id":"ck2424lvu00bvlksbhpumsc5w","_id":"ck2424lwi00ehlksbir5n5dvm"},{"post_id":"ck2424ltq006ilksbtvzq8593","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lwi00ejlksbw6uuz9o5"},{"post_id":"ck2424lts006llksbd02qcx81","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lwj00enlksbqv1udnlm"},{"post_id":"ck2424lts006llksbd02qcx81","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lwj00eolksbm6z5c4ja"},{"post_id":"ck2424lts006llksbd02qcx81","tag_id":"ck2424lwi00eilksb50ym92q9","_id":"ck2424lwk00eqlksbgftsdypv"},{"post_id":"ck2424lts006llksbd02qcx81","tag_id":"ck2424lwi00eklksb1bby3unf","_id":"ck2424lwk00erlksbdb7woo0j"},{"post_id":"ck2424lts006llksbd02qcx81","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lwk00etlksb19x4mn00"},{"post_id":"ck2424ltt006olksbf6kcf3ce","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lwm00exlksbvqet8vqz"},{"post_id":"ck2424ltt006olksbf6kcf3ce","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lwm00eylksbndu3svbq"},{"post_id":"ck2424ltt006olksbf6kcf3ce","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lwn00f0lksbwpryp3hp"},{"post_id":"ck2424ltt006olksbf6kcf3ce","tag_id":"ck2424lwi00eklksb1bby3unf","_id":"ck2424lwn00f1lksb4apcisdy"},{"post_id":"ck2424ltt006olksbf6kcf3ce","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lwn00f3lksbfrkwd0r1"},{"post_id":"ck2424ltu006slksbyjdo1il4","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lwp00f7lksb56ljkf8k"},{"post_id":"ck2424ltu006slksbyjdo1il4","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lwp00f8lksb28lwqnil"},{"post_id":"ck2424ltu006slksbyjdo1il4","tag_id":"ck2424lwn00f2lksbnbqiwu2u","_id":"ck2424lwp00falksbq62ecspn"},{"post_id":"ck2424ltu006slksbyjdo1il4","tag_id":"ck2424lwi00eilksb50ym92q9","_id":"ck2424lwp00fblksb3z3ge47l"},{"post_id":"ck2424ltu006slksbyjdo1il4","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lwq00fdlksbgm5qmgjq"},{"post_id":"ck2424ltv006vlksb374gv5v8","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lwt00filksbu4di6hdz"},{"post_id":"ck2424ltv006vlksb374gv5v8","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lwt00fjlksbq56s3y11"},{"post_id":"ck2424ltv006vlksb374gv5v8","tag_id":"ck2424lwp00fclksbd4vlhrrh","_id":"ck2424lwt00fllksb00k4m02g"},{"post_id":"ck2424ltv006vlksb374gv5v8","tag_id":"ck2424lwq00felksbbd5392v4","_id":"ck2424lwu00fmlksbct2kquqo"},{"post_id":"ck2424ltv006vlksb374gv5v8","tag_id":"ck2424lva009nlksblx5l3vvc","_id":"ck2424lwu00folksbliw79cpf"},{"post_id":"ck2424ltv006vlksb374gv5v8","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lwu00fplksb44jchi22"},{"post_id":"ck2424ltx006zlksb7paxbkt5","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lwv00fslksbjk4utq1i"},{"post_id":"ck2424ltx006zlksb7paxbkt5","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lwv00ftlksbzk3ght0j"},{"post_id":"ck2424ltx006zlksb7paxbkt5","tag_id":"ck2424lwu00fnlksbc2t9arxf","_id":"ck2424lww00fvlksbrl419qc5"},{"post_id":"ck2424ltx006zlksb7paxbkt5","tag_id":"ck2424lkt0010lksbws1pjbzp","_id":"ck2424lww00fwlksbcn1ab2m8"},{"post_id":"ck2424ltx006zlksb7paxbkt5","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lww00fylksb7p00xw1p"},{"post_id":"ck2424lty0071lksbhon558xs","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lwx00g1lksb37e1r31y"},{"post_id":"ck2424lty0071lksbhon558xs","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lwx00g2lksbztjnsj2r"},{"post_id":"ck2424lty0071lksbhon558xs","tag_id":"ck2424lww00fxlksbdtu15uk4","_id":"ck2424lwy00g4lksbni5b9dhl"},{"post_id":"ck2424lty0071lksbhon558xs","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lwy00g5lksbvata2kjj"},{"post_id":"ck2424lu00074lksbt8wxnjd1","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lx000galksb9zqv2pwm"},{"post_id":"ck2424lu00074lksbt8wxnjd1","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lx000gblksbtmemvxnw"},{"post_id":"ck2424lu00074lksbt8wxnjd1","tag_id":"ck2424lvy00calksby7owfrty","_id":"ck2424lx100gdlksb7xy0dtnb"},{"post_id":"ck2424lu00074lksbt8wxnjd1","tag_id":"ck2424lwy00g7lksbz4vk6qjh","_id":"ck2424lx100gelksb5at2elyo"},{"post_id":"ck2424lu00074lksbt8wxnjd1","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lx100gglksbny4t1zy0"},{"post_id":"ck2424lu10076lksb7o6nwoqu","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lx200gjlksbovwrzc7h"},{"post_id":"ck2424lu10076lksb7o6nwoqu","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lx300gklksb4m81os8e"},{"post_id":"ck2424lu10076lksb7o6nwoqu","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lx300gmlksbco8oktls"},{"post_id":"ck2424lu10076lksb7o6nwoqu","tag_id":"ck2424lww00fxlksbdtu15uk4","_id":"ck2424lx300gnlksb0y81rroo"},{"post_id":"ck2424lu20079lksb06ya682c","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lx600gtlksbbxnsa0ch"},{"post_id":"ck2424lu20079lksb06ya682c","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lx600gulksbvxtjwz3x"},{"post_id":"ck2424lu20079lksb06ya682c","tag_id":"ck2424lwi00eilksb50ym92q9","_id":"ck2424lx700gwlksbg826f3wb"},{"post_id":"ck2424lu20079lksb06ya682c","tag_id":"ck2424lx400gplksbv4r6t6zx","_id":"ck2424lx700gxlksbwsyiespg"},{"post_id":"ck2424lu20079lksb06ya682c","tag_id":"ck2424lwy00g7lksbz4vk6qjh","_id":"ck2424lx700gzlksb9v9u9wm6"},{"post_id":"ck2424lu20079lksb06ya682c","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lx700h0lksbbqwtpqw9"},{"post_id":"ck2424lu4007clksb0bv5bxfj","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lx900h4lksbc6edvvc1"},{"post_id":"ck2424lu4007clksb0bv5bxfj","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lx900h5lksb2n65obi3"},{"post_id":"ck2424lu4007clksb0bv5bxfj","tag_id":"ck2424lwb00dslksb0wvu9rh3","_id":"ck2424lxa00h7lksbbkb09bwt"},{"post_id":"ck2424lu4007clksb0bv5bxfj","tag_id":"ck2424lva009nlksblx5l3vvc","_id":"ck2424lxa00h8lksbqym6efud"},{"post_id":"ck2424lu4007clksb0bv5bxfj","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lxa00halksbrym1g5zv"},{"post_id":"ck2424lu5007flksbov6tzn2d","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lxc00hflksb2080vcrs"},{"post_id":"ck2424lu5007flksbov6tzn2d","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lxc00hglksbed74j18z"},{"post_id":"ck2424lu5007flksbov6tzn2d","tag_id":"ck2424lxa00h9lksbgohlr95h","_id":"ck2424lxd00hilksbqo8swqm8"},{"post_id":"ck2424lu5007flksbov6tzn2d","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lxd00hjlksbura8mzkd"},{"post_id":"ck2424lu5007flksbov6tzn2d","tag_id":"ck2424lxa00hclksb3v9jiwzx","_id":"ck2424lxd00hllksbar2rrl23"},{"post_id":"ck2424lu5007flksbov6tzn2d","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lxd00hmlksbu04f5vxl"},{"post_id":"ck2424lu6007jlksbds0bqjgo","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lxi00hslksbvt4q7a8p"},{"post_id":"ck2424lu6007jlksbds0bqjgo","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lxi00htlksb3xck1u9a"},{"post_id":"ck2424lu6007jlksbds0bqjgo","tag_id":"ck2424lwp00fclksbd4vlhrrh","_id":"ck2424lxj00hvlksbn5snodbh"},{"post_id":"ck2424lu6007jlksbds0bqjgo","tag_id":"ck2424lwf00e9lksb00ptkfia","_id":"ck2424lxj00hwlksbn7xuk7dw"},{"post_id":"ck2424lu6007jlksbds0bqjgo","tag_id":"ck2424lwi00eilksb50ym92q9","_id":"ck2424lxk00hylksbeprho9i2"},{"post_id":"ck2424lu6007jlksbds0bqjgo","tag_id":"ck2424lvj00aklksbr0uoclzy","_id":"ck2424lxk00hzlksb211inf4l"},{"post_id":"ck2424lu6007jlksbds0bqjgo","tag_id":"ck2424lvn00b3lksbf8uzrmqx","_id":"ck2424lxk00i1lksb5f1c1x7d"},{"post_id":"ck2424lu7007mlksbe569uyni","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lxn00i5lksbeclb4pb7"},{"post_id":"ck2424lu7007mlksbe569uyni","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lxn00i6lksbr7czru3s"},{"post_id":"ck2424lu7007mlksbe569uyni","tag_id":"ck2424lx400gplksbv4r6t6zx","_id":"ck2424lxn00i8lksbv1ip7xne"},{"post_id":"ck2424lu7007mlksbe569uyni","tag_id":"ck2424lwi00eilksb50ym92q9","_id":"ck2424lxn00i9lksbmv0kg4c5"},{"post_id":"ck2424lu7007mlksbe569uyni","tag_id":"ck2424ll00021lksb42bhpkur","_id":"ck2424lxo00iblksbc0ppo18n"},{"post_id":"ck2424lu7007mlksbe569uyni","tag_id":"ck2424lwy00g7lksbz4vk6qjh","_id":"ck2424lxo00iclksboky3pamq"},{"post_id":"ck2424lu7007mlksbe569uyni","tag_id":"ck2424lvn00b3lksbf8uzrmqx","_id":"ck2424lxo00ielksbedltbzpf"},{"post_id":"ck2424lub007plksbmci3id9e","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lxq00ihlksbud6dos8q"},{"post_id":"ck2424lub007plksbmci3id9e","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lxq00iilksbwa4zgyvz"},{"post_id":"ck2424lub007plksbmci3id9e","tag_id":"ck2424lxn00ialksbe77wnb9e","_id":"ck2424lxq00iklksb4qfx13vx"},{"post_id":"ck2424lub007plksbmci3id9e","tag_id":"ck2424lxo00idlksb2ju86xv5","_id":"ck2424lxq00illksbb2kxqk5n"},{"post_id":"ck2424lub007plksbmci3id9e","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lxr00inlksbwxnxv8mx"},{"post_id":"ck2424luc007rlksbftn3gwyp","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lxu00islksbhlhp28df"},{"post_id":"ck2424luc007rlksbftn3gwyp","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lxu00itlksbsmektip8"},{"post_id":"ck2424luc007rlksbftn3gwyp","tag_id":"ck2424lvn00b3lksbf8uzrmqx","_id":"ck2424lxv00ivlksbq8hltpqs"},{"post_id":"ck2424luc007rlksbftn3gwyp","tag_id":"ck2424lxr00iolksbw8fipd4s","_id":"ck2424lxv00iwlksbxpibkls7"},{"post_id":"ck2424luc007rlksbftn3gwyp","tag_id":"ck2424lwf00e9lksb00ptkfia","_id":"ck2424lxv00iylksbgfur37x1"},{"post_id":"ck2424luc007rlksbftn3gwyp","tag_id":"ck2424lkt0010lksbws1pjbzp","_id":"ck2424lxv00izlksbt7fmxeev"},{"post_id":"ck2424luc007rlksbftn3gwyp","tag_id":"ck2424lvn00b3lksbf8uzrmqx","_id":"ck2424lxw00j1lksb59ija9o1"},{"post_id":"ck2424lue007ulksbbz7bunk8","tag_id":"ck2424luk0086lksbsxfi9xlz","_id":"ck2424lxy00j5lksb0ml1b5na"},{"post_id":"ck2424lue007ulksbbz7bunk8","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lxy00j6lksbvcked0vu"},{"post_id":"ck2424lue007ulksbbz7bunk8","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lxy00j8lksb3mx714ox"},{"post_id":"ck2424lue007ulksbbz7bunk8","tag_id":"ck2424lvu00bvlksbhpumsc5w","_id":"ck2424lxy00j9lksbqb83i0ho"},{"post_id":"ck2424lue007ulksbbz7bunk8","tag_id":"ck2424lxw00j2lksbmzftkarc","_id":"ck2424lxz00jblksb67xvnuup"},{"post_id":"ck2424lue007ulksbbz7bunk8","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lxz00jclksbyq9mb3wq"},{"post_id":"ck2424lug007wlksbrv4jw9t5","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424ly000jglksbxwo2isq6"},{"post_id":"ck2424lug007wlksbrv4jw9t5","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424ly000jhlksbnsoyu86n"},{"post_id":"ck2424lug007wlksbrv4jw9t5","tag_id":"ck2424lxy00jalksb6yqhwo09","_id":"ck2424ly100jjlksbu11jqua5"},{"post_id":"ck2424lug007wlksbrv4jw9t5","tag_id":"ck2424lxz00jdlksbkqnripyi","_id":"ck2424ly100jklksbduflyj2g"},{"post_id":"ck2424lug007wlksbrv4jw9t5","tag_id":"ck2424lvn00b3lksbf8uzrmqx","_id":"ck2424ly100jmlksbeeoc1q4n"},{"post_id":"ck2424luh007zlksbuu7epaya","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424ly300jplksbgmnqgqi7"},{"post_id":"ck2424luh007zlksbuu7epaya","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424ly300jqlksb484scg8p"},{"post_id":"ck2424luh007zlksbuu7epaya","tag_id":"ck2424ly000jilksbwjyeh8bp","_id":"ck2424ly300jslksbjqa5ealy"},{"post_id":"ck2424luh007zlksbuu7epaya","tag_id":"ck2424ly100jllksb00d53ge3","_id":"ck2424ly300jtlksbzhtvkk39"},{"post_id":"ck2424luh007zlksbuu7epaya","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424ly400jvlksb1wga49wl"},{"post_id":"ck2424luj0083lksb9b9q4vnc","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424ly600jzlksb5imiyas5"},{"post_id":"ck2424luj0083lksb9b9q4vnc","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424ly600k0lksb6ex4lwok"},{"post_id":"ck2424luj0083lksb9b9q4vnc","tag_id":"ck2424ly300jrlksb50chb0ve","_id":"ck2424ly600k2lksbz4o4rmec"},{"post_id":"ck2424luj0083lksb9b9q4vnc","tag_id":"ck2424lxr00iolksbw8fipd4s","_id":"ck2424ly600k3lksbrqa8e1iv"},{"post_id":"ck2424luj0083lksb9b9q4vnc","tag_id":"ck2424lwf00e9lksb00ptkfia","_id":"ck2424ly700k5lksbhfz86bde"},{"post_id":"ck2424luj0083lksb9b9q4vnc","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424ly700k6lksbew5urpgc"},{"post_id":"ck2424luk0087lksb34bw7krt","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424ly800k8lksbqrnd2p39"},{"post_id":"ck2424luk0087lksb34bw7krt","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424ly800k9lksbw90pcp62"},{"post_id":"ck2424luk0087lksb34bw7krt","tag_id":"ck2424ly600k1lksbghvtrlu2","_id":"ck2424ly800kblksbmt4umlh2"},{"post_id":"ck2424lul008alksbvgoh3v5i","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lya00kelksbue54fmtx"},{"post_id":"ck2424lul008alksbvgoh3v5i","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lya00kflksbwxv6bv2q"},{"post_id":"ck2424lul008alksbvgoh3v5i","tag_id":"ck2424lvy00calksby7owfrty","_id":"ck2424lya00khlksblpx5rjcb"},{"post_id":"ck2424lul008alksbvgoh3v5i","tag_id":"ck2424lvu00bvlksbhpumsc5w","_id":"ck2424lya00kilksblnlhhy5c"},{"post_id":"ck2424lul008alksbvgoh3v5i","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lyb00kklksbh2g543uj"},{"post_id":"ck2424lum008elksbx88jkq10","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lye00knlksb92gssea7"},{"post_id":"ck2424lum008elksbx88jkq10","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lye00kolksbxv0nxf8i"},{"post_id":"ck2424lum008elksbx88jkq10","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lye00kqlksbxjfanwxq"},{"post_id":"ck2424lum008elksbx88jkq10","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lye00krlksb76dw5uzy"},{"post_id":"ck2424lum008elksbx88jkq10","tag_id":"ck2424lvu00bxlksbc4tg4dwb","_id":"ck2424lyf00ktlksb7phjdlbj"},{"post_id":"ck2424luo008hlksbhx29q12z","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lyg00kvlksb38a9cxbw"},{"post_id":"ck2424luo008hlksbhx29q12z","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lyg00kwlksbamvcj4f4"},{"post_id":"ck2424luo008hlksbhx29q12z","tag_id":"ck2424lvu00bvlksbhpumsc5w","_id":"ck2424lyg00kylksbzb4w8nfq"},{"post_id":"ck2424luo008hlksbhx29q12z","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lyg00kzlksb3wyhsa41"},{"post_id":"ck2424luq008klksbku82yea9","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lyh00l2lksbknio9uh6"},{"post_id":"ck2424luq008klksbku82yea9","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lyi00l3lksbxpzb52wu"},{"post_id":"ck2424luq008klksbku82yea9","tag_id":"ck2424lyg00kxlksb9t6i98ib","_id":"ck2424lyi00l5lksbtslsx2uk"},{"post_id":"ck2424luq008klksbku82yea9","tag_id":"ck2424lyg00l0lksbzlk2bq02","_id":"ck2424lyi00l6lksbz5pin5x6"},{"post_id":"ck2424lut008nlksbp1vgkiw1","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lyk00l9lksb4jbvcu00"},{"post_id":"ck2424lut008nlksbp1vgkiw1","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lyk00lalksbqxq6ktov"},{"post_id":"ck2424lut008nlksbp1vgkiw1","tag_id":"ck2424lvu00bvlksbhpumsc5w","_id":"ck2424lyl00lclksb1yy6z7fv"},{"post_id":"ck2424lut008nlksbp1vgkiw1","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lyl00ldlksb2btmkzpt"},{"post_id":"ck2424luu008plksbb5n9v9hf","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lym00lflksb96w40kd5"},{"post_id":"ck2424luu008plksbb5n9v9hf","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lym00lglksb6eqy66c4"},{"post_id":"ck2424luu008plksbb5n9v9hf","tag_id":"ck2424lkt0010lksbws1pjbzp","_id":"ck2424lym00lilksbwcsycuol"},{"post_id":"ck2424luu008plksbb5n9v9hf","tag_id":"ck2424lvn00b3lksbf8uzrmqx","_id":"ck2424lym00ljlksb5i0t45oc"},{"post_id":"ck2424luw008slksbj6j3rgev","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lyn00lllksb6fh3qoku"},{"post_id":"ck2424luw008slksbj6j3rgev","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lyn00lmlksb0g1m16pe"},{"post_id":"ck2424luw008slksbj6j3rgev","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lyo00lolksbep0xg96r"},{"post_id":"ck2424luw008slksbj6j3rgev","tag_id":"ck2424lkt0010lksbws1pjbzp","_id":"ck2424lyp00lplksb3tme81kc"},{"post_id":"ck2424lux008ulksbgwha9t5y","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lyp00lrlksbq4pd2mmw"},{"post_id":"ck2424lux008ulksbgwha9t5y","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lyp00lslksbm4d6ovyo"},{"post_id":"ck2424lux008ulksbgwha9t5y","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lyq00lulksbf0zsx8u9"},{"post_id":"ck2424luy008xlksbych894fh","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lyr00lwlksbkgaagll8"},{"post_id":"ck2424luy008xlksbych894fh","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lyr00lxlksb0y3lpght"},{"post_id":"ck2424luy008xlksbych894fh","tag_id":"ck2424lkt0010lksbws1pjbzp","_id":"ck2424lys00lzlksbhfxrz3ax"},{"post_id":"ck2424luy008xlksbych894fh","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lys00m0lksbni67auwl"},{"post_id":"ck2424luy008xlksbych894fh","tag_id":"ck2424lyp00ltlksb8o2kraak","_id":"ck2424lys00m2lksbjukupdc7"},{"post_id":"ck2424lv00090lksbc4l9vw90","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lyt00m3lksb9meq67e0"},{"post_id":"ck2424lv00090lksbc4l9vw90","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lyt00m5lksb65hyg09i"},{"post_id":"ck2424lv00090lksbc4l9vw90","tag_id":"ck2424lus008mlksbubzftowq","_id":"ck2424lyt00m6lksb38lcys76"},{"post_id":"ck2424lv00090lksbc4l9vw90","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lyu00m8lksbec38ptb6"},{"post_id":"ck2424lv10094lksbwttuwkab","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lyv00malksbkhga2qp0"},{"post_id":"ck2424lv10094lksbwttuwkab","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lyv00mblksbyiu9gwj3"},{"post_id":"ck2424lv10094lksbwttuwkab","tag_id":"ck2424lys00m1lksb0mdvb2pn","_id":"ck2424lyw00mdlksbmx5qm9om"},{"post_id":"ck2424lv10094lksbwttuwkab","tag_id":"ck2424lwf00e9lksb00ptkfia","_id":"ck2424lyw00melksb7o6dimlc"},{"post_id":"ck2424lv10094lksbwttuwkab","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lyw00mglksbcd2m8i8u"},{"post_id":"ck2424lv20097lksb0kupucym","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lyx00mjlksb6ayirdrc"},{"post_id":"ck2424lv20097lksb0kupucym","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lyy00mklksb44yn04mo"},{"post_id":"ck2424lv20097lksb0kupucym","tag_id":"ck2424lvn00b3lksbf8uzrmqx","_id":"ck2424lyy00mmlksba225cb0r"},{"post_id":"ck2424lv20097lksb0kupucym","tag_id":"ck2424lyw00mflksbm3we912s","_id":"ck2424lyy00mnlksbf5s3lccl"},{"post_id":"ck2424lv20097lksb0kupucym","tag_id":"ck2424lyw00mhlksbf2gmb73u","_id":"ck2424lyz00mplksbkvv4p5ph"},{"post_id":"ck2424lv4009blksbr9m1l0ip","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lyz00mqlksbvucwi8cc"},{"post_id":"ck2424lv4009blksbr9m1l0ip","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lz000mslksbqg6b4q5i"},{"post_id":"ck2424lv5009elksb9lf1wuul","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lz000mtlksbswo8hrqe"},{"post_id":"ck2424lv5009elksb9lf1wuul","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lz100mvlksbhah3up9k"},{"post_id":"ck2424lv5009elksb9lf1wuul","tag_id":"ck2424lkt0010lksbws1pjbzp","_id":"ck2424lz100mwlksb7dzvvfpr"},{"post_id":"ck2424lv5009elksb9lf1wuul","tag_id":"ck2424lv4009alksbisfiakfy","_id":"ck2424lz200mylksbf9kja6ft"},{"post_id":"ck2424lv7009glksb4e7orh1y","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lz200mzlksbvftpqtii"},{"post_id":"ck2424lv7009glksb4e7orh1y","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lz300n1lksbq644a8zq"},{"post_id":"ck2424lv7009glksb4e7orh1y","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lz300n2lksbj86zxe8i"},{"post_id":"ck2424lv7009glksb4e7orh1y","tag_id":"ck2424lvy00calksby7owfrty","_id":"ck2424lz300n4lksbcrqzkpow"},{"post_id":"ck2424lv8009jlksbvykhhxyr","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lz300n5lksbccnraj5e"},{"post_id":"ck2424lv8009jlksbvykhhxyr","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lz300n7lksbnanyvxki"},{"post_id":"ck2424lv8009jlksbvykhhxyr","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lz300n8lksbqhiyzr2p"},{"post_id":"ck2424lv9009llksbax2ilfx3","tag_id":"ck2424lz100mxlksb63hwpnfz","_id":"ck2424lz500nblksbby366yef"},{"post_id":"ck2424lv9009llksbax2ilfx3","tag_id":"ck2424lz200n0lksbhn4bdcdz","_id":"ck2424lz500nclksbtpo6gqa8"},{"post_id":"ck2424lv9009llksbax2ilfx3","tag_id":"ck2424lz300n3lksbsk4ipibm","_id":"ck2424lz500nelksbwtslpvam"},{"post_id":"ck2424lv9009llksbax2ilfx3","tag_id":"ck2424lz300n6lksbn7pypio2","_id":"ck2424lz500nflksbdlss2osj"},{"post_id":"ck2424lv9009llksbax2ilfx3","tag_id":"ck2424lz300n9lksbesq36l0o","_id":"ck2424lz700nhlksbikqu58i9"},{"post_id":"ck2424lva009olksbv1hqal6h","tag_id":"ck2424lku0012lksb8ed7ojns","_id":"ck2424lz700nilksbk1w1bg70"},{"post_id":"ck2424lva009olksbv1hqal6h","tag_id":"ck2424lz200n0lksbhn4bdcdz","_id":"ck2424lz800nklksbwi92tcfw"},{"post_id":"ck2424lva009olksbv1hqal6h","tag_id":"ck2424lml003wlksbwck7bl7x","_id":"ck2424lz800nllksbawl3jre9"},{"post_id":"ck2424lva009olksbv1hqal6h","tag_id":"ck2424lz500ndlksbyemmleqr","_id":"ck2424lz800nnlksbel4ec5zg"},{"post_id":"ck2424lvc009qlksbozcglg8l","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424lz900nolksbkghslisq"},{"post_id":"ck2424lvc009qlksbozcglg8l","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424lz900nplksbdpzby3c7"},{"post_id":"ck2424lvc009qlksbozcglg8l","tag_id":"ck2424lxo00idlksb2ju86xv5","_id":"ck2424lz900nqlksbjm7yk7bx"},{"post_id":"ck2424lvc009qlksbozcglg8l","tag_id":"ck2424lz800nmlksbqsjsabe9","_id":"ck2424lz900nrlksbov8cqt7m"},{"post_id":"ck2424lvc009qlksbozcglg8l","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424lza00nslksbhgmt2mcs"},{"post_id":"ck2424m0s00ntlksbuguwba6s","tag_id":"ck2424lxw00j4lksb1mdhokr7","_id":"ck2424m0u00nulksbj0c0ovrf"},{"post_id":"ck2424m0s00ntlksbuguwba6s","tag_id":"ck2424luh007ylksbfqh73unm","_id":"ck2424m0v00nvlksbxsh402c9"},{"post_id":"ck2424m0s00ntlksbuguwba6s","tag_id":"ck2424lvy00calksby7owfrty","_id":"ck2424m0v00nxlksb3kt3obbp"},{"post_id":"ck2424m0s00ntlksbuguwba6s","tag_id":"ck2424luv008rlksbzknwqyts","_id":"ck2424m0v00nylksbya7mimot"},{"post_id":"ck2424m3p00nzlksb8dku8w3k","tag_id":"ck2424m3s00o1lksbap2b2ca2","_id":"ck2424m3x00o7lksbbry8oml8"},{"post_id":"ck2424m3p00nzlksb8dku8w3k","tag_id":"ck2424lml003wlksbwck7bl7x","_id":"ck2424m3x00o9lksb8objgpxn"},{"post_id":"ck2424m3p00nzlksb8dku8w3k","tag_id":"ck2424m3u00o3lksb2k3ajuwp","_id":"ck2424m3y00oblksbdr9cakqa"},{"post_id":"ck2424m3q00o0lksbmdj3ax24","tag_id":"ck2424m3s00o1lksbap2b2ca2","_id":"ck2424m3y00odlksb9swtt5ke"},{"post_id":"ck2424m3q00o0lksbmdj3ax24","tag_id":"ck2424lml003wlksbwck7bl7x","_id":"ck2424m3y00oelksb4d3x5idy"},{"post_id":"ck2424m5u00oflksb0py5nenc","tag_id":"ck2424m3s00o1lksbap2b2ca2","_id":"ck2424m5x00oglksbl1nd0ahq"},{"post_id":"ck2424m5u00oflksb0py5nenc","tag_id":"ck2424lml003wlksbwck7bl7x","_id":"ck2424m5y00ohlksb8wxmri8m"}],"Tag":[{"name":"ArchLinux","_id":"ck2424lk20004lksbijwenhfk"},{"name":"PKGBUILD","_id":"ck2424lk90009lksbfw3qcei1"},{"name":"AUR","_id":"ck2424lki000elksbc36mrksk"},{"name":"ABS","_id":"ck2424lkn000jlksbkjuud4wc"},{"name":"ACM-ICPC","_id":"ck2424lkr000nlksb69i40jk0"},{"name":"Learning","_id":"ck2424lks000ulksb1yneapb4"},{"name":"DP","_id":"ck2424lkt0010lksbws1pjbzp"},{"name":"Notes","_id":"ck2424lku0012lksb8ed7ojns"},{"name":"Arch","_id":"ck2424lku0014lksbc5a1b02h"},{"name":"Linux","_id":"ck2424lku0017lksb5m89pgli"},{"name":"Gnome","_id":"ck2424lkv001alksbf3rvf5o0"},{"name":"Synaptics","_id":"ck2424lkv001blksbb5pwong2"},{"name":"LNMP","_id":"ck2424lkw001ilksb8iqkgeg5"},{"name":"Deb","_id":"ck2424lky001qlksbuxzydupq"},{"name":"Debtap","_id":"ck2424lky001tlksbzd5ihse6"},{"name":"C++","_id":"ck2424lkz001vlksbpgnzhwz6"},{"name":"Queue","_id":"ck2424ll0001ylksbwirrxgjc"},{"name":"PriorityQueue","_id":"ck2424ll00021lksb42bhpkur"},{"name":"Markdown","_id":"ck2424ll10026lksb1km5nz4q"},{"name":"Canvas","_id":"ck2424ll2002alksbq8zocx7d"},{"name":"Web","_id":"ck2424ll2002dlksbjui0syzz"},{"name":"ImageData","_id":"ck2424ll3002flksb54xvqz8u"},{"name":"Python","_id":"ck2424llt002rlksbw7hzg4nh"},{"name":"Tornado","_id":"ck2424llw002xlksbnv6zuq7c"},{"name":"Async","_id":"ck2424llz0033lksbm0hvvgm5"},{"name":"UEFI","_id":"ck2424lmh003ilksbh5tuzwg4"},{"name":"GPT","_id":"ck2424lmh003nlksb9o83srtp"},{"name":"双系统","_id":"ck2424lmi003olksb802dkzxh"},{"name":"Install","_id":"ck2424lmi003plksb9rs5q1uk"},{"name":"Gnome-tweaks","_id":"ck2424lmi003qlksbyons9he9"},{"name":"Numpy","_id":"ck2424lmj003tlksbgslxt2mr"},{"name":"MachineLearning","_id":"ck2424lml003wlksbwck7bl7x"},{"name":"Review","_id":"ck2424lmn003zlksbi9vtshdm"},{"name":"SpaceVim","_id":"ck2424lmo0043lksbrr2ju0lg"},{"name":"Reprint","_id":"ck2424lmp0046lksbqy1ahoam"},{"name":"Nju","_id":"ck2424lmq0049lksbwasg0q16"},{"name":"SummerCamp","_id":"ck2424lmr004clksb4t7751b6"},{"name":"Daily","_id":"ck2424lmr004glksb8u5npliz"},{"name":"Lift","_id":"ck2424lms004mlksblrlp3aj3"},{"name":"MNIST","_id":"ck2424lse004vlksbp0yupq33"},{"name":"Tensorflow","_id":"ck2424lsq0052lksby0ztctgy"},{"name":"LeNet-5","_id":"ck2424lt20057lksbf3rhlefc"},{"name":"Problems","_id":"ck2424lt5005dlksb3cfz3o8g"},{"name":"ML","_id":"ck2424lt8005hlksb7semngxc"},{"name":"Clustering","_id":"ck2424ltc005olksbj19f5lel"},{"name":"K-Means","_id":"ck2424ltg005vlksbx0p6597k"},{"name":"TensorFlow","_id":"ck2424ltj0062lksb0m47dl46"},{"name":"凸函数","_id":"ck2424ltq006glksb6onzgrhj"},{"name":"凸集","_id":"ck2424ltu006qlksbiuossj1n"},{"name":"凸优化","_id":"ck2424ltw006xlksbszvp2jp9"},{"name":"SVM","_id":"ck2424lu00073lksbnkxaxb00"},{"name":"超平面","_id":"ck2424lu20078lksbgbehtuq6"},{"name":"函数间隔","_id":"ck2424lu5007hlksb8a3evgaz"},{"name":"几何间隔","_id":"ck2424lub007olksb8rkc2744"},{"name":"Algorithm","_id":"ck2424luh007ylksbfqh73unm"},{"name":"LeetCode","_id":"ck2424luk0086lksbsxfi9xlz"},{"name":"Hash Map","_id":"ck2424lun008glksbp3coz9qr"},{"name":"Math","_id":"ck2424lus008mlksbubzftowq"},{"name":"Easy","_id":"ck2424luv008rlksbzknwqyts"},{"name":"Medium","_id":"ck2424lv4009alksbisfiakfy"},{"name":"String","_id":"ck2424lva009nlksblx5l3vvc"},{"name":"Split","_id":"ck2424lvd009slksblqav0ehi"},{"name":"Linked List","_id":"ck2424lvg00a5lksbg9uxbjhq"},{"name":"Large Number","_id":"ck2424lvg00a8lksbpp07gtjz"},{"name":"Reverse","_id":"ck2424lvj00aklksbr0uoclzy"},{"name":"Big Number","_id":"ck2424lvj00allksbf2v8ykmm"},{"name":"Match","_id":"ck2424lvn00b2lksbktfsp35h"},{"name":"Hard","_id":"ck2424lvn00b3lksbf8uzrmqx"},{"name":"Pointer","_id":"ck2424lvt00bolksb29jgp7fl"},{"name":"Map","_id":"ck2424lvu00bvlksbhpumsc5w"},{"name":"Integer","_id":"ck2424lvu00bxlksbc4tg4dwb"},{"name":"Binary Search","_id":"ck2424lvx00c9lksbnoke133t"},{"name":"Array","_id":"ck2424lvy00calksby7owfrty"},{"name":"Palindromic","_id":"ck2424lw100cnlksbl664yrsi"},{"name":"Prefix","_id":"ck2424lw600d7lksbty9y01x5"},{"name":"Closest","_id":"ck2424lw800dilksbuzd535o1"},{"name":"3Sum","_id":"ck2424lw900dklksb8dsou03f"},{"name":"Palindrome","_id":"ck2424lwb00dslksb0wvu9rh3"},{"name":"Recursive","_id":"ck2424lwf00e9lksb00ptkfia"},{"name":"LinkedList","_id":"ck2424lwi00eilksb50ym92q9"},{"name":"TwoPointer","_id":"ck2424lwi00eklksb1bby3unf"},{"name":"Swap","_id":"ck2424lwn00f2lksbnbqiwu2u"},{"name":"Stack","_id":"ck2424lwp00fclksbd4vlhrrh"},{"name":"Pair","_id":"ck2424lwq00felksbbd5392v4"},{"name":"Parentheses","_id":"ck2424lwu00fnlksbc2t9arxf"},{"name":"Vector","_id":"ck2424lww00fxlksbdtu15uk4"},{"name":"Merge","_id":"ck2424lwy00g7lksbz4vk6qjh"},{"name":"List","_id":"ck2424lx400gplksbv4r6t6zx"},{"name":"Xor","_id":"ck2424lxa00h9lksbgohlr95h"},{"name":"Linear","_id":"ck2424lxa00hclksb3v9jiwzx"},{"name":"Matrix","_id":"ck2424lxn00ialksbe77wnb9e"},{"name":"Search","_id":"ck2424lxo00idlksb2ju86xv5"},{"name":"BinaryTree","_id":"ck2424lxr00iolksbw8fipd4s"},{"name":"Majority","_id":"ck2424lxw00j2lksbmzftkarc"},{"name":"NowCoder","_id":"ck2424lxw00j4lksb1mdhokr7"},{"name":"Graph","_id":"ck2424lxy00jalksb6yqhwo09"},{"name":"Dijkstra","_id":"ck2424lxz00jdlksbkqnripyi"},{"name":"Scale","_id":"ck2424ly000jilksbwjyeh8bp"},{"name":"Binary","_id":"ck2424ly100jllksb00d53ge3"},{"name":"Tree","_id":"ck2424ly300jrlksb50chb0ve"},{"name":"Greedy","_id":"ck2424ly600k1lksbghvtrlu2"},{"name":"Sort","_id":"ck2424lyg00kxlksb9t6i98ib"},{"name":"BubbleSort","_id":"ck2424lyg00l0lksbzlk2bq02"},{"name":"Knapsack","_id":"ck2424lyp00ltlksb8o2kraak"},{"name":"BFS","_id":"ck2424lys00m1lksb0mdvb2pn"},{"name":"BigNumber","_id":"ck2424lyw00mflksbm3we912s"},{"name":"Factorial","_id":"ck2424lyw00mhlksbf2gmb73u"},{"name":"RNAi","_id":"ck2424lz100mxlksb63hwpnfz"},{"name":"siRNA","_id":"ck2424lz200n0lksbhn4bdcdz"},{"name":"Note","_id":"ck2424lz300n3lksbsk4ipibm"},{"name":"Basic","_id":"ck2424lz300n6lksbn7pypio2"},{"name":"Summary","_id":"ck2424lz300n9lksbesq36l0o"},{"name":"Paper","_id":"ck2424lz500ndlksbyemmleqr"},{"name":"Struct","_id":"ck2424lz800nmlksbqsjsabe9"},{"name":"机器学习基石","_id":"ck2424m3s00o1lksbap2b2ca2"},{"name":"PLA","_id":"ck2424m3u00o3lksb2k3ajuwp"}]}}