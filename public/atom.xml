<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Catch Your Dream</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://catchdream.me/"/>
  <updated>2019-07-12T12:06:48.147Z</updated>
  <id>https://catchdream.me/</id>
  
  <author>
    <name>Haniel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记2019南大计算机本科生开放日</title>
    <link href="https://catchdream.me/2019/07/12/%E8%AE%B02019%E5%8D%97%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AC%E7%A7%91%E7%94%9F%E5%BC%80%E6%94%BE%E6%97%A5/"/>
    <id>https://catchdream.me/2019/07/12/记2019南大计算机本科生开放日/</id>
    <published>2019-07-12T10:29:34.000Z</published>
    <updated>2019-07-12T12:06:48.147Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>2019年7月12，恩，南大夏令营第一天，一天之内心情就像打翻的五味瓶。。。</p><p>哎，写下来这些也是希望能给后面的学弟学妹点帮助，毕竟我也是看了很多以前别人写的夏令营的博客才完全了解夏令营。<br>不说了罢，再说，要落泪了…</p></div><a id="more"></a><h1 id="申请夏令营和选拔"><a href="#申请夏令营和选拔" class="headerlink" title="申请夏令营和选拔"></a>申请夏令营和选拔</h1><h2 id="初审"><a href="#初审" class="headerlink" title="初审"></a>初审</h2><p>南大入营选拔很看重绩点和排名，以及，学校，这些都是敲门砖。</p><p>当你绩点专业前5%，学校起码是211，你就有戏了，非211和985的，应该非常非常少，当然，如果你有很多厉害的奖，专利，论文啥的，就没问题<br>除了上面的敲门砖，竞赛、论文、获奖、专利、软著这些之类的，如果有比较厉害的，也会很有希望。</p><h2 id="复审"><a href="#复审" class="headerlink" title="复审"></a>复审</h2><p>不要以为收到第一封通知邮件就是入营了，那只是初审，复审还会刷掉点人。<br>复审需要寄送材料，按照邮件要求寄送即可，不要作假就行</p><p>2019年大概400左右人入营，南京市内100+，非南京市280+，大概只给100不到的优营名额，竞争还是很激烈的</p><h1 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a>夏令营</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>别想了，在你报名之前你就应该准备。</p><p>事实证明，如果你觉得自己有希望保研，最好大三下开学就准备夏令营，在大三下期末考之前，你需要认真复习准备我下面要说的。等期末结束再认真复习，就晚了。。<br>我就是，期末之前复习不多，期末之后确认入营了才认真起来，但是时间完全不够用。</p><p><strong>准备分为机试和面试</strong></p><ol><li>机试<ul><li>你需要学大量的算法，ACM中等难度就可以</li><li>刷大量的题，100道肯定不够的，可以刷<a href="https://leetcode.com/problemset/all/" target="_blank" rel="noopener">LeetCode</a>上的中等难度题，也可以找上面的分类题目写。还可以刷<a href="https://www.nowcoder.com/ta/kaoyan" target="_blank" rel="noopener">牛客网</a>的考研复试题。事实证明，这两个网站都很有用</li><li>刷完题要总结，可以用思维导图，我觉得挺好</li></ul></li><li>面试<ul><li>你需要复习数学相关，比如：概统、现代、离散</li><li>专业相关，比如：操作系统、数据结构、计网、计组、数据库。如果时间充足，全都复习，时间不够，按我的写的顺序复习</li></ul></li></ol><h2 id="第一天机试"><a href="#第一天机试" class="headerlink" title="第一天机试"></a>第一天机试</h2><p>第一天，算是最难受的了把。因为报道当天早上从学校出发的，所以要早起。但是，前一天晚上睡觉睡不着..不是我一个人，同行的四个人，都睡不着，一方面是无法避免的紧张，另一方面是，和自己生物钟不协调，睡太早</p><p>所以尽量提前几天调好生物钟把，精神会好点</p><p>上午11点左右到南大，路上本来想着再看看算法，但是因为晕车，困，没座位这些原因就没看。报道之后就直接去酒店登记入住了。酒店还是很棒的，毕竟四星级，条件很好。<br>每天的午饭晚饭有餐券。不得不说！南大的伙食真的好，虽然，很贵….我看到一个女生，两个大荤加一个蔬菜，好像还有汤，26元..正常人均15把</p><p>吃完饭就没多少时间了，因为着凉肚子难受，趴桌子趴了一会。复习也只能大概过一遍。所以尽量夏令营之前准备妥当。<br>吃饭的时候听可靠消息说今年的题目比较难，当时心里就慌了，后面等机房开门的时候就一直看算法，心情沉重，</p><h3 id="机试"><a href="#机试" class="headerlink" title="机试"></a>机试</h3><p>要求下午1点半到，两点开始考试。<br>一共两小时，三道题，每道题有10个测试用例，一个测试用例10分。满分也就是300分。</p><p>以前好像看到说可以看到测试用例。但是！并没有，只能看到你第几个通过，第几个没通过，而且今年看不到总排名</p><p>机试第一题大概意思是，给你一个不超过100位的数n，和一个不超过100的数字k，要求从数n中去掉k个数字，然后使得去掉k个数之后，n最小。</p><p>第二道题大概意思是，有B个男孩，G个女孩，要求所有男孩女孩排成一队，连续的男孩个数不可以超过K个，问一共有多少种排法</p><p>第三题是，给出一个二叉树的前序遍历序列和后序遍历序列，序列是没有空节点#号的，只有字母，问通过这两个序列可以构造多少中不同的二叉树，因为树的样子不一样，遍历的序列是可能一样的。比如前序序列:abc，后序序列cba，就有4种不同的树</p><p>题解等后面有了再更</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;2019年7月12，恩，南大夏令营第一天，一天之内心情就像打翻的五味瓶。。。&lt;/p&gt;
&lt;p&gt;哎，写下来这些也是希望能给后面的学弟学妹点帮助，毕竟我也是看了很多以前别人写的夏令营的博客才完全了解夏令营。&lt;br&gt;不说了罢，再说，要落泪了…&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Daily" scheme="https://catchdream.me/categories/Daily/"/>
    
    
      <category term="Daily" scheme="https://catchdream.me/tags/Daily/"/>
    
      <category term="Nju" scheme="https://catchdream.me/tags/Nju/"/>
    
      <category term="SummerCamp" scheme="https://catchdream.me/tags/SummerCamp/"/>
    
  </entry>
  
  <entry>
    <title>Linux将deb包转为ArchLinux软件包</title>
    <link href="https://catchdream.me/2019/07/03/Linux%E5%B0%86deb%E5%8C%85%E8%BD%AC%E4%B8%BAArchLinux%E8%BD%AF%E4%BB%B6%E5%8C%85/"/>
    <id>https://catchdream.me/2019/07/03/Linux将deb包转为ArchLinux软件包/</id>
    <published>2019-07-03T10:35:48.000Z</published>
    <updated>2019-07-03T10:56:57.898Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候可能找不到arch用的包，只有deb包或者rpm包。<br>将deb包转换为ArchLinux的包比较方便，使用了debtap这个工具<br>debtap代表了 DEB T o A rch （Linux） P ackage的意思</p></div><a id="more"></a><h2 id="安装debtap并更新数据"><a href="#安装debtap并更新数据" class="headerlink" title="安装debtap并更新数据"></a>安装debtap并更新数据</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>[依赖关系:]</strong> 需要提前安装好<strong> bash， binutils ，pkgfile 和 fakeroot 包</strong><br>如果直接安装会帮你安装依赖.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yaourt -S debtap</span><br></pre></td></tr></table></figure><p>遇到需要编辑的就默认enter跳过，需要安装的就确认，然后等就行了</p><h3 id="创建-更新-pkgfile-和-debtap-数据库。"><a href="#创建-更新-pkgfile-和-debtap-数据库。" class="headerlink" title="创建/更新 pkgfile 和 debtap 数据库。"></a>创建/更新 pkgfile 和 debtap 数据库。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo debtap -u</span><br></pre></td></tr></table></figure><h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><p>假如要转化name.deb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debtap name.deb</span><br></pre></td></tr></table></figure><p>中间可能要输入点东西，自己看情况输入就好</p><p><strong>其他参数：</strong></p><ul><li>略过除了编辑元数据之外的所有问题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debtap -q name.deb</span><br></pre></td></tr></table></figure><ul><li>略过所有的问题（不推荐）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debtap -Q name.deb</span><br></pre></td></tr></table></figure><ul><li>查看帮助</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debtap -h</span><br></pre></td></tr></table></figure><h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><p>使用pacman安装软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -U &lt;package-name&gt;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有时候可能找不到arch用的包，只有deb包或者rpm包。&lt;br&gt;将deb包转换为ArchLinux的包比较方便，使用了debtap这个工具&lt;br&gt;debtap代表了 DEB T o A rch （Linux） P ackage的意思&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Daily" scheme="https://catchdream.me/categories/Daily/"/>
    
    
      <category term="Daily" scheme="https://catchdream.me/tags/Daily/"/>
    
      <category term="Deb" scheme="https://catchdream.me/tags/Deb/"/>
    
      <category term="Debtap" scheme="https://catchdream.me/tags/Debtap/"/>
    
      <category term="ArchLinux" scheme="https://catchdream.me/tags/ArchLinux/"/>
    
  </entry>
  
  <entry>
    <title>动态规划套路详解</title>
    <link href="https://catchdream.me/2019/06/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%A5%97%E8%B7%AF%E8%AF%A6%E8%A7%A3/"/>
    <id>https://catchdream.me/2019/06/18/动态规划套路详解/</id>
    <published>2019-06-18T06:38:35.000Z</published>
    <updated>2019-06-18T07:06:11.597Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在LeetCode的<a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/" target="_blank" rel="noopener">322题题解</a>中看到一篇动态规划的详解，讲的很清楚，转载记录下</p><p>转自：<a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/" target="_blank" rel="noopener">LeetCode动态规划套路详解</a></p></div><a id="more"></a><h2 id="介绍-amp-闲谈"><a href="#介绍-amp-闲谈" class="headerlink" title="介绍&amp;闲谈"></a>介绍&amp;闲谈</h2><p>下面通过对斐波那契数列和这道凑零钱问题详解动态规划。如果只想看本题的答案，请直接翻到最后查看。</p><p>动态规划算法似乎是一种很高深莫测的算法，你会在一些面试或算法书籍的高级技巧部分看到相关内容，什么状态转移方程，<strong>重叠子问题</strong>，最优子结构等高大上的词汇也可能让你望而却步。</p><p>而且，当你去看用动态规划解决某个问题的代码时，你会觉得这样解决问题竟然如此巧妙，但却难以理解，你可能惊讶于人家是怎么想到这种解法的。</p><p>实际上，动态规划是一种常见的「算法设计技巧」，并没有什么高深莫测，至于各种高大上的术语，那是吓唬别人用的，只要你亲自体验几把，这些名词的含义其实显而易见，再简单不过了。</p><p>至于为什么最终的解法看起来如此精妙，是因为动态规划遵循一套固定的流程：<br>递归的暴力解法 -&gt; 带备忘录的递归解法 -&gt; 非递归的动态规划解法。</p><p>这个过程是层层递进的解决问题的过程，你如果没有前面的铺垫，直接看最终的非递归动态规划解法，当然会觉得牛逼而不可及了。</p><p>当然，见的多了，思考多了，是可以一步写出非递归的动态规划解法的。任何技巧都需要练习，我们先遵循这个流程走，算法设计也就这些套路，除此之外，真的没啥高深的。</p><p>以下，先通过两个个比较简单的例子：斐波那契和凑零钱问题，揭开动态规划的神秘面纱，描述上述三个流程。后续还会写几篇文章探讨如何使用动态规划技巧解决比较复杂的经典问题。</p><p>首先，第一个快被举烂了的例子，斐波那契数列。请读者不要嫌弃这个例子简单，因为简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙。后续，困难的例子有的是。</p><h2 id="步骤一、暴力的递归算法"><a href="#步骤一、暴力的递归算法" class="headerlink" title="步骤一、暴力的递归算法"></a>步骤一、暴力的递归算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。</p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。<br></p><p>这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p><strong>递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。</strong></p><p>子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><h2 id="步骤二、带备忘录的递归解法"><a href="#步骤二、带备忘录的递归解法" class="headerlink" title="步骤二、带备忘录的递归解法"></a>步骤二、带备忘录的递归解法</h2><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    <span class="comment">// 未被计算过</span></span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p>递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。</p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) … f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><h2 id="步骤三、动态规划"><a href="#步骤三、动态规划" class="headerlink" title="步骤三、动态规划"></a>步骤三、动态规划</h2><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「动态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><p>为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程</strong>，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，以上旨在演示算法设计螺旋上升的过程。当问题中要求求一个最优解或在代码中看到循环和 max、min 等函数时，十有八九，需要动态规划大显身手。</p><p>下面，看第二个例子，<strong>凑零钱问题</strong>，有了上面的详细铺垫，这个问题会很快解决。</p><p>题目：给你 k 种面值的硬币，面值分别为 c1, c2 … ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。</p><p>比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 11 = 5 + 5 + 1 。下面走流程。</p><h2 id="CoinChange问题"><a href="#CoinChange问题" class="headerlink" title="CoinChange问题"></a>CoinChange问题</h2><h3 id="一、暴力解法"><a href="#一、暴力解法" class="headerlink" title="一、暴力解法"></a>一、暴力解法</h3><p>首先是最困难的一步，写出状态转移方程，这个问题比较好写：</p>]其实，这个方程就用到了「最优子结构」性质：**原问题的解由子问题的最优解构成**。即 f(11) 由 f(10), f(9), f(6) 的最优解转移而来。记住，**要符合「最优子结构」，子问题间必须互相独立**。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高...... 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高...... 当然，最终就是你每门课都是满分，这就是最高的总成绩。得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。回到凑零钱问题，显然子问题之间没有相互制约，而是互相独立的。所以这个状态转移方程是可以得到正确答案的。之后就没啥难点了，按照方程写暴力递归算法即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="comment">// 金额不可达</span></span><br><span class="line">        <span class="keyword">if</span> (amount - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> subProb = coinChange(coins, amount - coin);</span><br><span class="line">        <span class="comment">// 子问题无解</span></span><br><span class="line">        <span class="keyword">if</span> (subProb == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans = min(ans, subProb + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画出递归树：</p><p>时间复杂度分析：子问题总数 x 每个子问题的时间。子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 <script type="math/tex">O(k\*n^k)</script>，指数级别。</p><h3 id="二、带备忘录的递归算法"><a href="#二、带备忘录的递归算法" class="headerlink" title="二、带备忘录的递归算法"></a>二、带备忘录的递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 备忘录初始化为 -2</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo(amount + <span class="number">1</span>, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> helper(coins, amount, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (memo[amount] != <span class="number">-2</span>) <span class="keyword">return</span> memo[amount];</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="comment">// 金额不可达</span></span><br><span class="line">        <span class="keyword">if</span> (amount - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> subProb = helper(coins, amount - coin, memo);</span><br><span class="line">        <span class="comment">// 子问题无解</span></span><br><span class="line">        <span class="keyword">if</span> (subProb == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans = min(ans, subProb + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录本轮答案</span></span><br><span class="line">    memo[amount] = (ans == INT_MAX) ? <span class="number">-1</span> : ans;</span><br><span class="line">    <span class="keyword">return</span> memo[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p><h3 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="三、动态规划"></a>三、动态规划</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins)</span><br><span class="line">            <span class="keyword">if</span> (coin &lt;= i)</span><br><span class="line">                dp[i] = min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。<strong>算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</strong></p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在LeetCode的&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;322题题解&lt;/a&gt;中看到一篇动态规划的详解，讲的很清楚，转载记录下&lt;/p&gt;
&lt;p&gt;转自：&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode动态规划套路详解&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Learning" scheme="https://catchdream.me/categories/Learning/"/>
    
    
      <category term="Learning" scheme="https://catchdream.me/tags/Learning/"/>
    
      <category term="DP" scheme="https://catchdream.me/tags/DP/"/>
    
      <category term="Reprint" scheme="https://catchdream.me/tags/Reprint/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-124-Binary Tree Maximum Path Sum</title>
    <link href="https://catchdream.me/2019/06/13/LeetCode-124-Binary-Tree-Maximum-Path-Sum/"/>
    <id>https://catchdream.me/2019/06/13/LeetCode-124-Binary-Tree-Maximum-Path-Sum/</id>
    <published>2019-06-13T15:41:23.000Z</published>
    <updated>2019-06-13T16:15:05.800Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>落了好多题没记录了，而且因为刷的是专项，没有按照顺序了，所以….顺序很乱，这阵子就先这样把，后面夏令营结束再按照顺序来，把以前的慢慢补上。</p><p>LeetCode中国还是挺方便的，加载速度比原版的快很多，而且可以中英文切换。</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/submissions/" target="_blank" rel="noopener">Problem</a></h2><p>Given a non-empty binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p><p>求二叉树最大的路径和，任意节点到任意节点的最大路径和</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>[1,2,3]<br><strong>Output:</strong>6<br><strong>Input:</strong>[-10,9,20,null,null,15,7]<br><strong>Output:</strong>42</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>二叉树一般就是递归，这道题也很明显用递归，找到左子树、右子树的最大路径和，一共算了下，大概有一下几种情况</li></ul><ol><li>左子树路径和加根节点值最大</li><li>右子树路径和加根节点值最大</li><li>左右子树路径和都是负数，所以单独的根节点值最大</li><li>左右子树路径和加上根节点值最大，<script type="math/tex">如果左右子树路径和都非负，那肯定就得加上嘛</script></li></ol><p>这里之所以不把左子树路径和与右子树路径和单独列出来，是因为递归到左右子树的时候就相当于判断过来</p><p>按照这样的思路，就可以想到办法了，求左右子树路径和，然后找到最大的一边，加上根节点值，这是前三种情况，再和第四种情况：三者之和 比较，就可以得到最后的结果resSum，然后和全局遍历maxSum比较：<script type="math/tex">maxSum = max(maxSum, resSum)</script></p><ul><li>改进的方法是，判断左右子树的路径和是否小于0，如果小于0，那肯定就不走这边，所以令其为0，最后就变成了一种情况，就是上面的第四种，只要把三者相加，再和全局变量maxSum比较就可以</li></ul><p>解释下，如果某一边大于0，那肯定要加上，如果小于0，不走那边就相当于加上0，就可以</p><p>但是最后的结果发现，虽然第二种办法，将四种情况缩成了一种情况，但是似乎时间会花的更多。第一种情况是32ms，第二种是40ms+。</p><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>递归，第一种解法，判断四种情况的，32ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxSum;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        maxSum = root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> rootGain = maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftGain = maxGain(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightGain = maxGain(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> rootGain = max(leftGain, rightGain)+root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> newPathGain = leftGain + rightGain + root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> resGain = max(newPathGain, rootGain);</span><br><span class="line">        <span class="keyword">if</span>(resGain &gt; maxSum)</span><br><span class="line">            maxSum = resGain;</span><br><span class="line">        <span class="keyword">if</span>(rootGain&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> rootGain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="C-Codes-1"><a href="#C-Codes-1" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>第二种解法，合并成一种情况的，44ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxSum;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        maxSum = root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> rootGain = maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftGain = max(maxGain(root-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightGain = max(maxGain(root-&gt;right), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> newPathGain = leftGain + rightGain + root-&gt;val;</span><br><span class="line">        maxSum = max(newPathGain, maxSum);</span><br><span class="line">        <span class="keyword">return</span> max(leftGain, rightGain)+root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>二叉树一般用递归就好了，查找还是啥操作的，一般递归+剪枝就可以，往这方向想 </li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;落了好多题没记录了，而且因为刷的是专项，没有按照顺序了，所以….顺序很乱，这阵子就先这样把，后面夏令营结束再按照顺序来，把以前的慢慢补上。&lt;/p&gt;
&lt;p&gt;LeetCode中国还是挺方便的，加载速度比原版的快很多，而且可以中英文切换。&lt;/p&gt;
&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a non-empty binary tree, find the maximum path sum.&lt;/p&gt;
&lt;p&gt;For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.&lt;/p&gt;
&lt;p&gt;求二叉树最大的路径和，任意节点到任意节点的最大路径和&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;[1,2,3]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;6&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt;[-10,9,20,null,null,15,7]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;42&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Hard" scheme="https://catchdream.me/tags/Hard/"/>
    
      <category term="DP" scheme="https://catchdream.me/tags/DP/"/>
    
      <category term="Recursive" scheme="https://catchdream.me/tags/Recursive/"/>
    
      <category term="BinaryTree" scheme="https://catchdream.me/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-125-Valid Palindrome</title>
    <link href="https://catchdream.me/2019/06/02/LeetCode-125-Valid-Palindrome/"/>
    <id>https://catchdream.me/2019/06/02/LeetCode-125-Valid-Palindrome/</id>
    <published>2019-06-01T16:55:08.000Z</published>
    <updated>2019-06-13T16:15:18.880Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">Problem</a></h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>“A man, a plan, a canal: Panama”<br><strong>Output:</strong>true</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>如果是单纯的回文串验证，那很简单，很多种方法</li><li>可以直接用函数将字符串逆序作比较</li><li>可以用两个指针指向头和尾，逐个字符比较</li><li>这道题因为还有空格，标点符号，大小写的问题，需要简单的处理下</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>8ms，超99%</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//全部变成小写并去掉非数字和字符的</span></span><br><span class="line">        transform(s.begin(),s.end(),s.begin(),::<span class="built_in">tolower</span>);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((s[i]&gt;=<span class="string">'0'</span> &amp;&amp; s[i]&lt;=<span class="string">'9'</span>) || (s[i]&gt;=<span class="string">'a'</span> &amp;&amp; s[i]&lt;=<span class="string">'z'</span>)) </span><br><span class="line">                res+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.empty()) <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=res.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;res.length() &amp;&amp; r&gt;=<span class="number">0</span> &amp;&amp; l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[l]==res[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info"><p>C++里面没有直接对字符串进行全部转换大写或者小写的方法<br>可以用<code>transform(s.begin(),s.end(),s.begin(),::tolower)</code><br>更多方法可以进行百度，如果懒得找也可以自己遍历字符修改大小写</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>要注意的就是字符串的预处理，并且处理之后如果是空串要返回true </li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.&lt;/p&gt;
&lt;p&gt;Note: For the purpose of this problem, we define empty string as valid palindrome.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;“A man, a plan, a canal: Panama”&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;true&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Easy" scheme="https://catchdream.me/tags/Easy/"/>
    
      <category term="String" scheme="https://catchdream.me/tags/String/"/>
    
      <category term="Palindrome" scheme="https://catchdream.me/tags/Palindrome/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-088-Merge Sorted Array</title>
    <link href="https://catchdream.me/2019/06/02/LeetCode-088-Merge-Sorted-Array/"/>
    <id>https://catchdream.me/2019/06/02/LeetCode-088-Merge-Sorted-Array/</id>
    <published>2019-06-01T16:40:13.000Z</published>
    <updated>2019-06-13T16:14:38.937Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">Problem</a></h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p><p><strong>Note:</strong> </p><ul><li>The number of elements initialized in nums1 and nums2 are m and n respectively.</li><li>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</li></ul><p>合并两个有序数组，合并到第一个数组里</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br><strong>Output:</strong><br>[1,2,2,3,5,6]</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>简单题，所以可以直接暴力求解</li><li>先把第一个数组备份到tmp，然后对tmp和第二个数组进行合并，结果放到nums1里面就行</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>12ms，超90%，大部分人都是这个时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            tmp.push_back(nums1[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>, i, j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;m &amp;&amp; j&lt;n;cnt++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]&lt;nums2[j])&#123;</span><br><span class="line">                nums1[cnt]=tmp[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[cnt]=nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m) nums1[cnt++]=tmp[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n) nums1[cnt++]=nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果是多个链表合并，不是这种有序数组两个合并的，可以看另一个题目，网站搜索合并多个链表</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of elements initialized in nums1 and nums2 are m and n respectively.&lt;/li&gt;
&lt;li&gt;You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合并两个有序数组，合并到第一个数组里&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nums1 = [1,2,3,0,0,0], m = 3&lt;br&gt;nums2 = [2,5,6],       n = 3&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;br&gt;[1,2,2,3,5,6]&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Easy" scheme="https://catchdream.me/tags/Easy/"/>
    
      <category term="Array" scheme="https://catchdream.me/tags/Array/"/>
    
      <category term="Merge" scheme="https://catchdream.me/tags/Merge/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-240-Search a 2D Matrix II</title>
    <link href="https://catchdream.me/2019/06/02/LeetCode-240-Search-a-2D-Matrix-II/"/>
    <id>https://catchdream.me/2019/06/02/LeetCode-240-Search-a-2D-Matrix-II/</id>
    <published>2019-06-01T16:29:32.000Z</published>
    <updated>2019-06-13T16:16:05.634Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">Problem</a></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><p>简单点说就是二维数组，从左向右递增，从上向下递增，然后查找输入的数组，要求高效</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br><strong>Output:</strong><br>Given target = 5, return true.<br>Given target = 20, return false.</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>如果是<script type="math/tex">O(n)</script>可能不行，毕竟要高效的算法，这里从数组的结构入手</li><li>以右上角为起点进行查找，如果比它大，就向下，如果比它小，就向左，一直找到边界位置</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>用时108ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="comment">//边界条件就是col&gt;=0 &amp;&amp; row&lt;n</span></span><br><span class="line">        <span class="keyword">while</span>(col&gt;=<span class="number">0</span> &amp;&amp; row&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col]&gt;target)</span><br><span class="line">                col--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col]&lt;target)</span><br><span class="line">                row++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对于这种排序好结构很明显的，尽量从结构上入手，找特点，而不是暴力解</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-a-2d-matrix-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Integers in each row are sorted in ascending from left to right.&lt;/li&gt;
&lt;li&gt;Integers in each column are sorted in ascending from top to bottom.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单点说就是二维数组，从左向右递增，从上向下递增，然后查找输入的数组，要求高效&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[&lt;br&gt;  [1,   4,  7, 11, 15],&lt;br&gt;  [2,   5,  8, 12, 19],&lt;br&gt;  [3,   6,  9, 16, 22],&lt;br&gt;  [10, 13, 14, 17, 24],&lt;br&gt;  [18, 21, 23, 26, 30]&lt;br&gt;]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;br&gt;Given target = 5, return true.&lt;br&gt;Given target = 20, return false.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Medium" scheme="https://catchdream.me/tags/Medium/"/>
    
      <category term="Matrix" scheme="https://catchdream.me/tags/Matrix/"/>
    
      <category term="Search" scheme="https://catchdream.me/tags/Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-136-Single Number</title>
    <link href="https://catchdream.me/2019/05/26/LeetCode-136-Single-Number/"/>
    <id>https://catchdream.me/2019/05/26/LeetCode-136-Single-Number/</id>
    <published>2019-05-25T16:57:09.000Z</published>
    <updated>2019-06-13T16:15:29.770Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到有算法面试集锦，刷点题，刚开始刷，前面都是简单题，随便看看了</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">Problem</a></h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p><p><strong>Note:</strong><br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>[2,2,1]<br><strong>Output:</strong>1</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>刚开始就是向简单的遍历一遍，用map存出现次数，但是要<script type="math/tex">O(1)</script> 的空间复杂度，所以不可以</li><li>然后想到排序，排序完找，但是要线性时间复杂度。。。</li><li>最后是用异或的方法，因为题目说的是，只有一个出现一次，其他的全部出现两次</li><li>两个相同的数异或（XOR），结果为0，0和0异或当然还是0，然后就剩下了单独的一个数字，0和非0数异或等于非0数本身</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>时间复杂度<script type="math/tex">O(n)</script>，空间复杂度<script type="math/tex">O(1)</script></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            res = res^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>注意题目细节，每个重复的数字都是出现两次 </li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;看到有算法面试集锦，刷点题，刚开始刷，前面都是简单题，随便看看了&lt;/p&gt;
&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/single-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a non-empty array of integers, every element appears twice except for one. Find that single one.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;[2,2,1]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;1&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://catchdream.me/tags/Math/"/>
    
      <category term="Easy" scheme="https://catchdream.me/tags/Easy/"/>
    
      <category term="Xor" scheme="https://catchdream.me/tags/Xor/"/>
    
      <category term="Linear" scheme="https://catchdream.me/tags/Linear/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-026-Remove Duplicates from Sorted Array</title>
    <link href="https://catchdream.me/2019/05/26/LeetCode-026-Remove-Duplicates-from-Sorted-Array/"/>
    <id>https://catchdream.me/2019/05/26/LeetCode-026-Remove-Duplicates-from-Sorted-Array/</id>
    <published>2019-05-25T16:56:26.000Z</published>
    <updated>2019-06-13T16:14:23.173Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">Problem</a></h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>[1,1,2]<br><strong>Output:</strong>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the returned length.</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>简单说就是去掉<strong>排好序的</strong>重复元素的嘛，然后要求空间复杂度<script type="math/tex">O(1)</script></li><li>利用双指针的思想，第一个指针指向排好序的最后一个元素，第二个指针指向当前的元素</li><li>如果当前元素不等于第一个指针指向的元素，那第一个指针自增，并赋值当前元素值</li><li>还有一种也能过的本办法，已经排序好了，所以遇到一个重复的删除一个就行，不过时间会花的很多</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>双指针法，时间复杂度是<script type="math/tex">O(n)</script>，花了32ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pre指向无重复排好序的最后一个位置</span></span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[pre])&#123;</span><br><span class="line">                pre++;</span><br><span class="line">                nums[pre]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="C-Codes-1"><a href="#C-Codes-1" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>暴力删除法，时间复杂度<script type="math/tex">O(n)</script>，用时252ms<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>双指针很多时候都是能用上的，特别是就地算法，或者查找、排序等算法 </li><li>简单题就不写Py的版本了</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;[1,1,2]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the returned length.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Easy" scheme="https://catchdream.me/tags/Easy/"/>
    
      <category term="Array" scheme="https://catchdream.me/tags/Array/"/>
    
      <category term="Duplicates" scheme="https://catchdream.me/tags/Duplicates/"/>
    
      <category term="Sort" scheme="https://catchdream.me/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-169-Majority Element</title>
    <link href="https://catchdream.me/2019/05/26/LeetCode-169-Majority-Element/"/>
    <id>https://catchdream.me/2019/05/26/LeetCode-169-Majority-Element/</id>
    <published>2019-05-25T16:55:31.000Z</published>
    <updated>2019-06-13T16:15:44.984Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">Problem</a></h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>[3,2,3]<br><strong>Output:</strong>3<br><strong>Input:</strong>[2,2,1,1,1,2,2]<br><strong>Output:</strong>2</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>找众数嘛，只要记录下来他们每个出现的次数就好了啊</li><li>用map存放每个数字出现的次数，然后遇到比n/2.0大的就return</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>时间复杂度<script type="math/tex">O(n)</script>,用时32ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mymap.count(nums[i])==<span class="number">1</span>)</span><br><span class="line">                mymap[nums[i]] = mymap[nums[i]]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mymap[nums[i]] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mymap[nums[i]]&gt;n/<span class="number">2.0</span>)&#123;</span><br><span class="line">                res = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>简单题就不写py版本了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>map真好用。。真香</li><li>数据量特别大的时候，可以用hash_map</li><li>map的查找方式是二分查找，如果是100万条记录，最多也只要20次的string.compare的比较，200万条记录，也只要用21次的比较</li><li>如果想要在如此大的记录量下，只用一两次的string.compare就找到记录，那就要用hash_map</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/majority-element/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.&lt;/p&gt;
&lt;p&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;[3,2,3]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;3&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt;[2,2,1,1,1,2,2]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;2&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://catchdream.me/tags/Math/"/>
    
      <category term="Easy" scheme="https://catchdream.me/tags/Easy/"/>
    
      <category term="Map" scheme="https://catchdream.me/tags/Map/"/>
    
      <category term="Majority" scheme="https://catchdream.me/tags/Majority/"/>
    
  </entry>
  
  <entry>
    <title>C++优先级队列</title>
    <link href="https://catchdream.me/2019/05/23/C-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <id>https://catchdream.me/2019/05/23/C-优先级队列/</id>
    <published>2019-05-23T05:42:24.000Z</published>
    <updated>2019-05-23T06:25:26.201Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写LeetCode的时候学了优先级队列，这里总结一下STL中优先级队列的使用和实现</p></div><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>优先级队列也是队列的一种，FIFO结构，但是和普通的队列不同的是有一个优先级的权重</p><p>优先级队列有两种，一种是最小优先队列，值小的优先级越大，另一种是最大优先队列，值大的优先级越大</p><p>头文件： “queue.h”, “functional.h”</p><p>插入和删除操作复杂度都是<script type="math/tex">O(lgn)</script></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;T&gt; pq;</span><br><span class="line">std::priority_queue&lt;T, std::vector&lt;T&gt;, cmp&gt; pq;</span><br></pre></td></tr></table></figure></p><p><strong>第一种构造函数：</strong></p><ul><li>传入一个基本类型或者自定义类，自定义类要重载<script type="math/tex"><</script>符号</li></ul><p><strong>第二种构造函数：</strong><br>参数介绍：</p><ol><li>是队列中元素的种类，可以是自定义的也可以是基本类型，默认是int</li><li>第二个是容纳优先级队列的容器，只需要知道默认是vector就好，使用的时候也是用vector</li><li>这个是最重要的参数，支持一个比较函数，默认是less，队列是最大优先队列。</li></ol><p>第三个参数有三种情况介绍：</p><ol><li>自定义比较结构，使用结构体，<strong>注意返回值！！</strong>，最小优先队列是大于</li><li>使用默认的类型时用less()或者greater()</li><li>使用自定义类的时候重载<script type="math/tex"><</script>符号</li></ol><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ol><li>q.empty(): 如果队列为空，则返回true，否则返回false</li><li>q.size():  返回队列中元素的个数</li><li>q.pop():   删除队首元素，但不返回其值</li><li>q.top():   返回具有最高优先级的元素值，最大优先队列找最大的元素，最小优先队列找最小的，但不删除该元素</li><li>q.push(item): 在基于优先级的适当位置插入新元素</li></ol><h3 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h3><p>注意这不是一个完整的C++代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含头文件并使用std命名空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种构造函数，采用默认优先级构造队列</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种构造函数，这里使用基本的int类型，如果看其他类型，请看LeetCode 23题代码</span></span><br><span class="line"><span class="comment">//自定义比较结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp1</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;<span class="comment">//最小值优先</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp1&gt;que1;<span class="comment">//最小值优先</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;que3;<span class="comment">//注意“&gt;&gt;”会被认为错误，greater在functional头文件中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据结构并重载小于操作符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">number1</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> number1 &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x&gt;a.x;<span class="comment">//最小值优先</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;number1&gt;que5; <span class="comment">//最小优先级队列</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"采用默认优先关系:/n(priority_queue&lt;int&gt;que;)/n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Queue 0:/n"</span>);</span><br><span class="line"><span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que.top());</span><br><span class="line">    que.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>引用博客：<a href="https://www.cnblogs.com/luoxn28/p/5616101.html" target="_blank" rel="noopener">优先队列原理与实现</a><br>推荐结合另一篇博客: <a href="https://blog.csdn.net/xiajun07061225/article/details/8556786" target="_blank" rel="noopener">【STL学习】优先级队列Priority Queue详解与C++编程实现</a><br>可以看这两篇博客了解插入和删除的原理，第一篇博客有图比较清楚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package priorityheap;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 优先队列类（最大优先队列）</span><br><span class="line"> */</span><br><span class="line">public class PriorityHeap &#123;</span><br><span class="line"></span><br><span class="line">    // ------------------------------ Instance Variables</span><br><span class="line"></span><br><span class="line">    private int[] arr;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    // ------------------------------ Constructors</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 优先队列数组默认大小为64</span><br><span class="line">     */</span><br><span class="line">    public PriorityHeap() &#123;</span><br><span class="line">        this(64);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PriorityHeap(int initSize) &#123;</span><br><span class="line">        if (initSize &lt;= 0) &#123;</span><br><span class="line">            initSize = 64;</span><br><span class="line">        &#125;</span><br><span class="line">        this.arr = new int[initSize];</span><br><span class="line">        this.size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ------------------------------ Public methods</span><br><span class="line"></span><br><span class="line">    public int max() &#123;</span><br><span class="line">        return this.arr[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int maxAndRemove() &#123;</span><br><span class="line">        int t = max();</span><br><span class="line"></span><br><span class="line">        this.arr[0] = this.arr[--size];</span><br><span class="line">        sink(0, this.arr[0]);</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void add(int data) &#123;</span><br><span class="line">        resize(1);</span><br><span class="line">        this.arr[size++] = data;</span><br><span class="line">        pop(size - 1, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ------------------------------ Private methods</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key下沉方法</span><br><span class="line">     */</span><br><span class="line">    private void sink(int i, int key) &#123;</span><br><span class="line">        while (2 * i &lt;= this.size - 1) &#123;</span><br><span class="line">            int child = 2 * i;</span><br><span class="line">            if (child &lt; this.size - 1 &amp;&amp; this.arr[child] &lt; this.arr[child + 1]) &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.arr[i] &gt;= this.arr[child]) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(i, child);</span><br><span class="line">            i = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key上浮方法</span><br><span class="line">     */</span><br><span class="line">    private void pop(int i, int key) &#123;</span><br><span class="line">        while (i &gt; 0) &#123;</span><br><span class="line">            int parent = i / 2;</span><br><span class="line">            if (this.arr[i] &lt;= this.arr[parent]) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(i, parent);</span><br><span class="line">            i = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重新调整数组大小</span><br><span class="line">     */</span><br><span class="line">    private void resize(int increaseSize) &#123;</span><br><span class="line">        if ((this.size + increaseSize) &gt; this.arr.length) &#123;</span><br><span class="line">            int newSize = (this.size + increaseSize) &gt; 2 * this.arr.length ? (this.size + increaseSize) : 2 * this.arr.length;</span><br><span class="line">            int[] t = this.arr;</span><br><span class="line"></span><br><span class="line">            this.arr = Arrays.copyOf(t, newSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Swaps arr[a] with arr[b].</span><br><span class="line">     */</span><br><span class="line">    private void swap(int a, int b) &#123;</span><br><span class="line">        int t = this.arr[a];</span><br><span class="line">        this.arr[a] = this.arr[b];</span><br><span class="line">        this.arr[b] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;写LeetCode的时候学了优先级队列，这里总结一下STL中优先级队列的使用和实现&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Learning" scheme="https://catchdream.me/categories/Learning/"/>
    
    
      <category term="C++" scheme="https://catchdream.me/tags/C/"/>
    
      <category term="Queue" scheme="https://catchdream.me/tags/Queue/"/>
    
      <category term="PriorityQueue" scheme="https://catchdream.me/tags/PriorityQueue/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-023-Merge k Sorted Lists</title>
    <link href="https://catchdream.me/2019/05/23/LeetCode-023-Merge-k-Sorted-Lists/"/>
    <id>https://catchdream.me/2019/05/23/LeetCode-023-Merge-k-Sorted-Lists/</id>
    <published>2019-05-23T05:10:02.000Z</published>
    <updated>2019-06-13T16:14:06.343Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">Problem</a></h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>[<br>　　1-&gt;4-&gt;5,<br>　　1-&gt;3-&gt;4,<br>　　2-&gt;6<br>]<br><strong>Output:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>相对上一题难度加大了一点，但是如果按照上一题的思路也是可以做的，就是时间复杂度会有点高</li><li>这里介绍两种方法，第一种就是类似上一题的解法，每次循环找到所有链表中最小的头结点，然后改变指针指向，并不新建节点，中间有个坑是测试用例中会有空的链表，要注意处理下。每次加一个节点，加的时候遍历所有链表，所以时间复杂度是<script type="math/tex">O(n \times k)</script>,n是节点总数，k是链表数</li><li>第二种方法是使用优先级队列，先将所有链表加入队列中，每次从队列中找到最小的节点，然后也是找n个节点，相对上一种方法是在<script type="math/tex">O(n \times k)</script>的k这里进行了优化，因为优先级队列存取是log()级别，因此时间复杂度是<script type="math/tex">O(n \times log(k))</script></li><li>还想到一种方法是迭代，用上一题的方法进行两两合并，没有实现这种方法，看了题解有分治法，使用递归进两两合并</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>就地改变链表指针指向，时间复杂度<script type="math/tex">O(n \times k)</script></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *pre = res;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(lists.size()!=<span class="number">0</span>)&#123; </span><br><span class="line">            <span class="comment">//确保lists[0]非NULL</span></span><br><span class="line">            <span class="keyword">while</span>(lists.size()&gt;<span class="number">0</span> &amp;&amp; lists[min]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                lists.erase(lists.begin()+min);</span><br><span class="line">                min = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lists.size()==<span class="number">0</span>) <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lists[i]==<span class="literal">NULL</span>) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(lists[i]-&gt;val&lt;lists[min]-&gt;val)</span><br><span class="line">                    min = i;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = lists[min];</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            lists[min] = lists[min]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用优先级队列进行每轮插入最小的节点，时间复杂度为<script type="math/tex">O(n \times log(k))</script></p><p>这里使用最小优先队列，最小的值优先级最大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义优先级队列比较结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//建立优先级队列，这里是最小优先队列，最小的值优先级最大</span></span><br><span class="line">        priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* <span class="built_in">list</span> : lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">list</span>!=<span class="literal">NULL</span>) pq.push(<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pq.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            p-&gt;next = pq.top();<span class="comment">//获取优先级最高的元素，即数字最小的</span></span><br><span class="line">            pq.pop();<span class="comment">//删除队首元素</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>) pq.push(p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>分治法，使用递归两两合并，最终的链表等于合并好的前半部分加上合并好的后半部分，对前半部分在进行半部分和半部分的合并。</p><p>下面贴一下题解的代码，Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        ListNode l1 = merge(lists, left, mid);</span><br><span class="line">        ListNode l2 = merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>这里使用方法二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        head = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">            <span class="keyword">if</span> lists[i] :</span><br><span class="line">                heapq.heappush(head, (lists[i].val, i))</span><br><span class="line">                lists[i] = lists[i].next</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            val, idx = heapq.heappop(head)</span><br><span class="line">            p.next = ListNode(val)</span><br><span class="line">            p = p.next</span><br><span class="line">            <span class="keyword">if</span> lists[idx]:</span><br><span class="line">                heapq.heappush(head, (lists[idx].val, idx))</span><br><span class="line">                lists[idx] = lists[idx].next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>合并多个链表相对上一题就是链表数变多之后的处理，可以用优先级队列加快节点的查找，也可以使用分治法，合并症各部分就是先合并前半部分和后半部分，再将这两个部分合在一起 </li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-k-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[&lt;br&gt;　　1-&amp;gt;4-&amp;gt;5,&lt;br&gt;　　1-&amp;gt;3-&amp;gt;4,&lt;br&gt;　　2-&amp;gt;6&lt;br&gt;]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="PriorityQueue" scheme="https://catchdream.me/tags/PriorityQueue/"/>
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Hard" scheme="https://catchdream.me/tags/Hard/"/>
    
      <category term="Merge" scheme="https://catchdream.me/tags/Merge/"/>
    
      <category term="List" scheme="https://catchdream.me/tags/List/"/>
    
      <category term="LinkedList" scheme="https://catchdream.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-021-Merge Two Sorted Lists</title>
    <link href="https://catchdream.me/2019/05/23/LeetCode-021-Merge-Two-Sorted-Lists/"/>
    <id>https://catchdream.me/2019/05/23/LeetCode-021-Merge-Two-Sorted-Lists/</id>
    <published>2019-05-22T16:28:14.000Z</published>
    <updated>2019-06-13T16:13:54.120Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="">Problem</a></h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p>简单说就是合并两个有序链表</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>Output:</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>第一种方法是新建一个链表，每次创建新的节点，不影响原始链表。在两个链表都非空的是比较结点值大小，将小的值作为新节点的值插入结果链表中，并移动指针。</li><li>第二种方法也挺简单，只是单纯的改变指针，就地合并，但是会影响原始链表。</li><li>Python使用的方法，递归，也是就地的，前面的较小的节点加上后面所有的排好序的节点就是要的结果</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>创建一个头结点，依次比较l1和l2的节点，逐个插入到新链表中，插入过程是创建了新的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = res;</span><br><span class="line">        ListNode *p1 = l1;</span><br><span class="line">        ListNode *p2 = l2;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">NULL</span> &amp;&amp; p2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val &gt; p2-&gt;val)&#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> ListNode(p2-&gt;val);</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> ListNode(p1-&gt;val);</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(p1-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(p2-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>这种方法也可以像方法一那样，创建一个头结点，然后比较l1和l2，依次改变两个链表的指针</p><p>我用了另一种就地方法，其中一个链表不变，另一个链表依次找到合适位置插入这个这个链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//p1: 结果链表头结点，指向较小的</span></span><br><span class="line">        <span class="comment">//p2: 另一个链表的头结点</span></span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode *p1, *p2;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            p1 = l1; p2 = l2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p1 = l2; p2 = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *prefix=p1, *res = p1;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//找到p2指向的节点第一次小于p1节点的位置，前插</span></span><br><span class="line">            <span class="keyword">while</span>(p1!=<span class="literal">NULL</span> &amp;&amp; p2-&gt;val &gt; p1-&gt;val)&#123;</span><br><span class="line">                prefix = prefix-&gt;next;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//p1到结尾</span></span><br><span class="line">            <span class="keyword">if</span>(p1==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                prefix-&gt;next = p2;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prefix-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">                prefix-&gt;next-&gt;next = p1;</span><br><span class="line">                prefix = prefix-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>递归的方法，每次保证递归返回的是较小的节点</p><p>这里用了交换l1和l2指针的方法，事实证明….不交换直接判断哪个小来调用递归时间少一点…佛了，交换是64ms，不交换是48ms…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span> l1.val&gt;l2.val: l1, l2 = l2, l1</span><br><span class="line">        l1.next = self.mergeTwoLists(l1.next,l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>链表的问题这里总结是两种方法，一种是迭代，一种是递归，迭代过程中要注意节点指针不要混乱了。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;
&lt;p&gt;简单说就是合并两个有序链表&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Easy" scheme="https://catchdream.me/tags/Easy/"/>
    
      <category term="Merge" scheme="https://catchdream.me/tags/Merge/"/>
    
      <category term="List" scheme="https://catchdream.me/tags/List/"/>
    
      <category term="LinkedList" scheme="https://catchdream.me/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-020-Valid Parentheses</title>
    <link href="https://catchdream.me/2019/05/22/LeetCode-020-Valid-Parentheses/"/>
    <id>https://catchdream.me/2019/05/22/LeetCode-020-Valid-Parentheses/</id>
    <published>2019-05-22T05:59:04.000Z</published>
    <updated>2019-06-13T16:13:38.203Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">Problem</a></h2><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>“()”<br><strong>Output:</strong> true<br><strong>Input:</strong>“[(])”<br><strong>Output:</strong> false</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>简单的利用栈，如果是左括号，就入栈，如果是右括号，就和栈顶匹配，相同，就让栈顶出栈，否则返回错误 ，这里用哈希表映射左右括号</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义栈和哈希表</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; chstack;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; mp;</span><br><span class="line">        mp[<span class="string">')'</span>]=<span class="string">'('</span>;</span><br><span class="line">        mp[<span class="string">']'</span>]=<span class="string">'['</span>;</span><br><span class="line">        mp[<span class="string">'&#125;'</span>]=<span class="string">'&#123;'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//左括号入栈</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span> || s[i]==<span class="string">'['</span> || s[i]==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                chstack.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右括号匹配栈顶</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(chstack.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(mp[s[i]]==chstack.top()) chstack.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果匹配完了栈为空，就是符合要求的</span></span><br><span class="line">        <span class="keyword">if</span>(chstack.empty())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        lookup = &#123;</span><br><span class="line">            <span class="string">"("</span>:<span class="string">")"</span>,</span><br><span class="line">            <span class="string">"["</span>:<span class="string">"]"</span>,</span><br><span class="line">            <span class="string">"&#123;"</span>:<span class="string">"&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> alp <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> alp <span class="keyword">in</span> lookup:</span><br><span class="line">                stack.append(alp)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> lookup[stack[<span class="number">-1</span>]] == alp:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>做过的题，简单的利用出栈入栈进行括号匹配 </li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.&lt;/p&gt;
&lt;p&gt;An input string is valid if:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Open brackets must be closed by the same type of brackets.&lt;/li&gt;
&lt;li&gt;Open brackets must be closed in the correct order.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note that an empty string is also considered valid.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;“()”&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; true&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt;“[(])”&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; false&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Easy" scheme="https://catchdream.me/tags/Easy/"/>
    
      <category term="String" scheme="https://catchdream.me/tags/String/"/>
    
      <category term="Stack" scheme="https://catchdream.me/tags/Stack/"/>
    
      <category term="Pair" scheme="https://catchdream.me/tags/Pair/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-017-Letter Combinations of a Phone Number</title>
    <link href="https://catchdream.me/2019/05/22/LeetCode-017-Letter-Combinations-of-a-Phone-Number/"/>
    <id>https://catchdream.me/2019/05/22/LeetCode-017-Letter-Combinations-of-a-Phone-Number/</id>
    <published>2019-05-22T05:48:56.000Z</published>
    <updated>2019-06-13T16:13:28.807Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">Problem</a></h2><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.<br>2：”abc”, 3-“def”, 4-“ghi”, 5-“jkl”, 6-“mno”, 7-“pqrs”, 8-“tuv”, 9-“wxyz”</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>“23”<br><strong>Output:</strong>[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>递归，当后面的全部完成了排列之后，前面的加上就是全部的排列方式，这里要记录前缀，到最后没有数字的时候，就添加前缀并返回</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:        </span><br><span class="line">    <span class="built_in">string</span> mapChar[<span class="number">10</span>] = &#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length()==<span class="number">0</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        recurDigit(digits,<span class="string">""</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurDigit</span><span class="params">(<span class="built_in">string</span> digits,<span class="built_in">string</span> prefix, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(digits==<span class="string">""</span>) &#123;</span><br><span class="line">            res.push_back(prefix);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> key = mapChar[digits[<span class="number">0</span>]-<span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">int</span> n = key.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            recurDigit(digits.substr(<span class="number">1</span>), prefix+key[i], res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>递归要处理好边界条件，这里是当digits为空的时候，就返回</li><li>这里用了记录前缀的方式，感觉也可以使用前面的加上后缀的方式，返回的时候返回字符，应该也可以</li><li>这题让我想到了全排列的解法</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/letter-combinations-of-a-phone-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.&lt;br&gt;2：”abc”, 3-“def”, 4-“ghi”, 5-“jkl”, 6-“mno”, 7-“pqrs”, 8-“tuv”, 9-“wxyz”&lt;/p&gt;
&lt;p&gt;A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;“23”&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Medium" scheme="https://catchdream.me/tags/Medium/"/>
    
      <category term="Map" scheme="https://catchdream.me/tags/Map/"/>
    
      <category term="Recursive" scheme="https://catchdream.me/tags/Recursive/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-016-3Sum Closest</title>
    <link href="https://catchdream.me/2019/05/22/LeetCode-016-3Sum-Closest/"/>
    <id>https://catchdream.me/2019/05/22/LeetCode-016-3Sum-Closest/</id>
    <published>2019-05-22T05:28:15.000Z</published>
    <updated>2019-06-13T16:13:18.983Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener">Problem</a></h2><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>Given array nums = [-1, 2, 1, -4], and target = 1.<br><strong>Output:</strong>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>还是基于上一道题，用三指针，在将向量排序后，第一个指针从前往后移动，后面两个指针一个指向第一个指针的后一个元素，另一个指向最后一个元素。记录和target相差最小的三数之和，每次比较target和当前三数之和，如果三数之和比target大，那就减小第三个指针位置，如果比target小，就增加第二个指针位置，相等就直接返回了。</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化为前三个的和与target的差</span></span><br><span class="line">        <span class="keyword">int</span> min_diff = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> l = i+<span class="number">1</span>, r = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="comment">//当前三个数和target的差</span></span><br><span class="line">                <span class="keyword">int</span> cur_diff = nums[i]+nums[l]+nums[r];</span><br><span class="line">                <span class="keyword">if</span>(target == cur_diff)<span class="keyword">return</span> target;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(target-cur_diff) &lt; <span class="built_in">abs</span>(target-min_diff))min_diff = cur_diff;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; cur_diff)l++;</span><br><span class="line">                <span class="keyword">if</span>(target &lt; cur_diff)r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = float(<span class="string">"inf"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right :</span><br><span class="line">                <span class="comment">#print(left,right)</span></span><br><span class="line">                cur = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> cur == target:<span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">if</span> abs(res-target) &gt; abs(cur-target):</span><br><span class="line">                    res = cur</span><br><span class="line">                <span class="keyword">if</span> cur &gt; target:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> cur &lt; target:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>基本办法和第15题一样，中间处理有点差别</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/3sum-closest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;Given array nums = [-1, 2, 1, -4], and target = 1.&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Medium" scheme="https://catchdream.me/tags/Medium/"/>
    
      <category term="Closest" scheme="https://catchdream.me/tags/Closest/"/>
    
      <category term="3Sum" scheme="https://catchdream.me/tags/3Sum/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-015-3Sum</title>
    <link href="https://catchdream.me/2019/05/19/LeetCode-015-3Sum/"/>
    <id>https://catchdream.me/2019/05/19/LeetCode-015-3Sum/</id>
    <published>2019-05-19T13:22:18.000Z</published>
    <updated>2019-06-13T16:13:07.697Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快半月没更新了，也没怎么刷题，家里有事情耽误了，后面一周又忙着别的，以后简单难度的题就直接略过了，加快进度，么得时间咯</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">Problem</a></h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong><br>The solution set must not contain duplicate triplets.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>nums = [-1, 0, 1, 2, -1, -4]<br><strong>Output:</strong>[ [-1, 0, 1], [-1, -1, 2] ]</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>暴力法，但是想想不优化的花<script type="math/tex">n^3</script>的复杂度还是算了，就算优化估计也难过</li><li>想了递归的方法，先固定一个数，问题变成找两个数和为第一个数的负数，然后再固定一个数，找最后一个，但是相当于也是<script type="math/tex">n^3</script>，想了用类似dp那样的优化，似乎也不行，数字只能用一次</li><li>最后的方法是，先选第一个数，然后找剩下的连个数，让三个数和为0，剩下的两个数找的时候优化一下，排序后一个从前一个从后找，具体看代码</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//先排序预处理，如果发现全都是大于0或者全小于0，或者少于三个元素，就返回</span></span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>||nums.front()&gt;<span class="number">0</span>||nums.back()&lt;<span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="comment">//很明显只需要找第一个数小于0的</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//这里记得要写i&gt;0，边界判断，容易丢</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//left自增，right自减</span></span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>, right = len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="number">0</span>)&#123;</span><br><span class="line">                    res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//如果出现数字相同跳过，注意边界条件：left &lt; right</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//很好理解，大于0说明正数太大，小于0说明负数太小</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tmp&gt;<span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tmp&lt;<span class="number">0</span>) left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> res[i] &gt; <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                cur_sum = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> cur_sum == <span class="number">0</span>:</span><br><span class="line">                    tmp = [nums[i],nums[left],nums[right]]</span><br><span class="line">                    res.append(tmp)</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right<span class="number">-1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> cur_sum &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>找符合条件的数的时候，双指针前后开始找很好用</li><li>边界条件判断很重要，条件语句要多想想，容易漏</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;快半月没更新了，也没怎么刷题，家里有事情耽误了，后面一周又忙着别的，以后简单难度的题就直接略过了，加快进度，么得时间咯&lt;/p&gt;
&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/3sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;The solution set must not contain duplicate triplets.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;nums = [-1, 0, 1, 2, -1, -4]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;[ [-1, 0, 1], [-1, -1, 2] ]&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Medium" scheme="https://catchdream.me/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-014-Longest Common Prefix</title>
    <link href="https://catchdream.me/2019/05/18/LeetCode-014-Longest-Common-Prefix/"/>
    <id>https://catchdream.me/2019/05/18/LeetCode-014-Longest-Common-Prefix/</id>
    <published>2019-05-18T04:55:53.000Z</published>
    <updated>2019-06-13T16:12:55.247Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一道简单题，看到腾讯50题里有，还是花点时间补上了，没想到简单题方法还这么多</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">Problem</a></h2><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>[“flower”,”flow”,”flight”]<br><strong>Output:</strong>“fl”</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>找公共前缀这个问题，比较简单的想法就是一个个比较嘛，最先想到的也是这种方法，以第一个字符串为基准，从前往后比较每个字符是否和后面的字符全部相等，如果有不等的，那肯定前面的就是最长的公共前缀了，如果都相等，那就继续比较后一个字符</li><li>另一种差不多的方法是从后往前，先比较最长的，再慢慢减小</li><li>优化的办法是二分查找，minLen作为最短字符串的长度，二分查找这个是否为最长公共前缀</li><li>题解中还有分治法，这个算法的思路来自于LCP操作的结合律。 我们可以发现： LCP(S1…Sn)=LCP(LCP(S1…Sk),LCP(Sk+1…Sn))，其中LCP(S1…Sn)是字符串[S1…Sn]的最长公共前缀</li><li>基于二分查找，更进一步是用字典树，详细的看题解把</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>第一种解法，最容易想到的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> prefix;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">0</span> || strs[<span class="number">0</span>].length()==<span class="number">0</span>)<span class="keyword">return</span> prefix;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs[<span class="number">0</span>].length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;strs.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[j].length()&lt;i+<span class="number">1</span> || strs[j][i]!=strs[<span class="number">0</span>][i])&#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(flag) prefix += strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>emm，简单题也有这么多种做法…</li><li>最长公共前缀可以1.遍历前缀，2.二分查找前缀，3.分治找前缀，4.字典树找前缀</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一道简单题，看到腾讯50题里有，还是花点时间补上了，没想到简单题方法还这么多&lt;/p&gt;
&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-prefix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;/p&gt;
&lt;p&gt;If there is no common prefix, return an empty string “”.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;[“flower”,”flow”,”flight”]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;“fl”&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Easy" scheme="https://catchdream.me/tags/Easy/"/>
    
      <category term="String" scheme="https://catchdream.me/tags/String/"/>
    
      <category term="Prefix" scheme="https://catchdream.me/tags/Prefix/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-013-Roman to Integer</title>
    <link href="https://catchdream.me/2019/05/01/LeetCode-013-Roman-to-Integer/"/>
    <id>https://catchdream.me/2019/05/01/LeetCode-013-Roman-to-Integer/</id>
    <published>2019-04-30T19:57:54.000Z</published>
    <updated>2019-06-13T16:12:45.133Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">Problem</a></h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br>Symbol　　　Value<br>I　　　　　　 1<br>V　　　　　　 5<br>X　　　　　　 10<br>L　　　　　　 50<br>C　　　　　　 100<br>D　　　　　　 500<br>M　　　　　　 1000</p><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9. </li><li>X can be placed before L (50) and C (100) to make 40 and 90. </li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>“III”<br><strong>Output:</strong>3</p><p><strong>Input:</strong>“IV”<br><strong>Output:</strong>4</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>想到两种方法，第一种是遍历字符串，判断每个字符和右边字符代表数字的大小，如果不小于右边的，就加上这个字符代表的数字，否则减去。遍历之前要建立字符对应数字的map，时间复杂度是O(n)</li><li>还有一种方法是遍历每种情况，然后从左向右查找字符串中的字符，并且记录出现的次数，最后加上次数乘以数字,时间复杂度也是O(n),但是比第一种会花更多时间，因为有无用的比较</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>第一种，遍历字符串，40ms，10.8MB<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; values;</span><br><span class="line">        values[<span class="string">'M'</span>]=<span class="number">1000</span>;</span><br><span class="line">        values[<span class="string">'D'</span>]=<span class="number">500</span>;</span><br><span class="line">        values[<span class="string">'C'</span>]=<span class="number">100</span>;</span><br><span class="line">        values[<span class="string">'L'</span>]=<span class="number">50</span>;</span><br><span class="line">        values[<span class="string">'X'</span>]=<span class="number">10</span>;</span><br><span class="line">        values[<span class="string">'V'</span>]=<span class="number">5</span>;</span><br><span class="line">        values[<span class="string">'I'</span>]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()<span class="number">-1</span>;i++)</span><br><span class="line">          values[s[i]]&gt;=values[s[i+<span class="number">1</span>]]?</span><br><span class="line">              res+=values[s[i]]:res-=values[s[i]];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//加上最后一位</span></span><br><span class="line">        res += values[s[s.length()<span class="number">-1</span>]];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>第二种，遍历每种情况，160ms，8.6MB<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> values[]=&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> chr[]=&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>, cnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.substr(pos,chr[i].length())==chr[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                pos+=chr[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">            res += values[i]*cnt;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>和C++相差不多，就不写了，比较简单</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>map真好用</li><li>尽量不要有没有用的比较判断之类的</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/roman-to-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.&lt;br&gt;Symbol　　　Value&lt;br&gt;I　　　　　　 1&lt;br&gt;V　　　　　　 5&lt;br&gt;X　　　　　　 10&lt;br&gt;L　　　　　　 50&lt;br&gt;C　　　　　　 100&lt;br&gt;D　　　　　　 500&lt;br&gt;M　　　　　　 1000&lt;/p&gt;
&lt;p&gt;For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.&lt;/p&gt;
&lt;p&gt;Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I can be placed before V (5) and X (10) to make 4 and 9. &lt;/li&gt;
&lt;li&gt;X can be placed before L (50) and C (100) to make 40 and 90. &lt;/li&gt;
&lt;li&gt;C can be placed before D (500) and M (1000) to make 400 and 900.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;“III”&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;“IV”&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;4&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://catchdream.me/tags/Math/"/>
    
      <category term="Easy" scheme="https://catchdream.me/tags/Easy/"/>
    
      <category term="String" scheme="https://catchdream.me/tags/String/"/>
    
      <category term="Integer" scheme="https://catchdream.me/tags/Integer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-012-Integer to Roman</title>
    <link href="https://catchdream.me/2019/04/30/LeetCode-012-Integer-to-Roman/"/>
    <id>https://catchdream.me/2019/04/30/LeetCode-012-Integer-to-Roman/</id>
    <published>2019-04-30T01:28:41.000Z</published>
    <updated>2019-06-13T16:12:33.110Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/integer-to-roman/" target="_blank" rel="noopener">Problem</a></h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><blockquote><p>Symbol　　　Value<br>I　　　　　　1<br>V　　　　　　5<br>X　　　　　　10<br>L　　　　　　50<br>C　　　　　　100<br>D　　　　　　500<br>M　　　　　　1000</p></blockquote><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9. </li><li>X can be placed before L (50) and C (100) to make 40 and 90. </li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul><p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong> 3<br><strong>Output:</strong> “III”<br><strong>Input:</strong> 4<br><strong>Output:</strong> “IV”<br><strong>Input:</strong> 58<br><strong>Output:</strong> “LVIII”<br><strong>Input:</strong> 1994<br><strong>Output:</strong> “MCMXCIV”</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>这题，题目比较长，可能容易晕，但是很好理解，就是把一个整数转成罗马数字，给出了每个字符表示的大小</li><li>简单的办法就是从最大值开始，整除得到这个字母的个数，求模得到剩余的数字，然后再次对较小的整除、求模一直到“I”，就是1为止，过程中把字符加到结果字符串上</li><li>这里由于有对应关系，所以C++中用两个数组表示对应关系，也可以用map<string,int>表示，Python直接用字典就可以</string,int></li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> values[]=&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> chr[]=&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">13</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num/values[i];j++)</span><br><span class="line">                res += chr[i];</span><br><span class="line">            num %= values[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        values = &#123;<span class="string">"M"</span>:<span class="number">1000</span>,<span class="string">"CM"</span>:<span class="number">900</span>,<span class="string">"D"</span>:<span class="number">500</span>,<span class="string">"CD"</span>:<span class="number">400</span>,<span class="string">"C"</span>:<span class="number">100</span>,<span class="string">"XC"</span>:<span class="number">90</span>,<span class="string">"L"</span>:<span class="number">50</span>,<span class="string">"XL"</span>:<span class="number">40</span>,<span class="string">"X"</span>:<span class="number">10</span>,<span class="string">"IX"</span>:<span class="number">9</span>,<span class="string">"V"</span>:<span class="number">5</span>,<span class="string">"IV"</span>:<span class="number">4</span>,<span class="string">"I"</span>:<span class="number">1</span>&#125;</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> values.items():</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(num//value):</span><br><span class="line">                res += key</span><br><span class="line">            num %= value                </span><br><span class="line">        <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>有对应关系的时候，没必要写很多重复代码，用map或者两个列表对应起来，遍历一遍就可以 </li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/integer-to-roman/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Symbol　　　Value&lt;br&gt;I　　　　　　1&lt;br&gt;V　　　　　　5&lt;br&gt;X　　　　　　10&lt;br&gt;L　　　　　　50&lt;br&gt;C　　　　　　100&lt;br&gt;D　　　　　　500&lt;br&gt;M　　　　　　1000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.&lt;/p&gt;
&lt;p&gt;Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I can be placed before V (5) and X (10) to make 4 and 9. &lt;/li&gt;
&lt;li&gt;X can be placed before L (50) and C (100) to make 40 and 90. &lt;/li&gt;
&lt;li&gt;C can be placed before D (500) and M (1000) to make 400 and 900.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 3&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; “III”&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt; 4&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; “IV”&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt; 58&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; “LVIII”&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt; 1994&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; “MCMXCIV”&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Medium" scheme="https://catchdream.me/tags/Medium/"/>
    
      <category term="String" scheme="https://catchdream.me/tags/String/"/>
    
      <category term="Map" scheme="https://catchdream.me/tags/Map/"/>
    
      <category term="Integer" scheme="https://catchdream.me/tags/Integer/"/>
    
  </entry>
  
</feed>
