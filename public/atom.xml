<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Catch Your Dream</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hanielxx.com/"/>
  <updated>2019-07-24T17:35:48.379Z</updated>
  <id>https://hanielxx.com/</id>
  
  <author>
    <name>Hanielxx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-025-Reverse Nodes in k-Group</title>
    <link href="https://hanielxx.com/2019/07/25/LeetCode-025-Reverse-Nodes-in-k-Group/"/>
    <id>https://hanielxx.com/2019/07/25/LeetCode-025-Reverse-Nodes-in-k-Group/</id>
    <published>2019-07-24T16:46:48.000Z</published>
    <updated>2019-07-24T17:35:48.379Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/submissions/" target="_blank" rel="noopener">Problem</a></h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong> 1-2-3-4-5<br><strong>Output:</strong> </p><blockquote><p>k=2, 2-1-4-3-5<br>k=3, 3-2-1-4-5</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>递归, 每次改变k个节点的链接顺序, 然后令最后一个节点的next等于下一次递归的返回值, 最后返回头节点, 如果本次不满k个, 直接返回. 每次递归的内容可以是迭代或者用栈, 两种方式的时间差不多</li><li>迭代, 基于第24题的迭代, 每次修改完一段之后, 要将此段和前一段相连, 还要和后一段相连, 要注意很多细节</li><li>利用栈, 因为k个节点进栈顺序和出栈顺序正好相反</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>节点数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>递归+栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span> || head==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* <span class="built_in">stack</span>[k];</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="comment">//存入栈中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">            <span class="built_in">stack</span>[i]=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//逆序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">stack</span>[i]-&gt;next=<span class="built_in">stack</span>[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//和后一段相连</span></span><br><span class="line">        <span class="built_in">stack</span>[<span class="number">0</span>]-&gt;next=reverseKGroup(p, k);</span><br><span class="line">        <span class="comment">//每次递归返回头节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>[k<span class="number">-1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>纯迭代, 相对递归感觉比较麻烦, 逻辑上要想更多, 但是资源肯定比递归消耗少<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *front, *rear, *tmp, *p, *q, *s;</span><br><span class="line">        front=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(front!=<span class="literal">NULL</span>) front=front-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        front=rear=head;</span><br><span class="line">        <span class="comment">//front指向第一个节点, rear指向k+1个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==k<span class="number">-1</span>) head=rear;</span><br><span class="line">            rear=rear-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//pre是前一段最后一个节点</span></span><br><span class="line">        ListNode *pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            p=front;q=front-&gt;next;s=q-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(q!=rear)&#123;</span><br><span class="line">                q-&gt;next=p;</span><br><span class="line">                p=q;q=s;</span><br><span class="line">                <span class="comment">//这里要注意rear可能是NULL, s-&gt;next需判断</span></span><br><span class="line">                <span class="keyword">if</span>(s==rear &amp;&amp; s==<span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> s=s-&gt;next;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//本段和后一段相连,此时q=rear, s=rear-&gt;next, </span></span><br><span class="line">            front-&gt;next=rear;</span><br><span class="line">            <span class="comment">//前面一段和本段第一个节点相连 </span></span><br><span class="line">            pre-&gt;next=p;</span><br><span class="line">            pre=front;</span><br><span class="line">            <span class="comment">//更新front和rear</span></span><br><span class="line">            front=rear;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">                <span class="comment">//rear可能没到目标就成了NULL</span></span><br><span class="line">                <span class="keyword">if</span>(rear==<span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">                rear=rear-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>递归+栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span> <span class="keyword">or</span> head==<span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        stack=[]</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="comment">#存入栈中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> p==<span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            stack.append(p);</span><br><span class="line">            p=p.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#逆序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            stack[i].next=stack[i<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">#和后一段相连, python递归要self.reverseKGroup()</span></span><br><span class="line">        stack[<span class="number">0</span>].next=self.reverseKGroup(p, k)</span><br><span class="line">        <span class="comment">#每次递归返回头节点</span></span><br><span class="line">        <span class="keyword">return</span> stack[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        front=head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> front!=<span class="keyword">None</span>:</span><br><span class="line">                front=front.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              <span class="keyword">return</span> head    </span><br><span class="line">        </span><br><span class="line">        front=rear=head</span><br><span class="line">        <span class="comment">#front指向第一个节点, rear指向k+1个节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> i==k<span class="number">-1</span>:</span><br><span class="line">                head=rear</span><br><span class="line">            rear=rear.next </span><br><span class="line">            </span><br><span class="line">        <span class="comment">#pre是前一段最后一个节点</span></span><br><span class="line">        pre=ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            p=front</span><br><span class="line">            q=front.next</span><br><span class="line">            s=q.next</span><br><span class="line">            <span class="keyword">while</span> q!=rear:</span><br><span class="line">                q.next=p</span><br><span class="line">                p=q</span><br><span class="line">                q=s</span><br><span class="line">                <span class="comment">#这里要注意rear可能是NULL, s-&gt;next需判断</span></span><br><span class="line">                <span class="keyword">if</span> s==rear <span class="keyword">and</span> s==<span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    s=s.next                     </span><br><span class="line">            <span class="comment">#本段和后一段相连,此时q=rear, s=rear-&gt;next, </span></span><br><span class="line">            front.next=rear</span><br><span class="line">            <span class="comment">#前面一段和本段第一个节点相连 </span></span><br><span class="line">            pre.next=p</span><br><span class="line">            pre=front</span><br><span class="line">            <span class="comment">#新front和rear</span></span><br><span class="line">            front=rear;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                <span class="comment">#rear可能没到目标就成了NULL</span></span><br><span class="line">                <span class="keyword">if</span> rear==<span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> head</span><br><span class="line">                rear=rear.next</span><br><span class="line">        <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>逆序问题可利用栈的特性</li><li>发现问题可以分为多个子问题, 利用递归</li><li>迭代的过程注意避免空指针和环</li></ul><hr><p>Python是真的不太熟悉啦</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-nodes-in-k-group/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.&lt;/p&gt;
&lt;p&gt;k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 1-2-3-4-5&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;k=2, 2-1-4-3-5&lt;br&gt;k=3, 3-2-1-4-5&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Hard" scheme="https://hanielxx.com/tags/Hard/"/>
    
      <category term="Reverse" scheme="https://hanielxx.com/tags/Reverse/"/>
    
      <category term="LinkedList" scheme="https://hanielxx.com/tags/LinkedList/"/>
    
      <category term="Stack" scheme="https://hanielxx.com/tags/Stack/"/>
    
      <category term="Recursion" scheme="https://hanielxx.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-024-Swap Nodes in Pairs</title>
    <link href="https://hanielxx.com/2019/07/24/LeetCode-024-Swap-Nodes-in-Pairs/"/>
    <id>https://hanielxx.com/2019/07/24/LeetCode-024-Swap-Nodes-in-Pairs/</id>
    <published>2019-07-23T17:15:46.000Z</published>
    <updated>2019-07-24T16:46:18.849Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/" target="_blank" rel="noopener">Problem</a></h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong> 1-2-3-4<br><strong>Output:</strong> 2-1-4-3</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>很直接的, 每两个节点交换一下顺序, 可以递归但是并不需要.</li><li>指针之间的交换要注意不要漏了某个next的赋值, 可能会导致出现环</li><li>多指针的题目宁愿多弄几个变量, 更清楚, 而不是一直next, next这样赋值</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p><strong>非递归做法</strong><br>8ms, 一般般把, 题目不是特别复杂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode* q=head-&gt;next;</span><br><span class="line">        ListNode *t, *s, *tmp;</span><br><span class="line">        t=q-&gt;next;<span class="comment">//第三个节点</span></span><br><span class="line">        <span class="comment">//交换第一第二节点, head-&gt;q 变为q-&gt;head, 然后q等于第二个节点</span></span><br><span class="line">        q-&gt;next=head;</span><br><span class="line">        head-&gt;next=t;</span><br><span class="line">        head=q;</span><br><span class="line">        q=head-&gt;next;</span><br><span class="line">        <span class="comment">//1234, 此时变为2134, q-&gt;val=1, t-&gt;val=3, s-&gt;val=4, tmp=NULL</span></span><br><span class="line">        <span class="keyword">while</span>(t!=<span class="literal">NULL</span> &amp;&amp; t-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            s=t-&gt;next;</span><br><span class="line">            <span class="comment">//tmp用于t的迭代</span></span><br><span class="line">            tmp=s-&gt;next;</span><br><span class="line">            <span class="comment">//令q-&gt;next等于第四个节点, 且交换3, 4节点, t-&gt;s变成s-&gt;t</span></span><br><span class="line">            q-&gt;next=s;</span><br><span class="line">            s-&gt;next=t;</span><br><span class="line">            <span class="comment">//这步防止t和s形成环, t-&gt;next==s, s-&gt;next==t</span></span><br><span class="line">            t-&gt;next=tmp;</span><br><span class="line">            <span class="comment">//更新q和t</span></span><br><span class="line">            q=t;</span><br><span class="line">            t=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>递归做法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *p1 = head;</span><br><span class="line">        ListNode *p2 = p1-&gt;next;</span><br><span class="line"></span><br><span class="line">        p1-&gt;next = swapPairs(p2-&gt;next);</span><br><span class="line">        p2-&gt;next = p1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        pre = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = pre</span><br><span class="line">        h = head</span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            <span class="keyword">if</span> h <span class="keyword">and</span> h.next:</span><br><span class="line">                tmp = h.next</span><br><span class="line">                p.next = tmp</span><br><span class="line">                h.next = h.next.next</span><br><span class="line">                tmp.next = h</span><br><span class="line">                h = h.next</span><br><span class="line">                p = p.next.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = h</span><br><span class="line">                h = h.next</span><br><span class="line">        <span class="keyword">return</span> pre.next</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="链表指针操作要注意别出现环"><a href="#链表指针操作要注意别出现环" class="headerlink" title="- 链表指针操作要注意别出现环"></a>- 链表指针操作要注意别出现环</h2>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a linked list, swap every two adjacent nodes and return its head.&lt;/p&gt;
&lt;p&gt;You may &lt;strong&gt;not&lt;/strong&gt; modify the values in the list’s nodes, only nodes itself may be changed.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 1-2-3-4&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; 2-1-4-3&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
      <category term="LinkedList" scheme="https://hanielxx.com/tags/LinkedList/"/>
    
      <category term="Swap" scheme="https://hanielxx.com/tags/Swap/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-022-Generate Parentheses</title>
    <link href="https://hanielxx.com/2019/07/23/LeetCode-022-Generate-Parentheses/"/>
    <id>https://hanielxx.com/2019/07/23/LeetCode-022-Generate-Parentheses/</id>
    <published>2019-07-22T17:00:33.000Z</published>
    <updated>2019-07-24T16:46:20.192Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">Problem</a></h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. </p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong> n=3<br><strong>Output:</strong></p><blockquote><p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>可以暴力求解, 将所有括号的全排列找出来,然后把里面括号匹配的拿出来</li><li>动态规划, 第n个括号总是在第n-1个括号的基础上添加的,假设最左边的左括号是添加上去的. 那么, 前面的n-1个括号便分为两部分,在新加入括号内部的, 和不在新括号内部的. 我们遍历在括号内部的括号对数0-idx-1,然后遍历在括号内的每个排列, 以及不在括号内的每个排列, 将他们拼凑到一起</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>四层循环, 第一层求2-n的结果, 第二层遍历在新括号内部的括号对数, 第三层和第四层, 遍历在新括号内部的括号排列, 和不在括号内部的括号排列, 加起来就是一个新的排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; dp(n+<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=&#123;<span class="string">""</span>&#125;;</span><br><span class="line">        dp[<span class="number">1</span>]=&#123;<span class="string">"()"</span>&#125;;</span><br><span class="line">        <span class="comment">//假设最左边的左括号是第n对括号新加进来的</span></span><br><span class="line">        <span class="comment">//遍历在第一个左括号对应的括号内的pair数, [0, idx-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">2</span>;idx&lt;=n;idx++) </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=idx<span class="number">-1</span>;i++)   <span class="comment">//在第一个左括号内的括号数</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">string</span> si:dp[i])    <span class="comment">//在第一个括号内的括号数的每个排列</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">string</span> sk:dp[idx<span class="number">-1</span>-i])  <span class="comment">//不在第一个括号内的括号的每个排列</span></span><br><span class="line">                        dp[idx].push_back(<span class="string">"("</span>+si+<span class="string">")"</span>+sk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>算法同C++</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solutin</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        total_l = []</span><br><span class="line">        total_l.append([<span class="keyword">None</span>])</span><br><span class="line">        total_l.append([<span class="string">"()"</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):  <span class="comment"># 开始计算i时的括号组合，记为l</span></span><br><span class="line">            l = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i): <span class="comment">#遍历所有可能的括号内外组合</span></span><br><span class="line">                now_list1 = total_l[j]</span><br><span class="line">                now_list2 = total_l[i<span class="number">-1</span>-j]</span><br><span class="line">                <span class="keyword">for</span> k1 <span class="keyword">in</span> now_list1:  <span class="comment">#开始具体取内外组合的实例</span></span><br><span class="line">                    <span class="keyword">for</span> k2 <span class="keyword">in</span> now_list2:</span><br><span class="line">                        <span class="keyword">if</span> k1 == <span class="keyword">None</span>:</span><br><span class="line">                            k1 = <span class="string">""</span></span><br><span class="line">                        <span class="keyword">if</span> k2 == <span class="keyword">None</span>:</span><br><span class="line">                            k2 = <span class="string">""</span></span><br><span class="line">                        el = <span class="string">"("</span> + k1 + <span class="string">")"</span> + k2</span><br><span class="line">                        l.append(el)</span><br><span class="line">            total_l.append(l)</span><br><span class="line">        <span class="keyword">return</span> total_l[n]</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>动态规划往往是递归转化过来, 如果能想到递归, 那可以考虑下DP怎么做, 当然, 暴力求解通常就是递归求解</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/generate-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. &lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; n=3&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[&lt;br&gt;  “((()))”,&lt;br&gt;  “(()())”,&lt;br&gt;  “(())()”,&lt;br&gt;  “()(())”,&lt;br&gt;  “()()()”&lt;br&gt;]&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
      <category term="DP" scheme="https://hanielxx.com/tags/DP/"/>
    
      <category term="Parentheses" scheme="https://hanielxx.com/tags/Parentheses/"/>
    
  </entry>
  
  <entry>
    <title>ArchLinux-Gnome下触摸板设置</title>
    <link href="https://hanielxx.com/2019/07/22/ArchLinux-Gnome%E4%B8%8B%E8%A7%A6%E6%91%B8%E6%9D%BF%E8%AE%BE%E7%BD%AE/"/>
    <id>https://hanielxx.com/2019/07/22/ArchLinux-Gnome下触摸板设置/</id>
    <published>2019-07-22T15:58:57.000Z</published>
    <updated>2019-07-24T05:27:44.327Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Arch下触摸板默认是没有模拟鼠标单击双击功能的, 通过设置可以修改,具体参考<a href="https://wiki.archlinux.org/index.php/Touchpad_Synaptics" target="_blank" rel="noopener">ArchWiki</a></p><p>这里没有使用配置文件,只是用<a href="https://wiki.archlinux.org/index.php/Touchpad_Synaptics#Synclient" target="_blank" rel="noopener">Synclient</a>这个命令行工具设置</p></div><a id="more"></a><h1 id="模拟鼠标点击"><a href="#模拟鼠标点击" class="headerlink" title="模拟鼠标点击"></a>模拟鼠标点击</h1><p>使用synclient查看当前触摸板设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ synclient -l</span><br></pre></td></tr></table></figure><p>可以发现TapButton1, TapButton2, TapButton3, 这三个都是0<br>我们修改 TapButton1=1, TapButton2=3, TapButton3=2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ synclient TapButton1=1 TapButton2=3 TapButton3=2</span><br></pre></td></tr></table></figure><h1 id="设置自然滚动"><a href="#设置自然滚动" class="headerlink" title="设置自然滚动"></a>设置自然滚动</h1><p>把VertScrollDelta 和 HorizScrollDelta设置成负数就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ synclient VertScrollDelta=-111 HorizScrollDelta=-111</span><br></pre></td></tr></table></figure><hr><p>其他一些配置比如环形滚动, 禁用触摸板什么的, 可以自己去wiki看说明.</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Arch下触摸板默认是没有模拟鼠标单击双击功能的, 通过设置可以修改,具体参考&lt;a href=&quot;https://wiki.archlinux.org/index.php/Touchpad_Synaptics&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ArchWiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里没有使用配置文件,只是用&lt;a href=&quot;https://wiki.archlinux.org/index.php/Touchpad_Synaptics#Synclient&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Synclient&lt;/a&gt;这个命令行工具设置&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://hanielxx.com/categories/Linux/"/>
    
    
      <category term="Arch" scheme="https://hanielxx.com/tags/Arch/"/>
    
      <category term="Linux" scheme="https://hanielxx.com/tags/Linux/"/>
    
      <category term="Gnome" scheme="https://hanielxx.com/tags/Gnome/"/>
    
      <category term="Synaptics" scheme="https://hanielxx.com/tags/Synaptics/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-019-Remove Nth Node From End of List</title>
    <link href="https://hanielxx.com/2019/07/21/LeetCode-019-Remove-Nth-Node-From-End-of-List/"/>
    <id>https://hanielxx.com/2019/07/21/LeetCode-019-Remove-Nth-Node-From-End-of-List/</id>
    <published>2019-07-21T15:51:02.000Z</published>
    <updated>2019-07-21T17:52:22.579Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/" target="_blank" rel="noopener">Problem</a></h2><p>Given a linked list, remove the n-th node from the end of list and return its head.</p><p>Note:<br>Given n will always be valid.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.<br>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><p>-<br>第一种方法是两次遍历,第一次计算出一共多少个节点,然后算出应该向后移动多少次,<br>找到那个节点, 删掉</p><ul><li>第二种方法是使用双指针一次遍历, 两个指针初始化为head,<br>后一个指针先跑n步, 然后当后一个指针到达最后一个位置时,<br>前一个指针是倒数第n+1个, 删掉第n个位置就可以</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>双指针<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        ListNode* pre=head;</span><br><span class="line">        <span class="keyword">for</span>(n;n&gt;=<span class="number">1</span>;n--) p=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next=pre-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> </span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        fast = dummy</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            fast = fast.next</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        slow = dummy</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        slow.next = slow.next.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>双指针另一个用法: 链表固定相差n个位置移动, 查找节点</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a linked list, remove the n-th node from the end of list and return its head.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Given n will always be valid.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.&lt;br&gt;After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
      <category term="LinkedList" scheme="https://hanielxx.com/tags/LinkedList/"/>
    
      <category term="TwoPointer" scheme="https://hanielxx.com/tags/TwoPointer/"/>
    
  </entry>
  
  <entry>
    <title>Arch安装和Gnome配置教程</title>
    <link href="https://hanielxx.com/2019/07/20/arch%E5%AE%89%E8%A3%85%E5%92%8Cgnome%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
    <id>https://hanielxx.com/2019/07/20/arch安装和gnome配置教程/</id>
    <published>2019-07-20T13:13:37.000Z</published>
    <updated>2019-07-24T05:27:59.300Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>两天前,我的arch,被我不小心升级glibc搞坏了..很久前就想重装下系统的,因此也就懒得重新再修复了,直接重装一个也挺好.</p><p>但是!隔了这么久重装系统搞得我心态都快崩了,各种找资料.<br>现在终于弄好啦,还是决定记录一下,以后就不用那么担心教程靠不靠谱</p></div><a id="more"></a><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul><li>已有系统: Win10</li><li>安装系统: archlinux-2019.07.1-x86_64</li><li>安装磁盘: 机械硬盘的后半部分(前半部分是windows的数据)</li><li>启动方式: UEFI</li><li>分区格式: GPT</li><li>桌面系统: Gnome3</li><li>参考链接: <a href="https://wiki.archlinux.org/index.php/Installation_guide_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87" target="_blank" rel="noopener">ArchWiki</a></li><li>参考链接: <a href="http://blog.lucode.net/linux/archlinux-install-tutorial.html" target="_blank" rel="noopener">Arch安装教程</a></li><li>参考链接: <a href="https://blog.csdn.net/r8l8q8/article/details/76516523" target="_blank" rel="noopener">Arch安装图文教程</a></li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="准备安装介质"><a href="#准备安装介质" class="headerlink" title="准备安装介质"></a>准备安装介质</h2><p>说的简单点就是为制作启动盘做准备,安装系统当然需要这个系统的镜像文件.<br>可以到<a href="https://www.archlinux.org/download/" target="_blank" rel="noopener">Arch Download</a>这里下载镜像<br>一直往下可以看到CHINA的标志, 推荐选择163的源下载,<a href="http://mirrors.163.com/archlinux/iso/2019.07.01/" target="_blank" rel="noopener">链接在这</a></p><h2 id="制作LiveCD"><a href="#制作LiveCD" class="headerlink" title="制作LiveCD"></a>制作LiveCD</h2><p>如果在windows环境制作的,可以使用<a href="http://sourceforge.net/p/usbwriter/wiki/Documentation/" target="_blank" rel="noopener">USBwriter</a>,或者其他一些工具</p><p>因为我电脑有现成的fedora media writer,所以用这个也可以制作</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>身边需要可以连接的网络,有线网或者无线网</p><p>如果没有wifi可以连,当然,这个wifi不能是校园网,不然没办法直接命令行连接.<br>没wifi可以手机开热点啊,hhh</p><h2 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h2><p>从widows盘那边分出一部分给linux,我选择先压缩卷,然后新建简单卷,之后的安装就安装在这个简单卷上.</p><p>选择新建简单卷还是因为安装的时候能够看的更清楚第一个分区的开始扇区</p><h2 id="设置usb启动"><a href="#设置usb启动" class="headerlink" title="设置usb启动"></a>设置usb启动</h2><p>如果以前设置过usb启动优先就不用管了</p><p>进入BIOS,设置开机选项,调整开机顺序,让usb启动排在第一位<br>完事之后就可以直接插入你的U盘,开始装系统!</p><h1 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h1><h2 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h2><p>后面需要安装很多东西,所以最好先联网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wifi-menu</span><br></pre></td></tr></table></figure><p>会跳出来wifi选择的页面,自己选之前准备好的wifi连上就成</p><h2 id="编辑mirrorlist"><a href="#编辑mirrorlist" class="headerlink" title="编辑mirrorlist"></a>编辑mirrorlist</h2><p>目的是为了后面下载的时候速度能快点,国外的镜像站太慢啦.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/pacman.d/mirrorlist</span><br><span class="line"># 按下面描述修改mirrorlist</span><br><span class="line"># pacman -Syy</span><br></pre></td></tr></table></figure><p>我默认你已经会vim了,找163关键词,然后把163的镜像站复制粘贴到第一个镜像站前面.一堆的网址就是镜像站啦.</p><p>如果不放心,还可以找关键词China,把其他的ustc之类的都放前面去.<br>记得,保存后<code>pacman -Syy</code></p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p><strong>最重要的一步来咯</strong><br>我选择了UEFI启动,对应使用GPT分区<br>我的机械硬盘是/dev/sdb</p><h3 id="分区规划"><a href="#分区规划" class="headerlink" title="分区规划"></a>分区规划</h3><p>创建4个分区如下</p><ul><li>/boot　200M　/dev/sdb3</li><li>/swap　8G　　/dev/sdb4</li><li>/root　60G　 /dev/sdb5</li><li>/home　150G　/dev/sdb6</li></ul><p>别问我为什么/root设置这么大，为什么人家都推荐30G左右…<br>重装的其中一个原因就是/root爆了，扩容又麻烦，原本设置的是40G<br>/swap设置的是和我物理内存一样的大小</p><h3 id="查看磁盘情况"><a href="#查看磁盘情况" class="headerlink" title="查看磁盘情况"></a>查看磁盘情况</h3><p>确定你要安装的磁盘是sd几，然后使用gdisk划分磁盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># fdisk -l</span><br></pre></td></tr></table></figure><p>你看到的东西应该类似下面的</p><blockquote><p>Disk /dev/sdb: 931.53 GiB, 1000204886016 bytes, 1953525168 sectors<br>Disk model: HGST HTS721010A9<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 4096 bytes<br>I/O size (minimum/optimal): 4096 bytes / 4096 bytes<br>Disklabel type: gpt<br>Disk identifier: 94717E4F-9437-4814-96AA-5CD870012F36</p><p>Device          Start        End   Sectors  Size Type<br>/dev/sdb1        2048  587202559 587200512  280G Microsoft basic data<br>/dev/sdb2   587202560 1468008447 880805888  420G Microsoft basic data<br>/dev/sdb3  1468008448 1468418047    409600  200M EFI System<br>/dev/sdb4  1468418048 1485195263  16777216    8G Linux swap<br>/dev/sdb5  1485195264 1611024383 125829120   60G Linux root (x86)<br>/dev/sdb6  1611024384 1925597183 314572800  150G Linux home</p><p>Disk /dev/sda: 119.25 GiB, 128035676160 bytes, 250069680 sectors<br>Disk model: SanDisk SD8SNAT-<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 4096 bytes<br>I/O size (minimum/optimal): 4096 bytes / 4096 bytes<br>Disklabel type: gpt<br>Disk identifier: A7EA8BD9-4B05-4419-AEFA-7B4F01E54CC2</p><p>Device         Start       End   Sectors   Size Type<br>/dev/sda1       2048    534527    532480   260M EFI System<br>/dev/sda2     534528    567295     32768    16M Microsoft reserved<br>/dev/sda3     567296 246266737 245699442 117.2G Microsoft basic data<br>/dev/sda4  246267904 250058751   3790848   1.8G Windows recovery environment</p></blockquote><p>通过容量判断我要安装的磁盘是sda还是sdb</p><p>通过Type可以看到sdb1和sdb2都是Microsoft basic data,那是我的D盘和F盘</p><h3 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdisk /dev/sdb</span><br></pre></td></tr></table></figure><p>记得这里sdb要换成你自己的sd..</p><p>gdisk的使用很简单，先使用？打印帮助，使用p打印分区表</p><p>如果你的磁盘是空的，使用o新建一个gpt分区表，如果不是空磁盘，别这么做</p><p>接着使用ｎ命令新建一个磁盘分区,然后输入分区号，默认回车就可以<br>然后设置开始扇区，如果没啥意外，直接回车<br>设置结束扇区，可以使用<strong>+60G</strong>这样的方式，不用自己计算，很方便<br>接着设置Hex code, 这个很重要,可以使用L查看所有的codes,下面列出要用的</p><blockquote><p>/boot: EF00<br>/swap: 8200<br>/root: 8303<br>/home: 8302</p></blockquote><h3 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h3><p>格式化EFI分区/boot</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkfs.fat -F32 /dev/sdb3</span><br></pre></td></tr></table></figure><p>格式化/root和/home</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkfs.ext4 /dev/sdb5</span><br><span class="line"># mkfs.ext4 /dev/sdb6</span><br></pre></td></tr></table></figure><p>开启swap分区/swap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkwsap /dev/sdb4</span><br><span class="line"># swapon /dev/sdb4</span><br></pre></td></tr></table></figure><h3 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h3><p>一般是将根分区/挂载到/mnt下,然后将/boot和/home挂载到/mnt/boot和/mnt/home</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mount /dev/sdb5 /mnt</span><br><span class="line"># mkdir /mnt/&#123;boot, home&#125;</span><br><span class="line"># mount /dev/sdb6 /mnt/home</span><br><span class="line"># mount /dev/sdb3 /mnt/boot</span><br></pre></td></tr></table></figure><h1 id="安装基本系统"><a href="#安装基本系统" class="headerlink" title="安装基本系统"></a>安装基本系统</h1><h2 id="部署基本系统"><a href="#部署基本系统" class="headerlink" title="部署基本系统"></a>部署基本系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacstrap -i /mnt base base-devel net-tools</span><br></pre></td></tr></table></figure><p>这里的net-tools提供了netstat和ifconfig等命令,可以选择不装,差别不大</p><h2 id="生成fstab"><a href="#生成fstab" class="headerlink" title="生成fstab"></a>生成fstab</h2><p>fstab中记录了挂载信息,使用下面命令生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>使用<code>cat /mnt/etc/fstab</code>检查</p><h2 id="基本系统设置"><a href="#基本系统设置" class="headerlink" title="基本系统设置"></a>基本系统设置</h2><h3 id="切换到新系统"><a href="#切换到新系统" class="headerlink" title="切换到新系统"></a>切换到新系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># arch-chroot /mnt /bin/bash</span><br></pre></td></tr></table></figure><h3 id="设置locale"><a href="#设置locale" class="headerlink" title="设置locale"></a>设置locale</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/locale.gen</span><br></pre></td></tr></table></figure><p>这里是配置本地语言环境,起码要中英文的UTF-8,所以把<code>en_US.UTF-8UTF-8</code>和<code>zh_CN.UTF-8 UTF-8</code>取消注释, 然后保存退出<br>然后执行: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># locale-gen</span><br><span class="line"># # echo LANG=en_US.UTF-8 &gt; /etc/locale.conf</span><br></pre></td></tr></table></figure><h3 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h3><p>执行如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><h3 id="设置硬件时间"><a href="#设置硬件时间" class="headerlink" title="设置硬件时间"></a>设置硬件时间</h3><p>执行如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hwclock --systohc --utc</span><br></pre></td></tr></table></figure><h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><p>建议使用小写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo 主机名 &gt; /etc/hostname</span><br><span class="line"># vim /etc/hosts</span><br></pre></td></tr></table></figure><p>hosts文件中有如下内容</p><blockquote><p>127.0.0.1    localhost<br>::1        localhost<br>127.0.1.1    myhostname.localdomain    myhostname</p></blockquote><p>如果系统有一个永久的 IP 地址，请使用这个永久的 IP 地址而不是 127.0.1.1</p><h3 id="生成Initramfs"><a href="#生成Initramfs" class="headerlink" title="生成Initramfs"></a>生成Initramfs</h3><p>注意,这步只对 LVM、 system encryption 或 RAID有效<br>正常情况下,在执行pacstrap的时候已经安装linux,并且mkinitcpio自动运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkinitcpio -p linux</span><br></pre></td></tr></table></figure><h3 id="用户设置"><a href="#用户设置" class="headerlink" title="用户设置"></a>用户设置</h3><p>修改root用户密码,并且创建一个新用户,同样修改密码<br>建议root密码和用户密码不要设置成一样的,平时用普通用户就可以</p><p><strong>如果需要用root,必须清楚自己每一步会有什么后果!</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># passwd</span><br><span class="line"># ****你的密码****</span><br><span class="line"># useradd -m -g users -s /bin/bash 用户名</span><br><span class="line"># passwd 用户名</span><br><span class="line"># ****用户密码****</span><br></pre></td></tr></table></figure><p>为用户添加sudo权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sudoers</span><br><span class="line"># 在root ALL=(ALL) ALL下面添加如下内容</span><br><span class="line">用户名 ALL=(ALL) ALL</span><br><span class="line"></span><br><span class="line"># 保存退出</span><br><span class="line"># :wq</span><br></pre></td></tr></table></figure><h3 id="配置UEFI引导-重点"><a href="#配置UEFI引导-重点" class="headerlink" title="配置UEFI引导(重点)"></a>配置UEFI引导(重点)</h3><p>(这里网上看到的都有点不太一样, 导致我安装完之后电脑一直找不到Linux的引导项,<br>一直进不来linux, 后来在archwiki上看到了正确的方法, 记录如下)</p><p>这里使用UEFI引导,而不是BIOS,两者的区别自行百度</p><p>关于启动加载器可以自己查看<a href="https://wiki.archlinux.org/index.php/Arch_boot_process_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%99%A8" target="_blank" rel="noopener">ArchWiki</a>,里面讲的很清楚</p><p>我们选择GRUB <a href="https://wiki.archlinux.org/index.php/GRUB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">ArchWiki</a>来引导系统,具体过程在archwiki中也讲的很清楚,这里不多赘述</p><p>安装必要软件包, efibootmgr是efi引导才要用的, ntfs-3g是为了能够识别windows的ntfs文件系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S dosfstools grub efibootmgr ntfs-3g</span><br></pre></td></tr></table></figure><p><strong>注意,我们选择的EFI系统分区是之前的/boot, 选择的启动引导器标识是GRUB,<br>不懂可以不管, 直接执行</strong></p><p>执行下面的命令来将 GRUB EFI 应用 <code>grubx64.efi</code> 安装到<br><code>/boot/EFI/GRUB/</code>，并将其模块安装到 <code>/boot/grub/x86_64-efi/</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</span><br></pre></td></tr></table></figure><p>安装完之后GRUB目录位于在/boot/grub/</p><p>然后执行下面命令生成主配置文件<code>grub.cfg</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>在/boot目录使用<code>tree -d</code>会有如下内容</p><blockquote><p>.<br>├── EFI<br>│   └── GRUB<br>├── grub<br>│   ├── fonts<br>│   ├── themes<br>│   │   └── starfield<br>│   └── x86_64-efi<br>└── syslinux</p></blockquote><h3 id="退出chroot重启"><a href="#退出chroot重启" class="headerlink" title="退出chroot重启"></a>退出chroot重启</h3><p>笔记本退出之前要先安装dialog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S iw wpa_supplicant dialog</span><br><span class="line"># exit</span><br><span class="line"># umount /mnt/&#123;boot, home&#125;</span><br><span class="line"># umount /mnt</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure><p>其实不重启也可以, 这时候还连着网, 直接把需要安装的一次性装了,<br>然后直接进到图形界面, 不然联网会很麻烦. 图形界面可以用networkmanager连网</p><h1 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h1><h2 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h2><p>具体的驱动匹配表可以查看<a href="https://wiki.archlinux.org/index.php/Xorg_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">ArchWiki</a></p><p>再次折腾了一次Nvidia驱动, 失败告终, 难受<br>显卡驱动默认的vesa可以兼容大部分显卡了<br>我是双显卡, 安装了下面三个显卡驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S xf86-video-vesa     通用驱动</span><br><span class="line"># pacman -S xf86-video-intel    intel集显驱动</span><br><span class="line"># pacman -S xf86-video-nouveau  开源的N卡驱动</span><br></pre></td></tr></table></figure><h2 id="触摸板驱动"><a href="#触摸板驱动" class="headerlink" title="触摸板驱动"></a>触摸板驱动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S xf86-input-synaptics</span><br></pre></td></tr></table></figure><h2 id="Xorg显示服务器"><a href="#Xorg显示服务器" class="headerlink" title="Xorg显示服务器"></a>Xorg显示服务器</h2><p>xorg是其他例如xfce和gnome, kde一些桌面环境的基础, 提供图形环境基本框架</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S xorg</span><br></pre></td></tr></table></figure><h1 id="安装Gnome以及配置"><a href="#安装Gnome以及配置" class="headerlink" title="安装Gnome以及配置"></a>安装Gnome以及配置</h1><h2 id="Gnome和优化工具"><a href="#Gnome和优化工具" class="headerlink" title="Gnome和优化工具"></a>Gnome和优化工具</h2><p>gnome是基本环境, gnome-extra是一个包合集, 里面有一些软件啥的,<br>如果是喜欢干干净净的可以不装extra, 以后缺啥装啥</p><p>gnome-tweak-tool是gnome桌面美化的很重要的工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S gnome gnome-extra gnome-tweak-tool</span><br></pre></td></tr></table></figure><h2 id="窗口管理服务gdm"><a href="#窗口管理服务gdm" class="headerlink" title="窗口管理服务gdm"></a>窗口管理服务gdm</h2><p>gnome一般用gdm, deepin用lightdm, xfce使用lxdm, kde使用sddm<br>我们安装gdm之后要启用它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S gdm</span><br><span class="line"># systemctl enable gdm</span><br></pre></td></tr></table></figure><h2 id="网络管理工具NetworkManager"><a href="#网络管理工具NetworkManager" class="headerlink" title="网络管理工具NetworkManager"></a>网络管理工具NetworkManager</h2><p>这一步做完之后就可以重启进入电脑啦, 其他的东西, 最好进入图形界面再做,<br>边做边看效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S networkmanager</span><br><span class="line"># systemctl enable NetworkManager</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure><h2 id="添加archlinux-cn源"><a href="#添加archlinux-cn源" class="headerlink" title="添加archlinux-cn源"></a>添加archlinux-cn源</h2><p>官方仓库里面有很多我们常用但是没有的, 添加这个源会好很多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># sudo vim /etc/pacman.conf</span><br><span class="line"># 在末尾添加如下内容</span><br><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel=Never</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><h1 id="其他常用软件和工具安装"><a href="#其他常用软件和工具安装" class="headerlink" title="其他常用软件和工具安装"></a>其他常用软件和工具安装</h1><h2 id="自带商店gnome-software"><a href="#自带商店gnome-software" class="headerlink" title="自带商店gnome-software"></a>自带商店gnome-software</h2><p>可以自己先逛逛自带的gnome-software, 商店里面有很多工具类的</p><p>如果发现商店打开后提示No application data found.可以按照如下操作恢复</p><ol><li>在设置中将语言改成其他语言,英到中</li><li>重启</li><li>将语言改回原来的, 中到英</li><li>重启<br>这样就可以啦</li></ol><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>下面这几个字体一般够用了, ttf-consolas-with-yahei是consolas和yahei结合体,<br>英文consolas, 中文yahei</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sudo pacman -S ttf-consolas-with-yahei</span><br><span class="line"># sudo pacman -S wqy-microhei tf-dejavu wqy-zenhei</span><br></pre></td></tr></table></figure><h2 id="fcitx输入法"><a href="#fcitx输入法" class="headerlink" title="fcitx输入法"></a>fcitx输入法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S fcitx-im fcitx fcitx-configtool</span><br><span class="line"># pacman -S fcitx-cloudpinyin fcitx-sogoupinyin</span><br></pre></td></tr></table></figure><p>安装完之后还需要编辑配置文件, 具体可以看<a href="https://wiki.archlinux.org/index.php/Fcitx" target="_blank" rel="noopener">ArchWiki</a><br>一些常见的问题wiki里面也都说到了,所以如果下面的过程出现未知错误, 移步wiki查看</p><p>修改配置文件, gnome on wayland, 无法读取~/.xprofile, 所以修改/etc/environment<br>如果在登陆的时候选择Xorg的Gnome, 可以新建~/.xprofile, 添加如下内容<br>然后重启生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/environment</span><br><span class="line"># 添加如下内容</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure><p>使用fcitx-configtool进行进一步配置, 启用cloudpinyin等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># fcitx-configtool</span><br><span class="line"># 在input method那里点加号, 添加Pinyin</span><br><span class="line"># 在global-config进行全局配置</span><br><span class="line"># 在Apperance进行字体大小调整和状态显示</span><br><span class="line"># Addon进行插件管理, 双击插件进行设置</span><br></pre></td></tr></table></figure><p>安装皮肤, 这里推荐一款简单好看的fcitx-skin-material</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo pacman -S fcitx-skin-material</span><br></pre></td></tr></table></figure><p>如果出现在gnome-terminal中Ctrl+Space调不出fcitx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># gsettings set org.gnome.settings-daemon.plugins.xsettings overrides &quot;&#123;&apos;Gtk/IMModule&apos;:&lt;&apos;fcitx&apos;&gt;&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="安装yaourt"><a href="#安装yaourt" class="headerlink" title="安装yaourt"></a>安装yaourt</h2><p>安装yaourt这个工具来使用AUR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo pacman -S yaourt</span><br></pre></td></tr></table></figure><h2 id="安装oh-my-fish"><a href="#安装oh-my-fish" class="headerlink" title="安装oh-my-fish"></a>安装oh-my-fish</h2><p>首先要安装fish, 相对于bash来说, 好用太多啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo pacman -S fish</span><br></pre></td></tr></table></figure><p>然后去github上找到<a href="https://github.com/oh-my-fish/oh-my-fish" target="_blank" rel="noopener">oh-my-fish</a>,<br>README上说的很清楚很详细. 下面通过git安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># with git</span><br><span class="line"># git clone https://github.com/oh-my-fish/oh-my-fish</span><br><span class="line"># cd oh-my-fish</span><br><span class="line"># bin/install --offline</span><br></pre></td></tr></table></figure><p>然后安装主题, 可以自己去github上挑选, <a href="https://github.com/oh-my-fish/oh-my-fish/blob/master/docs/Themes.md" target="_blank" rel="noopener">传送门</a><br>我这里安装<strong>batman</strong>这个主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># omf install batman</span><br><span class="line"># omf theme batman</span><br></pre></td></tr></table></figure><p>编辑配置文件, 设置一些全局变量方便使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vim $OMF_CONFIG/init.fish</span><br><span class="line"># 添加你的变量和function</span><br><span class="line"># 例如</span><br><span class="line"># set -xg dow $HOME/Documents/</span><br><span class="line"># function c</span><br><span class="line">#   clear</span><br><span class="line"># end</span><br></pre></td></tr></table></figure><p>fish的使用请</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>firefox和chrome我都用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo pacman -S firefox google-chrome</span><br></pre></td></tr></table></figure><h2 id="wps-office"><a href="#wps-office" class="headerlink" title="wps-office"></a>wps-office</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo pacman -S wps-office</span><br></pre></td></tr></table></figure><h2 id="音乐和视频"><a href="#音乐和视频" class="headerlink" title="音乐和视频"></a>音乐和视频</h2><p>网易云和vlc, 以及视频解码包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sudo pacman -S netease-cloud-music</span><br><span class="line"># sudo pacman -S vlc gstreamer0.10-plugins</span><br></pre></td></tr></table></figure><h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><p>tar unzip zip unrar rar 一般用tar就足够啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo pacman -S tar unzip zip unrar rar</span><br></pre></td></tr></table></figure><h1 id="Gnome桌面美化"><a href="#Gnome桌面美化" class="headerlink" title="Gnome桌面美化"></a>Gnome桌面美化</h1><p>推荐自己去<a href="https://www.gnome-look.org/" target="_blank" rel="noopener">Gnome-Look</a>找喜欢的主题和图标样式之类的</p><h2 id="GTK主题"><a href="#GTK主题" class="headerlink" title="GTK主题"></a>GTK主题</h2><p>我使用的是<a href="https://www.gnome-look.org/p/1214931/" target="_blank" rel="noopener">flat-remix-blue</a></p><p>安装步骤</p><ul><li><a href="https://www.gnome-look.org/p/1214931/startdownload?file_id=1563444013&amp;file_name=05-Flat-Remix-GTK-Blue-Dark_20190718.tar.xz&amp;file_type=application/x-xz&amp;file_size=480876" target="_blank" rel="noopener">下载主题</a></li><li>解压 <code>tar -xvf 05-Flat-Remix-GTK-Blue-Dark_20190718.tar.xz</code></li><li>将Flat-Remix-GTK-Blue-Dark目录放到~/.themes目录下 <code>mv Flat-Remix-GTK-Blue-Dark/ ~/.themes/</code></li><li>在gnome-tweaks里面启用</li></ul><h2 id="Gnome-Shell主题"><a href="#Gnome-Shell主题" class="headerlink" title="Gnome-Shell主题"></a>Gnome-Shell主题</h2><p>我使用的是<a href="https://www.gnome-look.org/p/1013030/" target="_blank" rel="noopener">Flat Remix GNOME/Ubuntu/GDM theme</a></p><p>安装步骤</p><ul><li><a href="https://www.gnome-look.org/p/1013030/" target="_blank" rel="noopener">下载shell主题</a></li><li>解压 <code>tar -xvf Flat-Remix-Dark-fullPanel_20190616.tar.xz</code></li><li>将其移动到~/.themes目录下</li><li>在gnome-tweaks里面的Extensions里面, 将User themes启用, 重启gnome-tweaks</li><li>在gnome-tweaks里面选择shell主题</li></ul><h2 id="GDM主题"><a href="#GDM主题" class="headerlink" title="GDM主题"></a>GDM主题</h2><p>推荐<a href="https://www.gnome-look.org/p/1207015/" target="_blank" rel="noopener">High_Ubunterra</a></p><p>安装步骤</p><ul><li>下载主题</li><li>解压</li><li>cd High_Ubunterra_DD-2.4(noPass)</li><li>chmod +x install.sh</li><li>./install.sh</li></ul><h2 id="icon主题"><a href="#icon主题" class="headerlink" title="icon主题"></a>icon主题</h2><p>推荐<a href="https://www.gnome-look.org/p/1279924/" target="_blank" rel="noopener">Tela Icon Theme</a><br>可以自己选择目录样式的颜色, 我安装的是manjaro<br>具体可以看<a href="https://github.com/vinceliuice/Tela-icon-theme" target="_blank" rel="noopener">github</a></p><p>安装步骤</p><ul><li>git clone <a href="https://github.com/vinceliuice/Tela-icon-theme.git" target="_blank" rel="noopener">https://github.com/vinceliuice/Tela-icon-theme.git</a></li><li>cd Tela-icon-theme</li><li>./install.sh -n Tela-manjaro</li></ul><h2 id="screenfetch"><a href="#screenfetch" class="headerlink" title="screenfetch"></a>screenfetch</h2><p>screenfetch可以在终端里输出你的系统logo和状态。<br>如果需要打开终端自动输出, 可以在~/.bashrc添加: screenfetch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo pacman -S screenfetch</span><br></pre></td></tr></table></figure><h2 id="dock栏"><a href="#dock栏" class="headerlink" title="dock栏"></a>dock栏</h2><p>既然是mac风, 那肯定还是要有dock比较好看, gnome on wayland<br>安装dash-to-dock插件, 具体参考<a href="https://micheleg.github.io/dash-to-dock/download.html#installation-from-source" target="_blank" rel="noopener">安装文档</a></p><p>安装方法</p><ol><li>安装包解压缩后，重命名（删除邮箱后面的字符）后复制到目录~/.local/share/gnome-shell/extensions/下，然后重启 GNOME，再打开 Tweaks，应该就能在Extensions上看到 </li><li>下载github上的源码包,然后make, make install, 重启gnome, 参考<a href="https://github.com/micheleg/dash-to-dock" target="_blank" rel="noopener">README</a></li></ol><h2 id="gnome-terminal背景透明"><a href="#gnome-terminal背景透明" class="headerlink" title="gnome-terminal背景透明"></a>gnome-terminal背景透明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yaourt -S gnome-terminal-transparency</span><br></pre></td></tr></table></figure><p>安装过程会提示和gnome-terminal冲突,确认删除就可以.<br>然后重启gnome-terminal, preference里面可以看到背景透明度设置</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>写了很多, 妈妈再也不用担心我重装系统啦!<br>作为一个参考吧, 以后总会因为各种原因需要重装.<br>所以记录一下, 也分享给新人使用, 岂不乐哉</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;两天前,我的arch,被我不小心升级glibc搞坏了..很久前就想重装下系统的,因此也就懒得重新再修复了,直接重装一个也挺好.&lt;/p&gt;
&lt;p&gt;但是!隔了这么久重装系统搞得我心态都快崩了,各种找资料.&lt;br&gt;现在终于弄好啦,还是决定记录一下,以后就不用那么担心教程靠不靠谱&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://hanielxx.com/categories/Linux/"/>
    
    
      <category term="Arch" scheme="https://hanielxx.com/tags/Arch/"/>
    
      <category term="Gnome" scheme="https://hanielxx.com/tags/Gnome/"/>
    
      <category term="UEFI" scheme="https://hanielxx.com/tags/UEFI/"/>
    
      <category term="GPT" scheme="https://hanielxx.com/tags/GPT/"/>
    
      <category term="双系统" scheme="https://hanielxx.com/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Install" scheme="https://hanielxx.com/tags/Install/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-018-4Sum</title>
    <link href="https://hanielxx.com/2019/07/17/LeetCode-018-4Sum/"/>
    <id>https://hanielxx.com/2019/07/17/LeetCode-018-4Sum/</id>
    <published>2019-07-17T07:00:41.000Z</published>
    <updated>2019-07-21T16:28:22.365Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">Problem</a></h2><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p><p><strong>Note:</strong><br>The solution set must not contain duplicate quadruplets.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong> nums = [1, 0, -1, 0, -2, 2], and target = 0<br><strong>Output:</strong><br>A solution set is:</p><blockquote><p>[<br>[-1, 0, 0, 1],<br>[-2, -1, 1, 2],<br>[-2, 0, 0, 2]<br>]</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><p>-<br>和<a href="https://catchdream.me/2019/05/19/LeetCode-015-3Sum/" target="_blank" rel="noopener">第15题3Sum</a>思路类似，十五题是固定一个数字，然后双指针求三数之和，这题固定两个数字，然后双指针求四数之和。其实原理和3Sum一样</p><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">4</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size()<span class="number">-2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> l = j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> r = nums.size()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[i]+nums[j]+nums[l]+nums[r];</span><br><span class="line">                    <span class="keyword">if</span>(tmp==target)&#123;</span><br><span class="line">                        res.insert(&#123;nums[i], nums[j], nums[l], nums[r]&#125;);</span><br><span class="line">                        r--;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(tmp&gt;target) r--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(tmp&lt;target) l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;(res.begin(), res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>为啥我总是不想用python再写一遍，感觉很没意思…<br>附上题解里找到<a href="https://leetcode-cn.com/problems/4sum/solution/gu-ding-liang-ge-shu-yong-shuang-zhi-zhen-zhao-lin/" target="_blank" rel="noopener">Python版本代码</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>: <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-3</span>):</span><br><span class="line">            <span class="comment"># 防止重复 数组进入 res</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 当数组最小值和都大于target 跳出</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[i+<span class="number">1</span>] + nums[i+<span class="number">2</span>] + nums[i+<span class="number">3</span>] &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 当数组最大值和都小于target,说明i这个数还是太小,遍历下一个</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[n<span class="number">-1</span>] + nums[n<span class="number">-2</span>] + nums[n<span class="number">-3</span>] &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n<span class="number">-2</span>):</span><br><span class="line">                <span class="comment"># 防止重复 数组进入 res</span></span><br><span class="line">                <span class="keyword">if</span> j - i &gt; <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 同理</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] + nums[j+<span class="number">1</span>] + nums[j+<span class="number">2</span>] &gt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 同理</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] + nums[n<span class="number">-1</span>] + nums[n<span class="number">-2</span>] &lt; target:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 双指针</span></span><br><span class="line">                left = j + <span class="number">1</span></span><br><span class="line">                right = n - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    tmp = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line">                    <span class="keyword">if</span> tmp == target:</span><br><span class="line">                        res.append([nums[i],nums[j],nums[left],nums[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right<span class="number">-1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> tmp &gt; target:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>双指针用法之一：找目标数字，四个数可以固定两个数，另外两个数双指针求</li><li>差不多类型的题，，，要学会套,举一反三不成,举一反一可以把</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/4sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;The solution set must not contain duplicate quadruplets.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = [1, 0, -1, 0, -2, 2], and target = 0&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;br&gt;A solution set is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[&lt;br&gt;[-1, 0, 0, 1],&lt;br&gt;[-2, -1, 1, 2],&lt;br&gt;[-2, 0, 0, 2]&lt;br&gt;]&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://hanielxx.com/tags/Math/"/>
    
      <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
      <category term="TwoPointer" scheme="https://hanielxx.com/tags/TwoPointer/"/>
    
  </entry>
  
  <entry>
    <title>记2019南大计算机本科生开放日</title>
    <link href="https://hanielxx.com/2019/07/12/%E8%AE%B02019%E5%8D%97%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AC%E7%A7%91%E7%94%9F%E5%BC%80%E6%94%BE%E6%97%A5/"/>
    <id>https://hanielxx.com/2019/07/12/记2019南大计算机本科生开放日/</id>
    <published>2019-07-12T10:29:34.000Z</published>
    <updated>2019-07-20T12:10:19.222Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2019年7月12，恩，南大夏令营第一天，一天之内心情就像打翻的五味瓶。。。</p><p>哎，写下来这些也是希望能给后面的学弟学妹点帮助，毕竟我也是看了很多以前别人写的夏令营的博客才完全了解夏令营。<br>不说了罢，再说，要落泪了…</p></div><a id="more"></a><h1 id="申请夏令营和选拔"><a href="#申请夏令营和选拔" class="headerlink" title="申请夏令营和选拔"></a>申请夏令营和选拔</h1><h2 id="初审"><a href="#初审" class="headerlink" title="初审"></a>初审</h2><p>南大入营选拔很看重绩点和排名，以及，学校，这些都是敲门砖。</p><p>当你绩点专业前5%，学校起码是211，你就有戏了，非211和985的，应该非常非常少，当然，如果你有很多厉害的奖，专利，论文啥的，就没问题<br>除了上面的敲门砖，竞赛、论文、获奖、专利、软著这些之类的，如果有比较厉害的，也会很有希望。</p><h2 id="复审"><a href="#复审" class="headerlink" title="复审"></a>复审</h2><p>不要以为收到第一封通知邮件就是入营了，那只是初审，复审还会刷掉点人。<br>复审需要寄送材料，按照邮件要求寄送即可，不要作假就行</p><p>2019年大概400左右人入营，南京市内100+，非南京市280+，大概只给100不到的优营名额，竞争还是很激烈的</p><h1 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a>夏令营</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>别想了，在你报名之前你就应该准备。</p><p>事实证明，如果你觉得自己有希望保研，最好大三下开学就准备夏令营，在大三下期末考之前，你需要认真复习准备我下面要说的。等期末结束再认真复习，就晚了。。<br>我就是，期末之前复习不多，期末之后确认入营了才认真起来，但是时间完全不够用。</p><p><strong>准备分为机试和面试</strong></p><ol><li>机试<ul><li>你需要学大量的算法，ACM中等难度就可以</li><li>刷大量的题，100道肯定不够的，可以刷<a href="https://leetcode.com/problemset/all/" target="_blank" rel="noopener">LeetCode</a>上的中等难度题，也可以找上面的分类题目写。还可以刷<a href="https://www.nowcoder.com/ta/kaoyan" target="_blank" rel="noopener">牛客网</a>的考研复试题。事实证明，这两个网站都很有用</li><li>刷完题要总结，可以用思维导图，我觉得挺好</li></ul></li><li>面试<ul><li>你需要复习数学相关，比如：概统、现代、离散</li><li>专业相关，比如：操作系统、数据结构、计网、计组、数据库。如果时间充足，全都复习，时间不够，按我的写的顺序复习</li></ul></li></ol><h2 id="第一天机试"><a href="#第一天机试" class="headerlink" title="第一天机试"></a>第一天机试</h2><p>第一天，算是最难受的了把。因为报道当天早上从学校出发的，所以要早起。但是，前一天晚上睡觉睡不着..不是我一个人，同行的四个人，都睡不着，一方面是无法避免的紧张，另一方面是，和自己生物钟不协调，睡太早</p><p>所以尽量提前几天调好生物钟把，精神会好点</p><p>上午11点左右到南大，路上本来想着再看看算法，但是因为晕车，困，没座位这些原因就没看。报道之后就直接去酒店登记入住了。酒店还是很棒的，毕竟四星级，条件很好。<br>每天的午饭晚饭有餐券。不得不说！南大的伙食真的好，虽然，很贵….我看到一个女生，两个大荤加一个蔬菜，好像还有汤，26元..正常人均15把</p><p>吃完饭就没多少时间了，因为着凉肚子难受，趴桌子趴了一会。复习也只能大概过一遍。所以尽量夏令营之前准备妥当。<br>吃饭的时候听可靠消息说今年的题目比较难，当时心里就慌了，后面等机房开门的时候就一直看算法，心情沉重，</p><h3 id="机试"><a href="#机试" class="headerlink" title="机试"></a>机试</h3><p>要求下午1点半到，两点开始考试。<br>一共两小时，三道题，每道题有10个测试用例，一个测试用例10分。满分也就是300分。</p><p>以前好像看到说可以看到测试用例。但是！并没有，只能看到你第几个通过，第几个没通过，而且今年看不到总排名</p><p><strong>第一题</strong></p><p>大概意思是，给你一个不超过100位的数n，和一个不超过100的数字k，要求从数n中去掉k个数字，然后使得去掉k个数之后，n最小。</p><p><strong>题解参考链接</strong>：<a href="https://blog.csdn.net/C20190413/article/details/77368590" target="_blank" rel="noopener">https://blog.csdn.net/C20190413/article/details/77368590</a>   </p><p><strong>第二题</strong></p><p>大概意思是，有B个男孩，G个女孩，要求所有男孩女孩排成一队，连续的男孩个数不可以超过K个，问一共有多少种排法</p><p><strong>思路参考：</strong></p><p>分路递归，看当前为止是男孩还是女孩。</p><p>所以第一路递归，当前是男孩，第二路递归，当前是女孩，然后继续递归遍历下一个位置。</p><p>当然会有限制条件，不可以连续超过k个男孩，我在参数中记录当前位置，前面的男孩个数。</p><p>如果女孩个数等于0，那后面全是男孩，要看剩下的男孩个数是否超过k，如果男孩个数为0，剩下全是女孩，返回1。</p><p>如果前面男孩个数已经k个了，这个位置只能是女孩。</p><p>大概这样。但是会超时，10个样例只通过了7个…后面也没想到怎么剪枝优化。</p><p><strong>第三题</strong></p><p>给出一个二叉树的前序遍历序列和后序遍历序列，序列是没有空节点#号的，只有字母，问通过这两个序列可以构造多少中不同的二叉树，因为树的样子不一样，遍历的序列是可能一样的。比如前序序列:abc，后序序列cba，就有4种不同的树</p><p><strong>思路参考链接</strong>：<a href="https://blog.csdn.net/C20190413/article/details/77368590" target="_blank" rel="noopener">https://blog.csdn.net/C20190413/article/details/77368590</a></p><h2 id="第二天面试"><a href="#第二天面试" class="headerlink" title="第二天面试"></a>第二天面试</h2><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>虽说，南大夏令营的结果是综合了机试和面试，综合排名。但是！<strong>实际情况是</strong>，机试稳了，面试就走过场了。面试相对来说没那么重要，但是为了不留遗憾，还是需要认真对待的。机试完一晚上加上第二天上午的时间，足够准备了。</p><p>这次的面试分两批，上下午。我是下午那批，所以有一个上午可以睡个好觉，吃个美滋滋的自助早餐，还能准备一会。</p><p><strong>每个人面试大概十分钟，只有一个英文面试题，一定要好好练练口语，以便临场发挥</strong></p><p>我这次面试比较轻松，没有太过刁难。上来先<strong>自我介绍</strong>，没说限制时间，基本上自己说完就好。</p><p>然后因为我说了国家级大创，所以，下一个问题<strong>问了大创项目</strong>，做了啥，怎么样，细节。还有会从你的回答中，<strong>延伸出去</strong>，问一些技术方面的问题。</p><p>大创这里三个老师都问了我问题，由易到难，中间还问了我通信如何实现高并发，如何处理请求，以及通过什么方式实现的通信，比如wifi，蓝牙，我说了是websocket。还问了更深的窄带物联网的通信。这里花的时间是比较多的。</p><p>随后一个老师<strong>英文提问</strong>自己哪门课学的比较好，为什么，紧张状态下真的话都说不清，很乱，这也是我面试唯一一个败笔….不过还好的是说完就冷静下来，继续回答问题。</p><p>自我介绍说想在大数据这方面继续深造，老师就问了<strong>为什么，如何看待大数据</strong>，一些理解把，<strong>延伸出去</strong>的问了如何看待大数据中的隐私问题，答完又问了解过隐私方面的协议，比如说xxx吗，确实没听过，就直说这个不是很了解。</p><p>整个面试还是比较轻松的，我的面试没那么难。</p><p>不过交流下来，差距还是挺大的，似乎只有我比较幸运，问的比较正常。其他的有很多挺难回答的问题，<strong>因老师和自我介绍而异</strong>把。</p><p><strong>面试的原则是实事求是，不会就是不会，还有就是更偏向随机应变，而不是死背稿子。</strong></p><p>在面试的时候一般都会很紧张，所以背的稿子几乎没啥用。甚至我的自我介绍都是临场发挥的，和稿子不大一样。</p><p><strong>建议</strong>是自我介绍好好写，记住大概要说的。然后基于自己的自我介绍，自己想可能会问啥问题，然后自己回答。</p><h2 id="联系导师签字"><a href="#联系导师签字" class="headerlink" title="联系导师签字"></a>联系导师签字</h2><p>面试完基本上就去找意向导师了，也有人第一天来就直接找了意向导师。</p><p>每个老师只能签四个人，所以说，如果去晚了，可能会没名额。</p><p>这个也挺难说，毕竟签了字，你也不一定能进南大，签了字，老师也不一定选你。</p><p><strong>这里的建议是：</strong><br>　　夏令营之前就了解好各个实验室的情况，起码有个大概了解。可以找本校的在南大读研的学长，让他给你说说情况，推荐下啥的。也可以避免踩雷。有了意向导师，在复审通过后就给老师发邮件，记得附上自己简历。</p><p>南大的实验室，除了LAMDA，其他的实力上来说应该差不多，只是有的比价偏理论，有的比较偏项目，有的比较综合，自己看方向和综合情况选把。</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>机试面试结束，先让我玩一个晚上，享受四星级酒店的待遇再说吧～</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2019年7月12，恩，南大夏令营第一天，一天之内心情就像打翻的五味瓶。。。&lt;/p&gt;
&lt;p&gt;哎，写下来这些也是希望能给后面的学弟学妹点帮助，毕竟我也是看了很多以前别人写的夏令营的博客才完全了解夏令营。&lt;br&gt;不说了罢，再说，要落泪了…&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Daily" scheme="https://hanielxx.com/categories/Daily/"/>
    
    
      <category term="Daily" scheme="https://hanielxx.com/tags/Daily/"/>
    
      <category term="Nju" scheme="https://hanielxx.com/tags/Nju/"/>
    
      <category term="SummerCamp" scheme="https://hanielxx.com/tags/SummerCamp/"/>
    
  </entry>
  
  <entry>
    <title>Linux将deb包转为ArchLinux软件包</title>
    <link href="https://hanielxx.com/2019/07/03/Linux%E5%B0%86deb%E5%8C%85%E8%BD%AC%E4%B8%BAArchLinux%E8%BD%AF%E4%BB%B6%E5%8C%85/"/>
    <id>https://hanielxx.com/2019/07/03/Linux将deb包转为ArchLinux软件包/</id>
    <published>2019-07-03T10:35:48.000Z</published>
    <updated>2019-07-24T05:29:24.520Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候可能找不到arch用的包，只有deb包或者rpm包。<br>将deb包转换为ArchLinux的包比较方便，使用了debtap这个工具<br>debtap代表了 DEB T o A rch （Linux） P ackage的意思</p></div><a id="more"></a><h2 id="安装debtap并更新数据"><a href="#安装debtap并更新数据" class="headerlink" title="安装debtap并更新数据"></a>安装debtap并更新数据</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>[依赖关系:]</strong> 需要提前安装好<strong> bash， binutils ，pkgfile 和 fakeroot 包</strong><br>如果直接安装会帮你安装依赖.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yaourt -S debtap</span><br></pre></td></tr></table></figure><p>遇到需要编辑的就默认enter跳过，需要安装的就确认，然后等就行了</p><h3 id="创建-更新-pkgfile-和-debtap-数据库。"><a href="#创建-更新-pkgfile-和-debtap-数据库。" class="headerlink" title="创建/更新 pkgfile 和 debtap 数据库。"></a>创建/更新 pkgfile 和 debtap 数据库。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo debtap -u</span><br></pre></td></tr></table></figure><h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><p>假如要转化name.deb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debtap name.deb</span><br></pre></td></tr></table></figure><p>中间可能要输入点东西，自己看情况输入就好</p><p><strong>其他参数：</strong></p><ul><li>略过除了编辑元数据之外的所有问题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debtap -q name.deb</span><br></pre></td></tr></table></figure><ul><li>略过所有的问题（不推荐）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debtap -Q name.deb</span><br></pre></td></tr></table></figure><ul><li>查看帮助</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debtap -h</span><br></pre></td></tr></table></figure><h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><p>使用pacman安装软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -U &lt;package-name&gt;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有时候可能找不到arch用的包，只有deb包或者rpm包。&lt;br&gt;将deb包转换为ArchLinux的包比较方便，使用了debtap这个工具&lt;br&gt;debtap代表了 DEB T o A rch （Linux） P ackage的意思&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://hanielxx.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://hanielxx.com/tags/Linux/"/>
    
      <category term="Deb" scheme="https://hanielxx.com/tags/Deb/"/>
    
      <category term="Debtap" scheme="https://hanielxx.com/tags/Debtap/"/>
    
      <category term="ArchLinux" scheme="https://hanielxx.com/tags/ArchLinux/"/>
    
  </entry>
  
  <entry>
    <title>动态规划套路详解</title>
    <link href="https://hanielxx.com/2019/06/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%A5%97%E8%B7%AF%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hanielxx.com/2019/06/18/动态规划套路详解/</id>
    <published>2019-06-18T06:38:35.000Z</published>
    <updated>2019-07-24T05:37:38.394Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在LeetCode的<a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/" target="_blank" rel="noopener">322题题解</a>中看到一篇动态规划的详解，讲的很清楚，转载记录下</p><p>转自：<a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/" target="_blank" rel="noopener">LeetCode动态规划套路详解</a></p></div><a id="more"></a><h2 id="介绍-amp-闲谈"><a href="#介绍-amp-闲谈" class="headerlink" title="介绍&amp;闲谈"></a>介绍&amp;闲谈</h2><p>下面通过对斐波那契数列和这道凑零钱问题详解动态规划。如果只想看本题的答案，请直接翻到最后查看。</p><p>动态规划算法似乎是一种很高深莫测的算法，你会在一些面试或算法书籍的高级技巧部分看到相关内容，什么状态转移方程，<strong>重叠子问题</strong>，最优子结构等高大上的词汇也可能让你望而却步。</p><p>而且，当你去看用动态规划解决某个问题的代码时，你会觉得这样解决问题竟然如此巧妙，但却难以理解，你可能惊讶于人家是怎么想到这种解法的。</p><p>实际上，动态规划是一种常见的「算法设计技巧」，并没有什么高深莫测，至于各种高大上的术语，那是吓唬别人用的，只要你亲自体验几把，这些名词的含义其实显而易见，再简单不过了。</p><p>至于为什么最终的解法看起来如此精妙，是因为动态规划遵循一套固定的流程：<br>递归的暴力解法 -&gt; 带备忘录的递归解法 -&gt; 非递归的动态规划解法。</p><p>这个过程是层层递进的解决问题的过程，你如果没有前面的铺垫，直接看最终的非递归动态规划解法，当然会觉得牛逼而不可及了。</p><p>当然，见的多了，思考多了，是可以一步写出非递归的动态规划解法的。任何技巧都需要练习，我们先遵循这个流程走，算法设计也就这些套路，除此之外，真的没啥高深的。</p><p>以下，先通过两个个比较简单的例子：斐波那契和凑零钱问题，揭开动态规划的神秘面纱，描述上述三个流程。后续还会写几篇文章探讨如何使用动态规划技巧解决比较复杂的经典问题。</p><p>首先，第一个快被举烂了的例子，斐波那契数列。请读者不要嫌弃这个例子简单，因为简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙。后续，困难的例子有的是。</p><h2 id="步骤一、暴力的递归算法"><a href="#步骤一、暴力的递归算法" class="headerlink" title="步骤一、暴力的递归算法"></a>步骤一、暴力的递归算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。</p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。<br></p><p>这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p><strong>递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。</strong></p><p>子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><h2 id="步骤二、带备忘录的递归解法"><a href="#步骤二、带备忘录的递归解法" class="headerlink" title="步骤二、带备忘录的递归解法"></a>步骤二、带备忘录的递归解法</h2><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    <span class="comment">// 未被计算过</span></span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p>递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。</p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) … f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><h2 id="步骤三、动态规划"><a href="#步骤三、动态规划" class="headerlink" title="步骤三、动态规划"></a>步骤三、动态规划</h2><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「动态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><p>为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程</strong>，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，以上旨在演示算法设计螺旋上升的过程。当问题中要求求一个最优解或在代码中看到循环和 max、min 等函数时，十有八九，需要动态规划大显身手。</p><p>下面，看第二个例子，<strong>凑零钱问题</strong>，有了上面的详细铺垫，这个问题会很快解决。</p><p>题目：给你 k 种面值的硬币，面值分别为 c1, c2 … ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。</p><p>比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 11 = 5 + 5 + 1 。下面走流程。</p><h2 id="CoinChange问题"><a href="#CoinChange问题" class="headerlink" title="CoinChange问题"></a>CoinChange问题</h2><h3 id="一、暴力解法"><a href="#一、暴力解法" class="headerlink" title="一、暴力解法"></a>一、暴力解法</h3><p>首先是最困难的一步，写出状态转移方程，这个问题比较好写：</p>]其实，这个方程就用到了「最优子结构」性质：**原问题的解由子问题的最优解构成**。即 f(11) 由 f(10), f(9), f(6) 的最优解转移而来。记住，**要符合「最优子结构」，子问题间必须互相独立**。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高...... 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高...... 当然，最终就是你每门课都是满分，这就是最高的总成绩。得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。回到凑零钱问题，显然子问题之间没有相互制约，而是互相独立的。所以这个状态转移方程是可以得到正确答案的。之后就没啥难点了，按照方程写暴力递归算法即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="comment">// 金额不可达</span></span><br><span class="line">        <span class="keyword">if</span> (amount - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> subProb = coinChange(coins, amount - coin);</span><br><span class="line">        <span class="comment">// 子问题无解</span></span><br><span class="line">        <span class="keyword">if</span> (subProb == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans = min(ans, subProb + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画出递归树：</p><p>时间复杂度分析：子问题总数 x 每个子问题的时间。子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 <script type="math/tex">O(k\*n^k)</script>，指数级别。</p><h3 id="二、带备忘录的递归算法"><a href="#二、带备忘录的递归算法" class="headerlink" title="二、带备忘录的递归算法"></a>二、带备忘录的递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 备忘录初始化为 -2</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo(amount + <span class="number">1</span>, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> helper(coins, amount, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (memo[amount] != <span class="number">-2</span>) <span class="keyword">return</span> memo[amount];</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="comment">// 金额不可达</span></span><br><span class="line">        <span class="keyword">if</span> (amount - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> subProb = helper(coins, amount - coin, memo);</span><br><span class="line">        <span class="comment">// 子问题无解</span></span><br><span class="line">        <span class="keyword">if</span> (subProb == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans = min(ans, subProb + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录本轮答案</span></span><br><span class="line">    memo[amount] = (ans == INT_MAX) ? <span class="number">-1</span> : ans;</span><br><span class="line">    <span class="keyword">return</span> memo[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p><h3 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="三、动态规划"></a>三、动态规划</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins)</span><br><span class="line">            <span class="keyword">if</span> (coin &lt;= i)</span><br><span class="line">                dp[i] = min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。<strong>算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</strong></p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在LeetCode的&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;322题题解&lt;/a&gt;中看到一篇动态规划的详解，讲的很清楚，转载记录下&lt;/p&gt;
&lt;p&gt;转自：&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode动态规划套路详解&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://hanielxx.com/categories/Notes/"/>
    
    
      <category term="Learning" scheme="https://hanielxx.com/tags/Learning/"/>
    
      <category term="Notes" scheme="https://hanielxx.com/tags/Notes/"/>
    
      <category term="DP" scheme="https://hanielxx.com/tags/DP/"/>
    
      <category term="Reprint" scheme="https://hanielxx.com/tags/Reprint/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-124-Binary Tree Maximum Path Sum</title>
    <link href="https://hanielxx.com/2019/06/13/LeetCode-124-Binary-Tree-Maximum-Path-Sum/"/>
    <id>https://hanielxx.com/2019/06/13/LeetCode-124-Binary-Tree-Maximum-Path-Sum/</id>
    <published>2019-06-13T15:41:23.000Z</published>
    <updated>2019-07-20T12:10:19.189Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>落了好多题没记录了，而且因为刷的是专项，没有按照顺序了，所以….顺序很乱，这阵子就先这样把，后面夏令营结束再按照顺序来，把以前的慢慢补上。</p><p>LeetCode中国还是挺方便的，加载速度比原版的快很多，而且可以中英文切换。</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/submissions/" target="_blank" rel="noopener">Problem</a></h2><p>Given a non-empty binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p><p>求二叉树最大的路径和，任意节点到任意节点的最大路径和</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>[1,2,3]<br><strong>Output:</strong>6<br><strong>Input:</strong>[-10,9,20,null,null,15,7]<br><strong>Output:</strong>42</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>二叉树一般就是递归，这道题也很明显用递归，找到左子树、右子树的最大路径和，一共算了下，大概有一下几种情况</li></ul><ol><li>左子树路径和加根节点值最大</li><li>右子树路径和加根节点值最大</li><li>左右子树路径和都是负数，所以单独的根节点值最大</li><li>左右子树路径和加上根节点值最大，<script type="math/tex">如果左右子树路径和都非负，那肯定就得加上嘛</script></li></ol><p>这里之所以不把左子树路径和与右子树路径和单独列出来，是因为递归到左右子树的时候就相当于判断过来</p><p>按照这样的思路，就可以想到办法了，求左右子树路径和，然后找到最大的一边，加上根节点值，这是前三种情况，再和第四种情况：三者之和 比较，就可以得到最后的结果resSum，然后和全局遍历maxSum比较：<script type="math/tex">maxSum = max(maxSum, resSum)</script></p><ul><li>改进的方法是，判断左右子树的路径和是否小于0，如果小于0，那肯定就不走这边，所以令其为0，最后就变成了一种情况，就是上面的第四种，只要把三者相加，再和全局变量maxSum比较就可以</li></ul><p>解释下，如果某一边大于0，那肯定要加上，如果小于0，不走那边就相当于加上0，就可以</p><p>但是最后的结果发现，虽然第二种办法，将四种情况缩成了一种情况，但是似乎时间会花的更多。第一种情况是32ms，第二种是40ms+。</p><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>递归，第一种解法，判断四种情况的，32ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxSum;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        maxSum = root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> rootGain = maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftGain = maxGain(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightGain = maxGain(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> rootGain = max(leftGain, rightGain)+root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> newPathGain = leftGain + rightGain + root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> resGain = max(newPathGain, rootGain);</span><br><span class="line">        <span class="keyword">if</span>(resGain &gt; maxSum)</span><br><span class="line">            maxSum = resGain;</span><br><span class="line">        <span class="keyword">if</span>(rootGain&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> rootGain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="C-Codes-1"><a href="#C-Codes-1" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>第二种解法，合并成一种情况的，44ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxSum;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        maxSum = root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> rootGain = maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftGain = max(maxGain(root-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightGain = max(maxGain(root-&gt;right), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> newPathGain = leftGain + rightGain + root-&gt;val;</span><br><span class="line">        maxSum = max(newPathGain, maxSum);</span><br><span class="line">        <span class="keyword">return</span> max(leftGain, rightGain)+root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>二叉树一般用递归就好了，查找还是啥操作的，一般递归+剪枝就可以，往这方向想 </li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;落了好多题没记录了，而且因为刷的是专项，没有按照顺序了，所以….顺序很乱，这阵子就先这样把，后面夏令营结束再按照顺序来，把以前的慢慢补上。&lt;/p&gt;
&lt;p&gt;LeetCode中国还是挺方便的，加载速度比原版的快很多，而且可以中英文切换。&lt;/p&gt;
&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a non-empty binary tree, find the maximum path sum.&lt;/p&gt;
&lt;p&gt;For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.&lt;/p&gt;
&lt;p&gt;求二叉树最大的路径和，任意节点到任意节点的最大路径和&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;[1,2,3]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;6&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt;[-10,9,20,null,null,15,7]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;42&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Hard" scheme="https://hanielxx.com/tags/Hard/"/>
    
      <category term="DP" scheme="https://hanielxx.com/tags/DP/"/>
    
      <category term="Recursive" scheme="https://hanielxx.com/tags/Recursive/"/>
    
      <category term="BinaryTree" scheme="https://hanielxx.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-125-Valid Palindrome</title>
    <link href="https://hanielxx.com/2019/06/02/LeetCode-125-Valid-Palindrome/"/>
    <id>https://hanielxx.com/2019/06/02/LeetCode-125-Valid-Palindrome/</id>
    <published>2019-06-01T16:55:08.000Z</published>
    <updated>2019-07-20T12:10:19.189Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">Problem</a></h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>“A man, a plan, a canal: Panama”<br><strong>Output:</strong>true</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>如果是单纯的回文串验证，那很简单，很多种方法</li><li>可以直接用函数将字符串逆序作比较</li><li>可以用两个指针指向头和尾，逐个字符比较</li><li>这道题因为还有空格，标点符号，大小写的问题，需要简单的处理下</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>8ms，超99%</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//全部变成小写并去掉非数字和字符的</span></span><br><span class="line">        transform(s.begin(),s.end(),s.begin(),::<span class="built_in">tolower</span>);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((s[i]&gt;=<span class="string">'0'</span> &amp;&amp; s[i]&lt;=<span class="string">'9'</span>) || (s[i]&gt;=<span class="string">'a'</span> &amp;&amp; s[i]&lt;=<span class="string">'z'</span>)) </span><br><span class="line">                res+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.empty()) <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=res.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;res.length() &amp;&amp; r&gt;=<span class="number">0</span> &amp;&amp; l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[l]==res[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info"><p>C++里面没有直接对字符串进行全部转换大写或者小写的方法<br>可以用<code>transform(s.begin(),s.end(),s.begin(),::tolower)</code><br>更多方法可以进行百度，如果懒得找也可以自己遍历字符修改大小写</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>要注意的就是字符串的预处理，并且处理之后如果是空串要返回true </li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.&lt;/p&gt;
&lt;p&gt;Note: For the purpose of this problem, we define empty string as valid palindrome.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;“A man, a plan, a canal: Panama”&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;true&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="String" scheme="https://hanielxx.com/tags/String/"/>
    
      <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
      <category term="Palindrome" scheme="https://hanielxx.com/tags/Palindrome/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-088-Merge Sorted Array</title>
    <link href="https://hanielxx.com/2019/06/02/LeetCode-088-Merge-Sorted-Array/"/>
    <id>https://hanielxx.com/2019/06/02/LeetCode-088-Merge-Sorted-Array/</id>
    <published>2019-06-01T16:40:13.000Z</published>
    <updated>2019-07-20T12:10:19.189Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">Problem</a></h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p><p><strong>Note:</strong> </p><ul><li>The number of elements initialized in nums1 and nums2 are m and n respectively.</li><li>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</li></ul><p>合并两个有序数组，合并到第一个数组里</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br><strong>Output:</strong><br>[1,2,2,3,5,6]</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>简单题，所以可以直接暴力求解</li><li>先把第一个数组备份到tmp，然后对tmp和第二个数组进行合并，结果放到nums1里面就行</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>12ms，超90%，大部分人都是这个时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            tmp.push_back(nums1[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>, i, j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;m &amp;&amp; j&lt;n;cnt++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]&lt;nums2[j])&#123;</span><br><span class="line">                nums1[cnt]=tmp[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[cnt]=nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m) nums1[cnt++]=tmp[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n) nums1[cnt++]=nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果是多个链表合并，不是这种有序数组两个合并的，可以看另一个题目，网站搜索合并多个链表</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of elements initialized in nums1 and nums2 are m and n respectively.&lt;/li&gt;
&lt;li&gt;You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合并两个有序数组，合并到第一个数组里&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nums1 = [1,2,3,0,0,0], m = 3&lt;br&gt;nums2 = [2,5,6],       n = 3&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;br&gt;[1,2,2,3,5,6]&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
      <category term="Array" scheme="https://hanielxx.com/tags/Array/"/>
    
      <category term="Merge" scheme="https://hanielxx.com/tags/Merge/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-240-Search a 2D Matrix II</title>
    <link href="https://hanielxx.com/2019/06/02/LeetCode-240-Search-a-2D-Matrix-II/"/>
    <id>https://hanielxx.com/2019/06/02/LeetCode-240-Search-a-2D-Matrix-II/</id>
    <published>2019-06-01T16:29:32.000Z</published>
    <updated>2019-07-20T12:10:19.189Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">Problem</a></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><p>简单点说就是二维数组，从左向右递增，从上向下递增，然后查找输入的数组，要求高效</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br><strong>Output:</strong><br>Given target = 5, return true.<br>Given target = 20, return false.</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>如果是<script type="math/tex">O(n)</script>可能不行，毕竟要高效的算法，这里从数组的结构入手</li><li>以右上角为起点进行查找，如果比它大，就向下，如果比它小，就向左，一直找到边界位置</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>用时108ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="comment">//边界条件就是col&gt;=0 &amp;&amp; row&lt;n</span></span><br><span class="line">        <span class="keyword">while</span>(col&gt;=<span class="number">0</span> &amp;&amp; row&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col]&gt;target)</span><br><span class="line">                col--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col]&lt;target)</span><br><span class="line">                row++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对于这种排序好结构很明显的，尽量从结构上入手，找特点，而不是暴力解</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-a-2d-matrix-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Integers in each row are sorted in ascending from left to right.&lt;/li&gt;
&lt;li&gt;Integers in each column are sorted in ascending from top to bottom.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单点说就是二维数组，从左向右递增，从上向下递增，然后查找输入的数组，要求高效&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[&lt;br&gt;  [1,   4,  7, 11, 15],&lt;br&gt;  [2,   5,  8, 12, 19],&lt;br&gt;  [3,   6,  9, 16, 22],&lt;br&gt;  [10, 13, 14, 17, 24],&lt;br&gt;  [18, 21, 23, 26, 30]&lt;br&gt;]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;br&gt;Given target = 5, return true.&lt;br&gt;Given target = 20, return false.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
      <category term="Matrix" scheme="https://hanielxx.com/tags/Matrix/"/>
    
      <category term="Search" scheme="https://hanielxx.com/tags/Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-136-Single Number</title>
    <link href="https://hanielxx.com/2019/05/26/LeetCode-136-Single-Number/"/>
    <id>https://hanielxx.com/2019/05/26/LeetCode-136-Single-Number/</id>
    <published>2019-05-25T16:57:09.000Z</published>
    <updated>2019-07-20T12:10:19.189Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到有算法面试集锦，刷点题，刚开始刷，前面都是简单题，随便看看了</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">Problem</a></h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p><p><strong>Note:</strong><br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>[2,2,1]<br><strong>Output:</strong>1</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>刚开始就是向简单的遍历一遍，用map存出现次数，但是要<script type="math/tex">O(1)</script> 的空间复杂度，所以不可以</li><li>然后想到排序，排序完找，但是要线性时间复杂度。。。</li><li>最后是用异或的方法，因为题目说的是，只有一个出现一次，其他的全部出现两次</li><li>两个相同的数异或（XOR），结果为0，0和0异或当然还是0，然后就剩下了单独的一个数字，0和非0数异或等于非0数本身</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>时间复杂度<script type="math/tex">O(n)</script>，空间复杂度<script type="math/tex">O(1)</script></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            res = res^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>注意题目细节，每个重复的数字都是出现两次 </li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;看到有算法面试集锦，刷点题，刚开始刷，前面都是简单题，随便看看了&lt;/p&gt;
&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/single-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a non-empty array of integers, every element appears twice except for one. Find that single one.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;[2,2,1]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;1&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://hanielxx.com/tags/Math/"/>
    
      <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
      <category term="Xor" scheme="https://hanielxx.com/tags/Xor/"/>
    
      <category term="Linear" scheme="https://hanielxx.com/tags/Linear/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-026-Remove Duplicates from Sorted Array</title>
    <link href="https://hanielxx.com/2019/05/26/LeetCode-026-Remove-Duplicates-from-Sorted-Array/"/>
    <id>https://hanielxx.com/2019/05/26/LeetCode-026-Remove-Duplicates-from-Sorted-Array/</id>
    <published>2019-05-25T16:56:26.000Z</published>
    <updated>2019-07-20T12:10:19.189Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">Problem</a></h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>[1,1,2]<br><strong>Output:</strong>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the returned length.</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>简单说就是去掉<strong>排好序的</strong>重复元素的嘛，然后要求空间复杂度<script type="math/tex">O(1)</script></li><li>利用双指针的思想，第一个指针指向排好序的最后一个元素，第二个指针指向当前的元素</li><li>如果当前元素不等于第一个指针指向的元素，那第一个指针自增，并赋值当前元素值</li><li>还有一种也能过的本办法，已经排序好了，所以遇到一个重复的删除一个就行，不过时间会花的很多</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>双指针法，时间复杂度是<script type="math/tex">O(n)</script>，花了32ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pre指向无重复排好序的最后一个位置</span></span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[pre])&#123;</span><br><span class="line">                pre++;</span><br><span class="line">                nums[pre]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="C-Codes-1"><a href="#C-Codes-1" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>暴力删除法，时间复杂度<script type="math/tex">O(n)</script>，用时252ms<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>双指针很多时候都是能用上的，特别是就地算法，或者查找、排序等算法 </li><li>简单题就不写Py的版本了</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;[1,1,2]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the returned length.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
      <category term="Array" scheme="https://hanielxx.com/tags/Array/"/>
    
      <category term="Duplicates" scheme="https://hanielxx.com/tags/Duplicates/"/>
    
      <category term="Sort" scheme="https://hanielxx.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-169-Majority Element</title>
    <link href="https://hanielxx.com/2019/05/26/LeetCode-169-Majority-Element/"/>
    <id>https://hanielxx.com/2019/05/26/LeetCode-169-Majority-Element/</id>
    <published>2019-05-25T16:55:31.000Z</published>
    <updated>2019-07-20T12:10:19.189Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">Problem</a></h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>[3,2,3]<br><strong>Output:</strong>3<br><strong>Input:</strong>[2,2,1,1,1,2,2]<br><strong>Output:</strong>2</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>找众数嘛，只要记录下来他们每个出现的次数就好了啊</li><li>用map存放每个数字出现的次数，然后遇到比n/2.0大的就return</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>时间复杂度<script type="math/tex">O(n)</script>,用时32ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mymap.count(nums[i])==<span class="number">1</span>)</span><br><span class="line">                mymap[nums[i]] = mymap[nums[i]]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mymap[nums[i]] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mymap[nums[i]]&gt;n/<span class="number">2.0</span>)&#123;</span><br><span class="line">                res = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>简单题就不写py版本了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>map真好用。。真香</li><li>数据量特别大的时候，可以用hash_map</li><li>map的查找方式是二分查找，如果是100万条记录，最多也只要20次的string.compare的比较，200万条记录，也只要用21次的比较</li><li>如果想要在如此大的记录量下，只用一两次的string.compare就找到记录，那就要用hash_map</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/majority-element/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.&lt;/p&gt;
&lt;p&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;[3,2,3]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;3&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt;[2,2,1,1,1,2,2]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;2&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://hanielxx.com/tags/Math/"/>
    
      <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
      <category term="Map" scheme="https://hanielxx.com/tags/Map/"/>
    
      <category term="Majority" scheme="https://hanielxx.com/tags/Majority/"/>
    
  </entry>
  
  <entry>
    <title>C++优先级队列</title>
    <link href="https://hanielxx.com/2019/05/23/C-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <id>https://hanielxx.com/2019/05/23/C-优先级队列/</id>
    <published>2019-05-23T05:42:24.000Z</published>
    <updated>2019-07-24T05:38:38.858Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写LeetCode的时候学了优先级队列，这里总结一下STL中优先级队列的使用和实现</p></div><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>优先级队列也是队列的一种，FIFO结构，但是和普通的队列不同的是有一个优先级的权重</p><p>优先级队列有两种，一种是最小优先队列，值小的优先级越大，另一种是最大优先队列，值大的优先级越大</p><p>头文件： “queue.h”, “functional.h”</p><p>插入和删除操作复杂度都是<script type="math/tex">O(lgn)</script></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;T&gt; pq;</span><br><span class="line">std::priority_queue&lt;T, std::vector&lt;T&gt;, cmp&gt; pq;</span><br></pre></td></tr></table></figure></p><p><strong>第一种构造函数：</strong></p><ul><li>传入一个基本类型或者自定义类，自定义类要重载<script type="math/tex"><</script>符号</li></ul><p><strong>第二种构造函数：</strong><br>参数介绍：</p><ol><li>是队列中元素的种类，可以是自定义的也可以是基本类型，默认是int</li><li>第二个是容纳优先级队列的容器，只需要知道默认是vector就好，使用的时候也是用vector</li><li>这个是最重要的参数，支持一个比较函数，默认是less，队列是最大优先队列。</li></ol><p>第三个参数有三种情况介绍：</p><ol><li>自定义比较结构，使用结构体，<strong>注意返回值！！</strong>，最小优先队列是大于</li><li>使用默认的类型时用less()或者greater()</li><li>使用自定义类的时候重载<script type="math/tex"><</script>符号</li></ol><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ol><li>q.empty(): 如果队列为空，则返回true，否则返回false</li><li>q.size():  返回队列中元素的个数</li><li>q.pop():   删除队首元素，但不返回其值</li><li>q.top():   返回具有最高优先级的元素值，最大优先队列找最大的元素，最小优先队列找最小的，但不删除该元素</li><li>q.push(item): 在基于优先级的适当位置插入新元素</li></ol><h3 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h3><p>注意这不是一个完整的C++代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含头文件并使用std命名空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种构造函数，采用默认优先级构造队列</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种构造函数，这里使用基本的int类型，如果看其他类型，请看LeetCode 23题代码</span></span><br><span class="line"><span class="comment">//自定义比较结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp1</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;<span class="comment">//最小值优先</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp1&gt;que1;<span class="comment">//最小值优先</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;que3;<span class="comment">//注意“&gt;&gt;”会被认为错误，greater在functional头文件中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据结构并重载小于操作符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">number1</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> number1 &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x&gt;a.x;<span class="comment">//最小值优先</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;number1&gt;que5; <span class="comment">//最小优先级队列</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"采用默认优先关系:/n(priority_queue&lt;int&gt;que;)/n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Queue 0:/n"</span>);</span><br><span class="line"><span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%3d"</span>,que.top());</span><br><span class="line">    que.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>引用博客：<a href="https://www.cnblogs.com/luoxn28/p/5616101.html" target="_blank" rel="noopener">优先队列原理与实现</a><br>推荐结合另一篇博客: <a href="https://blog.csdn.net/xiajun07061225/article/details/8556786" target="_blank" rel="noopener">【STL学习】优先级队列Priority Queue详解与C++编程实现</a><br>可以看这两篇博客了解插入和删除的原理，第一篇博客有图比较清楚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package priorityheap;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 优先队列类（最大优先队列）</span><br><span class="line"> */</span><br><span class="line">public class PriorityHeap &#123;</span><br><span class="line"></span><br><span class="line">    // ------------------------------ Instance Variables</span><br><span class="line"></span><br><span class="line">    private int[] arr;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    // ------------------------------ Constructors</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 优先队列数组默认大小为64</span><br><span class="line">     */</span><br><span class="line">    public PriorityHeap() &#123;</span><br><span class="line">        this(64);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PriorityHeap(int initSize) &#123;</span><br><span class="line">        if (initSize &lt;= 0) &#123;</span><br><span class="line">            initSize = 64;</span><br><span class="line">        &#125;</span><br><span class="line">        this.arr = new int[initSize];</span><br><span class="line">        this.size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ------------------------------ Public methods</span><br><span class="line"></span><br><span class="line">    public int max() &#123;</span><br><span class="line">        return this.arr[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int maxAndRemove() &#123;</span><br><span class="line">        int t = max();</span><br><span class="line"></span><br><span class="line">        this.arr[0] = this.arr[--size];</span><br><span class="line">        sink(0, this.arr[0]);</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void add(int data) &#123;</span><br><span class="line">        resize(1);</span><br><span class="line">        this.arr[size++] = data;</span><br><span class="line">        pop(size - 1, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ------------------------------ Private methods</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key下沉方法</span><br><span class="line">     */</span><br><span class="line">    private void sink(int i, int key) &#123;</span><br><span class="line">        while (2 * i &lt;= this.size - 1) &#123;</span><br><span class="line">            int child = 2 * i;</span><br><span class="line">            if (child &lt; this.size - 1 &amp;&amp; this.arr[child] &lt; this.arr[child + 1]) &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.arr[i] &gt;= this.arr[child]) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(i, child);</span><br><span class="line">            i = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key上浮方法</span><br><span class="line">     */</span><br><span class="line">    private void pop(int i, int key) &#123;</span><br><span class="line">        while (i &gt; 0) &#123;</span><br><span class="line">            int parent = i / 2;</span><br><span class="line">            if (this.arr[i] &lt;= this.arr[parent]) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(i, parent);</span><br><span class="line">            i = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重新调整数组大小</span><br><span class="line">     */</span><br><span class="line">    private void resize(int increaseSize) &#123;</span><br><span class="line">        if ((this.size + increaseSize) &gt; this.arr.length) &#123;</span><br><span class="line">            int newSize = (this.size + increaseSize) &gt; 2 * this.arr.length ? (this.size + increaseSize) : 2 * this.arr.length;</span><br><span class="line">            int[] t = this.arr;</span><br><span class="line"></span><br><span class="line">            this.arr = Arrays.copyOf(t, newSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Swaps arr[a] with arr[b].</span><br><span class="line">     */</span><br><span class="line">    private void swap(int a, int b) &#123;</span><br><span class="line">        int t = this.arr[a];</span><br><span class="line">        this.arr[a] = this.arr[b];</span><br><span class="line">        this.arr[b] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;写LeetCode的时候学了优先级队列，这里总结一下STL中优先级队列的使用和实现&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://hanielxx.com/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://hanielxx.com/tags/Notes/"/>
    
      <category term="C++" scheme="https://hanielxx.com/tags/C/"/>
    
      <category term="Queue" scheme="https://hanielxx.com/tags/Queue/"/>
    
      <category term="PriorityQueue" scheme="https://hanielxx.com/tags/PriorityQueue/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-023-Merge k Sorted Lists</title>
    <link href="https://hanielxx.com/2019/05/23/LeetCode-023-Merge-k-Sorted-Lists/"/>
    <id>https://hanielxx.com/2019/05/23/LeetCode-023-Merge-k-Sorted-Lists/</id>
    <published>2019-05-23T05:10:02.000Z</published>
    <updated>2019-07-20T12:10:19.189Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">Problem</a></h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>[<br>　　1-&gt;4-&gt;5,<br>　　1-&gt;3-&gt;4,<br>　　2-&gt;6<br>]<br><strong>Output:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>相对上一题难度加大了一点，但是如果按照上一题的思路也是可以做的，就是时间复杂度会有点高</li><li>这里介绍两种方法，第一种就是类似上一题的解法，每次循环找到所有链表中最小的头结点，然后改变指针指向，并不新建节点，中间有个坑是测试用例中会有空的链表，要注意处理下。每次加一个节点，加的时候遍历所有链表，所以时间复杂度是<script type="math/tex">O(n \times k)</script>,n是节点总数，k是链表数</li><li>第二种方法是使用优先级队列，先将所有链表加入队列中，每次从队列中找到最小的节点，然后也是找n个节点，相对上一种方法是在<script type="math/tex">O(n \times k)</script>的k这里进行了优化，因为优先级队列存取是log()级别，因此时间复杂度是<script type="math/tex">O(n \times log(k))</script></li><li>还想到一种方法是迭代，用上一题的方法进行两两合并，没有实现这种方法，看了题解有分治法，使用递归进两两合并</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>就地改变链表指针指向，时间复杂度<script type="math/tex">O(n \times k)</script></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *pre = res;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(lists.size()!=<span class="number">0</span>)&#123; </span><br><span class="line">            <span class="comment">//确保lists[0]非NULL</span></span><br><span class="line">            <span class="keyword">while</span>(lists.size()&gt;<span class="number">0</span> &amp;&amp; lists[min]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                lists.erase(lists.begin()+min);</span><br><span class="line">                min = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lists.size()==<span class="number">0</span>) <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lists[i]==<span class="literal">NULL</span>) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(lists[i]-&gt;val&lt;lists[min]-&gt;val)</span><br><span class="line">                    min = i;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = lists[min];</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            lists[min] = lists[min]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用优先级队列进行每轮插入最小的节点，时间复杂度为<script type="math/tex">O(n \times log(k))</script></p><p>这里使用最小优先队列，最小的值优先级最大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义优先级队列比较结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//建立优先级队列，这里是最小优先队列，最小的值优先级最大</span></span><br><span class="line">        priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* <span class="built_in">list</span> : lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">list</span>!=<span class="literal">NULL</span>) pq.push(<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pq.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            p-&gt;next = pq.top();<span class="comment">//获取优先级最高的元素，即数字最小的</span></span><br><span class="line">            pq.pop();<span class="comment">//删除队首元素</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>) pq.push(p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>分治法，使用递归两两合并，最终的链表等于合并好的前半部分加上合并好的后半部分，对前半部分在进行半部分和半部分的合并。</p><p>下面贴一下题解的代码，Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        ListNode l1 = merge(lists, left, mid);</span><br><span class="line">        ListNode l2 = merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>这里使用方法二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        head = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">            <span class="keyword">if</span> lists[i] :</span><br><span class="line">                heapq.heappush(head, (lists[i].val, i))</span><br><span class="line">                lists[i] = lists[i].next</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            val, idx = heapq.heappop(head)</span><br><span class="line">            p.next = ListNode(val)</span><br><span class="line">            p = p.next</span><br><span class="line">            <span class="keyword">if</span> lists[idx]:</span><br><span class="line">                heapq.heappush(head, (lists[idx].val, idx))</span><br><span class="line">                lists[idx] = lists[idx].next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>合并多个链表相对上一题就是链表数变多之后的处理，可以用优先级队列加快节点的查找，也可以使用分治法，合并症各部分就是先合并前半部分和后半部分，再将这两个部分合在一起 </li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-k-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[&lt;br&gt;　　1-&amp;gt;4-&amp;gt;5,&lt;br&gt;　　1-&amp;gt;3-&amp;gt;4,&lt;br&gt;　　2-&amp;gt;6&lt;br&gt;]&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="PriorityQueue" scheme="https://hanielxx.com/tags/PriorityQueue/"/>
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Hard" scheme="https://hanielxx.com/tags/Hard/"/>
    
      <category term="LinkedList" scheme="https://hanielxx.com/tags/LinkedList/"/>
    
      <category term="List" scheme="https://hanielxx.com/tags/List/"/>
    
      <category term="Merge" scheme="https://hanielxx.com/tags/Merge/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-021-Merge Two Sorted Lists</title>
    <link href="https://hanielxx.com/2019/05/23/LeetCode-021-Merge-Two-Sorted-Lists/"/>
    <id>https://hanielxx.com/2019/05/23/LeetCode-021-Merge-Two-Sorted-Lists/</id>
    <published>2019-05-22T16:28:14.000Z</published>
    <updated>2019-07-20T12:10:19.189Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="">Problem</a></h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p>简单说就是合并两个有序链表</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>Output:</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>第一种方法是新建一个链表，每次创建新的节点，不影响原始链表。在两个链表都非空的是比较结点值大小，将小的值作为新节点的值插入结果链表中，并移动指针。</li><li>第二种方法也挺简单，只是单纯的改变指针，就地合并，但是会影响原始链表。</li><li>Python使用的方法，递归，也是就地的，前面的较小的节点加上后面所有的排好序的节点就是要的结果</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>创建一个头结点，依次比较l1和l2的节点，逐个插入到新链表中，插入过程是创建了新的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = res;</span><br><span class="line">        ListNode *p1 = l1;</span><br><span class="line">        ListNode *p2 = l2;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">NULL</span> &amp;&amp; p2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val &gt; p2-&gt;val)&#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> ListNode(p2-&gt;val);</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> ListNode(p1-&gt;val);</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(p1-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(p2-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>这种方法也可以像方法一那样，创建一个头结点，然后比较l1和l2，依次改变两个链表的指针</p><p>我用了另一种就地方法，其中一个链表不变，另一个链表依次找到合适位置插入这个这个链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//p1: 结果链表头结点，指向较小的</span></span><br><span class="line">        <span class="comment">//p2: 另一个链表的头结点</span></span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode *p1, *p2;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            p1 = l1; p2 = l2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p1 = l2; p2 = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *prefix=p1, *res = p1;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//找到p2指向的节点第一次小于p1节点的位置，前插</span></span><br><span class="line">            <span class="keyword">while</span>(p1!=<span class="literal">NULL</span> &amp;&amp; p2-&gt;val &gt; p1-&gt;val)&#123;</span><br><span class="line">                prefix = prefix-&gt;next;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//p1到结尾</span></span><br><span class="line">            <span class="keyword">if</span>(p1==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                prefix-&gt;next = p2;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prefix-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">                prefix-&gt;next-&gt;next = p1;</span><br><span class="line">                prefix = prefix-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>递归的方法，每次保证递归返回的是较小的节点</p><p>这里用了交换l1和l2指针的方法，事实证明….不交换直接判断哪个小来调用递归时间少一点…佛了，交换是64ms，不交换是48ms…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span> l1.val&gt;l2.val: l1, l2 = l2, l1</span><br><span class="line">        l1.next = self.mergeTwoLists(l1.next,l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>链表的问题这里总结是两种方法，一种是迭代，一种是递归，迭代过程中要注意节点指针不要混乱了。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;
&lt;p&gt;简单说就是合并两个有序链表&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
      <category term="LinkedList" scheme="https://hanielxx.com/tags/LinkedList/"/>
    
      <category term="List" scheme="https://hanielxx.com/tags/List/"/>
    
      <category term="Merge" scheme="https://hanielxx.com/tags/Merge/"/>
    
  </entry>
  
</feed>
