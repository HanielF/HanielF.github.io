<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Catch Your Dream</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://catchdream.me/"/>
  <updated>2019-04-26T18:01:08.315Z</updated>
  <id>https://catchdream.me/</id>
  
  <author>
    <name>Haniel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-010-Regular Expression Matching</title>
    <link href="https://catchdream.me/2019/04/27/LeetCode-010-Regular-Expression-Matching/"/>
    <id>https://catchdream.me/2019/04/27/LeetCode-010-Regular-Expression-Matching/</id>
    <published>2019-04-26T17:43:57.000Z</published>
    <updated>2019-04-26T18:01:08.315Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">Problem</a></h2><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*‘.</p><blockquote><p>‘.’ Matches any single character.<br>‘*‘ Matches zero or more of the preceding element.</p></blockquote><p>The matching should cover the entire input string (not partial).</p><p><strong>Note</strong>:</p><blockquote><p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.</p></blockquote><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong> s=”aa” p=”a”<br><strong>Output:</strong> false<br><strong>Input:</strong> s=”aa” p=”a*“<br><strong>Output:</strong> true<br><strong>Input:</strong> s=”ab” p=”.*“<br><strong>Output:</strong> true<br><strong>Input:</strong> s=”aab” p=”c*a*b”<br><strong>Output:</strong> true<br><strong>Input:</strong> s=”mississippi” p=”mis*is*p*.”<br><strong>Output:</strong> false</p><p>佛了，一道题搞了两个多小时，还是有bug…貌似方法错了，题解说了递归和DP，我用到了递归，可还是不行，DP就直接没想到，先码着回头改</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>递归</li><li>DP动态规划</li></ul><h2 id="Java-Codes"><a href="#Java-Codes" class="headerlink" title="Java Codes"></a>Java Codes</h2><p><strong>递归方法，题解上的Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern.isEmpty()) <span class="keyword">return</span> text.isEmpty();</span><br><span class="line">        <span class="keyword">boolean</span> first_match = (!text.isEmpty() &amp;&amp;</span><br><span class="line">                               (pattern.charAt(<span class="number">0</span>) == text.charAt(<span class="number">0</span>) || pattern.charAt(<span class="number">0</span>) == <span class="string">'.'</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern.length() &gt;= <span class="number">2</span> &amp;&amp; pattern.charAt(<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (isMatch(text, pattern.substring(<span class="number">2</span>)) ||</span><br><span class="line">                    (first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自上而下的DP</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Result &#123;</span><br><span class="line">    TRUE, FALSE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Result[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> Result[text.length() + <span class="number">1</span>][pattern.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>, text, pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j] == Result.TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (j == pattern.length())&#123;</span><br><span class="line">            ans = i == text.length();</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> first_match = (i &lt; text.length() &amp;&amp;</span><br><span class="line">                                   (pattern.charAt(j) == text.charAt(i) ||</span><br><span class="line">                                    pattern.charAt(j) == <span class="string">'.'</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                ans = (dp(i, j+<span class="number">2</span>, text, pattern) ||</span><br><span class="line">                       first_match &amp;&amp; dp(i+<span class="number">1</span>, j, text, pattern));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = first_match &amp;&amp; dp(i+<span class="number">1</span>, j+<span class="number">1</span>, text, pattern);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i][j] = ans ? Result.TRUE : Result.FALSE;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自下而上的DP</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[text.length() + <span class="number">1</span>][pattern.length() + <span class="number">1</span>];</span><br><span class="line">        dp[text.length()][pattern.length()] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = text.length(); i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = pattern.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> first_match = (i &lt; text.length() &amp;&amp;</span><br><span class="line">                                       (pattern.charAt(j) == text.charAt(i) ||</span><br><span class="line">                                        pattern.charAt(j) == <span class="string">'.'</span>));</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || first_match &amp;&amp; dp[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = first_match &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>暂时码着自己代码，还有bug，在s遍历完了，p没遍历完时会出错…代码太丑陋了，只会暴力吗，僵硬…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> si=<span class="number">0</span>,pi=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sn=s.length(), pn=p.length();</span><br><span class="line">        <span class="keyword">for</span>(pi;pi&lt;pn,si&lt;sn;pi++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;s.substr(si)&lt;&lt;<span class="string">"\t"</span>&lt;&lt;p.substr(pi)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">switch</span>(p[pi])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'.'</span>:        <span class="comment">//任意单个字符</span></span><br><span class="line">                    si++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:        <span class="comment">//零个或者多个前面的元素</span></span><br><span class="line">                    <span class="keyword">if</span>(p[pi<span class="number">-1</span>]==<span class="string">'.'</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(pi==pn<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//如果.*是最后两个字符，直接返回true</span></span><br><span class="line">                        <span class="keyword">while</span>((p[pi+<span class="number">1</span>]==<span class="string">'.'</span>||p[pi+<span class="number">1</span>]==<span class="string">'*'</span>)&amp;&amp;pi&lt;pn)&#123; <span class="comment">//如果后面持续特殊字符</span></span><br><span class="line">                            pi++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(pi==pn)<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//如果到最后全是特殊字符</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//p[pi+1]是普通字符,让si++,找s[si]==p[pi+1]</span></span><br><span class="line">                        <span class="keyword">while</span>(s[si]!=p[pi+<span class="number">1</span>] &amp;&amp; si&lt;sn) si++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(p[pi<span class="number">-1</span>]!=s[si])<span class="comment">//零个</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//一个或者多个,后面部分的需要也匹配</span></span><br><span class="line">                    <span class="keyword">if</span>(p[pi<span class="number">-1</span>]==s[si])si++;</span><br><span class="line">                    <span class="keyword">if</span>(si==sn &amp;&amp; pi==pn<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(si==sn)si--;</span><br><span class="line">                    <span class="keyword">while</span>(p[pi<span class="number">-1</span>]==s[si] &amp;&amp;(si&lt;sn &amp;&amp; pi+<span class="number">1</span>&lt;pn &amp;&amp; isMatch(s.substr(si),p.substr(pi+<span class="number">1</span>))==<span class="literal">false</span>))&#123;</span><br><span class="line">                        si++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">if</span>(p[pi]==s[si] &amp;&amp; si&lt;sn)&#123;           <span class="comment">//相等就继续遍历</span></span><br><span class="line">                        si++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="comment">//不等，则判断后面是否有*，如果有，这个字符可以跳过,注意这里si并没有自增</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(p[pi]!=s[si] &amp;&amp; pi+<span class="number">1</span>&lt;pn &amp;&amp; p[pi+<span class="number">1</span>]==<span class="string">'*'</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pi==pn &amp;&amp; si==sn)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>评论区有人一行正则就搞定了，我觉得，python一行也够了…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>正则匹配这里，其实应该先想到递归和DP的，但是思维太局限，训练的少，虽然会递归和DP，但是想不起来用..仿佛读了假书..</li><li>算法题需要训练，不光是会算法，不然都不知道题目应该用什么算法…</li><li>后面还要改</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/regular-expression-matching/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*‘.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;‘.’ Matches any single character.&lt;br&gt;‘*‘ Matches zero or more of the preceding element.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The matching should cover the entire input string (not partial).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;s could be empty and contains only lowercase letters a-z.&lt;br&gt;p could be empty and contains only lowercase letters a-z, and characters like . or *.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; s=”aa” p=”a”&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; false&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt; s=”aa” p=”a*“&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; true&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt; s=”ab” p=”.*“&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; true&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt; s=”aab” p=”c*a*b”&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; true&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt; s=”mississippi” p=”mis*is*p*.”&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt; false&lt;/p&gt;
&lt;p&gt;佛了，一道题搞了两个多小时，还是有bug…貌似方法错了，题解说了递归和DP，我用到了递归，可还是不行，DP就直接没想到，先码着回头改&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode, DP, String, Match" scheme="https://catchdream.me/tags/LeetCode-DP-String-Match/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-009-Palindrome Number</title>
    <link href="https://catchdream.me/2019/04/19/LeetCode-009-Palindrome-Number/"/>
    <id>https://catchdream.me/2019/04/19/LeetCode-009-Palindrome-Number/</id>
    <published>2019-04-18T16:24:57.000Z</published>
    <updated>2019-04-18T16:34:33.087Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">Problem</a></h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>121<br><strong>Output:</strong>true<br><strong>Input:</strong>-121<br><strong>Output:</strong>true</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>首先想到的肯定是转成字符串，然后前后每个数判断是否相等，遇到不等的就return，这种方法会创建一个字符串，可能会慢一点</li><li>另一种方法也很容易想，就是把数字翻转过来嘛，再比较，相等的就是回文数了，但是可能会出现翻转后的数字溢出的问题，所以，可以只把后半部分的数字翻转，和前半部分的数字比较，如果是奇数位，可以把多一位的那部分除以10再比较。</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>转成字符串的方法，36ms，8.2MB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(int x) &#123;</span><br><span class="line">        string xstr = to_string(x);</span><br><span class="line">        int n = xstr.length();</span><br><span class="line">        for(int i=0;i&lt;n/2;i++)&#123;</span><br><span class="line">            if(xstr[i]!=xstr[n-i-1]) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>Python的代码和这个几乎一样，就不写了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>因为是简单题，所以没啥思维难度，很容易想到方法，要注意的还是细节上面小心点 </li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/palindrome-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;121&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;true&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt;-121&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;true&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="String" scheme="https://catchdream.me/tags/String/"/>
    
      <category term="Palindrome" scheme="https://catchdream.me/tags/Palindrome/"/>
    
  </entry>
  
  <entry>
    <title>MNIST入门-手写数字识别问题集锦</title>
    <link href="https://catchdream.me/2019/04/18/MNIST%E5%85%A5%E9%97%A8-%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>https://catchdream.me/2019/04/18/MNIST入门-手写数字识别问题集锦/</id>
    <published>2019-04-17T18:12:37.000Z</published>
    <updated>2019-04-18T16:26:37.846Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>记录一下手写数字识别这个项目过程中遇到的问题，以及解决方法，还有一些图像处理方面的文章推荐</p></div><a id="more"></a><h2 id="canvas画笔位置有偏移"><a href="#canvas画笔位置有偏移" class="headerlink" title="canvas画笔位置有偏移"></a>canvas画笔位置有偏移</h2><ul><li>使用<code>window.innerHeight || document.documentElement.clientHeight</code>语句获取视窗高度，同理获得宽度</li><li>移动端获得视窗的高度和宽度后，根据高视窗的大小设置canvas大小，以及下方按钮文字等大小</li><li>PC端通过canvas的<code>mousedown、mousemove、mouseup</code>这三个事件绘图，画笔的起始点和新点用<code>event.clientX - canvas.offsetLeft</code>获取x，同理获取y,</li><li>移动端用<code>touchstart、touchmove、touchend</code>这三个事件，画笔的起始点和终点都用<code>event.targetTouches[0].clientX - canvas.offsetLeft</code>获取x，<code>event.targetTouches[0].clientY - canvas.offsetTop</code>获取y</li></ul><h2 id="canvas用二次贝塞尔曲线绘图"><a href="#canvas用二次贝塞尔曲线绘图" class="headerlink" title="canvas用二次贝塞尔曲线绘图"></a>canvas用二次贝塞尔曲线绘图</h2><p><strong>PC端mousemove事件代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PC端鼠标移动</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (onoff == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//获取新点和中点</span></span><br><span class="line">    <span class="keyword">var</span> newx = event.clientX - canvas.offsetLeft;</span><br><span class="line">    <span class="keyword">var</span> newy = event.clientY - canvas.offsetTop;</span><br><span class="line">    midx = <span class="number">0.5</span>*(newx+oldx);</span><br><span class="line">    midy = <span class="number">0.5</span>*(newy+oldy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置粗细和颜色</span></span><br><span class="line">    ctx.lineWidth = linew;</span><br><span class="line">    ctx.strokeStyle = linecolor;</span><br><span class="line">    ctx.lineCap = <span class="string">'round'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制二次贝塞尔</span></span><br><span class="line">    ctx.moveTo(oldx,oldy);</span><br><span class="line">    ctx.quadraticCurveTo( midx , midy , newx , newy );</span><br><span class="line">    ctx.stroke();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转移新旧坐标</span></span><br><span class="line">    oldx = newx;</span><br><span class="line">    oldy = newy;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mobile端mousemove事件代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动端手指移动</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tMove</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//获取新点和中点</span></span><br><span class="line">  <span class="keyword">var</span> touche = event.targetTouches[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> newx = touche.clientX - canvas.offsetLeft;</span><br><span class="line">  <span class="keyword">var</span> newy = touche.clientY - canvas.offsetTop;</span><br><span class="line">  midx = <span class="number">0.5</span>*(newx+oldx);</span><br><span class="line">  midy = <span class="number">0.5</span>*(newy+oldy);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置粗细和颜色</span></span><br><span class="line">  ctx.lineWidth = linew;</span><br><span class="line">  ctx.strokeStyle = linecolor;</span><br><span class="line">  ctx.lineCap = <span class="string">'round'</span></span><br><span class="line"></span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(oldx,oldy);</span><br><span class="line">  ctx.quadraticCurveTo(midx,midy,newx,newy);</span><br><span class="line">  ctx.stroke();</span><br><span class="line"></span><br><span class="line">  oldx = newx;</span><br><span class="line">  oldy = newy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="canvas的imageData像素级缩放"><a href="#canvas的imageData像素级缩放" class="headerlink" title="canvas的imageData像素级缩放"></a>canvas的imageData像素级缩放</h2><p>想要获得canvas上的图像并且缩放到28*28，使用scale方法是不行的，必须获取所有的像素RGBA值，然后横向隔一段取一个点，竖向隔几行取一行，一共横向每行取28个像素点，竖向取28行</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩放imageData,scale:倍数,返回:imageData</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scaleImageData</span>(<span class="params">imageData, scale</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scaled =</span><br><span class="line">      ctx.createImageData(imageData.width * scale, imageData.height * scale);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> row = <span class="number">0</span>; row &lt; imageData.height; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> col = <span class="number">0</span>; col &lt; imageData.width; col++) &#123;</span><br><span class="line">      <span class="keyword">var</span> sourcePixel = [</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">0</span>],</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">1</span>],</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">2</span>],</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">3</span>]</span><br><span class="line">      ];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; scale; y++) &#123;</span><br><span class="line">        <span class="keyword">var</span> destRow = <span class="built_in">Math</span>.floor(row * scale) + y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; scale; x++) &#123;</span><br><span class="line">          <span class="keyword">var</span> destCol = <span class="built_in">Math</span>.floor(col * scale) + x;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            scaled.data[(destRow * scaled.width + destCol) * <span class="number">4</span> + i] = sourcePixel[i];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  alert(scaled.data.length);</span></span><br><span class="line">  <span class="keyword">return</span> scaled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取服务器的ip"><a href="#获取服务器的ip" class="headerlink" title="获取服务器的ip"></a>获取服务器的ip</h2><p>这里取巧了，直接从浏览器显示部分获取<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取服务器ip，运行时urlPath为https://192.168.137.1:8000/</span></span><br><span class="line"><span class="function">function <span class="title">getRemoteIp</span><span class="params">()</span></span>&#123;</span><br><span class="line">  var urlPath = window.document.location.href;  <span class="comment">//浏览器显示地址 http://10.15.5.83:5555/ISV/demo.aspx?a=1&amp;b=2</span></span><br><span class="line">  <span class="comment">// var docPath = window.document.location.pathname; //文件在服务器相对地址 /ISV/demo.aspx</span></span><br><span class="line">  <span class="comment">// var index = urlPath.indexOf(docPath);</span></span><br><span class="line">  var serverPath = urlPath.substring(<span class="number">7</span>, urlPath.length-<span class="number">1</span>);<span class="comment">//服务器ip 192.168.137.1</span></span><br><span class="line">  <span class="keyword">return</span> serverPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UA检测"><a href="#UA检测" class="headerlink" title="UA检测"></a>UA检测</h2><p>因为要适配移动端和PC端，所以简单的UA检测还是必要的，这里没有做的很复杂<br>主要就是通过检测<code>navigator.platfowm</code>中的关键词来判断</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var ua = navigator.userAgent; </span><br><span class="line">var system = &#123;</span><br><span class="line">  win : <span class="keyword">false</span>,</span><br><span class="line">  mac : <span class="keyword">false</span>,</span><br><span class="line">  linux : <span class="keyword">false</span>,</span><br><span class="line">  <span class="comment">// mobile</span></span><br><span class="line">  iphone : <span class="keyword">false</span>,</span><br><span class="line">  android : <span class="keyword">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p = navigator.platform;</span><br><span class="line">system.win = p.indexOf(<span class="string">'Win'</span>) == <span class="number">0</span>;</span><br><span class="line">system.mac = p.indexOf(<span class="string">'Mac'</span>) == <span class="number">0</span>;</span><br><span class="line">system.linux = p.indexOf(<span class="string">'Linux'</span>) == <span class="number">0</span>;</span><br><span class="line">system.iphone = ua.indexOf(<span class="string">'iPhone'</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">system.android = ua.indexOf(<span class="string">'Android'</span>) &gt; -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(system.win||system.mac)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(system.android||system.iphone)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="python根据数组生成图片"><a href="#python根据数组生成图片" class="headerlink" title="python根据数组生成图片"></a>python根据数组生成图片</h2><p>dtype一定要写的，不写生成错误<br>imgData就是图片的RGBA数据数组，要转成np数组才可以用PIL的Image.fromarray()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = np.asarray(imgData, dtype=np.uint8)</span><br><span class="line">image = Image.fromarray(array, <span class="string">'RGBA'</span>) </span><br><span class="line">image.save(outputImgPath + imgName +<span class="string">'.png'</span>)</span><br></pre></td></tr></table></figure><h2 id="将RGBA转换为RGB格式数组"><a href="#将RGBA转换为RGB格式数组" class="headerlink" title="将RGBA转换为RGB格式数组"></a>将RGBA转换为RGB格式数组</h2><p>网上看了很多，有用PIL的，还有直接写算法转换的，用opencv的…很多<br>这里发现PIL的不好用，读出来还是RGBA的格式，而且没办法用函数在数组上转换</p><p>最后解决办法是:</p><ul><li>从前端传过来的数据是字典类型，先获取values()</li><li>将dict.vlues这个数组转换为ndarray数组</li><li>转换完了,再把这个RGBA数组用 PIL 转换为图片</li><li>用save()方法保存为临时图片</li><li>用opencv读取临时图片的RGB通道的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 将图片数据转换为ndarray类型</span><br><span class="line">npData = np.array(imageData,dtype=np.uint8).reshape(<span class="number">28</span>,<span class="number">28</span>,<span class="number">4</span>)</span><br><span class="line"># 将RGBA格式数组转换为图片</span><br><span class="line">image = Image.fromarray(npData, <span class="string">'RGBA'</span>) </span><br><span class="line"># 保存临时图片</span><br><span class="line">image.save(<span class="string">'static/images/npimg.png'</span>)</span><br><span class="line"></span><br><span class="line"># 用opencv读取图片的RGB数据</span><br><span class="line">rgbImage = cv2.imread(<span class="string">'static/images/npimg.png'</span>, cv2.IMREAD_COLOR)</span><br></pre></td></tr></table></figure><h2 id="cv2-imread-path-flags"><a href="#cv2-imread-path-flags" class="headerlink" title="cv2.imread(path[, flags])"></a>cv2.imread(path[, flags])</h2><p>cv2的imread函数的第二个参数这里说明下:</p><blockquote><p>如果不设置，读进来的是BGR格式的数据，值在0-255,flag一共有3个取值<br>cv2.IMREAD_COLOR : 读入彩色图片,任何与透明度相关通道的会被忽视,默认以这种方式读入.<br>cv2.IMREAD_GRAYSCALE : 以灰度图的形式读入图片<br>cv2.IMREAD_UNCHANGED : 保留读取图片原有的颜色通道.</p></blockquote><p>可以简单的用<strong>-1,0,1</strong>来分别表示这3个flag</p><h2 id="Python图像处理"><a href="#Python图像处理" class="headerlink" title="Python图像处理"></a>Python图像处理</h2><h3 id="图片的读写方式总结"><a href="#图片的读写方式总结" class="headerlink" title="图片的读写方式总结"></a>图片的读写方式总结</h3><p>找到一个很全的博客，推荐一下：<a href="https://www.jb51.net/article/135307.htm" target="_blank" rel="noopener">Python各类图像库的图片读写方式总结</a></p><h3 id="opencv的基本操作"><a href="#opencv的基本操作" class="headerlink" title="opencv的基本操作"></a>opencv的基本操作</h3><p>推荐看看这篇文章：<a href="https://www.jianshu.com/p/ed00179ede34" target="_blank" rel="noopener">点击跳转</a></p><h3 id="tensorflow简单的图像处理"><a href="#tensorflow简单的图像处理" class="headerlink" title="tensorflow简单的图像处理"></a>tensorflow简单的图像处理</h3><p>推荐链接：<a href="https://blog.csdn.net/jia20003/article/details/79118769" target="_blank" rel="noopener">使用TensorFlow进行简单的图像处理</a></p><h3 id="PIL格式转换"><a href="#PIL格式转换" class="headerlink" title="PIL格式转换"></a>PIL格式转换</h3><p>推荐链接：<a href="https://blog.csdn.net/icamera0/article/details/50843172" target="_blank" rel="noopener">Python图像处理库PIL中图像格式转换（一）</a></p><h2 id="对图片灰度化"><a href="#对图片灰度化" class="headerlink" title="对图片灰度化"></a>对图片灰度化</h2><p>如果只是灰度的话可以用PIL的convert函数，很方便，但是这里要用tensorflow，所以得用<code>tf.image_to_grayscale(imageData)</code>这个函数。注意事先要先将数据格式转换为<code>tf.float32</code>类型的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将rgb图片转换为float32格式</span></span><br><span class="line">rgbImage = tf.image.convert_image_dtype(rgbImage, tf.float32)</span><br><span class="line"><span class="comment"># 将图片灰度化得到(28,28,1)格式的tensor</span></span><br><span class="line">rgbImage = tf.image.rgb_to_grayscale(rgbImage</span><br></pre></td></tr></table></figure><h2 id="后端改变图片的背景和画笔颜色数据"><a href="#后端改变图片的背景和画笔颜色数据" class="headerlink" title="后端改变图片的背景和画笔颜色数据"></a>后端改变图片的背景和画笔颜色数据</h2><p>出于美观，前端并不是黑底白字，但是模型训练的是黑底白字的，虽然后面测试用了灰度数据，还是会不准确，所以在数据处理前，对imageData中的部分像素进行修改，将橙色变为黑色，黑色画笔变为白色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将橙色的背景转换为黑色,将画笔的黑色转为白色</span></span><br><span class="line"><span class="comment"># input: RGBA格式图片数据</span></span><br><span class="line"><span class="comment"># output: 修改过的RGBA格式图片数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reveBlack</span><span class="params">(imageData)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(imageData),<span class="number">4</span>):</span><br><span class="line">        <span class="comment"># 如果画笔为白色</span></span><br><span class="line">        <span class="keyword">if</span> imageData[i]==<span class="number">0</span> <span class="keyword">and</span> imageData[i+<span class="number">1</span>]==<span class="number">0</span> <span class="keyword">and</span> imageData[i+<span class="number">2</span>]==<span class="number">0</span>:</span><br><span class="line">            imageData[i]=imageData[i+<span class="number">1</span>]=imageData[i+<span class="number">2</span>]=<span class="number">255</span></span><br><span class="line">        <span class="comment"># 如果背景为橙色</span></span><br><span class="line">        <span class="keyword">if</span> imageData[i]==<span class="number">255</span> <span class="keyword">and</span> imageData[i+<span class="number">1</span>]==<span class="number">165</span> <span class="keyword">and</span> imageData[i+<span class="number">2</span>]==<span class="number">0</span>:</span><br><span class="line">            imageData[i]=imageData[i+<span class="number">1</span>]=imageData[i+<span class="number">2</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> imageDat</span><br></pre></td></tr></table></figure><h2 id="tensor和numpy数组转换"><a href="#tensor和numpy数组转换" class="headerlink" title="tensor和numpy数组转换"></a>tensor和numpy数组转换</h2><h3 id="tensor转ndarray"><a href="#tensor转ndarray" class="headerlink" title="tensor转ndarray"></a>tensor转ndarray</h3><p>由于项目里面是模型恢复，所以没有初始化这步<br>有两种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 将tensor转换为ndarray</span></span><br><span class="line">init = tf.initialize_all_variables()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="comment"># 第一种</span></span><br><span class="line">    ndName = tensorName1.eval(session=sess)</span><br><span class="line">    <span class="comment">#第二种</span></span><br><span class="line">    ndName = sess.run(tensorName2)</span><br></pre></td></tr></table></figure><h2 id="ndarray转tensor"><a href="#ndarray转tensor" class="headerlink" title="ndarray转tensor"></a>ndarray转tensor</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将ndarray转换为tensor</span></span><br><span class="line">tensorName =  tf.convert_to_tensor(ndName, dtype = tf.float32)</span><br></pre></td></tr></table></figure><h2 id="使用训练好的模型"><a href="#使用训练好的模型" class="headerlink" title="使用训练好的模型"></a>使用训练好的模型</h2><p><strong>参考链接：</strong><a href="https://blog.csdn.net/yanchujian88/article/details/80559936" target="_blank" rel="noopener">言初见的CSDN博客</a></p><p>训练用的算法是Lenet-5，下面的代码是部分调用模型代码，因为只有一张图片的数据，并不是用整个测试集，所以有些地方会有点不一样</p><p>主要还是通过恢复模型，传入图片数据来获得预测结果</p><p>注意点：</p><ol><li>x占位符的shape，要注意个train的一致，第一个shape要是1，因为只有一个图片</li><li>使用tf.argmax(y,1)函数获得最大预测的下标,这里就是结果了，因为是0-9正好对应了下标</li><li>输入的feed_dict测试数据必须是ndarray，不可以是tensor，因此要转换以下</li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义输入格式(1,28,28,1)</span></span><br><span class="line">x = tf.placeholder(tf.float32, [<span class="number">1</span>, </span><br><span class="line">                                mnist_inference.IMAGE_SIZE, </span><br><span class="line">                                mnist_inference.IMAGE_SIZE, </span><br><span class="line">                                mnist_inference.NUM_CHANNEL], </span><br><span class="line">                                name=<span class="string">'x-input'</span>)</span><br><span class="line"><span class="comment">#直接通过调用封装好的函数来计算前向传播的结果 </span></span><br><span class="line">y = mnist_inference.interence(x,<span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用tf.argmax(y, 1)就可以得到输入样例的预测类别 </span></span><br><span class="line">prediction = tf.argmax(y, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过变量重命名的方式来加载模型</span></span><br><span class="line"><span class="comment"># 所有滑动平均的值组成的字典,处在/ExponentialMovingAverage下的值  </span></span><br><span class="line"><span class="comment"># 为了方便加载时重命名滑动平均量，tf.train.ExponentialMovingAverage类  </span></span><br><span class="line"><span class="comment"># 提供了variables_to_store函数来生成tf.train.Saver类所需要的变量  </span></span><br><span class="line"><span class="comment"># 这些值要从模型中提取</span></span><br><span class="line">variable_averages = tf.train.ExponentialMovingAverage(mnist_train.MOVING_AVERAGE_DECAY)</span><br><span class="line">variable_to_restore = variable_averages.variables_to_restore()</span><br><span class="line">saver = tf.train.Saver(variable_to_restore)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用数据测试模型</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess: </span><br><span class="line">    <span class="comment"># get_checkoutpoint_state()会通过checkoutpoint文件自动找到目录中最新模型的文件名</span></span><br><span class="line">    ckpt = tf.train.get_checkpoint_state(mnist_train.MODEL_PATH)</span><br><span class="line">    <span class="keyword">if</span> ckpt <span class="keyword">and</span> ckpt.model_checkpoint_path:</span><br><span class="line">        <span class="comment"># 加载模型</span></span><br><span class="line">        saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将tensor转换为np数组,这里也可以用np的reshape方法</span></span><br><span class="line">        rgbNpData = tf.reshape(rgbImage,[<span class="number">1</span>,</span><br><span class="line">                                            mnist_inference.IMAGE_SIZE, </span><br><span class="line">                                            mnist_inference.IMAGE_SIZE, </span><br><span class="line">                                            mnist_inference.NUM_CHANNEL])</span><br><span class="line">        <span class="comment"># 将tensor转换为ndarray</span></span><br><span class="line">        reshaped_data = rgbNpData.eval()</span><br><span class="line">        <span class="comment"># 将输入的测试数据格式调整为一个四维矩阵</span></span><br><span class="line">        validate_feed = &#123;x: reshaped_data&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获得预测的结果数组</span></span><br><span class="line">        predictionNum = sess.run(prediction, feed_dict = validate_feed)</span><br><span class="line">        print(<span class="string">"Number is %d"</span> %(predictionNum[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">tf.reset_default_graph()</span><br></pre></td></tr></table></figure><h2 id="报错：Error-the-tensor’s-graph-is-different-from-the-session’s-graph"><a href="#报错：Error-the-tensor’s-graph-is-different-from-the-session’s-graph" class="headerlink" title="报错：Error: the tensor’s graph is different from the session’s graph"></a>报错：Error: the tensor’s graph is different from the session’s graph</h2><p>这是因为session里面的图和使用的图不一样导致的，刚开始不清楚，把参考的博客上面的那句： with tf.Graph().as_default() as g:写上去了，导致默认图被设置成了g，但是用的又是恢复的图，所以不一样了</p><p>解决办法炒鸡简单…但是debug的过程里就一直没意识到就是了…就是把那句话去掉就行了哇</p><h2 id="报错：List-of-Tensors-when-single-Tensor-expected"><a href="#报错：List-of-Tensors-when-single-Tensor-expected" class="headerlink" title="报错：List of Tensors when single Tensor expected"></a>报错：List of Tensors when single Tensor expected</h2><p>使用tf.constant()函数的时候可能会报这个错误</p><p>看看这个函数的定义：</p><blockquote><p>def constant(value, dtype=None, shape=None, name=”Const”, verify_shape=False)<br>value: A constant value (or list) of output type dtype.<br>Returns: A Constant Tensor.</p></blockquote><p>问题也应该清楚了，constant要求输入的是list，用的时候如果传入了tensor类型的，当然就不可以了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遇到的问题还是很多的，好几个bug都折磨了我几个小时，找不到bug在哪太艰难了，深深的感受到要学了点基础再来做项目，就说这个tensorflow，没有大致的学一遍，遇到问题完全就是无头苍蝇，不好排错</p><p>一个项目学到的东西还是挺多的，实战真的很重要啊</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;记录一下手写数字识别这个项目过程中遇到的问题，以及解决方法，还有一些图像处理方面的文章推荐&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="MachineLearning" scheme="https://catchdream.me/categories/MachineLearning/"/>
    
    
      <category term="Daily" scheme="https://catchdream.me/tags/Daily/"/>
    
      <category term="ML" scheme="https://catchdream.me/tags/ML/"/>
    
      <category term="MNIST" scheme="https://catchdream.me/tags/MNIST/"/>
    
      <category term="Tensorflow" scheme="https://catchdream.me/tags/Tensorflow/"/>
    
      <category term="LeNet-5" scheme="https://catchdream.me/tags/LeNet-5/"/>
    
      <category term="Problems" scheme="https://catchdream.me/tags/Problems/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-008-String to Integer (atoi)</title>
    <link href="https://catchdream.me/2019/04/16/LeetCode-008-String-to-Integer-atoi/"/>
    <id>https://catchdream.me/2019/04/16/LeetCode-008-String-to-Integer-atoi/</id>
    <published>2019-04-16T14:26:17.000Z</published>
    <updated>2019-04-17T18:23:03.300Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">Problem</a></h2><p>实现C++的atoi()函数<br>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p></div><a id="more"></a><div class="note info"><p><strong>Note:</strong>  </p><blockquote><p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: <script type="math/tex">[−2^{31},  2^{31} − 1]</script>. If the numerical value is out of the range of representable values, INT_MAX <script type="math/tex">2^{31}-1</script> or INT_MIN <script type="math/tex">-2^{31}</script> is returned.</p></blockquote></div><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>“42”<br><strong>Output:</strong>42<br><strong>Input:</strong>“    -42”<br><strong>Output:</strong>-42<br><strong>Input:</strong>“words and 987”<br><strong>Output:</strong>987</p><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>没啥思维量，就是简单的遍历每个字符，然后设置两个flag，一个用于判断有没有到数字部分，第二个判断是不是负数，如果没到数字部分，就要分情况讨论，如果到了数字部分，判断到没到非数字，到了就退出，没到就每个数字加到结果上</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>每个字符遍历过去的方法，12ms，8.4MB<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">//是否到数字部分</span></span><br><span class="line">        <span class="keyword">int</span> flag2 = <span class="number">1</span>;<span class="comment">//负数标志，有就变为-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//已经开始数字部分的情况，即flag = true</span></span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;INT_MAX)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag &amp;&amp; (str[i]&lt;<span class="string">'0'</span> || str[i]&gt;<span class="string">'9'</span>)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag) tmp = tmp*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//还没到数字的情况，前面那部分，分为空格、非数字非符号、数字或正负号</span></span><br><span class="line">            <span class="keyword">if</span>(!flag &amp;&amp; str[i]==<span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!flag &amp;&amp; str[i]!=<span class="string">'+'</span> &amp;&amp; str[i]!=<span class="string">'-'</span> &amp;&amp; (str[i]&lt;<span class="string">'0'</span> || str[i]&gt;<span class="string">'9'</span>) )</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!flag &amp;&amp; (str[i]==<span class="string">'+'</span> || str[i]==<span class="string">'-'</span>|| (str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)))&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(str[i]==<span class="string">'-'</span>)flag2 = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(str[i]==<span class="string">'+'</span>||str[i]==<span class="string">'-'</span>)<span class="keyword">continue</span>;</span><br><span class="line">                tmp = tmp*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp*=flag2;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(tmp&lt;INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>借用了<a href="http://chengfeng96.com/blog/2017/03/07/LeetCode-No-8-String-to-Integer-atoi/" target="_blank" rel="noopener">HazzaCheng的代码</a>,这道题用python解简直作弊..<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        ls = list(s.strip())</span><br><span class="line">        <span class="keyword">if</span> len(ls) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        sign = <span class="number">-1</span> <span class="keyword">if</span> ls[<span class="number">0</span>] == <span class="string">'-'</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> ls[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">'-'</span>, <span class="string">'+'</span>]:</span><br><span class="line">            <span class="keyword">del</span> ls[<span class="number">0</span>]</span><br><span class="line">        res, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(ls) <span class="keyword">and</span> ls[i].isdigit():</span><br><span class="line">            res = res * <span class="number">10</span> + ord(ls[i]) - ord(<span class="string">'0'</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">-2</span> ** <span class="number">31</span>, min(sign * res, <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>要注意各种情况的判断</li><li>就算用了long long作为中转，在循环中也要判断是否已经超过int表示范围，提前break，可能出现longlong都无法表示的测试</li><li>注意空串</li><li>注意前面的符号</li><li>不应该进行的操作及时continue掉</li><li>还是会出现’+’号的</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;实现C++的atoi()函数&lt;br&gt;The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.&lt;/p&gt;
&lt;p&gt;The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.&lt;/p&gt;
&lt;p&gt;If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.&lt;/p&gt;
&lt;p&gt;If no valid conversion could be performed, a zero value is returned.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-007-Reverse Integer</title>
    <link href="https://catchdream.me/2019/04/16/LeetCode-007-Reverse-Integer/"/>
    <id>https://catchdream.me/2019/04/16/LeetCode-007-Reverse-Integer/</id>
    <published>2019-04-16T14:07:29.000Z</published>
    <updated>2019-04-16T14:25:07.956Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">Problem</a></h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>123<br><strong>Output:</strong>321<br><strong>Input:</strong>-123<br><strong>Output:</strong>-321</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>用字符串的方法，先将输入转换成字符串，然后判断第一个字符是不是‘-’，是就加到结果字符串上，最后逆序添加字符到结果字符串上，再将字符串转换成长整数，return之前判断是否有溢出</li><li>题解的办法是用取模的方法获取每一位之后再加到结果上，遍历一遍，但是这种方法在计算结果时容易溢出，要事先检查</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>我的字符串方法，4ms，8.3MB<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(x);</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'-'</span>)&#123;</span><br><span class="line">            str = str.substr(<span class="number">1</span>,str.length());</span><br><span class="line">            res+=<span class="string">'-'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            res+=str[str.length()<span class="number">-1</span>-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> tmp =  atol(res.c_str());</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span> || tmp&lt;<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)*(<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>题解的数学方法，8ms，8.3MB<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>Python的和第一种方法一样做，差别不大</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>C++中int型最大最小可以用<limits.h>中的INT_MAX和INT_MIN表示，分别是<script type="math/tex">2^31=2147483647</script>和<script type="math/tex">-2^31-1=-2147483648</script></limits.h></li><li>C++中有atoi(),atol(),c_str(),to_string()这几种方法，分别是字符串转int，字符串转long，字符串转C串，整形转字符串</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;123&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;321&lt;br&gt;&lt;strong&gt;Input:&lt;/strong&gt;-123&lt;br&gt;&lt;strong&gt;Output:&lt;/strong&gt;-321&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Reverse" scheme="https://catchdream.me/tags/Reverse/"/>
    
      <category term="Big Number" scheme="https://catchdream.me/tags/Big-Number/"/>
    
      <category term="String" scheme="https://catchdream.me/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-006-ZigZag Conversion</title>
    <link href="https://catchdream.me/2019/04/15/LeetCode-006-ZigZag-Conversion/"/>
    <id>https://catchdream.me/2019/04/15/LeetCode-006-ZigZag-Conversion/</id>
    <published>2019-04-15T12:47:37.000Z</published>
    <updated>2019-04-15T13:25:28.728Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/zigzag-conversion/submissions/" target="_blank" rel="noopener">Problem</a></h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><blockquote><p>P   A   H   N<br>A P L S I I G<br>Y   I   R  </p></blockquote><p>And then read line by line: <strong>“PAHNAPLSIIGYIR”</strong><br>Write the code that will take a string and make this conversion given a number of rows:   </p><blockquote><p>string convert(string s, int numRows);</p></blockquote></div><a id="more"></a><div class="note info"><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong> s = “PAYPALISHIRING”, numRows = 3<br><strong>Output:</strong> “PAHNAPLSIIGYIR”</p><p><strong>Input:</strong> s = “PAYPALISHIRING”, numRows = 4<br><strong>Output:</strong> “PINALSIGYAHRPI”<br><strong>Explanation:</strong></p><blockquote><p>P     I    N<br>A   L S  I G<br>Y A   H R<br>P     I</p></blockquote></div><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>想到的是用数学方法，遍历每一行，然后计算每一行字符的位置，逐个添加进去，是题解的第二种方法。每行的字符位置都满足一个数列，所以可以很简单的计算出来。时间复杂度是<script type="math/tex">O(n)</script>.</li><li>题解还给了一种方法是按行排序，每一行建一个字符串，从左向右迭代源字符串，判断每个字符是属于哪一行，然后加到那一行的字符串上，最后对每行字符串拼接，原理感觉和上一种方法差不多。时间复杂度也是<script type="math/tex">O(n)</script>  </li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>自己想到的解法，用时12ms，内存10.2MB，超过99.51%感觉还是挺快的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">ceil</span>(len*<span class="number">1.0</span>/numRows);</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">2</span>*numRows<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;   <span class="comment">//遍历行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=num;j++)&#123;    <span class="comment">//遍历每个Z</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; (j<span class="number">-1</span>)*d&lt;len)&#123;  <span class="comment">//第一行</span></span><br><span class="line">                    res+=s[(j<span class="number">-1</span>)*d];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==(numRows<span class="number">-1</span>) &amp;&amp; ((j<span class="number">-1</span>)*d+numRows<span class="number">-1</span>)&lt;len)&#123; <span class="comment">//最后一行</span></span><br><span class="line">                    res+=s[(j<span class="number">-1</span>)*d+numRows<span class="number">-1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123; <span class="comment">//其余行</span></span><br><span class="line">                        <span class="keyword">if</span>((j<span class="number">-1</span>)*d+i&lt;len)</span><br><span class="line">                            res+=s[(j<span class="number">-1</span>)*d+i];</span><br><span class="line">                        <span class="keyword">if</span>(j*d-i&lt;len)</span><br><span class="line">                            res+=s[j*d-i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>第二种遍历每个字符的解法:测试是20ms，12.6MB<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; rows(min(numRows, <span class="keyword">int</span>(s.size())));</span><br><span class="line">        <span class="keyword">int</span> curRow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> goingDown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            rows[curRow] += c;</span><br><span class="line">            <span class="keyword">if</span> (curRow == <span class="number">0</span> || curRow == numRows - <span class="number">1</span>) goingDown = !goingDown;</span><br><span class="line">            curRow += goingDown ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> row : rows) ret += row;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        slen = len(s)</span><br><span class="line">        num = math.ceil(slen/numRows);</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        d = <span class="number">2</span>*numRows<span class="number">-2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> numRows==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,num+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">and</span> (j<span class="number">-1</span>)*d&lt;slen:</span><br><span class="line">                    res = res + s[(j<span class="number">-1</span>)*d]</span><br><span class="line">                <span class="keyword">elif</span> i==numRows<span class="number">-1</span> <span class="keyword">and</span> (j<span class="number">-1</span>)*d+numRows<span class="number">-1</span>&lt;slen:</span><br><span class="line">                    res = res + s[(j<span class="number">-1</span>)*d+numRows<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    <span class="keyword">if</span> (j<span class="number">-1</span>)*d+i&lt;slen:</span><br><span class="line">                        res = res + s[(j<span class="number">-1</span>)*d+i]</span><br><span class="line">                    <span class="keyword">if</span>(j*d-i&lt;slen):</span><br><span class="line">                        res = res + s[j*d-i]</span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>很多题目可以直接从数学角度着手，会很方便</li><li>暴力法在很多时候都有用啊，时间复杂度不够再优化下说不定就过了</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/zigzag-conversion/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;P   A   H   N&lt;br&gt;A P L S I I G&lt;br&gt;Y   I   R  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And then read line by line: &lt;strong&gt;“PAHNAPLSIIGYIR”&lt;/strong&gt;&lt;br&gt;Write the code that will take a string and make this conversion given a number of rows:   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;string convert(string s, int numRows);&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://catchdream.me/tags/Math/"/>
    
      <category term="String" scheme="https://catchdream.me/tags/String/"/>
    
      <category term="Split" scheme="https://catchdream.me/tags/Split/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-005-Longest Palindromic Substring</title>
    <link href="https://catchdream.me/2019/04/14/LeetCode-005-Longest-Palindromic-Substring/"/>
    <id>https://catchdream.me/2019/04/14/LeetCode-005-Longest-Palindromic-Substring/</id>
    <published>2019-04-14T13:22:07.000Z</published>
    <updated>2019-04-14T14:28:04.363Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/longest-palindromic-substring/solution/" target="_blank" rel="noopener">Problem</a></h2><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><blockquote><p>“babad” —-&gt; “bab”<br>“cbbd” —-&gt; “bb”</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li><strong>暴力法</strong>：首先想到的当然是暴力法…暴力大法好/斜眼笑</li><li><strong>遍历中心点暴力:</strong>感觉直接暴力子串太幼稚，想了想可以遍历所有字串的中心点，于是产生了下面第一种解法，遍历每个下标，然后对子串是奇数个字符和偶数个字符分别查找最长子串，记录最长子串起始下标和长度，最后返回。时间复杂度是<script type="math/tex">O(n^2)</script></li><li><strong>动态规划: </strong>看了题解，里面讲到了动态规划的解法，首先是有一个二维数组P[i, j]，用于保存i-j位置这段子串是不是回文，是就是true，不是就是false，初始化P中长度为1和2的子串，P[i-1, j+1]=True相当于：<strong>P[i, j]==true &amp;&amp; S[i-1]==S[j+1]</strong></li><li><strong>翻转字符串和原字符串比较：</strong>:把字符串翻转，然后和原来的比较，找到最长的公共子串就是要的结果，这种方法有缺陷就是可能存在非回文子串的反向副本，改进的办法也很简单，就是比较找到的公共子串的索引是否和反向子串的原索引相同，不相同就可以排除了</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>遍历中心点法：用了32ms，8.8MB</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//判断子串为奇数个字符时</span></span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i-tmp&gt;=<span class="number">0</span> &amp;&amp; i+tmp&lt;n &amp;&amp; s[i-tmp]==s[i+tmp])&#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="number">2</span>*tmp+<span class="number">1</span>)&gt;maxLen)&#123;</span><br><span class="line">                    maxLen = <span class="number">2</span>*tmp+<span class="number">1</span>;</span><br><span class="line">                    pos = i-tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//断子串为偶数个字符时</span></span><br><span class="line">            tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i-tmp+<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; i+tmp&lt;n &amp;&amp; s[i-tmp+<span class="number">1</span>]==s[i+tmp] )&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*tmp&gt;maxLen)&#123;</span><br><span class="line">                    maxLen = <span class="number">2</span>*tmp;</span><br><span class="line">                    pos = i-tmp+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substr(pos,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>动态规划版本：用了140ms，13.1MB</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> p[n][n]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化数组边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            p[i][i]=<span class="number">1</span>;</span><br><span class="line">            p[i][i+<span class="number">1</span>]=s[i]==s[i+<span class="number">1</span>]?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(p[i][i+<span class="number">1</span>])&#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                maxLen = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p[n<span class="number">-1</span>][n<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//动规循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;   <span class="comment">//长度-1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;n;j++)&#123;   <span class="comment">//起始下标</span></span><br><span class="line">                <span class="keyword">if</span>( p[j+<span class="number">1</span>][j+i<span class="number">-1</span>]==<span class="number">1</span> &amp;&amp; s[j]==s[j+i])&#123;</span><br><span class="line">                    p[j][j+i]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i+<span class="number">1</span>)&gt;maxLen)&#123;</span><br><span class="line">                        maxLen = i+<span class="number">1</span>;</span><br><span class="line">                        pos = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(pos,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>算法题要注意边界问题，遍历的时候别下标越界</li><li>C++中数组要注意初始化，不会像java那样有默认值</li><li>动态规划注意初始化边界</li><li>暴力的时候注意子串长度还可以是偶数</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/solution/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;“babad” —-&amp;gt; “bab”&lt;br&gt;“cbbd” —-&amp;gt; “bb”&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://catchdream.me/tags/Math/"/>
    
      <category term="String" scheme="https://catchdream.me/tags/String/"/>
    
      <category term="Palindromic" scheme="https://catchdream.me/tags/Palindromic/"/>
    
      <category term="DP" scheme="https://catchdream.me/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-004-Median of Two Sorted Arrays</title>
    <link href="https://catchdream.me/2019/04/14/LeetCode-004-Median-of-Two-Sorted-Arrays/"/>
    <id>https://catchdream.me/2019/04/14/LeetCode-004-Median-of-Two-Sorted-Arrays/</id>
    <published>2019-04-13T17:48:43.000Z</published>
    <updated>2019-04-13T18:34:55.257Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">Problem</a></h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.<br>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br>You may assume nums1 and nums2 cannot be both empty</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><blockquote><p>a = [1, 3], b = [2] —-&gt; 2.0<br>a = [1, 2], b = [3, 4] —-&gt; 2.5</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>刚开始是一点思路都么得…如果没有O(log (m+n))的限制，还能用遍历的方法找到，但是加了log，应该是要用二叉的</li><li>题解里面给出了将两个数组，以i，j为分界，分为两部分:[0,i-1], [i,m-1], [0, j-1], [j,n-1]，使得左边的[0,i-1], [0,j-1] 全都小于右边的[i,m-1], [j,n-1]，利用中位数的意义</li><li>前提要<strong>确保m&lt;=n</strong>，这很重要！刚开始就弄反了导致一直找不到bug..</li><li>同时配合二叉搜索，这时搜索的条件就变成了：如果左边的有大于右边的数，就缩小，如果右边的有小于左边的数，就扩大</li><li>这里需要判断几个边界条件：i=0, j=0, i=m, j=n这四种</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>用时是36ms, 内存9.6MB</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n=nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)&#123;    <span class="comment">//确保m&lt;=n,不然会造成j可能是负数</span></span><br><span class="line">            nums1.swap(nums2);</span><br><span class="line">            <span class="keyword">int</span> tmp=m; m=n; n=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> imin=<span class="number">0</span>,imax=m,half=(m+n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(imin&lt;=imax)&#123;</span><br><span class="line">            <span class="keyword">int</span> i=(imin+imax)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j=half - i;</span><br><span class="line">            <span class="keyword">int</span> maxLeft = <span class="number">0</span>, minRight=<span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i&lt;imax &amp;&amp; nums2[j<span class="number">-1</span>]&gt;nums1[i])&#123;  <span class="comment">//i太小</span></span><br><span class="line">                imin = i+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;imin &amp;&amp; nums1[i<span class="number">-1</span>]&gt;nums2[j])&#123;   <span class="comment">//i太大</span></span><br><span class="line">                imax=i<span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//maxleft = max(nums1[i-1],nums2[j-1]), i, j可能是0, i-1就可能为-1</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123; maxLeft=nums2[j<span class="number">-1</span>];&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123; maxLeft = nums1[i<span class="number">-1</span>];&#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; maxLeft = nums1[i<span class="number">-1</span>]&gt;nums2[j<span class="number">-1</span>]?nums1[i<span class="number">-1</span>]:nums2[j<span class="number">-1</span>];&#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果是奇数个</span></span><br><span class="line">                <span class="keyword">if</span>((m+n)%<span class="number">2</span>)&#123; <span class="keyword">return</span> maxLeft;&#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//maxRight = max(nums1[i], nums2[j]), i, j可能是m和n，nums1[i]就会越界</span></span><br><span class="line">                <span class="keyword">if</span>(i==m)&#123; minRight=nums2[j];&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==n)&#123; minRight = nums1[i];&#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; minRight=nums1[i]&lt;nums2[j]?nums1[i]:nums2[j];&#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> (minRight+maxLeft)/<span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n):</span><br><span class="line">            nums1,nums2,m,n = nums2,nums1,n,m</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 整除</span></span><br><span class="line">        imin, imax, half = <span class="number">0</span>, m, (m+n+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> imin&lt;=imax:</span><br><span class="line">            i = (imin+imax)//<span class="number">2</span>;</span><br><span class="line">            j = half - i;</span><br><span class="line">            maxLeft = <span class="number">0</span></span><br><span class="line">            minRight = <span class="number">0</span></span><br><span class="line">            print(i,j)</span><br><span class="line">            <span class="keyword">if</span> i&lt;m <span class="keyword">and</span> nums2[j<span class="number">-1</span>]&gt;nums1[i]:</span><br><span class="line">                imin = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums1[i<span class="number">-1</span>]&gt;nums2[j]:</span><br><span class="line">                imax = i<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span>: maxLeft = nums2[j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j==<span class="number">0</span>: maxLeft = nums1[i<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    maxLeft = max(nums2[j<span class="number">-1</span>],nums1[i<span class="number">-1</span>])</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (m+n)%<span class="number">2</span>==<span class="number">1</span>: <span class="keyword">return</span> maxLeft</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> i==m: minRight = nums2[j]</span><br><span class="line">                <span class="keyword">elif</span> j==n: minRight = nums1[i]</span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    minRight = min(nums1[i],nums2[j])</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">return</span> (minRight+maxLeft)/<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对用到中位数的题目可以想想中位数的意义，搜索那个分界点，可以直接遍历分界点也可以二叉找，看时间复杂度。</li><li>要注意前提是m&lt;=n，不然会出错</li><li>注意搜索时候变化条件，还有几个边界情况注意判断</li><li>while循环的条件这里是imin&lt;=imax，等于的时候就是到叶子节点了</li><li>python这里居然只能用双斜线整除</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;br&gt;Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).&lt;br&gt;You may assume nums1 and nums2 cannot be both empty&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;a = [1, 3], b = [2] —-&amp;gt; 2.0&lt;br&gt;a = [1, 2], b = [3, 4] —-&amp;gt; 2.5&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://catchdream.me/tags/Math/"/>
    
      <category term="Binary Search" scheme="https://catchdream.me/tags/Binary-Search/"/>
    
      <category term="Array" scheme="https://catchdream.me/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-003-Longest Substring Without Repeating Characters</title>
    <link href="https://catchdream.me/2019/04/13/LeetCode-003-Longest-Substring-Without-Repeating-Characters/"/>
    <id>https://catchdream.me/2019/04/13/LeetCode-003-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2019-04-12T17:02:13.000Z</published>
    <updated>2019-04-13T05:26:45.199Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Problem</a></h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><blockquote><p>“abcabcbb” —-&gt; 3<br>“bbbbb” —-&gt; 1<br>“pwwkew” —-&gt; 3</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>第一反应下想到的也是暴力遍历，写一个判断有没有重复字符串的函数，然后遍历每个子串，时间复杂度是<script type="math/tex">O(n^3)</script>，太高了，导致第一次提交没过，后面优化了下暴力法，过了。</li><li>除了暴力，题解上给出了<strong>滑动窗口</strong>的解法，利用前后两个指针i,j 不断移动来遍历字符串以及子串，i,j中间的就是没有重复字符的,如果遇到重复字符，就把i自增，一直到没有重复字符为止（就是相当于找到和j处的相同字符的为止），时间复杂度是<script type="math/tex">O(n)</script></li><li>最后是优化的滑动窗口，先记录每个字符第一次出现的位置pos，然后第二次出现的时候，将第一个指针i直接变成pos+1</li><li>对上面的优化还有一个技巧是利用整数数组代替Map，也可以用bitmap每一位表示一个字符数量</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>这是我优化过的暴力法，勉强过了，判断函数那边用了太大的数组，可以用bitmap降低空间复杂度</p><p>用了72ms,20.1MB…僵硬</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//i是最大长度，j是每次遍历的起始位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="comment">//这里让i直接从max开始，可以少一点没用的遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=max;i+j&lt;=s.length();i++)&#123;</span><br><span class="line">                <span class="comment">//如果有重复字符直接退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(!judgeSubstring(s.substr(j,i))) <span class="keyword">break</span>;</span><br><span class="line">                max=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeSubstring</span><span class="params">(<span class="built_in">string</span> substr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;substr.length();i++)&#123;</span><br><span class="line">            <span class="comment">//如果不是0就肯定有重复字符</span></span><br><span class="line">            <span class="keyword">if</span>(tmp[<span class="keyword">int</span>(substr[i])])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            tmp[<span class="keyword">int</span>(substr[i])]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好了，这是第三种方法对应的代码，这次只用了12ms,9.1MB，话说感觉这种滑动窗口有点像快排…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="comment">//用来保存每个字符的下一个位置，用于出现重复字符的时候直接赋值给i</span></span><br><span class="line">        <span class="keyword">int</span> cNum[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;      </span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i是第一个指针，j是第二个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,i=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">//如果不为0就是出现了和s[j]一样的字符，让i等于那个字符的后一个位置</span></span><br><span class="line">            <span class="keyword">if</span>(cNum[s[j]])&#123;</span><br><span class="line">                i = cNum[s[j]]&gt;i?cNum[s[j]]:i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不管有没有重复字符都要更新max和cNum[s[j]]</span></span><br><span class="line">            <span class="comment">//很明显，如果有，i已经被更新，相当于已经变成了没有重复字符的情形，位置也要更新</span></span><br><span class="line">            max=(j-i+<span class="number">1</span>)&gt;max?(j-i+<span class="number">1</span>):max;</span><br><span class="line">            cNum[s[j]]=j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>用时52ms，12.7MB</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cNum=dict()</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> cNum:</span><br><span class="line">                start=max(start,cNum[s[i]])</span><br><span class="line">            res=max(res,i-start+<span class="number">1</span>)</span><br><span class="line">            cNum[s[i]]=i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总感觉自己想的太简单，优化还是有点难度的，这道题关键的就是一次遍历，用两个指针表示字符串，并且没有单独拿出字符串判断，而是用set或者map、dict这种方式记录当前子串的内容，用于判断是否有没有出现重复字符，优化的时候减少无用的遍历</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a string, find the length of the &lt;strong&gt;longest substring&lt;/strong&gt; without repeating characters.&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;“abcabcbb” —-&amp;gt; 3&lt;br&gt;“bbbbb” —-&amp;gt; 1&lt;br&gt;“pwwkew” —-&amp;gt; 3&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://catchdream.me/tags/Math/"/>
    
      <category term="String" scheme="https://catchdream.me/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Canvas中像素级别ImageData缩放</title>
    <link href="https://catchdream.me/2019/04/10/Canvas%E4%B8%AD%E5%83%8F%E7%B4%A0%E7%BA%A7%E5%88%ABImageData%E7%BC%A9%E6%94%BE/"/>
    <id>https://catchdream.me/2019/04/10/Canvas中像素级别ImageData缩放/</id>
    <published>2019-04-10T12:56:48.000Z</published>
    <updated>2019-04-16T14:04:05.259Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>弄Web端手写数字识别的时候要把Canvas缩成32*32大小的，刚开始想的是用canvas的画布缩放，弄了好久发现行不通，然后无意中发现可以获得每个像素的RGBA的值，然后又自己尝试每个像素缩放，语法不熟悉，各种尝试…<br>好了不多说了，代码在下面</p></div><a id="more"></a><h2 id="Canvas中对ImageData数据缩放"><a href="#Canvas中对ImageData数据缩放" class="headerlink" title="Canvas中对ImageData数据缩放"></a>Canvas中对ImageData数据缩放</h2><ul><li>ctx: 原始canvas的context</li><li>outCtx: 输出canvas的context</li><li>scale: 缩放倍数</li><li>scaled: 缩放后的ImageData</li><li>imageData.data: 图像的RGBA数组，是一个一维数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genImg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgData = ctx.getImageData(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">  outCtx.putImageData(scaleImageData(imgData,<span class="number">0.5</span>),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scaleImageData</span>(<span class="params">imageData, scale</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scaled =</span><br><span class="line">      outCtx.createImageData(imageData.width * scale, imageData.height * scale);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> row = <span class="number">0</span>; row &lt; imageData.height; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> col = <span class="number">0</span>; col &lt; imageData.width; col++) &#123;</span><br><span class="line">      <span class="keyword">var</span> sourcePixel = [</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">0</span>],</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">1</span>],</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">2</span>],</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">3</span>]</span><br><span class="line">      ];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; scale; y++) &#123;</span><br><span class="line">        <span class="keyword">var</span> destRow = <span class="built_in">Math</span>.floor(row * scale) + y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; scale; x++) &#123;</span><br><span class="line">          <span class="keyword">var</span> destCol = <span class="built_in">Math</span>.floor(col * scale) + x;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            scaled.data[(destRow * scaled.width + destCol) * <span class="number">4</span> + i] = sourcePixel[i];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> scaled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note "><p>主要就是scaleImageData这个函数，原型是stackoverflow上的，不过有bug，自己修改了下。<br>遇到问题果然还是要看源码…</p></div>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;弄Web端手写数字识别的时候要把Canvas缩成32*32大小的，刚开始想的是用canvas的画布缩放，弄了好久发现行不通，然后无意中发现可以获得每个像素的RGBA的值，然后又自己尝试每个像素缩放，语法不熟悉，各种尝试…&lt;br&gt;好了不多说了，代码在下面&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Daily" scheme="https://catchdream.me/categories/Daily/"/>
    
    
      <category term="Canvas" scheme="https://catchdream.me/tags/Canvas/"/>
    
      <category term="Web" scheme="https://catchdream.me/tags/Web/"/>
    
      <category term="Daily" scheme="https://catchdream.me/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-002-Add Two Numbers</title>
    <link href="https://catchdream.me/2019/04/09/LeetCode-002-Add-Two-Numbers/"/>
    <id>https://catchdream.me/2019/04/09/LeetCode-002-Add-Two-Numbers/</id>
    <published>2019-04-08T16:39:36.000Z</published>
    <updated>2019-04-13T03:25:06.848Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">Problem</a></h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers.<br>The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit.<br>Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><p>因为以前做过差不多的题目，而且感觉也不难，设置一个进位标志，然后一个个往后加。</p><p>犯了三个小错误</p><ul><li>算当前node的值时居然没把carry一起加起来算</li><li>算下次的carry时没有把上次的carry加上</li><li>忘了最后一次还可能有进位，要新建一个node</li></ul><p>还纠结好久要不要头结点，刚开始以为题目不可以用头结点，毕竟Example上没有，写到后面还是出错了，看了题解换了有头结点的版本就好了。</p><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *tmp = res;</span><br><span class="line">        ListNode *p = l1;</span><br><span class="line">        ListNode *q = l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tmp-&gt;next = <span class="keyword">new</span> ListNode((p-&gt;val + q-&gt;val+carry)%<span class="number">10</span>);<span class="comment">//把+carry放在了%10的后面</span></span><br><span class="line">            carry = (p-&gt;val + q-&gt;val+carry)/<span class="number">10</span>;<span class="comment">//居然漏了+carry</span></span><br><span class="line"></span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line"></span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tmp-&gt;next = <span class="keyword">new</span> ListNode((p-&gt;val + carry)%<span class="number">10</span>);</span><br><span class="line">            carry = (p-&gt;val + carry)/<span class="number">10</span>;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tmp-&gt;next = <span class="keyword">new</span> ListNode((q-&gt;val + carry)%<span class="number">10</span>);</span><br><span class="line">            carry = (q-&gt;val + carry)/<span class="number">10</span>;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>) tmp-&gt;next = <span class="keyword">new</span> ListNode(carry);<span class="comment">//漏了最后的进位</span></span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note default"><p>我这里在最后用了两个while来判断是否结束，题解上面是在第一个while里面对p和q进行了处理：<br>　　只要到了NULL，就让它的值为0，时间复杂度上来说是一样的，都是<script type="math/tex">\max{l1的节点数，l2的节点数}</script>，简单理解为<script type="math/tex">O(n)</script></p></div><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>一共两种，不是自己写的，不是很熟悉Python的链表，多看看学习下。</p><p>第一中的sum写法不是很懂…绝望，第二种比较好理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        res = ListNode(0)</span><br><span class="line">        tmp = res</span><br><span class="line">        left = 0</span><br><span class="line"></span><br><span class="line">        while l1 or l2 or left:</span><br><span class="line">            left, right = divmod(sum(l and l.val or 0 for l in (l1, l2)) + left, 10)</span><br><span class="line">            tmp.next = ListNode(right)</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">            l1 = l1 and l1.next</span><br><span class="line">            l2 = l2 and l2.next</span><br><span class="line"></span><br><span class="line">        return res.next</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        head = ListNode(0)</span><br><span class="line">        curr = head</span><br><span class="line">        carry, total = 0, 0</span><br><span class="line"></span><br><span class="line">        while(l1 or l2):</span><br><span class="line">            a = l1.val if l1 else 0</span><br><span class="line">            b = l2.val if l2 else 0</span><br><span class="line">            total = a + b + carry</span><br><span class="line">            carry = total // 10</span><br><span class="line"></span><br><span class="line">            if l1 or l2:</span><br><span class="line">                curr.next = ListNode(total % 10)</span><br><span class="line"></span><br><span class="line">            if l1:</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            if l2:</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            curr = curr.next</span><br><span class="line"></span><br><span class="line">        if carry&gt;0:</span><br><span class="line">            curr.next = ListNode(carry)</span><br><span class="line"></span><br><span class="line">        return head.next</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉自己解题速度有点慢，而且粗心犯小错误。</p><p>感觉是练得太少，以后加油！</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;You are given two &lt;strong&gt;non-empty&lt;/strong&gt; linked lists representing two non-negative integers.&lt;br&gt;The digits are stored in &lt;strong&gt;reverse order&lt;/strong&gt; and each of their nodes contain a single digit.&lt;br&gt;Add the two numbers and return it as a linked list.&lt;br&gt;You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;&lt;a href=&quot;#Example&quot; class=&quot;headerlink&quot; title=&quot;Example:&quot;&gt;&lt;/a&gt;Example:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br&gt;Output: 7 -&amp;gt; 0 -&amp;gt; 8&lt;br&gt;Explanation: 342 + 465 = 807.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="https://catchdream.me/tags/Linked-List/"/>
    
      <category term="Large Number" scheme="https://catchdream.me/tags/Large-Number/"/>
    
      <category term="Math" scheme="https://catchdream.me/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基石--Feasibility of Learning</title>
    <link href="https://catchdream.me/2019/04/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3-Feasibility-of-Learning/"/>
    <id>https://catchdream.me/2019/04/08/机器学习基石-Feasibility-of-Learning/</id>
    <published>2019-04-08T09:38:49.000Z</published>
    <updated>2019-04-08T10:46:57.196Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>《机器学习基石》第四讲<strong>Feasibility of Learning</strong>的课程笔记。主要介绍了机器学习的可行性。</p></div><a id="more"></a><p>机器学习很多时候，如果不加限制，常常会因为标准的不同，而有很多的不一样的结果。</p><p>并且，在训练集内得到的结果拟合的很好，但是在测试集甚至所有的可能来看，可能就是错误的，可能就是不确定的</p><h1 id="Learning-is-impossiable"><a href="#Learning-is-impossiable" class="headerlink" title="Learning is impossiable"></a>Learning is impossiable</h1><h2 id="No-Free-Lunch"><a href="#No-Free-Lunch" class="headerlink" title="No Free Lunch"></a>No Free Lunch</h2><blockquote><p>即: 天下没有免费的午餐<br>用于比较两种优化算法之间的关系，即如何确定一种算法比另外一种算法好</p></blockquote><p>NFL定理的前提是，所有问题出现的机会相等、或所有问题都是同等重要。</p><p>而实际情形往往并不是这样。一般我们只需要关注自己正要解决的问题即可。而对于我们的解决方案在另一个问题上的表现是否同等出色，我们并不关心。</p><blockquote><p>因此，脱离具体问题而空谈“什么算法最好”之类的讨论毫无意义.<br> 因为若考虑所有潜在的问题，那么所有的模型、算法都一样好——这也是我们通过NFL定理得出的。<br>要比较模型的相对优劣，则必须建立在与之对应的学习问题之上。</p></blockquote><h1 id="Probability-to-the-Rescue"><a href="#Probability-to-the-Rescue" class="headerlink" title="Probability to the Rescue"></a>Probability to the Rescue</h1><h2 id="Hoeffding’s-Inequality"><a href="#Hoeffding’s-Inequality" class="headerlink" title="Hoeffding’s Inequality"></a>Hoeffding’s Inequality</h2><blockquote><p>Hoeffding 不等式</p></blockquote><p>大概意思就是不知道很大的样本中的概率，但是我们可以通过很多次的抽样，得到的概率来推测真正的概率。</p><p>想到以前数学家证明硬币一面朝上的概率，通过很多很多很多次的抛硬币来统计每面朝上的概率，最后证明就是1/2，并且抛的次数越多，概率越接近。</p><img src="/2019/04/08/机器学习基石-Feasibility-of-Learning/fol1.png" title="Hoeffding Inequality 1/2"><img src="/2019/04/08/机器学习基石-Feasibility-of-Learning/fol2.png" title="Hoeffding Inequality 2/2"><h1 id="Connection-to-Learning"><a href="#Connection-to-Learning" class="headerlink" title="Connection to Learning"></a>Connection to Learning</h1><script type="math/tex; mode=display">E_in(h) $$代表我们抽的样本中的不一致概率$$ E_out(h) $$代表总的样本中的不一致的概率可以推断说N足够大时，$$ E_in(h) \sim E_out(h)</script><p>如果<script type="math/tex">E_in(h) \sim E_out(h)</script>，并且<script type="math/tex">E_in(h)</script>很小，我们就可以推断，<script type="math/tex">E_out(h)</script>很小，并且，<script type="math/tex">h \sim f with respect to P</script></p><img src="/2019/04/08/机器学习基石-Feasibility-of-Learning/fol3.png" title="Added Componentss"><img src="/2019/04/08/机器学习基石-Feasibility-of-Learning/fol4.png" title="The Formal Guarantee"><div class="note danger"><p><strong>real learning</strong> is: <script type="math/tex">A</script> shall <strong>make choices <script type="math/tex">\in H</script></strong> (like PLA)<br>rather than <em>being forced to pick one h</em></p></div><div class="note info"><p>可以使用历史数据(data)来验证一个假设的表现到底好不好, 可以理解为验证集</p></div>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;《机器学习基石》第四讲&lt;strong&gt;Feasibility of Learning&lt;/strong&gt;的课程笔记。主要介绍了机器学习的可行性。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="MachineLearning" scheme="https://catchdream.me/categories/MachineLearning/"/>
    
      <category term="机器学习基石" scheme="https://catchdream.me/categories/MachineLearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3/"/>
    
    
      <category term="MachineLearning" scheme="https://catchdream.me/tags/MachineLearning/"/>
    
      <category term="机器学习基石" scheme="https://catchdream.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-001-Two Sum</title>
    <link href="https://catchdream.me/2019/04/07/LeetCode-001-Two-Sum/"/>
    <id>https://catchdream.me/2019/04/07/LeetCode-001-Two-Sum/</id>
    <published>2019-04-07T15:31:44.000Z</published>
    <updated>2019-04-13T03:45:10.721Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Problem</a></h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. UPDATE (2016/2/13): The return format had been changed to zero-based indices. Please read the above updated description carefully.</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>刚开始第一反应就是暴力遍历，但是时间复杂度是<script type="math/tex">O(n^2)</script></li><li>题解用了hash map，时间复杂度为<script type="math/tex">O(n)</script><ul><li>第一种方式是两遍hash，第一遍将元素添加进去，第二遍遍历元素</li><li>第二种方式一遍hash，一边添加元素一边判断结果是否在已添加的元素中</li></ul></li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; numMap;          <span class="comment">//创建map</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt;::iterator it;   <span class="comment">//创建迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            it=numMap.find(target-nums[i]);       <span class="comment">//find函数查找key</span></span><br><span class="line">            <span class="keyword">if</span>(it!=numMap.end())&#123;                 <span class="comment">//如果到了end就说明没找到</span></span><br><span class="line">                res.push_back(i);</span><br><span class="line">                res.push_back(numMap[target-nums[i]]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            numMap.insert(make_pair(nums[i],i));  <span class="comment">//插入pair</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info"><h2 id="C-中vector用法回忆："><a href="#C-中vector用法回忆：" class="headerlink" title="C++中vector用法回忆："></a>C++中vector用法回忆：</h2><ul><li>创建：vector<int> vec;</int></li><li>访问：int i=vec[0];</li><li>插入：vec.push_back(1);vec.insert(index,val)，在第i个元素后面插入</li><li>删除：<ul><li>vec.pop_back(),删除最后一个</li><li>vec.erase(index)，删除index位置处元素</li><li>vec.erase(1,3)，删除[1,3)区间的元素</li></ul></li><li>大小：vec.size();</li><li>清空：vec.clear();</li><li>翻转：reverse(vec.begin(),vec.end());将元素翻转在vecotr，要#include<algorithm></algorithm></li><li>排序：<ul><li>sort(vec.begin(),vec.end());默认按照升序排列</li><li>sort(vec.begin(),vec.end(),cmp);定义排序比较函数将序排列<blockquote><p>bool cmp(const int&amp;a,const int&amp;b){<br>  return a&gt;b;<br>}</p></blockquote></li></ul></li><li>迭代器访问<blockquote><p>vector<int>::iterator it;<br>for(it=vec.begin();it!=vec.end();it++)<br>  cout&lt;&lt;*it&lt;&lt;endl;</int></p></blockquote></li></ul></div><div class="note info"><h2 id="C-中map的用法"><a href="#C-中map的用法" class="headerlink" title="C++中map的用法"></a>C++中map的用法</h2><ul><li>创建：map\<string, int\="">mapString; key类型为string，val类型为int</string,></li><li>添加：<ul><li>mapString[“hello”]=1; 最常用的最简单的插入方式,<strong>会覆盖之前的数据</strong></li><li>mapString.insert(make_pair(“hello”,1));  次常用,<strong> insert()不会覆盖之前的数据</strong></li><li>mapString.insert(pair<string,int>(“hello”,1));</string,int></li><li>mapString.insert(map<string,int>::value_type(“hello”,1));</string,int></li></ul></li><li><p>迭代：</p><blockquote><p>map<string,int>::iterator it;<br>for ( it = mapString.begin( ); it != mapString.end( ); it++ )<br>  cout &lt;&lt; “ “ &lt;&lt; it -&gt; second;</string,int></p></blockquote></li><li><p>查找：</p><ul><li><strong>不建议!</strong> mapString[“hello”];返回”hello”对应的值，如果不存在，则添加一个元素，key为”hello”,val为类型默认值,并返回这个默认值</li><li>mapString.count(“hello”); map::count()方法返回被查找元素的个数,只有0或1</li><li>map::find()方法,返回的是被查找元素的位置，没有则返回map.end()<blockquote><p>map<string,int>::iterator it;<br>it = mapString.find(“hello”);<br>if(it==test.end()){<br>  cout&lt;&lt;”hello not found”&lt;&lt;endl;<br>}</string,int></p></blockquote></li></ul></li><li><p>删除:</p><ul><li>mapString.erase(“hello”);</li><li>用迭代器删除,注意在迭代期间是不能被删除的<blockquote><p>map<string,int>::iterator it;<br>it = mapString.find(“hello”);</string,int></p><p>if(it==mapString.end())  cout&lt;&lt;”hello not found”&lt;&lt;endl;<br>else  mapString.erase(it);</p></blockquote></li></ul></li><li><p>排序：map中元素自动按照key升序排序，不可以用sort函数</p></li><li>大小：mapString.size();</li><li>清除：mapString.clear();</li></ul></div><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> map:</span><br><span class="line">                <span class="keyword">return</span> [map[target - num], i]</span><br><span class="line">            map[num] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><div class="note info"><p>list中遍历的三种方式：</p><ol><li>for items in list:  根据元素遍历</li><li>for index in range(len(list)):  根据索引遍历</li><li>enumerate(seq, [start=0])  创建枚举对象，同时列出数据下标和数据<ul><li>seq: 一个序列、迭代器或其他支持迭代对象, 如列表、元组或字符串</li><li>start: 下标起始位置</li><li>返回：一个列表 [(下标，数据)…], 例如[(1, ‘a’), (2, ‘b’), (3, ‘c’)]</li></ul></li><li>iterList = iter(list)  创建迭代器遍历<ul><li>用法：for item in iterList: print(item)</li></ul></li></ol></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然第一题很简单，但是深入了看还是能学了不少东西的，在遍历这方面，时间复杂度优化可以用map，C++时间复杂度可以从<script type="math/tex">O(n)</script>降到<script type="math/tex">O(logn)</script>，python和java可以直接降到<script type="math/tex">O(1)</script>.</p><p>而且打完代码复习了C++中vector的用法，还有pythonlist的enumerate遍历。C++ STL中的map是现学现卖了.</p><p>打算每天一题，感觉有点晚了，亡羊补牢把。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9,&lt;/p&gt;
&lt;p&gt;Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. UPDATE (2016/2/13): The return format had been changed to zero-based indices. Please read the above updated description carefully.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://catchdream.me/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://catchdream.me/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://catchdream.me/tags/Math/"/>
    
      <category term="Hash Map" scheme="https://catchdream.me/tags/Hash-Map/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基石--Types of Learning</title>
    <link href="https://catchdream.me/2019/04/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3-Types-of-Learning/"/>
    <id>https://catchdream.me/2019/04/07/机器学习基石-Types-of-Learning/</id>
    <published>2019-04-07T12:54:44.000Z</published>
    <updated>2019-04-08T09:35:53.894Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>《机器学习基石》第三讲<strong>Types of Learning</strong>的笔记。主要介绍了机器学习的集中分类标准和具体分类。</p></div><a id="more"></a><h1 id="不同的输出空间"><a href="#不同的输出空间" class="headerlink" title="不同的输出空间"></a>不同的输出空间</h1><h2 id="二元分类-binary-classification"><a href="#二元分类-binary-classification" class="headerlink" title="二元分类: binary classification"></a>二元分类: binary classification</h2><p>很基本的分类问题，输出只有两种. 通俗的理解就是简单的是非题，要么是，要么不是。</p><h2 id="多元分类-multiclass-classification"><a href="#多元分类-multiclass-classification" class="headerlink" title="多元分类: multiclass classification"></a>多元分类: multiclass classification</h2><p>很简单的例子就是对硬币的分类，课程中使用了美元的分类，1c, 5c, 10c, 25c 这样。</p><p>输出可以不只两种，上述硬币的分类输出为四，输出可以是K种。</p><p>二元分类是特殊的多元分类，即K=2的情况。</p><p><strong>应用场景</strong>:主要是视觉或听觉的辨识</p><ul><li>数字识别</li><li>图片内容分类</li><li>邮件的分类</li></ul><h2 id="回归问题-Regression"><a href="#回归问题-Regression" class="headerlink" title="回归问题: Regression"></a>回归问题: Regression</h2><p>$ y=R $ or $y = [lower, upper] \setminus R (bounded regression)$</p><p><strong>特点是</strong>输出是一个实数</p><p><strong>应用</strong></p><ul><li>股票价格</li><li>温度预测</li></ul><h2 id="结构化学习-Structed-Learning"><a href="#结构化学习-Structed-Learning" class="headerlink" title="结构化学习: Structed Learning"></a>结构化学习: Structed Learning</h2><p>理解起来就是多元分类的扩展，有很多很多的类别，但是类别和类别之间有着某种潜在结构，我们要输出的就是这种结构。</p><p>比如一个句子，可以是主谓宾、主谓等等，但是不可能是谓语谓语谓语这样。我们如果对一个句子进行语法判断，输出空间就是这些结构，而不是一个个的类别。</p><p><strong>应用</strong>:输出空间有着某种结构</p><ul><li>蛋白质的结构</li><li>自然语言处理中语言的parse tree</li></ul><p>总的可以看下图：<br><img src="/2019/04/07/机器学习基石-Types-of-Learning/tol1.png" title="Learning with Different Output Space"></p><h1 id="不同程度标记的样本"><a href="#不同程度标记的样本" class="headerlink" title="不同程度标记的样本"></a>不同程度标记的样本</h1><h2 id="监督学习-Supervised-Learning"><a href="#监督学习-Supervised-Learning" class="headerlink" title="监督学习: Supervised Learning"></a>监督学习: Supervised Learning</h2><p>给了一堆样本，然后还对每个样本进行了标记是什么，即每个<script type="math/tex">x_n</script>对应一个<script type="math/tex">y_n</script></p><h2 id="非监督学习-Unsupervised-Learning"><a href="#非监督学习-Unsupervised-Learning" class="headerlink" title="非监督学习: Unsupervised Learning"></a>非监督学习: Unsupervised Learning</h2><p>给了一对样本，但是不给样本的正确标记(without yn), 让机器自己去把样本分成几类。</p><p><strong>聚类</strong>就相当于是<strong>非监督的多分类问题</strong></p><ul><li>把一些文章按照不同的topic分类</li><li>按照消费者的资料把消费者分类,针对不同的人群进行促销。</li></ul><p><strong>密度预测</strong>相当于是<strong>Unsupervised bounded regression</strong></p><ul><li>交通车流量分析,按照位置分</li></ul><p><strong>异常监测</strong>相当于是<strong>Unsupervised binary classification</strong></p><ul><li>网络流量分析</li></ul><div class="note info"><p>聚类通常比较有用，但是评定聚类的好坏通常比较困难。</p></div><h2 id="半监督式学习-Semi-supervised-Learning"><a href="#半监督式学习-Semi-supervised-Learning" class="headerlink" title="半监督式学习: Semi-supervised Learning"></a>半监督式学习: Semi-supervised Learning</h2><p>比如硬币识别，但是只给了一部分<script type="math/tex">y_n</script>，和其他没有标记的样本混在一起</p><p><strong>应用</strong></p><ul><li>人脸识别，只有少量标记的面部照片</li><li>药物效果预测，只有少量的药物有标签</li></ul><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>一种非常不同的，但是很自然的学习方式。不直接告诉它你要做什么，但是可以通过一定的行为反应，惩罚错误的结果，奖励正确的结果。</p><p>比如训练狗狗，做得对就奖励，做的错就惩罚，没办法直接说给他听。</p><p><strong>应用</strong></p><ul><li>广告系统输入的是顾客资料，顾客点击或者不点击，推荐</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2019/04/07/机器学习基石-Types-of-Learning/tol2.png" title="Learning with Different Data Label yn"><h1 id="不同的训练方式"><a href="#不同的训练方式" class="headerlink" title="不同的训练方式"></a>不同的训练方式</h1><h2 id="batch-Supervised-multiclass-classification"><a href="#batch-Supervised-multiclass-classification" class="headerlink" title="batch Supervised multiclass classification"></a>batch Supervised multiclass classification</h2><p>成批的将数据喂给机器学习的算法，算法从所有已知的data中学习，得到假设<script type="math/tex">g</script><br><strong>应用</strong></p><ul><li>数据是email，得到邮件分类器</li><li>数据是cancer资料，得到cancer分类器</li></ul><div class="note info"><p>根据数据是否一次送入模型中训练分为batch learning和online learning.</p><p>batch learning像是填鸭式，online learning像是教书，一条一条教.</p></div><h2 id="online-learning"><a href="#online-learning" class="headerlink" title="online learning"></a>online learning</h2><p>指每次有新样本的时候就用来训练更新 hypothesis，每一轮<script type="math/tex">g</script>会更好, 常见的比如说有垃圾邮件分类系统.</p><p>增强学习和PLA常常比较接近online learning</p><h2 id="active-learning"><a href="#active-learning" class="headerlink" title="active learning"></a>active learning</h2><p>希望是机器能够主动的问选择的<script type="math/tex">x_n</script>对应的<script type="math/tex">y_n</script>，可以通过这种方式用很少的labels来提高<script type="math/tex">g</script></p><h1 id="不同的输入空间"><a href="#不同的输入空间" class="headerlink" title="不同的输入空间"></a>不同的输入空间</h1><p>根据输入的样本的特征来分也可以分为下面三类（虽然这种分类方法并不常见）：concrete features，raw features 和 abstract features。</p><h2 id="concrete-features"><a href="#concrete-features" class="headerlink" title="concrete features"></a>concrete features</h2><p>指输入的样本已经标注好了各种特征，如信用卡例子中顾客的各种资料</p><h2 id="raw-features"><a href="#raw-features" class="headerlink" title="raw features"></a>raw features</h2><p>一般指图像或音频中的图像或声波，这些信息是原始的信号，需要进行一些转换才能使用。</p><p>比如手写数字识别，16x16的像素格，可以将16x16=256个像素变成一个256维的向量输入。</p><h2 id="abstract-features"><a href="#abstract-features" class="headerlink" title="abstract features"></a>abstract features</h2><p>课程中用了KDDCup的例子，给出每个用户和他们喜欢听的音乐，要预测这个用户对一个新歌曲的评分是多少。<br>输入的是，用户id，歌曲的id，输出是评分数字</p><p>但是输入的特征并不是很直接，需要一方面人来提示，还有是机器自己从每个人喜欢听的歌里面得到特征，从每首歌的曲风等特征里面总结出特征，然后再用这些特征训练，得到结果。</p><p>这种按照输入样本的 features 进行分类的方法在实际中并不常用，因为输入的样本往往是各种 features交杂在一起的，不同问题需要与其相应的 features 才能得到好的效果，features 对结果的影响比较大。因此机器学习中也产生了 feature engineering 一说。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><img src="/2019/04/07/机器学习基石-Types-of-Learning/tol3.png" title="Learning with Different input Space">]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;《机器学习基石》第三讲&lt;strong&gt;Types of Learning&lt;/strong&gt;的笔记。主要介绍了机器学习的集中分类标准和具体分类。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="MachineLearning" scheme="https://catchdream.me/categories/MachineLearning/"/>
    
      <category term="机器学习基石" scheme="https://catchdream.me/categories/MachineLearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3/"/>
    
    
      <category term="MachineLearning" scheme="https://catchdream.me/tags/MachineLearning/"/>
    
      <category term="机器学习基石" scheme="https://catchdream.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基石--PLA算法</title>
    <link href="https://catchdream.me/2019/04/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3-PLA%E7%AE%97%E6%B3%95/"/>
    <id>https://catchdream.me/2019/04/07/机器学习基石-PLA算法/</id>
    <published>2019-04-07T04:36:48.000Z</published>
    <updated>2019-04-07T07:21:53.563Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>《机器学习基石》第二讲 <strong>Learning to Answer Yes/NO</strong> 课程笔记。这一讲主要介绍了机器学习基本概念和感知机，以及其训练算法PLA。</p></div><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><script type="math/tex">\mathcal f</script>: 未知的目标函数</li><li><script type="math/tex">\mathcal D</script>: 训练样本，数据集</li><li><script type="math/tex">\mathcal A</script>: 学习算法</li><li><script type="math/tex">\mathcal H</script>: 假设集</li><li><script type="math/tex">\mathcal g</script>: 最终的假设，是\mathcalf的一个近似函数</li></ul><p>课件上很清楚的描绘了机器学习的一个过程<br><img src="/2019/04/07/机器学习基石-PLA算法/pla1.png" title="基本过程"></p><h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><p>感知机是神经网络的基础，与线性回归（Linear Regression），逻辑回归（Logistics Regression）等模型也非常类似，是一种非常典型的线性模型。</p><p>原始的感知机算法用于解决二分类问题，其思想如下：假设样本有 d 个特征，但是每个特征的重要性不一样，因此各个特征的权重也不一样，对其进行加权后得到的总和假如大于某个阈值则认为归为其中一类，反之归为另一类。如在信用卡的例子中，通过感知机有如下的结果<br><img src="/2019/04/07/机器学习基石-PLA算法/pla2.png" title="推导过程"></p><p>然后可以将threshold化为常数项作为<script type="math/tex">w_0</script>,简化为下图：<br><img src="/2019/04/07/机器学习基石-PLA算法/pla3.png" title="简化过程"><br>上面的<script type="math/tex">w</script>和<script type="math/tex">x</script>均为一个列向量，即<script type="math/tex">w</script>转置后成为行向量</p><h2 id="PLA"><a href="#PLA" class="headerlink" title="PLA"></a>PLA</h2><p>感知机要通过学习才能对样本进行正确的分类，这个学习的过程就是PLA(Perceptron Learning Algorithm).</p><p><strong>过程如下</strong>：</p><ol><li>随机初始化参数<script type="math/tex">w</script></li><li>利用参数<script type="math/tex">w</script>预测每个样本点的值并与其实际的值比较，对于分类错误的样本点(xn,yn),利用公式<script type="math/tex">w=w+ynxn</script>更新参数<script type="math/tex">w</script>的值</li><li>重复上面的过程直到所有的样本点都能够被参数<script type="math/tex">w</script>正确预测。</li></ol><p>对于某个被预测错误的样本点，参数<script type="math/tex">w</script>更新过程如下：<br><img src="/2019/04/07/机器学习基石-PLA算法/pla4.png" title="w的更新"></p><p>注意上面的算法的前提是所有的样本点都必须线性可分，假如样本点线性不可分，那么PLA按照上面的规则会陷入死循环中。如下是线性可分与线性不可分的例子)<br><img src="/2019/04/07/机器学习基石-PLA算法/pla5.png" title="线性不可分的例子"></p><h2 id="收敛性证明"><a href="#收敛性证明" class="headerlink" title="收敛性证明"></a>收敛性证明</h2><p>上面提到只有当所有的样本均为线性可分时，PLA才能将所有的样本点正确分类后再停下了，但是这仅仅是定性的说明而已，并没有严格的数学正面来支撑其收敛性，下面要讲的便是通过数学证明来说明 PLA 算法的收敛性。</p><p>课程中用两次递进的证明来说明收敛性<br><img src="/2019/04/07/机器学习基石-PLA算法/pla6.png" title="简单证明"></p><p>上面讲的是随着参数<script type="math/tex">w</script>的更新,<script type="math/tex">w^T_fw_t+1</script>的值越来越大，也就是两者越来越相似<br>衡量两个向量相似性的一种方法就是考虑他们的内积，值越大，代表两者约接近，但是这里还没对向量归一化，所以证明并不严格，但是已经说明了两者具有这个趋势，下面是更严格的过程<br><img src="/2019/04/07/机器学习基石-PLA算法/pla7.png" title="严格证明"></p><p>上面似乎只是说明了经过 T 次的纠错，wt 的值会限制在一个范围内，但是并没有给出最终结论</p><script type="math/tex; mode=display">{w_f \over ||w_f||}{w_T \over ||w_T||} \ge \sqrt{T} * constant</script><p>的证明过程，因此在这里进行推导过程的描述<br>(注：这里的<script type="math/tex">w_f</script>是不变的，因此<script type="math/tex">w_f</script>与<script type="math/tex">w^T_f</script>是一样的)</p><p>假设经过了 T 次纠错，那由第一张PPT可知</p><script type="math/tex; mode=display">w^T_fw_T \ge w_f^Tw_{T-1} + \min_{n}y_nw_f^Tx_n</script><p>而由第二章张ppt可知</p><script type="math/tex; mode=display">||w_T||^2 \le ||w_{T-1}||^2 + \max_n||x_n||^2 \le T\max_n||x_n||^2</script><p>即：<script type="math/tex">||w_T|| \le \sqrt{T}\max_n||x_n||</script></p><p>综合上面两个式子有</p><script type="math/tex; mode=display">{w_f^T \over ||w_f^T||}{w_T \over ||w_T||} \ge {T\min_ny_n^Tw^T_fx_n \over ||w_f^T||\sqrt{T}\max_n||x_n||} = \sqrt{T}{\min_ny_n{w_f^T \over ||w_f^T||}x_n \over \max_n||x_n||} = \sqrt{T} * constant</script><p>因此上面的命题得证。至此，已经可知道犯错误的次数 T 是受到某个上限的约束的。下面会给出这个具体的上限是多少。</p><p>又因为</p><script type="math/tex; mode=display">1 \ge {w_f^T \over ||w_f^T||}{w_T\over||w_T||} \ge \sqrt{T} * constant</script><script type="math/tex; mode=display">{1\over constant^2 } \ge T</script><p>即犯错的次数上限是${1 \over constant^2}$,假设令</p><script type="math/tex; mode=display">\max_n||x||^2 = R^2, \rho = \min_ny_n{w_f^T \over ||w_f^T||}x_n</script><p>则有</p><script type="math/tex; mode=display">T \le {R^2 \over \rho^2}</script><p>这也说明了PLA会在有限步内收敛，这个证明也是后面的练习答案</p><h2 id="优缺点和优化"><a href="#优缺点和优化" class="headerlink" title="优缺点和优化"></a>优缺点和优化</h2><p>PLA 的优点和缺点都非常明显，其中优点是简单，易于实现</p><p>缺点是假设了数据是线性可分的，然而事先并无法知道数据是否线性可分的。正如上面提到的一样，假如将PLA 用在线性不可分的数据中时，会导致PLA永远都无法对样本进行正确分类从而陷入到死循环中。</p><p>为了避免上面的情况，将 PLA 的条件放宽一点，不再要求所有的样本都能正确地分开，而是要求犯错的的样本尽可能的少，即将问题变为了</p><script type="math/tex; mode=display">arg\min_w\sum_{n=0}^N1\{y_n \neq sign(w^Tx_n)\}</script><p>这个最优化问题是个 NP-hard 问题，无法求得其最优解，因此只能求尽可能接近其最优解的近似解。讲义中提出的一种求解其近似解的算法<code>Pocket Algorithm</code>。  </p><p>其思想就是每次保留当前最好的<script type="math/tex">w</script>, 当遇到错误的样本点对<script type="math/tex">w</script>进行修正后，比较修正后的<script type="math/tex">w</script>与原来最好的<script type="math/tex">w</script>在整个样本点上的总体效果再决定保留哪一个，重复迭代足够多的次数后返回当前得到的最好的<script type="math/tex">w</script>。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;《机器学习基石》第二讲 &lt;strong&gt;Learning to Answer Yes/NO&lt;/strong&gt; 课程笔记。这一讲主要介绍了机器学习基本概念和感知机，以及其训练算法PLA。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="MachineLearning" scheme="https://catchdream.me/categories/MachineLearning/"/>
    
      <category term="机器学习基石" scheme="https://catchdream.me/categories/MachineLearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3/"/>
    
    
      <category term="MachineLearning" scheme="https://catchdream.me/tags/MachineLearning/"/>
    
      <category term="机器学习基石" scheme="https://catchdream.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3/"/>
    
      <category term="PLA" scheme="https://catchdream.me/tags/PLA/"/>
    
  </entry>
  
  <entry>
    <title>MNIST入门-手写数字识别</title>
    <link href="https://catchdream.me/2019/04/02/MNIST%E5%85%A5%E9%97%A8-%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>https://catchdream.me/2019/04/02/MNIST入门-手写数字识别/</id>
    <published>2019-04-02T02:11:01.000Z</published>
    <updated>2019-04-13T15:10:28.987Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p><strong>Target</strong><br>将训练一个机器学习模型用于预测图片里面的数字.  </p><p>理解TensorFlow工作流程和机器学习的基本概念</p><p>和官网不同的是只记录关键点</p></div><a id="more"></a><p><strong>关键词</strong></p><p><a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST</a><br><a href="http://www.tensorfly.cn/tfdoc/tutorials/mnist_beginners.html" target="_blank" rel="noopener">TensorFlow</a><br><a href="https://blog.csdn.net/google19890102/article/details/41594889" target="_blank" rel="noopener">Softmax Regression</a></p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><ul><li>数据集被分成两部分：60000行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）</li><li>把这些图片设为“xs”，把这些标签设为“ys”<ul><li>训练数据集的图片是 mnist.train.images ，训练数据集的标签是 mnist.train.labels</li></ul></li><li>mnist.train.images 是一个形状为 [60000, 784] 的张量，第一个维度数字索引图片，第二个维度数字索引每张图片中的像素点<ul><li>向量值表某个像素的强度值，值介于0和1之间</li></ul></li><li>mnist.train.labels 是一个 [60000, 10] 的数字矩阵<ul><li>标签数据是”one-hot vectors”</li><li>10维，只有一个维度非0</li><li>标签0将表示成([1,0,0,0,0,0,0,0,0,0,0])</li></ul></li></ul><h2 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h2><p>softmax模型可以用来给不同的对象分配概率。即使在之后，我们训练更加精细的模型时，最后一步也需要用softmax来分配概率。</p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><ul><li>对数据进行加权求和，在手写数字识别的例子里就是丢每个像素值加权求和</li><li>在每个像素值求和的后面加上一个偏置量<script type="math/tex">b_i</script>，这是由于输入会有一些干扰量</li></ul><p>可以得到输入图片 x ，[784]的向量，它代表的是数字 i 的证据可以表示:</p><script type="math/tex; mode=display">evidence_i = \sum_jW_{i,j}x_j+b_i</script><p>其中<script type="math/tex">W_i</script>维度是[784,10]，代表权重，<script type="math/tex">b_i</script>维度是[10]代表是数字i类的偏置量，j代表图片x的像素索引用于求和</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>再使用softmax函数将evidence转换成概率y</p><script type="math/tex; mode=display">y=softmax(evidence)</script><p>softmax函数可以看成是激励函数(activation)，把线性函数输出转换成想要的格式:关于10个数字的概率分布。</p><script type="math/tex; mode=display">softmax(x) = normalize(exp(x))</script><script type="math/tex; mode=display">softmax(x)_i = {exp(x_i) \over \sum_jexp(x_j)}</script><div class="note "><p>即：把输入值当成幂指数求值，再正则化这些结果值</p></div><p>结合上面的evidence可以知道，evidence越大，正则化后的结果更大，就是权重更大。<br><img src="/2019/04/02/MNIST入门-手写数字识别/sof1.png"><br>进一步写成:</p><script type="math/tex; mode=display">y = softmax(W_x + b)</script><h2 id="实现模型"><a href="#实现模型" class="headerlink" title="实现模型"></a>实现模型</h2>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;Target&lt;/strong&gt;&lt;br&gt;将训练一个机器学习模型用于预测图片里面的数字.  &lt;/p&gt;
&lt;p&gt;理解TensorFlow工作流程和机器学习的基本概念&lt;/p&gt;
&lt;p&gt;和官网不同的是只记录关键点&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="MachineLearning" scheme="https://catchdream.me/categories/MachineLearning/"/>
    
    
      <category term="TensorFlow" scheme="https://catchdream.me/tags/TensorFlow/"/>
    
      <category term="ML" scheme="https://catchdream.me/tags/ML/"/>
    
      <category term="MNIST" scheme="https://catchdream.me/tags/MNIST/"/>
    
  </entry>
  
  <entry>
    <title>Fedora 26 编译内核</title>
    <link href="https://catchdream.me/2019/04/01/Fedora26%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/"/>
    <id>https://catchdream.me/2019/04/01/Fedora26编译内核/</id>
    <published>2019-03-31T16:09:49.000Z</published>
    <updated>2019-03-31T19:33:55.064Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"><br>被迫很不情愿的编译内核…以前服务器上编译过，贼麻烦，现在又要编译，为了不让我的Arch出什么幺蛾子，新弄了个虚拟机练手了。<br>还是Fedora26的，现在都出29了，时间过得真快。</p><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="查看自己内核版本"><a href="#查看自己内核版本" class="headerlink" title="查看自己内核版本"></a>查看自己内核版本</h2><pre><code>uname -aLinux localhost.localdomain 4.11.8-300.fc26.x86_64 #1 SMP Thu Jun 29 20:09:48 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</code></pre><h2 id="下载内核并解压到-usr-src目录下"><a href="#下载内核并解压到-usr-src目录下" class="headerlink" title="下载内核并解压到/usr/src目录下"></a>下载内核并解压到/usr/src目录下</h2><p>推荐一下<a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/" target="_blank" rel="noopener">上海交大的网站</a>，速度挺快的。<br>下载好后<code>tar xf linux-5.0.1.tar.gz -C /usr/src</code>解压到/usr/src下</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><div class="note danger"><p>make编译内核起码预留10个G，编译完之后，不然存储会不够，又要重新弄。<br>boot分区发现200M会不够用，改成500M可以，扩容还是挺麻烦的<br>/ 根目录（具体来说是 /lib，没挂载/lib的话就默认是使用/目录） 要有至少4G的空余空间</p></div><h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><h2 id="make-makemenuconfig"><a href="#make-makemenuconfig" class="headerlink" title="make makemenuconfig"></a>make makemenuconfig</h2><p>这是带有图形化界面的配置命令，在这里面可以定制很多功能。<br>常见的是定制内核版本，或者开启ntfs的功能。</p><p>内核版本在general setup里面，找到local version -append to kernel release</p><p>ntfs在file-systems下面，很下面的位置，找到DOS/FAT/NT Filesystems，进入后用M键启用NTFS，用模块的方式，并在下面的NTFS write support 那里用y键启用  </p><p>然后 保存退出</p><p>如果想用默认配置，可以直接方向键选择<strong>save</strong>，然后<strong>exit</strong>。</p><p>刚开始使用这个命令可能会一直报错，解决的基本原则是提示缺少什么包</p><p>就在这个包的名字后面加上-devel，然后用dnf安装（其他版本也一样，只要换一下包管理器名）</p><h3 id="缺少ncurses-devel包"><a href="#缺少ncurses-devel包" class="headerlink" title="缺少ncurses-devel包"></a>缺少ncurses-devel包</h3><pre><code>dnf install ncurses-devel</code></pre><h3 id="缺少flex包"><a href="#缺少flex包" class="headerlink" title="缺少flex包"></a>缺少flex包</h3><pre><code>dnf install flex</code></pre><h3 id="缺少bison包"><a href="#缺少bison包" class="headerlink" title="缺少bison包"></a>缺少bison包</h3><pre><code>dnf install bison</code></pre><h3 id="报错：You-are-building-kernel-with-non-retpoline-compiler"><a href="#报错：You-are-building-kernel-with-non-retpoline-compiler" class="headerlink" title="报错：You are building kernel with non-retpoline compiler."></a>报错：You are building kernel with non-retpoline compiler.</h3><p>应该升级GCC了，刚开始一直卡在这，网上也没发现non-retpoline是什么鬼，后来才发现是gcc版本太低，可能我刚装的虚拟机，没升级…      </p><pre><code>dnf update gcc</code></pre><h3 id="缺少libelf-dev-libelf-devel-or-elfutils-libelf-devel"><a href="#缺少libelf-dev-libelf-devel-or-elfutils-libelf-devel" class="headerlink" title="缺少libelf-dev, libelf-devel or elfutils-libelf-devel"></a>缺少libelf-dev, libelf-devel or elfutils-libelf-devel</h3><p>报错：error: Cannot generate ORC metadata for CONFIG_UNWINDER_ORC=y, please install libelf-dev, libelf-devel or elfutils-libelf-devel</p><p>这个直接安装会发现源里面没有，可以选择rpm包安装,也可以：</p><pre><code>dnf install binutils gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms</code></pre><p>这也是百度到的办法…当时都惊了，源里面居然都没有…</p><p>这里在装dkms,kernel-devel,patch的时候，安装了elfutils-libelf-devel和zlib-devel依赖</p><h3 id="缺少openssl"><a href="#缺少openssl" class="headerlink" title="缺少openssl"></a>缺少openssl</h3><p>报错:scripts/sign-file.c:25:10: fatal error: openssl/opensslv.h: No such file or directory</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <openssl opensslv.h=""></openssl></h1><p> 这里<code>dnf install openssl</code>发现已经安装了，很奇怪，后来发现libssl-devel在redhat系这里叫<strong>openssl-devel</strong></p><p>所以<code>dnf install openssl-devel</code></p><p> 如果是<strong>debian</strong>系的，应该是安装<strong>openss</strong>和<strong>libssl-devel</strong></p><h2 id="make-mrproper"><a href="#make-mrproper" class="headerlink" title="make mrproper"></a>make mrproper</h2><p>清除编译过程中产生的所有中间文件   </p><p>假如你之前也编译过内核，而你没有用此命令去清除之前编译产生的.o文件，那么，在make的时候，可能就会产生干扰。  </p><p>清除之后要重新make menuconfig 生成.config文件</p><h2 id="make-j8"><a href="#make-j8" class="headerlink" title="make -j8"></a>make -j8</h2><p><strong>-j</strong>是代表编译时用几个线程，这里开了8个线程来编译，不然太慢了。</p><h2 id="make-modules-install"><a href="#make-modules-install" class="headerlink" title="make modules_install"></a>make modules_install</h2><p>安装内核模块，这里比较快，一会会就好了，安装完后可以看到/lib/modules目录下就会出现新的内核。</p><h2 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h2><p>安装bzImage为/boot/vmlinuz-VERSION-RELEASE，并生成initramfs文件<br>使用ls /boot就可以查看新生成的文件，注意以安装的版本结尾的文件就好</p><p>查看grub.cfg, <code>ls /boot/grub2</code>, 应该就有grub.cfg引导文件了</p><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p>这时候应该就可以在启动项发现新的内核了</p><h2 id="删除旧内核"><a href="#删除旧内核" class="headerlink" title="删除旧内核"></a>删除旧内核</h2><ul><li><p>删除/lib/modules/目录下不需要的内核库文件</p></li><li><p>删除/usr/src/linux/目录下不需要的内核源码</p></li><li><p>删除/boot目录下启动的内核和内核映像文件</p></li><li><p>更改grub的配置文件，删除不需要的内核启动列表</p></li></ul><hr><p>这时候内核编译就结束了，还是挺耗时间的，特别是编译的时候。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;br&gt;被迫很不情愿的编译内核…以前服务器上编译过，贼麻烦，现在又要编译，为了不让我的Arch出什么幺蛾子，新弄了个虚拟机练手了。&lt;br&gt;还是Fedora26的，现在都出29了，时间过得真快。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://catchdream.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://catchdream.me/tags/Linux/"/>
    
      <category term="Learning" scheme="https://catchdream.me/tags/Learning/"/>
    
  </entry>
  
  <entry>
    <title>cannot start gnome-tweaks</title>
    <link href="https://catchdream.me/2019/03/20/cannot-start-gnome-tweaks/"/>
    <id>https://catchdream.me/2019/03/20/cannot-start-gnome-tweaks/</id>
    <published>2019-03-20T12:36:47.000Z</published>
    <updated>2019-03-20T13:21:11.350Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>今天在用Gnome-tweaks的时候发现打不开了???很莫名其妙,怀疑是滚动更新滚炸了。bing了一下在stackoverflow上找到了解决办法。<br><a id="more"></a></p><h1 id="无法打开gnome-tweaks"><a href="#无法打开gnome-tweaks" class="headerlink" title="无法打开gnome-tweaks"></a>无法打开gnome-tweaks</h1><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[sudo] password for root: </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/bin/gnome-tweaks&quot;, line 13, in &lt;module&gt;</span><br><span class="line">    import gi</span><br><span class="line">ModuleNotFoundError: No module named &apos;gi&apos;</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>参照了<a href="https://stackoverflow.com/questions/32640083/gnome-terminal-not-starting-due-to-error-in-python-script-related-to-gi" target="_blank" rel="noopener">stackoverflow</a></p><p><strong>步骤如下</strong></p><ul><li>在命令行进入python2、python3测试import gi，看有没有gi这个包</li><li>发现只有python3.7下面有这个包</li><li>$ sudo vim /usr/bin/gnome-tweaks</li><li>编辑第一行，把<code>#!/usr/bin/env python</code>改成<code>#!/usr/bin/python</code></li><li>我这里<code>python-&gt;python3.7</code>,如果不是的话要写成<code>!/usr/bin/python3.7</code></li><li>重新运行gnome-tweaks</li><li>注意不要带sudo,我这里sudo出现了如下报错<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No protocol specified</span><br><span class="line">Unable to init server: Could not connect: Connection refused</span><br></pre></td></tr></table></figure></li></ul><hr><p>OK，问题解决</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;今天在用Gnome-tweaks的时候发现打不开了???很莫名其妙,怀疑是滚动更新滚炸了。bing了一下在stackoverflow上找到了解决办法。&lt;br&gt;
    
    </summary>
    
      <category term="Daily" scheme="https://catchdream.me/categories/Daily/"/>
    
    
      <category term="Daily" scheme="https://catchdream.me/tags/Daily/"/>
    
      <category term="Linux" scheme="https://catchdream.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SpaceVim中自定义Markdown相关快捷键</title>
    <link href="https://catchdream.me/2019/03/18/SpaceVim%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89Markdown%E7%9B%B8%E5%85%B3%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://catchdream.me/2019/03/18/SpaceVim中自定义Markdown相关快捷键/</id>
    <published>2019-03-18T15:14:48.000Z</published>
    <updated>2019-04-02T02:09:41.924Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>  SpaceVim对Markdown的注释居然是html版本的，预览的时候还是可以显示，百度了才知道用[[//]]:#()的方法，就想着弄了快捷键，又是挖坑踩坑…<br>  <a id="more"></a></p><h1 id="Markdown注释方法"><a href="#Markdown注释方法" class="headerlink" title="Markdown注释方法"></a>Markdown注释方法</h1><h2 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h2><p>注意：需要在前面空一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&apos;display: none&apos;&gt;</span><br><span class="line">哈哈我是注释，不会在浏览器中显示。</span><br><span class="line">我也是注释。</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h2 id="html注释"><a href="#html注释" class="headerlink" title="html注释"></a>html注释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--哈哈我是注释，不会在浏览器中显示。--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">哈哈我是多段</span><br><span class="line">注释，</span><br><span class="line">不会在浏览器中显示。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><h2 id="利用Markdown原理"><a href="#利用Markdown原理" class="headerlink" title="利用Markdown原理"></a>利用Markdown原理</h2><p>利用markdown的解析原理来实现注释的。一般有的markdown解析器不支持上面的注释方法，这个时候就可以用此方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[//]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[//]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure><p>其中，这种方法最稳定，适用性最强：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[//]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure></p><p>还看到这种最可爱，超级无敌萌的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^_^]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure></p><h1 id="SpaceVim中自定义快捷键"><a href="#SpaceVim中自定义快捷键" class="headerlink" title="SpaceVim中自定义快捷键"></a>SpaceVim中自定义快捷键</h1><p><strong>下面是<a href="https://spacevim.org/cn" target="_blank" rel="noopener">SpaceVim官网</a>的说明</strong></p><blockquote><p>启动函数<br>由于 toml 配置的局限性，SpaceVim 提供了两种启动函数 bootstrap_before 和 bootstrap_after，在该函数内可以使用 Vim script。<br>可通过 ~/.SpaceVim.d/init.toml 的 [options] 片段中的这两个选项 bootstrap_before 和 bootstrap_after 来指定函数名称，例如：</p><p>[options]<br>　　bootstrap_before = “myspacevim#before”<br> 　　bootstrap_after  = “myspacevim#after”<br>启动函数文件应放置在 Vim &amp;runtimepath 的 autoload 文件夹内。例如：</p><p>文件名：~/.SpaceVim.d/autoload/myspacevim.vim</p><p>function! myspacevim#before() abort<br>　　let g:neomake_enabled_c_makers = [‘clang’]<br>　　nnoremap jk <esc><br>endfunction</esc></p><p>function! myspacevim#after() abort<br>　　iunmap jk<br>endfunction<br>函数 bootstrap_before 将在读取用户配置后执行，而函数 bootstrap_after 将在 VimEnter autocmd 之后执行。</p><p>如果你需要添加自定义以 SPC 为前缀的快捷键，你需要使用 bootstrap function，在其中加入：</p><p>function! myspacevim#before() abort<br>　　call SpaceVim#custom#SPCGroupName([‘G’], ‘+TestGroup’)<br>　　call SpaceVim#custom#SPC(‘nore’, [‘G’, ‘t’], ‘echom 1’, ‘echomessage 1’, 1)<br>endfunction</p></blockquote><h1 id="vim中定义快捷键相关说明"><a href="#vim中定义快捷键相关说明" class="headerlink" title="vim中定义快捷键相关说明"></a>vim中定义快捷键相关说明</h1><h2 id="autocmd"><a href="#autocmd" class="headerlink" title="autocmd"></a>autocmd</h2><ul><li>autocmd是一个十分强大的命令，在.vimrc中配置以后在用vim创建文件的时候就会自动执行一些命令</li></ul><h2 id="键盘映射"><a href="#键盘映射" class="headerlink" title="键盘映射"></a>键盘映射</h2><p>具体参照<a href="https://www.cnblogs.com/softwaretesting/archive/2011/09/28/2194515.html" target="_blank" rel="noopener">Vim中的键映射</a></p><p>使用map命令，可以将键盘上的某个按键与Vim的命令绑定起来。例如使用以下命令，可以通过F5键将单词用花括号括起来：   </p><p>　　:map <f5> i{e<esc>a}<esc>  </esc></esc></f5></p><p>其中：i{将插入字符{，然后使用Esc退回到命令状态；接着用e移到单词结尾，a}增加字符}，最后退至命令状态。</p><p>在执行以上命令之后，光标定位在一个单词上（例如amount），按下F5键，这时字符就会变成{amount}的形式。   </p><h2 id="不同模式下的键盘映射"><a href="#不同模式下的键盘映射" class="headerlink" title="不同模式下的键盘映射"></a>不同模式下的键盘映射</h2><p>使用下表中不同形式的map命令，可以针对特定的模式设置键盘映射：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Command</th><th style="text-align:center">Normal</th><th style="text-align:center">Visual</th><th style="text-align:center">Operator Pending</th><th style="text-align:center">插入模式</th><th style="text-align:center">命令行模式</th></tr></thead><tbody><tr><td style="text-align:center">命令</td><td style="text-align:center">常规模式</td><td style="text-align:center">可视化模式</td><td style="text-align:center">运算符模式</td><td style="text-align:center">Insert Only</td><td style="text-align:center">Command Line</td></tr><tr><td style="text-align:center">:map</td><td style="text-align:center">y</td><td style="text-align:center">y</td><td style="text-align:center">y</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:nmap</td><td style="text-align:center">y</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:vmap</td><td style="text-align:center"></td><td style="text-align:center">y</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:omap</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">y</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:map!</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">y</td><td style="text-align:center">y</td></tr><tr><td style="text-align:center">:imap</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">y</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:cmap</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">y</td></tr></tbody></table></div><h1 id="SpaceVim中进行自定义SPC开头的键映射"><a href="#SpaceVim中进行自定义SPC开头的键映射" class="headerlink" title="SpaceVim中进行自定义SPC开头的键映射"></a>SpaceVim中进行自定义SPC开头的键映射</h1><p>下面是将SPC-v-c定义为Markdown文本中行注释，SPC-v-u对Markdown进行行取消注释，SPC-v-p进行Markdown文件样式预览.</p><p><strong>~/.SpaceVim.d/autoload/myspacevim.vim</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function! myspacevim#before() abort</span><br><span class="line">　　set wrap</span><br><span class="line"></span><br><span class="line">    &quot;v开头为自定义快捷键</span><br><span class="line">　　call SpaceVim#custom#SPCGroupName([&apos;v&apos;], &apos;+Personal Key Bindings&apos;)</span><br><span class="line"></span><br><span class="line">    &quot;使用v-p进行markdown网页预览</span><br><span class="line">　　autocmd BufRead,BufNewFile *.&#123;md,mdown,mkd,mkdn,markdown,mdwn&#125; call SpaceVim#custom#SPC(&apos;nore&apos;, [&apos;v&apos;, &apos;p&apos;], &apos;:!google-chrome-stable &quot;%:p&quot;&apos;, &apos;Markdown-Previews&apos;,1)</span><br><span class="line"></span><br><span class="line">    &quot;对markdown进行行注释，在行首插入[//]:#(,在行尾插入右括号),命令是&apos;I[//]:#(&lt;Esc&gt;A)&lt;Esc&gt;&apos;,注意这里的&lt;Esc&gt;要用Ctrl-Esc来完成 </span><br><span class="line">　　call SpaceVim#custom#SPC(&apos;nore&apos;, [&apos;v&apos;, &apos;c&apos;], &apos;I[//]:#(&lt;Esc&gt;A)&lt;Esc&gt;&apos;, &apos;Markdown-comment one line&apos;, 0)</span><br><span class="line"></span><br><span class="line">    &quot;对markdown取消行注释,在行首删除[//]:#(,在行尾删除右括号)</span><br><span class="line">　　call SpaceVim#custom#SPC(&apos;nore&apos;, [&apos;v&apos;, &apos;u&apos;], &apos;07x$x&apos;, &apos;Markdown-uncomment one line&apos;, 0)</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><h2 id="———————"><a href="#———————" class="headerlink" title="———————-"></a>———————-</h2><p>其实…我就想弄两个快捷键…</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;  SpaceVim对Markdown的注释居然是html版本的，预览的时候还是可以显示，百度了才知道用[[//]]:#()的方法，就想着弄了快捷键，又是挖坑踩坑…&lt;br&gt;
    
    </summary>
    
      <category term="Learning" scheme="https://catchdream.me/categories/Learning/"/>
    
    
      <category term="SpaceVim" scheme="https://catchdream.me/tags/SpaceVim/"/>
    
      <category term="Markdown" scheme="https://catchdream.me/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Tornado中的异步</title>
    <link href="https://catchdream.me/2019/03/17/Tornado%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5/"/>
    <id>https://catchdream.me/2019/03/17/Tornado中的异步/</id>
    <published>2019-03-17T14:32:28.000Z</published>
    <updated>2019-03-17T14:34:59.281Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Tornado中的异步"><a href="#Tornado中的异步" class="headerlink" title="Tornado中的异步"></a>Tornado中的异步</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>因为epoll主要用来解决网络IO的并发问题，所以Tornado中的异步也主要体现在网络的IO异步上，即异步web<br><a id="more"></a></p><h2 id="tornado-httpclient-AsyncHttpClinet"><a href="#tornado-httpclient-AsyncHttpClinet" class="headerlink" title="tornado.httpclient.AsyncHttpClinet"></a>tornado.httpclient.AsyncHttpClinet</h2><ul><li>是Tornado提供的异步web请求客户端，用来进行异步web请求</li><li>from tornado.httpclient import AsyncHttpClinet</li></ul><h2 id="fetch-request-callback-None"><a href="#fetch-request-callback-None" class="headerlink" title="fetch(request, callback = None)"></a>fetch(request, callback = None)</h2><ul><li>此函数用于执行一个Web请求，并异步响应返回一个tornado.httpclient.HttpResponse</li><li>request可以是一个URL，也可以是一个Tornado.httpclient.HttpResponse对象,如果插入的是url，会自动生成一个request对象</li></ul><h2 id="HTTPRequest"><a href="#HTTPRequest" class="headerlink" title="HTTPRequest"></a>HTTPRequest</h2><ul><li>HTTP请求类，该类的构造函数可以接收参数    </li><li>参数:<ul><li>url: 字符串类型，要访问的网址，必传</li><li>method：字符串类型，http请求方式</li><li>headers：字典或者HTTPHeaders，附加的协议头</li><li>body: HTTP请求体</li></ul></li></ul><h2 id="HTTPResponse"><a href="#HTTPResponse" class="headerlink" title="HTTPResponse"></a>HTTPResponse</h2><ul><li>HTTP响应类</li><li>属性<ul><li>code: 状态码</li><li>reason： 状态码的描述</li><li>body： 相应的数据</li><li>error： 是否有异常</li></ul></li></ul><h2 id="tornado-web-asynchronous装饰器"><a href="#tornado-web-asynchronous装饰器" class="headerlink" title="@tornado.web.asynchronous装饰器"></a>@tornado.web.asynchronous装饰器</h2><ul><li>不关闭通信的通道</li><li><strong>实际操作发现无法使用这个装饰器</strong></li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="回调函数实现的异步"><a href="#回调函数实现的异步" class="headerlink" title="回调函数实现的异步"></a>回调函数实现的异步</h3><p><strong>Handler代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class StudentsHandler(RequestHandler):</span><br><span class="line">    def on_response(self, response):</span><br><span class="line">        if response.error:</span><br><span class="line">            self.send_error(500)</span><br><span class="line">        else:</span><br><span class="line">            data = json.loads(response.body)</span><br><span class="line">            # 这里本身无法write,要打开通道，用asynchronous装饰器</span><br><span class="line">            self.write(data)</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line">    # 不关闭通信的通道</span><br><span class="line">    #  @tornado.web.asynchronous</span><br><span class="line">    # 实操发现用不了这个装饰器</span><br><span class="line">    def get(self, *args, **kwargs):</span><br><span class="line">        url = &quot;http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&amp;t=&amp;market=360zhushou&amp;client=android&amp;appname=budejie&amp;device=&amp;jdk=1&amp;ver=8.0.1&amp;udid=&amp;from=android&quot;</span><br><span class="line">        # 创建客户端</span><br><span class="line">        client = AsyncHTTPClient()</span><br><span class="line">        # on_response是回调函数,如果请求成功，就进行on_response回调函数</span><br><span class="line">        client.fetch(url, self.on_response)</span><br><span class="line">        #  self.write(&quot;OK&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="协程实现的异步"><a href="#协程实现的异步" class="headerlink" title="协程实现的异步"></a>协程实现的异步</h3><p><strong>Handler代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Students2Handler(RequestHandler):</span><br><span class="line">    @tornado.gen.coroutine</span><br><span class="line">    def get(self, *args, **kwargs):</span><br><span class="line">        url = &quot;http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&amp;t=&amp;market=360zhushou&amp;client=android&amp;appname=budejie&amp;device=&amp;jdk=1&amp;ver=8.0.1&amp;udid=&amp;from=android&quot;</span><br><span class="line">        client = AsyncHTTPClient()</span><br><span class="line">        # 耗时操作挂起</span><br><span class="line">        res = yield client.fetch(url)</span><br><span class="line">        if res.error:</span><br><span class="line">            self.send_error(500)</span><br><span class="line">        else:</span><br><span class="line">            data = json.loads(res.body)</span><br><span class="line">            self.write(data)</span><br></pre></td></tr></table></figure></p><h3 id="协程异步并将异步web请求单独出来"><a href="#协程异步并将异步web请求单独出来" class="headerlink" title="协程异步并将异步web请求单独出来"></a>协程异步并将异步web请求单独出来</h3><p><strong>Handler代码</strong></p><pre><code>class Students3Handler(RequestHandler):    # 简化get函数    @tornado.gen.coroutine    def get(self, *args, **kwargs):        res = yield self.getData()        self.write(res)    # 这里也要加装饰器，这里也是耗时操作    @tornado.gen.coroutine    def getData(self):        url = &quot;http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&amp;t=&amp;market=360zhushou&amp;client=android&amp;appname=budejie&amp;device=&amp;jdk=1&amp;ver=8.0.1&amp;udid=&amp;from=android&quot;        client = AsyncHTTPClient()        # 耗时操作        res = yield client.fetch(url)        if res.error:            #  表示没有结果            ret = {&quot;ret&quot;: 0}        else:            ret = json.loads(res.body)        #  相当于gen.send()函数        raise tornado.gen.Return(ret)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;Tornado中的异步&quot;&gt;&lt;a href=&quot;#Tornado中的异步&quot; class=&quot;headerlink&quot; title=&quot;Tornado中的异步&quot;&gt;&lt;/a&gt;Tornado中的异步&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;因为epoll主要用来解决网络IO的并发问题，所以Tornado中的异步也主要体现在网络的IO异步上，即异步web&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://catchdream.me/categories/Python/"/>
    
    
      <category term="Python" scheme="https://catchdream.me/tags/Python/"/>
    
      <category term="Tornado" scheme="https://catchdream.me/tags/Tornado/"/>
    
  </entry>
  
</feed>
