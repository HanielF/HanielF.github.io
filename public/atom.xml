<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Catch Your Dream</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hanielxx.com/"/>
  <updated>2020-07-15T02:01:02.016Z</updated>
  <id>https://hanielxx.com/</id>
  
  <author>
    <name>Hanielxx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-034-Find First and Last Position of Element in Sorted Array</title>
    <link href="https://hanielxx.com/LeetCode/2019-11-06-LeetCode-034-Find%20First%20and%20Last%20Position%20of%20Element%20in%20Sorted%20Array.html"/>
    <id>https://hanielxx.com/LeetCode/2019-11-06-LeetCode-034-Find First and Last Position of Element in Sorted Array.html</id>
    <published>2019-11-06T04:10:35.000Z</published>
    <updated>2020-07-15T02:01:02.016Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><p>If the target is not found in the array, return [-1, -1].</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>nums = [5,7,7,8,8,10], target = 8<br>nums = [5,7,7,8,8,10], target = 6</p></blockquote><p><strong>Output:</strong></p><blockquote><p>[3,4]<br>[-1,-1]</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>题目要求<script type="math/tex">O(log n)</script>级别的时间复杂度，又是查找，所以肯定是二分查找比较快</li><li>这里要求的是找到最左边的target和最右边的target</li><li>两种思路<ul><li>直接按照原始二分，找到一个之后，向左右遍历</li><li>直接找左边界和右边界，两次查找</li></ul></li><li>下面采用的是第一种思路，第二种思路见题解：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" rel="external nofollow noopener noreferrer" target="_blank">二分查找算法细节详解</a></li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>找到一个target之后往左右遍历，8ms，10.2MB</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> mid;</span><br><span class="line">      <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]) l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      <span class="keyword">int</span> l,r;</span><br><span class="line">      <span class="keyword">int</span> pos = binarySearch(nums,target);</span><br><span class="line">      <span class="keyword">if</span>(pos==<span class="number">-1</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        l = r = pos;</span><br><span class="line">        <span class="keyword">while</span>(r+<span class="number">1</span>&lt;nums.size() &amp;&amp; nums[r+<span class="number">1</span>]==target) r++;</span><br><span class="line">        <span class="keyword">while</span>(l<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; nums[l<span class="number">-1</span>]==target) l--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.&lt;/p&gt;&lt;p&gt;Your algorithm’s runtime complexity must be in the order of O(log n).&lt;/p&gt;&lt;p&gt;If the target is not found in the array, return [-1, -1].&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;nums = [5,7,7,8,8,10], target = 8&lt;br&gt;nums = [5,7,7,8,8,10], target = 6&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;[3,4]&lt;br&gt;[-1,-1]&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="List" scheme="https://hanielxx.com/tags/List/"/>
    
      <category term="Search" scheme="https://hanielxx.com/tags/Search/"/>
    
      <category term="BinarySearch" scheme="https://hanielxx.com/tags/BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-033-Search in Rotated Sorted Array</title>
    <link href="https://hanielxx.com/LeetCode/2019-11-05-LeetCode-033-Search-in-Rotated-Sorted-Array.html"/>
    <id>https://hanielxx.com/LeetCode/2019-11-05-LeetCode-033-Search-in-Rotated-Sorted-Array.html</id>
    <published>2019-11-05T04:25:45.000Z</published>
    <updated>2020-07-15T02:01:02.016Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/submissions/" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>nums = [4,5,6,7,0,1,2], target = 0<br>nums = [4,5,6,7,0,1,2], target = 3</p></blockquote><p><strong>Output:</strong></p><blockquote><p>4<br>-1</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>题目要求时间复杂度要在<script type="math/tex">O(log n)</script>，所以很自然要想到二分搜索</li><li>基础版本的二分搜索很明显不适用，因为有一个分隔点，要在此基础上修改</li><li>思路是：判断分隔点在前半部分还是在后半部分，以mid为分界。找到有序的部分，在这部分上应用二叉搜索查找target。如果target不在有序的部分内，则转移到无序的部分，然后继续这样找有序的部分。具体看代码注释</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    mid = (l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果nums[mid]==target，就返回</span></span><br><span class="line">    <span class="keyword">if</span>(target==nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前半部分有序，即切割点在后半部分</span></span><br><span class="line">    <span class="comment">// 注意这里是大于等于，将mid=l的情况分为前半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&gt;=nums[l])&#123;</span><br><span class="line">      <span class="comment">// 如果target在有序部分，则二分</span></span><br><span class="line">      <span class="keyword">if</span>(target&gt;=nums[l] &amp;&amp; target&lt;nums[mid])&#123;</span><br><span class="line">        r=mid<span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        l=mid+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 如果后半部分有序，即切割点在前半部分</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(target&gt;nums[mid] &amp;&amp; target&lt;=nums[r])&#123;</span><br><span class="line">        l=mid+<span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        r=mid<span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums=&#123;<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;search(nums, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_rotate_index</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                pivot = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[pivot] &gt; nums[pivot + <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> pivot + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> nums[pivot] &lt; nums[left]:</span><br><span class="line">                        right = pivot - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = pivot + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            Binary search</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                pivot = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[pivot] == target:</span><br><span class="line">                    <span class="keyword">return</span> pivot</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; nums[pivot]:</span><br><span class="line">                        right = pivot - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = pivot + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> nums[<span class="number">0</span>] == target <span class="keyword">else</span> <span class="number">-1</span> </span><br><span class="line">        </span><br><span class="line">        rotate_index = find_rotate_index(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># if target is the smallest element</span></span><br><span class="line">        <span class="keyword">if</span> nums[rotate_index] == target:</span><br><span class="line">            <span class="keyword">return</span> rotate_index</span><br><span class="line">        <span class="comment"># if array is not rotated, search in the entire array</span></span><br><span class="line">        <span class="keyword">if</span> rotate_index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> search(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> target &lt; nums[<span class="number">0</span>]:</span><br><span class="line">            <span class="comment"># search on the right side</span></span><br><span class="line">            <span class="keyword">return</span> search(rotate_index, n - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># search on the left side</span></span><br><span class="line">        <span class="keyword">return</span> search(<span class="number">0</span>, rotate_index)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>这样的题目，还是从基础算法着手，然后将基础算法和具体题目结合起来。这题关键就是找到有序的部分，然后应用二分搜索。</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array/submissions/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;/p&gt;&lt;p&gt;(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).&lt;/p&gt;&lt;p&gt;You are given a target value to search. If found in the array return its index, otherwise return -1.&lt;/p&gt;&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;&lt;p&gt;Your algorithm’s runtime complexity must be in the order of O(log n).&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;nums = [4,5,6,7,0,1,2], target = 0&lt;br&gt;nums = [4,5,6,7,0,1,2], target = 3&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;4&lt;br&gt;-1&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
      <category term="List" scheme="https://hanielxx.com/tags/List/"/>
    
      <category term="Search" scheme="https://hanielxx.com/tags/Search/"/>
    
      <category term="BinarySearch" scheme="https://hanielxx.com/tags/BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>EM算法</title>
    <link href="https://hanielxx.com/Notes/2019-11-04-EM-Notes.html"/>
    <id>https://hanielxx.com/Notes/2019-11-04-EM-Notes.html</id>
    <published>2019-11-04T05:42:24.000Z</published>
    <updated>2020-07-15T02:01:02.032Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><p>主要介绍EM的整个推导过程。</p></div><a id="more"></a><h2 id="1-Jensen不等式"><a href="#1-Jensen不等式" class="headerlink" title="1. Jensen不等式"></a>1. Jensen不等式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>回顾优化理论中的一些概念:</p><ul><li>设f是定义域为实数的函数</li><li>如果对于所有的实数x，<script type="math/tex">f''(x) \ge 0</script>，那么f是凸函数。</li><li>当x是向量时，如果其hessian矩阵H是半正定的（<script type="math/tex">H \ge 0</script>），那么f是凸函数。</li><li>如果<script type="math/tex">f''(x) \gt 0</script>或者<script type="math/tex">H \gt 0</script>，那么称f是严格凸函数。</li></ul><h3 id="Jensen的表述"><a href="#Jensen的表述" class="headerlink" title="Jensen的表述"></a>Jensen的表述</h3><div class="note"><p>如果f是凸函数，X是随机变量，那么<script type="math/tex">E[f(X)] \ge f(EX)</script><br>特别地，如果f是严格凸函数，那么<script type="math/tex">E[f(X)] = f(EX)</script>, 当且仅当<script type="math/tex">p(x=E[x]=1)</script>，也就是说X是常量。</p><p>这里我们将<script type="math/tex">f(E[x])</script>简写为<script type="math/tex">f(EX)</script>。</p></div><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>如果用图表示会很清晰：</p><center><img src="/Notes/2019-11-04-EM-Notes/1.png" title="图示"></center><p>图中，实线f是凸函数，X是随机变量，有0.5的概率是a，有0.5的概率是b。（就像掷硬币一样）。<br>X的期望值就是a和b的中值了，图中可以看到<script type="math/tex">E[f(X)]  \ge f(EX)</script>成立。</p><p>当<script type="math/tex">f</script>是（严格）凹函数即当且仅当<script type="math/tex">-f</script>是（严格）凸函数。</p><p>Jensen不等式应用于凹函数时，不等号方向反向，也就是<script type="math/tex">E[f(X)] \le f(EX)</script>。</p><h2 id="2-EM算法"><a href="#2-EM算法" class="headerlink" title="2. EM算法"></a>2. EM算法</h2><h3 id="隐藏变量"><a href="#隐藏变量" class="headerlink" title="隐藏变量"></a>隐藏变量</h3><p>给定的训练样本是<script type="math/tex">{ x^{(1)},...,x^{(m)}}</script>，样例间独立，我们想找到每个样例隐含的类别z，能使得<script type="math/tex">p(x,z)</script>最大。<script type="math/tex">p(x,z)</script>的最大似然估计如下：</p><script type="math/tex;mode=display">\begin{equation}\begin{split}{\ell}(\theta) &= \sum_{i=1}^m log p (x;\theta) \\&= \sum_{i=1}^m log \sum_z p(x,z;\theta)\end{split}\end{equation}</script><ul><li>第一步是对极大似然取对数</li><li>第二步是对每个样例的每个可能类别z求联合分布概率和</li><li>直接求<script type="math/tex">\theta</script>一般比较困难，因为有隐藏变量z存在，但是一般确定了z后，求解就容易了。</li></ul><h3 id="建立、优化下界"><a href="#建立、优化下界" class="headerlink" title="建立、优化下界"></a>建立、优化下界</h3><p>EM是一种解决存在隐含变量优化问题的有效方法。既然不能直接最大化<script type="math/tex">\ell(\theta)</script>，我们可以不断地建立<script type="math/tex">\ell</script>的下界（E步），然后优化下界（M步）。</p><p>这句话比较抽象，看下面的。</p><ul><li>对于每一个样例i，让<script type="math/tex">Q_i</script>表示该样例隐含变量z的某种分布，<script type="math/tex">Q(i)</script>满足的条件是<script type="math/tex">\sum_z Q_i(z)=1, Q_i(z) \ge 0</script>。</li><li>如果z是连续性的，那么<script type="math/tex">Q_i</script>是概率密度函数，需要将求和符号换做积分符号。</li><li>比如要将班上学生聚类，假设隐藏变量z是身高，那么就是连续的高斯分布。如果按照隐藏变量是男女，那么就是伯努利分布了。</li></ul><p>可以由前面阐述的内容得到下面的公式：</p><p>\begin{equation}\begin{split}<br>\sum_i logp(x^{(i)}; \theta) &amp;= \sum_i log \sum_{z^{(i)}} p(x^{(i)},z^{(i)}; \theta) \\<br>&amp;= \sum_i log \sum_{z^{(i)}} Q_i(z^{(i)}) {p(x^{(i)}, z^{(i)}; \theta) \over Q_i(z^{(i)})} \\<br>&amp; \ge \sum_i \sum_{z^{(i)}} Q_i(z^{(i)}) log {p(x^{(i)},z^{(i)}; \theta) \over Q_i(z^{(i)})}<br>\end{split}\end{equation}</p><ul><li>（1）到（2）比较直接，就是分子分母同乘以一个相等的函数。</li><li>（2）到（3）利用了Jensen不等式，考虑到<script type="math/tex">log(x)</script>是凹函数（二阶导数小于0），而且<script type="math/tex">\sum_{z^{(i)}} Q_i(z^{(i)})[{ p(x^{(i)}), z^{(i)}; \theta] \over Q_i(z^{(i)}) }]</script>就是<script type="math/tex">[{ {p(x^{(i)}, z^{(i)}; \theta)} \over Q_i(z^{(i)}) }]</script>的期望（回想期望公式中的Lazy Statistician规则）</li></ul><p>设Y是随机变量X的函数<script type="math/tex">Y=g(X)</script>（g是连续函数），那么</p><ul><li>（1） X是离散型随机变量，它的分布律为<script type="math/tex">P(X=x_k)=p_k, k=1,2,..</script>。若<script type="math/tex">\sum_{k=1}^{\infty}g(x_k)p_k</script>绝对收敛，则有<script type="math/tex;mode=display">E(Y) = E[g(X)] = \sum_{k=1}^{\infty}g(x_k)p_k</script></li><li>（2） X是连续型随机变量，它的概率密度为<script type="math/tex">f(x)</script>，若<script type="math/tex">{\int}_{-\infty}^{\infty}g(x)f(x)dx</script>绝对收敛，则有<script type="math/tex;mode=display">E(Y)=E[g(X)]={\int}_{-\infty}^{\infty}g(x)f(x)d(x)</script></li></ul><p>对应于上述问题，Y是<script type="math/tex">[{ p(x^{(i)}, z^{(i)}; \theta) \over Q_i(z^{(i)}) }]</script>，X是<script type="math/tex">z^{(i)}</script>，<script type="math/tex">Q_i(z^{(i)})</script>是<script type="math/tex">p_k</script>，<script type="math/tex">g</script>是<script type="math/tex">z^{(i)}</script>到<script type="math/tex">[ { { p(x^{(i)}, z^{(i)}; \theta) } \over Q_i(z^{(i)}) }]</script>的映射。这样解释了式子（2）中的期望，再根据凹函数时的Jensen不等式：</p><script type="math/tex;mode=display">f(E_{z^{(i)}{\sim}Q_i}[{ {p(x^{(i)}, z^{(i)}; \theta)} \over Q_i(z^{(i)}) }]) \ge E_{z^{(i)}{\sim}Q_i}[{ f({ p(x^{(i)},z^{(i)};\theta) } \over Q_i(z^{(i)})) }]</script><p>可以得到（3）。</p><p>这个过程可以看作是对<script type="math/tex">{\ell}</script>求了下界。对于<script type="math/tex">Q_i</script>的选择，有多种可能，那种更好的？假设<script type="math/tex">\theta</script>已经给定，那么<script type="math/tex">{\ell}(\theta)</script>的值就决定于<script type="math/tex">Q_i(z^{(i)})</script>和<script type="math/tex">p(x^{(i)},z^{(i)})</script>了。我们可以通过调整这两个概率使下界不断上升，以逼近<script type="math/tex">{\ell}</script>的真实值，那么什么时候算是调整好了呢？当不等式变成等式时，说明我们调整后的概率能够等价于<script type="math/tex">{\ell}</script>了。按照这个思路，我们要找到等式成立的条件。</p><p>根据Jensen不等式，要想让等式成立，需要让随机变量变成常数值，这里得到：</p><script type="math/tex;mode=display">{ p(x^{(i)},z^{(i)}; \theta) \over Q_i(z^{(i)})} =c</script><p>c为常数，不依赖于<script type="math/tex">z^{(i)}</script>。对此式子做进一步推导，我们知道<script type="math/tex">\sum_z Q(z^{(i)})=q</script>，那么也就有<script type="math/tex">\sum_z p(x^{(i)},z^{(i)};\theta) =c</script>，（多个等式分子分母相加不变，这个认为每个样例的两个概率比值都是c），那么有下式：</p><script type="math/tex;mode=display">\begin{equation}\begin{split}Q_i(Z^{(i)}) &= {p(x^{(i)},z^{(i)};\theta) \over \sum_z p(x^{(i)},z;\theta)} \\&= {p(x^{(i)},z^{(i)};\theta) \over p(x^{(i)};\theta) }\\&= p(z^{(i)}|x^{(i)};\theta)\end{split}\end{equation}</script><p>至此，我们推出了在固定其他参数<script type="math/tex">\theta</script>后，<script type="math/tex">Q_i(z^{(i)})</script>的计算公式就是后验概率，解决<script type="math/tex">Q_i(z^{(i)})</script>如何选择的问题。这一步就是E步，建立<script type="math/tex">{\ell}(\theta)</script>的下界。接下来的M步，就是在给定i<script type="math/tex">Q_i(z^{(i)})</script>后，调整<script type="math/tex">\theta</script>，去极大化<script type="math/tex">{\ell}(\theta)</script>的下界（在固定<script type="math/tex">Q_i(z^{(i)})</script>后，下界还可以调整的更大）。</p><h3 id="EM算法步骤"><a href="#EM算法步骤" class="headerlink" title="EM算法步骤"></a>EM算法步骤</h3><p><strong>一般的EM算法的步骤如下：</strong></p><p>循环重复直到收敛</p><ol><li><p>（E步）对于每一个i，计算：</p><script type="math/tex;mode=display">Q_i(z^{(i)}) := p(z^{(i)}|x^{(i)};\theta)</script></li><li><p>（M步）计算：</p><script type="math/tex;mode=display">\theta := arg max_\theta \sum_i \sum_{z^{(i)}} Q_i(z^{(i)})log{p(z^{(i)},z^{(i)};\theta) \over Q_i(z^{(i)}) }</script></li></ol><h3 id="EM算法收敛"><a href="#EM算法收敛" class="headerlink" title="EM算法收敛"></a>EM算法收敛</h3><p>那么究竟怎么确保EM收敛？</p><ul><li>假定<script type="math/tex">\theta^{(t)} 和 \theta^{(t+1)}</script>是EM第t次和t+1次迭代后的结果。</li><li>如果我们证明了<script type="math/tex">{\ell}(\theta^{(t)}) \le {\ell}(\theta^{(t+1)})</script>，也就是说极大似然估计单调增加，那么最终我们会到达最大似然估计的最大值。</li></ul><p>下面来证明，选定<script type="math/tex">\theta^{(t)}</script>后，我们得到E步</p><script type="math/tex;mode=display">Q_i^{(t)} := p(z^{(i)} | x^{(i)} ; \theta^{(t)} )</script><p>这一步保证了在给定<script type="math/tex">\theta^{(t)}</script>时，Jensen不等式中的等式成立，也就是</p><script type="math/tex;mode=display">{\ell}(\theta^{(t)}) = \sum_i \sum_{z^{(i)}} Q_i^{(t)}(z^{(i)}) log{ p(x^{(i)},z^{(i)};\theta^{(t)}) \over Q_i^{(i)}(z^{(i)})}</script><p>然后进行M步，固定<script type="math/tex">Q_i^{(t)}</script>，并将<script type="math/tex">\theta^{(t)}</script>视作变量，对上面的<script type="math/tex">{\ell}(\theta^{(t)})</script>求导后，得到<script type="math/tex">\theta^{(t+1)}</script>，这样经过一些推导会有以下式子成立：</p><script type="math/tex;mode=display">\begin{equation}\begin{split}{\ell}(\theta^{(t+1)}) &\ge \sum_i \sum_{z^{(i)}} Q_i^{(t)}(z^{(i)})log{ p(x^{(i)},z^{(i)});\theta^{(t+1)} \over Q_i^{(t)}(z^{(i)})} \\&\ge \sum_i \sum_{z^{(i)}} Q_i^{(i)}(z^{(i)})log{ p(x^{(i)},z^{(i)};\theta^{(t)}) \over Q_i^{(t)(z^{(i)})}} \\&= {\ell}(\theta^{(t)})\end{split}\end{equation}</script><p>解释第（4）步，得到<script type="math/tex">\theta^{(t+1)}</script>，只是最大化<script type="math/tex">{\ell}(\theta^{(t)})</script>，也就是<script type="math/tex">{\ell}(\theta^{(t+1)})</script>的下界，而没有使等式成立，等式成立只有是在固定<script type="math/tex">\theta</script>，并按E步得到<script type="math/tex">Q_i</script>时才能成立。</p><p>况且根据我们前面得到的下式，对于所有的<script type="math/tex">Q_i 和 \theta</script>都成立</p><script type="math/tex;mode=display">{\ell} \ge \sum_i \sum_{z^{(i)}} Q_i(z^{(i)})log{ p(x^{(i)},z^{(i)};\theta) \over Q_i(z^{(i)})}</script><p>第（5）步利用了M步的定义，M步就是将<script type="math/tex">\theta^{(t)}</script>调整到<script type="math/tex">|the^{(t+1)}</script>，使得下界最大化。因此（5）成立，（6）是之前的等式结果。</p><p>这样就证明了<script type="math/tex">{\ell}(\theta)</script>会单调增加。一种收敛方法是<script type="math/tex">{\ell}(\theta)</script>不再变化，还有一种就是变化幅度很小。</p><p>再次解释一下（4）、（5）、（6）。首先（4）对所有的参数都满足，而其等式成立条件只是在固定<script type="math/tex">\theta</script>，并调整好Q时成立，而第（4）步只是固定Q，调整<script type="math/tex">\theta</script>，不能保证等式一定成立。（4）到（5）就是M步的定义，（5）到（6）是前面E步所保证等式成立条件。也就是说E步会将下界拉到与<script type="math/tex">{\ell}(\theta)</script>一个特定值（这里<script type="math/tex">\theta^{(t)}</script>）一样的高度，而此时发现下界仍然可以上升，因此经过M步后，下界又被拉升，但达不到与<script type="math/tex">{\ell}(\theta)</script>另外一个特定值一样的高度，之后E步又将下界拉到与这个特定值一样的高度，重复下去，直到最大值。</p><p>如果我们定义:</p><script type="math/tex;mode=display">J(Q,\theta) = \sum_i \sum_{z^{(i)}} Q_i(z^{(i)})log{ p(x^{(i)},z^{(i)};\theta) \over Q_i(z^{(i)})}</script><p>从前面的推导中我们知道<script type="math/tex">{\ell}(\theta) \ge J(Q,\theta)</script>，EM可以看作是J的坐标上升法，E步固定<script type="math/tex">\theta</script>，优化<script type="math/tex">Q</script>，M步固定<script type="math/tex">Q</script>优化<script type="math/tex">\theta</script>。</p><h2 id="高斯混合模型"><a href="#高斯混合模型" class="headerlink" title="高斯混合模型"></a>高斯混合模型</h2><p>我们已经知道了EM的精髓和推导过程，再次审视一下混合高斯模型。之前提到的混合高斯模型的参数<script type="math/tex">\phi , \mu  和 \sum</script>计算公式都是根据很多假定得出的，有些没有说明来由。为了简单，这里在M步只给出<script type="math/tex">\phi 和 \mu</script>的推导方法。</p><h3 id="E步"><a href="#E步" class="headerlink" title="E步"></a>E步</h3><p>E步很简单，按照一般EM公式得到：</p><script type="math/tex;mode=display">\omega_j^{(i)} = Q_i(z^{(i)}=j) = P(z^{(i)}=j|x^{(i)}; \phi,\mu,\sum)</script><p>简单解释就是每个样例i的隐含类别<script type="math/tex">z^{(i)}</script>为j的概率可以通过后验概率计算得到。</p><h3 id="M步"><a href="#M步" class="headerlink" title="M步"></a>M步</h3><p>在M步中，我们需要在固定<script type="math/tex">Q_i(z^{(i)})</script>后最大化最大似然估计，也就是</p><script type="math/tex;mode=display">\begin{equation}\begin{split}\sum_{i=1}^m \sum_{z^{(i)}} & Q_i(z^{(i)})log{ p(x^{(i)},z^{(i)};\phi, \mu, \sum) \over Q_i(z^{(i)})} \\&= \sum_{i=1}^m \sum_{j=1}^k Q_i(z^{(i)}=j)log{ p(x^{(i)}| z^{(i)}=j;\mu,\sum)p(z^{(i)}=j;\phi) \over Q_i(z^{(i)}=j)} \\&= \sum_{i=1}^m \sum_{j=1}^k \omega_j^{(i)} log { {1 \over (2\pi)^{n/2}|\sum_j|^{1/2} } exp(-{1 \over 2}(x^{(i)}-\mu_j)^T \sum_j^{-1}(x^{(i)}-\mu_j)) \cdot \phi_j \over \omega_j^{(i)} }\end{split}\end{equation}</script><p>这是将<script type="math/tex">z^{(i)}</script>的k种情况展开后的样子，未知参数<script type="math/tex">\phi_j , \mu_j 和 \sum_j</script>。</p><p>固定<script type="math/tex">\phi_j和\sum_j</script>对<script type="math/tex">\mu_j</script>求导得</p><center><img src="/Notes/2019-11-04-EM-Notes/4.png"></center><p>等于0时，得到</p><script type="math/tex;mode=display">\mu_l := {\sum_{i=1}^m \omega_l^{(i)}x^{(i)} \over \sum_{i=1}^m \omega_l^{(i)}}</script><p>这就是我们之前模型中的<script type="math/tex">\mu</script>的更新公式。</p><p>然后推导<script type="math/tex">\phi_j</script>的更新公式。看之前得到的</p><script type="math/tex;mode=display">\sum_{i=1}^m \sum_{j=1}^k \omega_j^{(i)} log { {1 \over (2\pi)^{n/2}|\sum_j|^{1/2}} exp(-{1 \over 2}(x^{(i)}-\mu_j)^T \sum_j^{-1}(x^{(i)}-\mu_j)) \cdot \phi_j \over \omega_j^{(i)}}</script><p>在<script type="math/tex">\phi和\mu</script>确定后，分子上面的一串都是常数了，实际上需要优化的公式是：</p><script type="math/tex;mode=display">\sum_{i=1}^m \sum_{j=1}^k \omega_j^{(i)} log \phi_j</script><p>需要知道的是，<script type="math/tex">\phi_j</script>还需要满足一定的约束条件就是<script type="math/tex">\sum_{j=1}^k \phi_j =1</script>。</p><h3 id="构造拉格郎日乘子优化"><a href="#构造拉格郎日乘子优化" class="headerlink" title="构造拉格郎日乘子优化"></a>构造拉格郎日乘子优化</h3><p>这个优化问题我们很熟悉了，直接构造拉格朗日乘子。</p><script type="math/tex;mode=display">L(\phi) = \sum_{i=1}^m \sum_{j=1}^k \omega_j^{(i)} log \phi_j + \beta(\sum_{j=1}^k \phi_j-1)</script><p>还有一点就是<script type="math/tex">\phi_j \ge 0</script>，但这一点会在得到的公式里自动满足。</p><p>求导得：</p><script type="math/tex;mode=display">{\partial \over \partial \phi_j} L( \phi ) = \sum_{i=1}^m {\omega_j^{(i)} \over \phi_j}+\beta</script><p>等于0时，得到:</p><script type="math/tex;mode=display">\phi_j = {\sum_{i=1}^m \omega_j^{(i)} \over -\beta}</script><p>也就是说<script type="math/tex">\phi_j \propto \sum_{i=1}^m \omega_j^{(i)}</script>。再次使用<script type="math/tex">\sum_{j=1}^k \phi_j = 1</script>，得到</p><script type="math/tex;mode=display">-\beta = \sum_{i=1}^m \sum_{j=1}^k \omega_j^{(i)} = \sum_{i=1}^m 1 = m</script><p>这样就神奇地得到了<script type="math/tex">\beta</script>。</p><p>那么就顺势得到M步中<script type="math/tex">\phi_j</script>的更新公式：</p><script type="math/tex;mode=display">\phi_j := {1 \over m} \sum_{i=1}^m \omega_j^{(i)}</script><p><script type="math/tex">\sum</script>的推导也类似，不过稍微复杂一些，毕竟是矩阵。结果在之前的混合高斯模型中已经给出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果将样本看作观察值，潜在类别看作是隐藏变量，那么聚类问题也就是参数估计问题。</p><p>只不过聚类问题中参数分为隐含类别变量和其他参数，这犹如在x-y坐标系中找一个曲线的极值，然而曲线函数不能直接求导，因此什么梯度下降方法就不适用了。<br>但固定一个变量后，另外一个可以通过求导得到，因此可以使用坐标上升法，一次固定一个变量，对另外的求极值，最后逐步逼近极值。</p><p>对应到EM上，E步估计隐含变量，M步估计其他参数，交替将极值推向最大。EM中还有&ldquo;硬&rdquo;指定和&ldquo;软&rdquo;指定的概念，&ldquo;软&rdquo;指定看似更为合理，但计算量要大，&ldquo;硬&rdquo;指定在某些场合如K-means中更为实用（要是保持一个样本点到其他所有中心的概率，就会很麻烦）。</p><p>另外，EM的收敛性证明方法确实很牛，能够利用log的凹函数性质，还能够想到利用创造下界，拉平函数下界，优化下界的方法来逐步逼近极大值。而且每一步迭代都能保证是单调的。</p><p>最重要的是证明的数学公式非常精妙，硬是分子分母都乘以z的概率变成期望来套上Jensen不等式。</p><p>有一个EM应用的例子，明白地说就是将班上学生的身高都放在一起，要求聚成两个类。<br>这些身高可以看作是男生身高的高斯分布和女生身高的高斯分布组成。因此变成了如何估计每个样例是男生还是女生，然后在确定男女生情况下，如何估计均值和方差，里面也给出了公式，有兴趣可以参考。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;主要介绍EM的整个推导过程。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://hanielxx.com/categories/Notes/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="MachineLearning" scheme="https://hanielxx.com/tags/MachineLearning/"/>
    
      <category term="Notes" scheme="https://hanielxx.com/tags/Notes/"/>
    
      <category term="EM" scheme="https://hanielxx.com/tags/EM/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-031-Next Permutation</title>
    <link href="https://hanielxx.com/LeetCode/2019-11-04-LeetCode-031-Next-Permutation.html"/>
    <id>https://hanielxx.com/LeetCode/2019-11-04-LeetCode-031-Next-Permutation.html</id>
    <published>2019-11-04T01:46:18.000Z</published>
    <updated>2020-07-15T02:01:02.016Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/next-permutation/" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be in-place and use only constant extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ol><li>暴力方法<ul><li>直接求出所有可能的排列，然后找下一个比当前序列更大的</li><li>很明显不太现实，因为时间复杂度$O(n!)$</li></ul></li><li>正确姿势<ul><li>首先了解到一个规律：如果序列递减排列，那就已经是最大的了，没有更大的</li><li>因为要找字典序更大的，所以应该尽量修改后面部分的数字</li><li>如果后面部分的数字，都是递减的，那么只能继续往前找数字</li><li>因此：从后往前找到比后一个数字小的数字i，那么就可以通过改变这个数字i，及它后面所有数字的排列找到结果</li><li>我们在后面递减的序列中找最接近数字i的数字j，交换两个数字，固定数字i，这时候i后面的数字还是全部递减的，所以，将它们逆序，得到最小的。再加上i就是字典序的下一个排列</li></ul></li></ol><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>这次用了英文注释，后面慢慢的都用英文写注释了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Find target i, which is smaller than i+1</span></span><br><span class="line">        <span class="keyword">int</span> target=nums.size()<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(target&gt;=<span class="number">0</span> &amp;&amp; nums[target]&gt;=nums[target+<span class="number">1</span>])</span><br><span class="line">            target--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If nums is descending</span></span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span> reverse(nums.begin(),nums.end());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Find the bigger number</span></span><br><span class="line">        <span class="comment">//Pay attention to the boundary </span></span><br><span class="line">        <span class="keyword">int</span> bigger=target+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(bigger&lt;nums.size() &amp;&amp; nums[bigger]&gt;nums[target])&#123; </span><br><span class="line">            bigger++;</span><br><span class="line">        &#125;</span><br><span class="line">        bigger--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//swap the bigger number and target</span></span><br><span class="line">        <span class="keyword">int</span> tmp = nums[target];</span><br><span class="line">        nums[target] = nums[bigger];</span><br><span class="line">        nums[bigger]=tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//reverse nums[target+1:N-1]</span></span><br><span class="line">        reverse(nums.begin()+target+<span class="number">1</span>,nums.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        firstIndex = <span class="number">-1</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(nums, i, j)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                nums[i],nums[j] = nums[j], nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                firstIndex = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#print(firstIndex)</span></span><br><span class="line">        <span class="keyword">if</span> firstIndex == <span class="number">-1</span>:</span><br><span class="line">            reverse(nums, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        secondIndex = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, firstIndex, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[firstIndex]:</span><br><span class="line">                secondIndex = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[firstIndex],nums[secondIndex] = nums[secondIndex], nums[firstIndex]</span><br><span class="line">        reverse(nums, firstIndex+<span class="number">1</span>, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>字典序问题，不应该从前往后比较，应该从后往前，越低位的越小</li><li>通过极端情况，如从整个序列降序和升序的情况，来找思路</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.&lt;/p&gt;&lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).&lt;/p&gt;&lt;p&gt;The replacement must be in-place and use only constant extra memory.&lt;/p&gt;&lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;1,2,3 → 1,3,2&lt;br&gt;3,2,1 → 1,2,3&lt;br&gt;1,1,5 → 1,5,1&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
      <category term="List" scheme="https://hanielxx.com/tags/List/"/>
    
      <category term="Permutation" scheme="https://hanielxx.com/tags/Permutation/"/>
    
      <category term="In-Place" scheme="https://hanielxx.com/tags/In-Place/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-029-Divide Two Integers</title>
    <link href="https://hanielxx.com/LeetCode/2019-10-31-leetcode-028-divide-two-integers.html"/>
    <id>https://hanielxx.com/LeetCode/2019-10-31-leetcode-028-divide-two-integers.html</id>
    <published>2019-10-31T03:54:20.000Z</published>
    <updated>2020-07-15T02:01:02.016Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/divide-two-integers/submissions/" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.</p><p>Return the quotient after dividing dividend by divisor.</p><p>The integer division should truncate toward zero.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>dividend = 10, divisor = 3<br>dividend = 7, divisor = -3</p></blockquote><p><strong>Output:</strong></p><blockquote><p>3<br>-2</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>刚开始就是想到用减法，把被除数和除数都变成正数，然后一个个减。这样虽然能做，但是复杂度太高，总超时</li><li>题解中都用到了左移和右移这样的方法，看了之后按照自己的理解，将除数的倍数存在向量中，一直到最接近被除数。比如被除数是23，除数是5，，那么向量中就存放<code>5&lt;&lt;0=5，5&lt;&lt;1=10，10&lt;&lt;1=20</code>。分别对应的是<code>1&lt;&lt;0=1，1&lt;&lt;1=2 和 1&lt;&lt;2=4</code>。最后的结果计算是，<code>23&gt;20，res+4，23-20=3, 3&lt;10, 3&lt;5</code>，都不加，结果就是<code>4</code></li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">0</span> || (dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>)) <span class="keyword">return</span> INT_MAX; </span><br><span class="line">        <span class="keyword">if</span>(dividend == divisor) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisor == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> symbolFlag= (dividend&lt;<span class="number">0</span>)==(divisor&lt;<span class="number">0</span>);    <span class="comment">//符号，同号为1</span></span><br><span class="line">        <span class="keyword">int</span> minFlag = dividend==INT_MIN;    <span class="comment">//被除数为INT_MIN标识</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果负数为2147483648，就先加上一个除数绝对值</span></span><br><span class="line">        <span class="keyword">if</span>(dividend==INT_MIN) dividend+=<span class="built_in">abs</span>(divisor); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//全部变成正数</span></span><br><span class="line">        divisor=<span class="built_in">abs</span>(divisor);</span><br><span class="line">        dividend=<span class="built_in">abs</span>(dividend);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>, tmp=divisor;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//直到divisor大于dividend</span></span><br><span class="line">        <span class="keyword">while</span>(tmp&lt;=dividend)&#123;</span><br><span class="line">            nums.push_back(tmp);</span><br><span class="line">            <span class="keyword">if</span>(INT_MAX-tmp&lt;tmp) <span class="keyword">break</span>;  <span class="comment">//如果右移溢出，那肯定也大于divideng</span></span><br><span class="line">            tmp&lt;&lt;=<span class="number">1</span>;    <span class="comment">//除数乘以2</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从后往前减</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dividend&gt;=nums[i])&#123;</span><br><span class="line">                result += <span class="number">1</span>&lt;&lt;i;     <span class="comment">//result加上对应的数量</span></span><br><span class="line">                dividend -= nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理结果</span></span><br><span class="line">        <span class="keyword">if</span>(minFlag)&#123;    <span class="comment">//绝对值需加上1</span></span><br><span class="line">            <span class="keyword">if</span>(symbolFlag)&#123; <span class="comment">//同号</span></span><br><span class="line">                result = result==INT_MAX? result : result+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123; <span class="comment">//异号</span></span><br><span class="line">                result = -result<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            result = symbolFlag?result:-result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>题解：<a href="https://leetcode-cn.com/problems/divide-two-integers/solution/xiao-xue-sheng-du-hui-de-lie-shu-shi-suan-chu-fa-b/" rel="external nofollow noopener noreferrer" target="_blank">小学生都会的列竖式算除法</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line">    sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)</span><br><span class="line">    dividend = abs(dividend)</span><br><span class="line">    divisor = abs(divisor)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="comment">#把除数不断左移，直到它大于被除数</span></span><br><span class="line">    <span class="keyword">while</span> dividend &gt;= divisor:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        divisor &lt;&lt;= <span class="number">1</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        divisor &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> divisor &lt;= dividend:</span><br><span class="line">            result += <span class="number">1</span> &lt;&lt; count <span class="comment">#这里的移位运算是把二进制（第count+1位上的1）转换为十进制</span></span><br><span class="line">            dividend -= divisor</span><br><span class="line">    <span class="keyword">if</span> sign: result = -result</span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">if</span> -(<span class="number">1</span>&lt;&lt;<span class="number">31</span>) &lt;= result &lt;= (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span> <span class="keyword">else</span> (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="大整数进制转换"><a href="#大整数进制转换" class="headerlink" title="大整数进制转换"></a>大整数进制转换</h2><p>附上自己做的思维导图截图</p><img src="/LeetCode/2019-10-31-leetcode-028-divide-two-integers/1.png"><h2 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h2><p>附上自己做的思维导图截图</p><img src="/LeetCode/2019-10-31-leetcode-028-divide-two-integers/2.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>大整数运算，时间复杂度太高的，可以想想移位运算和二进制模拟。甚至是字符串。</li><li>联想到大整数乘除法。</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/divide-two-integers/submissions/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.&lt;/p&gt;&lt;p&gt;Return the quotient after dividing dividend by divisor.&lt;/p&gt;&lt;p&gt;The integer division should truncate toward zero.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;dividend = 10, divisor = 3&lt;br&gt;dividend = 7, divisor = -3&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;3&lt;br&gt;-2&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://hanielxx.com/tags/Math/"/>
    
      <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
      <category term="BigNumber" scheme="https://hanielxx.com/tags/BigNumber/"/>
    
      <category term="ShiftOperation" scheme="https://hanielxx.com/tags/ShiftOperation/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="https://hanielxx.com/Notes/2019-10-30-kmp-algorithm.html"/>
    <id>https://hanielxx.com/Notes/2019-10-30-kmp-algorithm.html</id>
    <published>2019-10-30T04:35:59.000Z</published>
    <updated>2020-07-15T02:01:02.036Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><p>KMP算法又复习了一遍，写个总结，贴下自己的代码。</p></div><a id="more"></a><h2 id="KMP算法介绍和原理"><a href="#KMP算法介绍和原理" class="headerlink" title="KMP算法介绍和原理"></a>KMP算法介绍和原理</h2><p>简单说就是字符串匹配，在主串中匹配模式串，返回匹配到的下标。</p><p>具体的可以看<a href="https://www.cnblogs.com/yjiyjige/p/3263858.html" rel="external nofollow noopener noreferrer" target="_blank">详解KMP算法</a>这篇博客，讲的挺好的，也有图解。<br>这里只放几张截图，不做详细介绍了。</p><img src="/Notes/2019-10-30-kmp-algorithm/1.png" title="基本思想"> <img src="/Notes/2019-10-30-kmp-algorithm/2.png" title="j指针移动的位置"> <img src="/Notes/2019-10-30-kmp-algorithm/3.png" title="next[j]=k，表示当T[i] != P[j]时，j指针的下一个位置"> <img src="/Notes/2019-10-30-kmp-algorithm/4.png" title="j=0和j=1时的情况"> <img src="/Notes/2019-10-30-kmp-algorithm/5.png" title="P[k]=P[j]时，next[j+1]==next[j]+1"> <img src="/Notes/2019-10-30-kmp-algorithm/6.png" title="P[k] != P[j]时， k = next[k]"><h2 id="KMP算法实现"><a href="#KMP算法实现" class="headerlink" title="KMP算法实现"></a>KMP算法实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">i<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用next作为变量名会报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> SIZE = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> myNext[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// myNext[j] = k，表示当T[i] !=</span></span><br><span class="line">  <span class="comment">// P[j]时，j指针的下一个位置，myNext[0]=-1表示主串后移 </span></span><br><span class="line">  <span class="built_in">memset</span>(myNext, <span class="number">-1</span>, <span class="keyword">sizeof</span>(myNext));</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (j &lt; p.length() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//如果两个字符相等或者k==-1</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) &#123;</span><br><span class="line">      <span class="comment">//当后两个字符相等时，跳转到k就没必要了，因为p[j]==p[k]，所以应该跳转到myNext[k]</span></span><br><span class="line">      <span class="comment">//因此要设置为myNext[k]</span></span><br><span class="line">      <span class="keyword">if</span> (p[++j] == p[++k]) &#123;</span><br><span class="line">        myNext[j] = myNext[k];</span><br><span class="line">        <span class="comment">//不等就正常跳转</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        myNext[j] = k;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//不等就k=myNext[k]，往前找匹配的</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      k = myNext[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts主串，ps模式串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> ts, <span class="built_in">string</span> ps)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//主串位置</span></span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">//模式串位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> tsLen = ts.length(), psLen = ps.length();</span><br><span class="line">  <span class="keyword">if</span> (tsLen == <span class="number">0</span> &amp;&amp; psLen == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (tsLen == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (psLen == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  getNext(ps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里如果直接写 i&lt;ts.length() &amp;&amp;</span></span><br><span class="line">  <span class="comment">// j&lt;ps.length()会出错，只进行一次循环就跳出了，很奇怪</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; tsLen &amp;&amp; j &lt; psLen) &#123;</span><br><span class="line">    <span class="comment">//当j为-1时，要移动的是i，当然j也要自增归0</span></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">-1</span> || ts[i] == ps[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// i不需要回溯了，i=i-j+1，j回到指定位置</span></span><br><span class="line">      j = myNext[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//全部匹配，返回主串匹配的下标，否则返回-1</span></span><br><span class="line">  <span class="keyword">if</span> (j == ps.length()) &#123;</span><br><span class="line">    <span class="keyword">return</span> i - j;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> t = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="built_in">string</span> p = <span class="string">"ll"</span>;</span><br><span class="line">  <span class="comment">// 输出2</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; KMP(t, p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;KMP算法又复习了一遍，写个总结，贴下自己的代码。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://hanielxx.com/categories/Notes/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="String" scheme="https://hanielxx.com/tags/String/"/>
    
      <category term="Match" scheme="https://hanielxx.com/tags/Match/"/>
    
      <category term="KMP" scheme="https://hanielxx.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-028-Implement strStr()</title>
    <link href="https://hanielxx.com/LeetCode/2019-10-30-LeetCode-028-Implement-strStr.html"/>
    <id>https://hanielxx.com/LeetCode/2019-10-30-LeetCode-028-Implement-strStr.html</id>
    <published>2019-10-30T04:30:27.000Z</published>
    <updated>2020-07-15T02:01:02.016Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>Implement strStr().</p><p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>haystack = “hello”, needle = “ll”</p></blockquote><p><strong>Output:</strong></p><blockquote><p>2</p></blockquote><p><strong>Input:</strong></p><blockquote><p>haystack = “aaaaa”, needle = “bba”</p></blockquote><p><strong>Output:</strong></p><blockquote><p>-1</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>很明显是一个字符串匹配的问题，自然想到用KMP算法</li><li>难的是会不会KMP…</li><li>KMP本身难点在getNext()函数，具体见代码和注释</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//如果使用next作为变量名会报错</span></span><br><span class="line">    <span class="keyword">int</span> myNext[<span class="number">1000000</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = KMP(haystack,needle);</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">      <span class="comment">// myNext[j] = k，表示当T[i] != P[j]时，j指针的下一个位置，myNext[0]=-1表示主串后移</span></span><br><span class="line">      <span class="built_in">memset</span>(myNext,<span class="number">-1</span>,<span class="keyword">sizeof</span>(myNext));</span><br><span class="line">      <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> k=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(j&lt;p.length()<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//如果两个字符相等或者k==-1</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">-1</span> || p[j]==p[k])&#123;</span><br><span class="line">          <span class="comment">//当后两个字符相等时，跳转到k就没必要了，因为p[j]==p[k]，所以应该跳转到myNext[k]</span></span><br><span class="line">          <span class="comment">//因此要设置为myNext[k]</span></span><br><span class="line">          <span class="keyword">if</span>(p[++j] == p[++k])&#123;</span><br><span class="line">            myNext[j]=myNext[k];</span><br><span class="line">          <span class="comment">//不等就正常跳转</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            myNext[j]=k;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//不等就k=myNext[k]，往前找匹配的</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          k=myNext[k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ts主串，ps模式串</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> ts, <span class="built_in">string</span> ps)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;  <span class="comment">//主串位置</span></span><br><span class="line">      <span class="keyword">int</span> j=<span class="number">0</span>;  <span class="comment">//模式串位置</span></span><br><span class="line">        </span><br><span class="line">      <span class="keyword">int</span> tsLen = ts.length(), psLen = ps.length();</span><br><span class="line">      <span class="keyword">if</span>(tsLen==<span class="number">0</span> &amp;&amp; psLen==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(tsLen==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span>(psLen==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">      getNext(ps);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 这里如果直接写 i&lt;ts.length() &amp;&amp; j&lt;ps.length()会出错，只进行一次循环就跳出了，很奇怪</span></span><br><span class="line">      <span class="keyword">while</span>(i&lt;tsLen &amp;&amp; j&lt;psLen)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"Before: i: "&lt;&lt;i&lt;&lt;" j: "&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//当j为-1时，要移动的是i，当然j也要自增归0</span></span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span> || ts[i]==ps[j])&#123;</span><br><span class="line">          i++;</span><br><span class="line">          j++;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">// i不需要回溯了，i=i-j+1，j回到指定位置</span></span><br><span class="line">          j=myNext[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"Before: i: "&lt;&lt;i&lt;&lt;" j: "&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//全部匹配，返回主串匹配的下标，否则返回-1</span></span><br><span class="line">      <span class="keyword">if</span>(j==ps.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>理解KMP很重要，每一步要理解为什么</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-strstr/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Implement strStr().&lt;/p&gt;&lt;p&gt;Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;haystack = “hello”, needle = “ll”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;2&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;haystack = “aaaaa”, needle = “bba”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;-1&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
      <category term="KMP" scheme="https://hanielxx.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-027-Remove-Element</title>
    <link href="https://hanielxx.com/LeetCode/2019-10-24-LeetCode-027-Remove-Element.html"/>
    <id>https://hanielxx.com/LeetCode/2019-10-24-LeetCode-027-Remove-Element.html</id>
    <published>2019-10-24T01:27:06.000Z</published>
    <updated>2020-07-15T02:01:02.016Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/remove-element/" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>Given nums = [3,2,2,3], val = 3,</p></blockquote><p><strong>Output:</strong></p><blockquote><p>Your function should return length = 2, with the first two elements of nums being 2.</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>题目要求就地，不使用额外空间，所以只能在原数组修改</li><li>双指针，以前的题目中用了很多。如果后一个指针内容和前一个不相等，就赋值，然后全部自增。否则就只有后指针自增。</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val) nums[pos++]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-element/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given an array nums and a value val, remove all instances of that value in-place and return the new length.&lt;/p&gt;&lt;p&gt;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&lt;/p&gt;&lt;p&gt;The order of elements can be changed. It doesn’t matter what you leave beyond the new length.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Given nums = [3,2,2,3], val = 3,&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 2.&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
      <category term="Vector" scheme="https://hanielxx.com/tags/Vector/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-026-Remove Duplicates from Sorted Array</title>
    <link href="https://hanielxx.com/LeetCode/2019-10-24-Remove-Duplicates-from-Sorted-Array.html"/>
    <id>https://hanielxx.com/LeetCode/2019-10-24-Remove-Duplicates-from-Sorted-Array.html</id>
    <published>2019-10-24T01:19:10.000Z</published>
    <updated>2020-07-15T02:01:02.016Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>Given nums = [1,1,2]</p></blockquote><p><strong>Output:</strong></p><blockquote><p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>和前一个元素比较，直接对vector进行元素删除</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.&lt;/p&gt;&lt;p&gt;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Given nums = [1,1,2]&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://hanielxx.com/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://hanielxx.com/tags/LeetCode/"/>
    
      <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
      <category term="Vector" scheme="https://hanielxx.com/tags/Vector/"/>
    
  </entry>
  
  <entry>
    <title>凸函数、Jensen不等式、凸集和凸优化</title>
    <link href="https://hanielxx.com/MachineLearning/2019-10-20-convex-function-set-optimization.html"/>
    <id>https://hanielxx.com/MachineLearning/2019-10-20-convex-function-set-optimization.html</id>
    <published>2019-10-20T13:38:40.000Z</published>
    <updated>2020-07-15T02:01:02.022Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><p>记录凸函数、凸集和凸优化的一些问题。<br>在一些算法优化中要用到。</p></div><a id="more"></a><h2 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>用简单的一元函数<script type="math/tex">f(x)</script>来说，如果对于任意<script type="math/tex">t \in [0,1]</script>均满足：<script type="math/tex">f(tx_1+(1−t)x_2) \le tf(x_1)+(1−t)f(x_2)</script>，则称f(x)为凸函数(convex function)</p><p>如果对于任意tϵ(0,1)均满足：<script type="math/tex">f(tx_1+(1−t)x_2) \lt tf(x_1)+(1−t)f(x_2)，则称f(x)为严格凸函数(convex function)</script></p><p>直观上理解，凸函数的隔线在曲线下方。<br></p><p>上述可以推广到多元函数。</p><p>如果优化函数是凸函数，那么，局部最小就是全局最小，不会陷入局部最优里。<br>SVM的目标函数<script type="math/tex">||\omega||^2</script>就是一个凸函数</p><h3 id="判断凸函数"><a href="#判断凸函数" class="headerlink" title="判断凸函数"></a>判断凸函数</h3><ul><li>一元函数：求二阶导数的符号来判断，如果非负，就是凸函数</li><li>多元函数：通过Hessian矩阵的正定性判断，如果Hessian矩阵是半正定矩阵，那就是凸函数</li></ul><h3 id="性质：Jensen不等式"><a href="#性质：Jensen不等式" class="headerlink" title="性质：Jensen不等式"></a>性质：Jensen不等式</h3><p>凸函数满足Jensen不等式：</p><p>一元情况：对于任意<script type="math/tex">t \in [0,1]</script>均满足：<script type="math/tex">f(tx_1+(1−t)x_2) \le tf(x_1)+(1−t)f(x_2)</script></p><img src="/MachineLearning/2019-10-20-convex-function-set-optimization/Jensen.jpg" title="Jensen不等式在一元函数图像中的解释"><p>推广：</p><p>如果 f 是凸函数，X是随机变量，那么<script type="math/tex">\theta_1,…,\theta_k \ge 0，\theta_1 + … + \theta_k = 1</script>,<script type="math/tex">f(\theta_1x_1+ … + \theta_kx_k) \le \theta_1f(x_1)+ … + \theta_kf(x_k)</script></p><p>如果把<script type="math/tex">\theta</script>看成是<script type="math/tex">x_k</script>的概率，那么就可以理解成下面的一般式子：</p><script type="math/tex;mode=display">f(E(X)) \le E(f(X))</script><p>如果是凹函数，那么很容易想到，应该把不等号反过来，原理相同。</p><p>在EM算法中，收敛性证明部分就是用到的凹函数Jensen不等式，而不是凸函数。</p><div class="note info"><p>简言之：</p><ul><li><strong>凸函数：函数的期望，大于等于，期望的函数</strong></li><li><strong>凹函数：函数的期望，小于等于，期望的函数</strong></li></ul></div><h2 id="凸集"><a href="#凸集" class="headerlink" title="凸集"></a>凸集</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>如果集合 C 为凸集，那么对于任意的<script type="math/tex">x1,x2 in C 与0 \le \theta \le 1都有 \theta x_1+(1−\theta)x_2 in C</script>，与仿射集的区别在于仿射集并没有<script type="math/tex">\theta \ge 0</script>的要求，例如一条线段是凸集，而一条直线是仿射集。</p><p>扩展到多维的情况，如果有<script type="math/tex">\theta_1 + \theta_2 +...+ \theta_k = 1, \theta_i \gt 0</script>，则称具有<script type="math/tex">\theta_1x_1 + \theta_2x_2 +...+ \theta_kx_k</script>形式的点为<script type="math/tex">x_1,x_2....x_k</script>的凸组合。</p><p>称由集合<script type="math/tex">C \subset R^n</script>中点的所有凸组合所组成的集合为C的凸包：</p><script type="math/tex;mode=display">conv C = { \theta_1x_1 +...+ \theta_kx_k | x_1,..,x_k in C, \theta_1+\theta_2+...+\theta_k=1, \theta_i \ge 0}</script><p>与仿射包同样，凸包也是包含 C 的最小的凸集，在一般情况下，设<script type="math/tex">C \subset R^n</script>是凸集，x 是随机变量，并且<script type="math/tex">x in C</script>的概率为1，那么<script type="math/tex">E x \in C</script></p><h3 id="重要的凸集"><a href="#重要的凸集" class="headerlink" title="重要的凸集"></a>重要的凸集</h3><p>任意的仿射集和子空间都是凸集，一些比较简单的例如空集<script type="math/tex">\emptyset</script>，单点集{x0}，全空间<script type="math/tex">R^n</script>，直线/射线/线段都是凸的。</p><p>还有一些比较重要的凸集如下：</p><ol><li>超平面<script type="math/tex">{x|a^Tx = b}</script>和半空间<script type="math/tex">{x|a^Tx \le b}</script></li><li>Euclid球<script type="math/tex">B(x_c,r)={x| ||x−x_c||_2 \le r}</script></li><li>椭球$$ \xi ={x|(x−x_c)^T P^(−1) (x−x_c) \le 1}</li><li>范数球<script type="math/tex">{x| ||x−x_c|| \le r}，其中 ||⋅|| 是</script>R^n $$中的范数</li><li>范数锥<script type="math/tex">C={(x,t)| ||x|| \le t} \subset R^(n+1)</script></li><li>多面体<script type="math/tex">P={x|a^T_j \le b_j, j=1,...,m, c^T_j x = d_j,j=1,...,p}</script>，即为有限个半空间和超平面的交集，单纯形也为凸集，是一种特殊的多面体半正定锥<script type="math/tex">S^n_+={X \subset R^{n∗n}|X=X^T,X \ge 0}</script>，即为半正定对称矩阵的集合_</li></ol><h2 id="凸优化问题"><a href="#凸优化问题" class="headerlink" title="凸优化问题"></a>凸优化问题</h2><p>在优化问题中，凸优化问题由于具有优良的性质（局部最优解即是全局最优解），受到广泛研究。<br>主要作用是，将有约束条件的转换成无约束条件的。</p><p>对于一个含约束的优化问题：</p><script type="math/tex;mode=display">\left\{\begin{array}{c}min_x  f(x) \\s.t. x in C\end{array}\right.</script><p>其中，f(x) 为一个凸函数，变量x 的可行域C 是一个凸集，那么这个优化问题称为一个凸优化问题。<br>将上面的约束条件的形式更加明确一点，一个凸优化问题可以写成：</p><script type="math/tex;mode=display">\left\{\begin{array}{c}min_x  f(x) \\s.t.  & g_i(x) \le 0 \\& h_i(x) = 0\end{array}\right.</script><p>其中，f(x) 当然仍然为一个凸函数，但对约束条件有一定要求：<script type="math/tex">g_i(x)</script>是凸函数；<script type="math/tex">h_i(x)</script>为仿射函数。这样的要求当然是为了保证可行域是一个凸集。</p><p>不等式约束中<script type="math/tex">g_i(x)</script>为凸函数，而凸函数的水平截集<script type="math/tex">{x|g_i(x) \le \alpha}是一个凸集(凸函数的性质)，这就使得不等式约束保证了可行域为凸集；对于等式约束</script>h_i(x)=0 $$可以写成：</p><script type="math/tex;mode=display">\left\{\begin{array}{c}h_i(x) \le 0 \\h_i(x) \ge 0\end{array}\right.</script><p>要使得满足条件的x 组成的集合为凸集，就要求<script type="math/tex">h_i(x)</script>既是一个凸函数，又是一个凹函数，这样hi(x)便只能是仿射函数了。</p><p>以上便是凸优化问题的一般形式。常见的线性规划、二次规划、二次约束二次规划等优化问题都是凸优化问题。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;记录凸函数、凸集和凸优化的一些问题。&lt;br&gt;在一些算法优化中要用到。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="MachineLearning" scheme="https://hanielxx.com/categories/MachineLearning/"/>
    
    
      <category term="凸函数" scheme="https://hanielxx.com/tags/%E5%87%B8%E5%87%BD%E6%95%B0/"/>
    
      <category term="凸集" scheme="https://hanielxx.com/tags/%E5%87%B8%E9%9B%86/"/>
    
      <category term="凸优化" scheme="https://hanielxx.com/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"/>
    
      <category term="SVM" scheme="https://hanielxx.com/tags/SVM/"/>
    
  </entry>
  
  <entry>
    <title>超平面、函数间隔和几何间隔</title>
    <link href="https://hanielxx.com/MachineLearning/2019-10-20-hyperplane-functionalmargin-geometricmargin.html"/>
    <id>https://hanielxx.com/MachineLearning/2019-10-20-hyperplane-functionalmargin-geometricmargin.html</id>
    <published>2019-10-20T12:24:35.000Z</published>
    <updated>2020-07-15T02:01:02.032Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><p>关于超平面、函数间隔以及几何间隔的理解。<br>这些在SVM中要用到。</p></div><a id="more"></a><h2 id="超平面"><a href="#超平面" class="headerlink" title="超平面"></a>超平面</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>超平面是指n维线性空间中维度为n-1的子空间。它可以把线性空间分割成不相交的两部分。比如二维空间中，一条直线是一维的，它把平面分成了两块；三维空间中，一个平面是二维的，它把空间分成了两块。</li><li>法向量是指垂直于超平面的向量</li></ol><h3 id="法向量和超平面公式"><a href="#法向量和超平面公式" class="headerlink" title="法向量和超平面公式"></a>法向量和超平面公式</h3><p>假设在<script type="math/tex">R^3</script>空间内，那么法向量和平面总是垂直的。如下图：<br></p><script type="math/tex;mode=display">x(x_1', x_2, x_3)</script><script type="math/tex;mode=display">x(x_1, x_2, x_3)，x'(x_1', x_2', x_3')，w(w_1, w_2, w_3)</script><p>不难看出，<script type="math/tex">x - x'</script>和法向量垂直，于是：</p><script type="math/tex;mode=display">(x-x')w = 0</script><script type="math/tex;mode=display">(x_1-x_1', x_2-x_2', x_3-x_3') · (w_1, w_2, w_3) = 0</script><p>化简后得：</p><script type="math/tex;mode=display">x_1w_1 + x_2w_2 + x_3w_3 = w_1x_1' + w_2x_2' + w_3x_3'</script><p>由于其为常数项，所以令：</p><script type="math/tex;mode=display">b = -w^Tx'</script><p>于是超平面公式可以写成:</p><script type="math/tex;mode=display">w^Tx+b = 0</script><p>同样可以推导到<script type="math/tex">R^n</script>空间</p><h3 id="点到超平面距离"><a href="#点到超平面距离" class="headerlink" title="点到超平面距离"></a>点到超平面距离</h3><img src="/MachineLearning/2019-10-20-hyperplane-functionalmargin-geometricmargin/distance.png" title="点到超平面距离"><p>x是平面外一点，距离平面是d，即红色线。<br>通过三角函数得到：</p><script type="math/tex;mode=display">cos{\theta}=\dfrac{d}{||x-x'||}</script><p>又因为d和法向量平行，所以可以通过向量相乘等于模乘模乘cos得到：</p><script type="math/tex;mode=display">|(x-x')\omega|=||x-x'||\cdot||\omega||\cdot\cos{\theta}</script><p>联立得到：</p><script type="math/tex;mode=display">d = \dfrac{|(x-x')\omega|}{||\omega||}=\dfrac{|\omega x-\omega x'|}{||\omega||}</script><p>因为<script type="math/tex">x'</script>在超平面内，<script type="math/tex">\omega x'=-b</script>，于是最后得到的任意点到超平面的距离公式：</p><script type="math/tex;mode=display">d=\dfrac{|\omega x+b|}{||\omega||}</script><p>其实高中学过一点<script type="math/tex">x_i, y_i</script>到直线<script type="math/tex">ax+by+c=0</script>的距离公式：</p><script type="math/tex;mode=display">d(x_i, y_i) = {|ax_i+by_i+c| \over \sqrt{a^2+b^2}}</script><p>这个和上面通用的公式可以对应</p><h2 id="函数间隔"><a href="#函数间隔" class="headerlink" title="函数间隔"></a>函数间隔</h2><p>在超平面确定的情况下，点到平面距离公式中，分母不变，所以分子<script type="math/tex">|\omega·x + b|</script>可以近似表示点到超平面的距离。</p><p>如果<script type="math/tex">\omega · x + b > 0</script>，则被认为是正类，否则为负类<br>如果都正确分类，那么<script type="math/tex">y(\omega ·x +b) > 0</script>，如果分类错误，那么小于0.<br>同时，<script type="math/tex">y(\omega ·x +b) > 0</script>的绝对值越大，则确信度越大</p><p>因此用这个来表示函数间隔。对于一个训练样本(x(i),y(i))我们定义它到超平面(w,b)的函数间隔为:</p><script type="math/tex;mode=display">\hatγ = y^{(i)}(w^Tx^{(i)}+b)</script><p>函数间隔越大越好，并且如果<script type="math/tex">\hatγ > 0</script>，则样本正确分类<br>对于整个训练集，定义函数间隔为所有样本中最小的那个函数间隔:</p><script type="math/tex;mode=display">\hatγ = min_i \hatγ^{(i)}</script><h2 id="几何间隔"><a href="#几何间隔" class="headerlink" title="几何间隔"></a>几何间隔</h2><p>对于函数间隔，有个问题就是，可以在不改变超平面的情况下，让函数间隔任意大。<br>如果<script type="math/tex">\omega</script>和<script type="math/tex">b</script>倍增，函数间隔改变，但是超平面不变。</p><p>因此我们对函数间隔加上一个限制：</p><script type="math/tex;mode=display">||\omega|| = 1</script><p>这样是为了，让<script type="math/tex">\omega和b</script>倍增的时候，分母也会倍增，所以几何间隔就不会改变。<br>当<script type="math/tex">||\omega||=1</script>的时候，几何间隔就是函数间隔</p><p>所以几何间隔的公式就是：</p><script type="math/tex;mode=display">γ^{(i)} = y^{(i)}({w^T \over ∥w∥}x^{(i)}+{b \over ∥w∥})</script><p>训练集的集合间隔是所有样本中最小的那个：</p><script type="math/tex;mode=display">γ = min_iγ^{(i)}</script><p>有没有发现，几何间隔其实就是<strong>点到平面的距离</strong></p><p>函数间隔和几何间隔的关系：</p><script type="math/tex;mode=display">γ^{(i)}={\hatγ^{(i)} \over ∥w∥ }</script><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;关于超平面、函数间隔以及几何间隔的理解。&lt;br&gt;这些在SVM中要用到。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="MachineLearning" scheme="https://hanielxx.com/categories/MachineLearning/"/>
    
    
      <category term="SVM" scheme="https://hanielxx.com/tags/SVM/"/>
    
      <category term="超平面" scheme="https://hanielxx.com/tags/%E8%B6%85%E5%B9%B3%E9%9D%A2/"/>
    
      <category term="函数间隔" scheme="https://hanielxx.com/tags/%E5%87%BD%E6%95%B0%E9%97%B4%E9%9A%94/"/>
    
      <category term="几何间隔" scheme="https://hanielxx.com/tags/%E5%87%A0%E4%BD%95%E9%97%B4%E9%9A%94/"/>
    
  </entry>
  
  <entry>
    <title>论文笔记 | 基于机器学习的siRNA沉默效率预测方法研究</title>
    <link href="https://hanielxx.com/Notes/2019-10-17-Paper-note-Research-on-prediction-method-of-siRNA-silencing-efficiency-based-on-machine-learning.html"/>
    <id>https://hanielxx.com/Notes/2019-10-17-Paper-note-Research-on-prediction-method-of-siRNA-silencing-efficiency-based-on-machine-learning.html</id>
    <published>2019-10-17T02:56:51.000Z</published>
    <updated>2020-07-15T02:01:02.059Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><p>最近在看<a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2017&amp;filename=1017152231.nh" rel="external nofollow noopener noreferrer" target="_blank">基于机器学习的siRNA沉默效率预测方法研究</a>这篇论文，论文一共98页，实在太长，不得不单独一篇笔记用于记录要点。</p><p>这篇论文在使用机器学习方法研究siRNA沉默效率这方面讲的还是很清楚的，用以入门。</p></div><a id="more"></a><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="研究意义"><a href="#研究意义" class="headerlink" title="研究意义"></a>研究意义</h2><p>这里主要讲述了RNAi的起源、作用机制和应用，可以参考上一篇文章<a href="https://hanielxx.com/Notes/2019-10-01-basic-knowledge-of-RNAi.html">RNAi和siRNA设计基础</a>，这里就不记录了。</p><h2 id="国内外研究动态"><a href="#国内外研究动态" class="headerlink" title="国内外研究动态"></a>国内外研究动态</h2><h3 id="基于规则的第一代-siRNA-沉默效率预测方法"><a href="#基于规则的第一代-siRNA-沉默效率预测方法" class="headerlink" title="基于规则的第一代 siRNA 沉默效率预测方法"></a>基于规则的第一代 siRNA 沉默效率预测方法</h3><p>早期主要是用统计学方法寻找siRNA不同沉默效率的规则，因此沉默效率不能量化，只能分高效和低效siRNA</p><p>主要是在siRNA不同位置上的规则约束，这部分可以用一张表总结。<br><img src="/Notes/2019-10-17-Paper-note-Research-on-prediction-method-of-siRNA-silencing-efficiency-based-on-machine-learning/1-1.png" title="siRNA序列打分规则"></p><p>其次需要考虑siRNA热力学稳定性，主要是下面两种规则：<br><img src="/Notes/2019-10-17-Paper-note-Research-on-prediction-method-of-siRNA-silencing-efficiency-based-on-machine-learning/1-2.png" title="siRNA热力学稳定性规则"></p><p><strong>缺点是：</strong></p><ol><li>样本量太少</li><li>规则不够具体</li><li>没有设置权重区分规则重要性</li><li>具有数据偏向性<h3 id="基于机器学习的第二代-siRNA-沉默效率预测方法"><a href="#基于机器学习的第二代-siRNA-沉默效率预测方法" class="headerlink" title="基于机器学习的第二代 siRNA 沉默效率预测方法"></a>基于机器学习的第二代 siRNA 沉默效率预测方法</h3></li></ol><h4 id="数据集方面"><a href="#数据集方面" class="headerlink" title="数据集方面"></a>数据集方面</h4><p>主要是使用Huesken数据集，Huesken 数据集到目前为止同样实验条件下提出的数量最多的数据集。</p><p>其他一些包括化学修饰的数据集可以有需要再去论文中查看。</p><h3 id="特征方面"><a href="#特征方面" class="headerlink" title="特征方面"></a>特征方面</h3><ol><li>碱基组成</li><li><p>1-3mer的motif频率和位置特征</p></li><li><p>热力学参数，包括siRNA 双链的G ，siRNA 反义链的内部分子结构稳定性，局部靶标的 mRNA 稳定性以及 siRNA 双链中每相邻两个碱基对的稳定性等等</p></li><li>反义链的二级结构</li><li>与mRNA有区别的结构特征</li><li>靶mRNA的二级结构</li><li><p>靶mRNA内多个反义链结合位点的能量</p></li><li><p>siRNA的3n+1位碱基组成，也意味着siRNA的绑定蛋白和效率有关</p></li><li>siRNA上下游碱基，可能是上下游特定的motif可能影响效率</li></ol><h4 id="算法方面"><a href="#算法方面" class="headerlink" title="算法方面"></a>算法方面</h4><p>统计如下：</p><ol><li>GP算法</li><li>GSK和SVM</li><li>神经网络</li><li>线性回归</li><li>决策树</li><li>随机森林>SVM</li><li>后缀树</li><li>规则矩阵，利用已知规则设置权重，结合半监督的回归算法</li></ol><h1 id="机器学习在siRNA沉默效率预测中的应用"><a href="#机器学习在siRNA沉默效率预测中的应用" class="headerlink" title="机器学习在siRNA沉默效率预测中的应用"></a>机器学习在siRNA沉默效率预测中的应用</h1><h2 id="siRNA样本收集"><a href="#siRNA样本收集" class="headerlink" title="siRNA样本收集"></a>siRNA样本收集</h2><p>此需要选择具有代表性、数量充足的样本集合。生物信息学使用的数据还需要注意数据是否存在冗余</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;最近在看&lt;a href=&quot;https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&amp;amp;dbname=CDFDLAST2017&amp;amp;filename=1017152231.nh&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;基于机器学习的siRNA沉默效率预测方法研究&lt;/a&gt;这篇论文，论文一共98页，实在太长，不得不单独一篇笔记用于记录要点。&lt;/p&gt;&lt;p&gt;这篇论文在使用机器学习方法研究siRNA沉默效率这方面讲的还是很清楚的，用以入门。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://hanielxx.com/categories/Notes/"/>
    
    
      <category term="MachineLearning" scheme="https://hanielxx.com/tags/MachineLearning/"/>
    
      <category term="Notes" scheme="https://hanielxx.com/tags/Notes/"/>
    
      <category term="siRNA" scheme="https://hanielxx.com/tags/siRNA/"/>
    
      <category term="Paper" scheme="https://hanielxx.com/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>每个人都需要一个引路人</title>
    <link href="https://hanielxx.com/Daily/2019-10-16-everyone-need-a-life-coach.html"/>
    <id>https://hanielxx.com/Daily/2019-10-16-everyone-need-a-life-coach.html</id>
    <published>2019-10-16T15:14:02.000Z</published>
    <updated>2020-07-15T02:01:02.012Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一阵子回了趟高中，时隔两年再次进入当初的校园，有点兴奋又有点感慨。<br>如今已经是准研究生，又仿佛到了大学刚开学那时候。<br>回顾之前的生活，由心的感叹，真的每个人都需要一个人生的引路人。</p></div><a id="more"></a><h2 id="重返高中"><a href="#重返高中" class="headerlink" title="重返高中"></a>重返高中</h2><h3 id="高中的变化"><a href="#高中的变化" class="headerlink" title="高中的变化"></a>高中的变化</h3><p>毕业之后，高中变了很多。在操场后面建了体育馆，而且学校后面那条小河，以及附近的荒地，都被归入学校的范围了。在原有的基础上扩建了很多。原本的正门变成了后门，新建了一个更气派的大门。</p><p>在学校门口看着以前小小的高中变了模样，心里还是很开心的。想着要见到班主任了，突然又有点紧张。印象里上次见他应该是大一的时候，那时还能有几个同伴，现在大家都很忙，就只有自己一个人孤零零的回来。</p><h3 id="我的班主任"><a href="#我的班主任" class="headerlink" title="我的班主任"></a>我的班主任</h3><p>原本还担心这么久不见，会没有话可谈，没想到能和他聊一上午。似乎是因为穿着的问题，班主任看起来更加像是中年男人了。印象里高中那会，他看起来还是挺年轻的。</p><p>班主任和学生之间的话题，似乎永远都会围绕着学习和日常生活，少有打趣和玩笑。</p><p>在他面前，我似乎还是当初那个说着“你让我把目标定为年级前几，我现在做到了。”的那个孩子，不管过了几年，还是他的学生。</p><p>高中那时候只想着好好学习，没那么多烦心事。偶尔以为自己成绩不错骄傲一下，在其他同学面前像个爱炫耀的小公鸡。现在想想真的很轻松，也很快乐。</p><p>班上的同学似乎对班主任都有点偏见，总说他不靠谱，没其他班主任好。但我感觉，从心底他们还是非常认可他的，说的话似乎都是在开玩笑。老师说，毕业之后，很多人都私下和他有联系，更让我确定是这样。</p><p>和他聊了很多，说了自己目前的现状，说到了未来的发展，说到了曾经的我们，还有现在的学弟学妹们。看得出来，老师对我回去看望他很开心，对我现在的发展也很满意。以后再回去可能得等毕业了。时间过得很快，总感觉还想呆在学校，呆在我的高中生活里。</p><h3 id="给高中学弟学妹们的话"><a href="#给高中学弟学妹们的话" class="headerlink" title="给高中学弟学妹们的话"></a>给高中学弟学妹们的话</h3><p>最后临走，在他现在带的班级里和学弟学妹们讲了点话。是，他还是做班主任，但是带的学生，却不是第一届了。</p><p>看着学弟学妹们稚嫩的样子，心里感慨更多了。想说很多，又不知道从何说起。</p><p>简单的提了一下自己认为高中很重要的学习方法，又提醒他们不要早恋。听老班说，现在的学生没有以前质量高了，而且都不在乎学业，没什么目标。我想，可能只有到最后，他们才能明白，高中是最应该好好读书的时候。</p><p>最后还是提醒他们说要目光放长远点，但是，我感觉，这时候的这些小雏鹰，不到最后是不会明白这个道理的。</p><p>讲的比较乱，后来回去也挺后悔，应该早点准备这个讲话。很多我认为应该告诉他们的，还是没有想起来。</p><h3 id="回去后的感叹"><a href="#回去后的感叹" class="headerlink" title="回去后的感叹"></a>回去后的感叹</h3><p>高中，一个呈上启下的阶段，真的很重要。我认为除了好好学习，埋头刷题，学习方面还需要自我总结，好的学习方法从来都是自己总结出来的，别人的，真的不一定适合。这些总结学习方法的能力，并不是只适用于高中，大学乃至未来的生活都会用到。直接的表现就是，别人感觉你比他聪明，其实只是学习能力的一个提升。</p><p>除了学习，我认为心理素质和精神素质的培养也很重要，当然，这是在大学才发现的。必须在高中就培养出较好的心理承受能力，比较平稳的，最好是积极乐观的心态。如果在高中这方面忽视了，结果很可能是大学的时候，承受不住各种压力，各种挫折失败，一次次的让自己崩溃。如果乐观还好，悲观的话，那带来的可能就是灾难性的后果，被压力打败，对未来没有希望，对自己没有信心，那很可能就会有抑郁症。</p><p>除了这方面，还有需要重视的是对未来自己发展的一个规划。简单说就是自己未来的职业。这个选择，可能决定未来的人生。高考填专业，一方面是要看自己感不感兴趣，另一方面，是这个专业是否有前景。</p><p>我认为，感兴趣可能要占到0.7的权重，前景可能只占到0.3。从大学开始，更多的是兴趣驱动。</p><p>你应该做的是，将自己非常感兴趣的，有点兴趣的，可能感兴趣的，所有方向都列出来，然后在这里面挑选最有前景又有兴趣的。</p><p>人生最完美的，就是能够把自己的兴趣作为职业。而这个决定权，在高考填志愿那时候的你手中。</p><p>如果你没有选择自己感兴趣的，而是热门专业。那你要做的就是，在大学四年里，尽量对这个方向培养出兴趣。实在不喜欢，那你在大二下学期前就应该找到自己真正喜欢的方向。否则除非你不读研，不然会很累。</p><p>如果你在高中找到了自己兴趣所在，又能学有余力。那希望你能够利用课余时间自学一下那方面的基础知识。</p><p>你高中学的基础，都是你大学比别人优秀的资本。</p><p>我是多希望当初能这样给学弟学妹们讲讲啊，这样他们会少走很多弯路，会有一个长远的视角。不会像我这样，只有自己吃了亏，才意识到当初应该怎样怎样。</p><h2 id="大学三年"><a href="#大学三年" class="headerlink" title="大学三年"></a>大学三年</h2><p>在学习、生活和情感，这三个方面中，引路人在学习方面的作用算是最大了吧。<br>而生活和情感，这需要自己真正经历过，体验过，感悟过，才能有所收获。</p><h3 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h3><p>这三年，回想起来最大的感受还是过的太快了。</p><p>另一方面可能就是遗憾了。从大一开始，就因为各种踩坑，没能把握很多机会，挺后悔的，后面也在尽力弥补。</p><p>听过一句话说的挺好，“人活着就是会后悔的，我们要做的，就是尽力去弥补。”</p><p>大学三年，大一一整年的基础课，数学占了大头。现在才发现，那些课都是以后学习和科研要用到的，不存在无用这种说法。大二就开始有了专业课，而这些专业课，是我们能够实习工作的基础，也是考研保研的一个重点考察部分。总的来说，基础知识收获还是很多的。</p><p>但是在算法、竞赛、论文、软著等这些加分项上，真的还是欠缺很多。如果大一能够知道算法的重要性，打一年半年的ACM，如果大二能够重视竞赛，花更多的课外时间而不是只是假期，在准备竞赛上，可能竞赛成绩会更好。如果当时选择多加一个实验室，可能本科懂得会更多，也更有可能遇到带本科生的导师。如果大二下能够知道论文的重要性，着手发论文，那保研或许不会那么坎坷。如果夏令营多投几个，而不是只抓南大和东南，或许我保研之路不会这么提心吊胆，预推免和九推会冒着很大的风险。</p><p>幸运的是，三年历程有惊无险，后期弥补了很多。何况如今都懂了，未来也会更加主动地取借鉴学长学姐们的经验，尽量避免研究生三年踩大坑。</p><h3 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h3><p>逐渐从一个青涩的高中生，只在象牙塔中生活过的高中生，变成了一个已经被叫叔叔的，慢慢接触社会的青年。</p><p>从前的生活真的很轻松，没有那么多烦恼，什么事情都有爸爸妈妈挡着，活像一只小雏鹰，自由、奋发向上。</p><p>而今，开始独立生活。接触了社会上的一些人，才知道怎么说话，怎么做事，怎么和社会人群相处。<br>发过了传单，才知道赚钱是多么不容易，也要体谅基层工作者。</p><p>不要给保洁叔叔阿姨添麻烦，不要冷漠拒绝发传单的人们，不要对他人那么冷漠。因为只有当你被无数人拒绝之后才知道，这是多么难受的一种感觉。</p><p>做过了家教，才知道生存不一定非要卖苦力，自己的知识也可以作为生存的资本，要多挖掘自己的能力在社会中的价值。</p><p>接触的人多了，终于知道要注意形象。穿衣、护肤、发型甚至培养气质样样不可少。好的形象无形中也能提升自我价值。</p><p>被别人依赖过，才明白，独立是多么重要。自己做好自己的事情，不光是一种本分，也是对自己的一种锻炼。</p><h3 id="情感方面"><a href="#情感方面" class="headerlink" title="情感方面"></a>情感方面</h3><p>….未完</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前一阵子回了趟高中，时隔两年再次进入当初的校园，有点兴奋又有点感慨。&lt;br&gt;如今已经是准研究生，又仿佛到了大学刚开学那时候。&lt;br&gt;回顾之前的生活，由心的感叹，真的每个人都需要一个人生的引路人。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Daily" scheme="https://hanielxx.com/categories/Daily/"/>
    
    
      <category term="Daily" scheme="https://hanielxx.com/tags/Daily/"/>
    
      <category term="Lift" scheme="https://hanielxx.com/tags/Lift/"/>
    
  </entry>
  
  <entry>
    <title>RNAi和siRNA设计基础</title>
    <link href="https://hanielxx.com/Notes/2019-10-01-basic-knowledge-of-RNAi.html"/>
    <id>https://hanielxx.com/Notes/2019-10-01-basic-knowledge-of-RNAi.html</id>
    <published>2019-10-01T10:40:22.000Z</published>
    <updated>2020-07-15T02:01:02.039Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><p>刚接触siRNA搜索、设计和评测这方面的研究，记录一下基本的概念和一些基础知识，还有自己的理解总结。</p></div><a id="more"></a><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="英文缩写"><a href="#英文缩写" class="headerlink" title="英文缩写"></a>英文缩写</h3><ol><li>RNAi：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RNA干扰</li><li>siRNA：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小干扰RNA</li><li>dsRNA：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Double-stranded RNA的缩写，是指双链核糖核酸</li><li><a href="https://baike.baidu.com/item/shRNA" rel="external nofollow noopener noreferrer" target="_blank">shRNA</a>：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是英文单词short hairpin RNA的缩写。翻译为“短发夹RNA”。shRNA包括两个短反向重复序列。克隆到shRNA表达载体中的shRNA包括两个短反向重复序列，中间由一茎环（loop）序列分隔的，组成发夹结构，由polⅢ启动子控制。随后再连上5-6个T作为RNA聚合酶Ⅲ的转录终止子。</li><li>Argonaute (AGO)：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一类庞大的蛋白质家族，是组成RISCs复合物的主要成员。AGO蛋白质主要包含两个结构域：PAZ和PIWI两个结构域，但具体功能现在尚不清楚。</li><li><p>Dicer酶：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是RNAase Ⅲ家族中的一员，主要切割dsRNA或者茎环结构的RNA前体成为小RNAs分子。对应地，我们将这种小RNAs分子命名为siRNAs和miRNA。Dicer有着较多的结构域，最先在果蝇中发现，并且在不同的生物体上表现出很高的保守性。</p></li><li><p>RISC：RISC诱导沉默复合体（全称：RNA-induced silencing complex）：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种由siRNA与Argonaute蛋白和Dicer酶复合形成的复合物。在RNAi中，利用siRNA的反义链切割靶mRNA，达到基因沉默。</p></li><li><p>BLAST (Basic Local Alignment Search Tool)：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是一套在蛋白质数据库或DNA数据库中进行相似性比较的分析工具。BLAST程序能迅速与公开数据库进行相似性序列比较。BLAST结果中的得分是对一种对相似性的统计说明。</p></li><li><p>rRNA（核糖体RNA）是核糖体的组成成分,它和蛋白质共同组成了核糖体.<br>tRNA（转运RNA）可以转运氨基酸.<br>mRNA（信使RNA）是由细胞核内的DNA转录来的,相当于蛋白质的设计图纸.</p></li><li><p>UTR：非翻译区</p></li><li><p><a href="http://www.baike.com/wiki/SD%E5%BA%8F%E5%88%97" rel="external nofollow noopener noreferrer" target="_blank">SD序列</a>：mRNA起始部位的碱基序列，为mRNA与核糖体的结合位点称SD序列.在DNA上相应的位点也称SD序列，一般位于操纵基因和第一个结构基因之间，部分序列与操纵基因重叠.</p></li></ol><h3 id="名词概念"><a href="#名词概念" class="headerlink" title="名词概念"></a>名词概念</h3><ol><li>质粒：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小型环状DNA分子，包括三部分：遗传标记基因，复制区，目的基因.在所有的细菌类群中都可发现，它们是独立于细菌染色体外自我复制的DNA分子</li><li><p>质粒载体：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;质粒载体是在天然质粒的基础上为适应实验室操作而进行人工构建的质粒。与天然质粒相比，质粒载体通常带有一个或一个以上的选择性标记基因（如抗生素抗性基因）和一个人工合成的含有多个限制性内切酶识别位点的多克隆位点序列，并去掉了大部分非必需序列，使分子量尽可能减少，以便于基因工程操作</p></li><li><p>转染：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是真核细胞主动或被动导入外源DNA片段而获得新的表型的过程</p></li><li><p>细胞株：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过选择法或克隆形成法从原代培养物或细胞系中获得具有特殊性质或标志物的培养物称为细胞株。<br>细胞株是用单细胞分离培养或通过筛选的方法，由单细胞增殖形成的细胞群。细胞株的特殊性质或标志必须在整个培养期间始终存在。原代培养物经首次传代成功后即为细胞系(cell line)， 由原先存在于原代培养物中的细胞世系所组成。如果不能继续传代，或传代次数有限， 可称为有限细胞系(finite cell line)， 如可以连续培养， 则称为连续细胞系(continuous cell line)， 培养50代以上并无限培养下去。 所以细胞株是通过选择法或克隆形成法从原代培养物或细胞系中获得的具有特殊性质或标志的培养细胞。从培养代数来讲，可培养到40-50代。细胞株的特殊性质或标志必须在整个培养期间始终存在。对于人类肿瘤细胞，在体外培养半年以上，生长稳定，并连续传代的即可称为连续性株或系。</p></li><li><p>核酸酶：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能够将聚核苷酸链的磷酸二酯键切断的酶，称为核酸酶。 有些核酸酶只能作用于RNA，称为核糖核酸酶（RNase），有些核酸酶只能作用于DNA，称为脱氧核糖核酸酶（DNase），有些核酸酶专一性较低，既能作用于RNA也能作用于DNA，因此统称为核酸酶（nuclease）。根据核酸酶作用的位置不同，又可将核酸酶分为核酸外切酶（exonuclease）和核酸内切酶</p></li><li><p>逆转录病毒：<a href="https://www.zhihu.com/question/23745748" rel="external nofollow noopener noreferrer" target="_blank">病毒的分类</a></p></li><li><p><a href="https://www.zhihu.com/question/21112790" rel="external nofollow noopener noreferrer" target="_blank">DNA中的3’端和5’端</a></p></li><li><p>化学修饰：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凡通过化学基团的引入或除去，而使蛋白质或核酸共价结构发生改变的现象。它以引起酶分子共价键的变化、化学结构的改变而影响酶活性。酶的化学修饰是在另一种酶的催化下完成的，是体内快速调节的另一种重要方式。</p></li><li><p>正义链：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与转录出的mRNA序列相同的（DNA中的T在RNA中为U）那条DNA单链那条链为正义链，与之互补的为反义链。</p></li><li><p>PCR扩增产物：可分为长产物片段和短产物片段两部分。短产物指数倍增加，长产物算术倍增加，所以重复多次后，可以忽略长产物，得到的是目的基因。<br>反应体系由模板DNA、一对引物、dNTP、耐高温的DNA聚合酶、酶反应缓冲体系及必须的离子等所组成。PCR反应循环的第一步为加热变性，使双链模板DNA变性为单链；第二步为复性，每个引物将与互补的DNA序列杂交；第三步为延伸，在耐高温的DNA聚合酶作用下，以变性的单链DNA为模板，从引物3ˊ端开始按5ˊ→3ˊ方向合成DNA链。这样经过一个周期的变性——复性——延伸等三步反应就可以产生倍增的DNA，假设PCR的效率为100%,反复n周期后，理论上就能扩增2n倍。PCR反应一般30-40次循环，DNA片段可放大数百万倍。<br>见<a href="https://zhidao.baidu.com/question/345141221.html" rel="external nofollow noopener noreferrer" target="_blank">PCR的扩增产物是什么，怎么扩增出来的</a></p></li></ol><h3 id="基本单位"><a href="#基本单位" class="headerlink" title="基本单位"></a>基本单位</h3><ol><li><p>碱基(A，G，C，T，U)：<br>&nbsp;&nbsp;&nbsp;&nbsp;DNA有四种碱基对，即鸟嘌呤(G),腺嘌呤(A),胞嘧啶(C),胸腺嘧啶(T).其中G与C配对，A与T配对。RNA有A，G，C，U(尿嘧啶)这四种</p></li><li><p>bp：<br>&nbsp;&nbsp;&nbsp;&nbsp; 碱基对的数目单位,100bp即两条链上各有100个碱基.</p></li><li><p>nt：<br>&nbsp;&nbsp;&nbsp;&nbsp;核苷酸的单位，25nt RNA是指25个核苷酸碱基的小RNA</p></li></ol><h2 id="RNAi实验相关"><a href="#RNAi实验相关" class="headerlink" title="RNAi实验相关"></a>RNAi实验相关</h2><ol><li>四要素：<ul><li>目标基因的dsRNA，看需求</li><li>转染或者将dsRNA送入细胞的方法，具体看下面的三种方法</li><li>对照</li><li>检测表达情况的方法，即检验RNAi效果</li></ul></li><li>注意点<ul><li>siRNA长度的选择</li><li>shRNA表达水平太高会导致细胞毒性或脱靶，要防止过表达</li></ul></li><li>三种实现方法</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">适用类型</th><th style="text-align:center">导入材料</th><th style="text-align:center">过程</th><th style="text-align:center">其他材料</th><th style="text-align:center">沉默类型</th></tr></thead><tbody><tr><td style="text-align:center">非哺乳生物</td><td style="text-align:center">dsRNA</td><td style="text-align:center">导入dsRNA，使用Dicer酶切割dsRNA得到siRNAs，获得RISC诱导沉默复合体，切割靶mRNA</td><td style="text-align:center">Dicer酶</td><td style="text-align:center">瞬时基因沉默3-7天</td></tr><tr><td style="text-align:center">哺乳生物</td><td style="text-align:center">siRNAs</td><td style="text-align:center">直接导入siRNAs，获得RISC，切割靶mRNA</td><td style="text-align:center">无</td><td style="text-align:center">瞬时基因沉默3-7天</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">shRNA的DNA表达载体</td><td style="text-align:center">导入shRNA表达载体，使用Dicer酶切割shRNA，得到siRNAs，后续相同</td><td style="text-align:center">Dicer酶</td><td style="text-align:center">长效基因沉默</td></tr></tbody></table></div><h2 id="siRNA设计"><a href="#siRNA设计" class="headerlink" title="siRNA设计"></a>siRNA设计</h2><h3 id="结构和选择标准"><a href="#结构和选择标准" class="headerlink" title="结构和选择标准"></a>结构和选择标准</h3><ul><li>理想siRNA是23bp，双链部分是19bp，正义链和反义链为21bp，3‘端和5’端分别是两个突出核苷酸</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">5’端</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5…10</th><th style="text-align:center">11…14</th><th style="text-align:center">15…18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21…23</th><th style="text-align:center">3’端</th></tr></thead><tbody><tr><td style="text-align:center">理想状态</td><td style="text-align:center">第一个核苷酸对沉默作用非必须</td><td style="text-align:center">A</td><td style="text-align:center">A</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">T</td><td style="text-align:center">T</td><td style="text-align:center">UU/TT结尾，抵抗核糖核苷酸酶</td></tr><tr><td style="text-align:center">有效状态</td><td style="text-align:center"></td><td style="text-align:center">-</td><td style="text-align:center">A</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">T</td><td style="text-align:center">T</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">有效状态</td><td style="text-align:center"></td><td style="text-align:center">-</td><td style="text-align:center">A</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center"></td><td style="text-align:center">—</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">选择标准(正义链：3-23，21nt)</td><td style="text-align:center"></td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">5. 为A</td><td style="text-align:center">-</td><td style="text-align:center">6. 第十位为U</td><td style="text-align:center">8. 第13位非G</td><td style="text-align:center">2. 15-19位有3+个A/U碱基对</td><td style="text-align:center">4. 为A; 7.不能为G/C</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">/</td></tr></tbody></table></div><div class="note info"><p>正义链：3-23，一般TT结尾<br>反义链：1-21的互补链(A-T, C-G)，一般TT开头</p><p>反义RNA和靶RNA互补配对，参与基因表达调控。分3类：</p><ol><li>直接和靶mRNA的S-D序列或部分编码区结合，抑制翻译，或者结合成双链RNA被RNA酶Ⅲ降解</li><li>和非编码区结合，引起mRNA构象变化，抑制翻译</li><li>直接抑制mRNA转录</li></ol></div><p><strong>选择标准：</strong></p><ol><li>G/C含量=30～52%</li><li>在第15 ～19位核苷酸的位置个或更多的A/U碱基对（正义链）</li><li>发夹结构预测（没有内部重或回文结构）Tm&lt;20℃</li><li>19位核苷酸为A（正义链）</li><li>3位核苷酸为A（正义链）</li><li>10位核苷酸为U（正义链）</li><li>19位核苷酸不能为G或C（正义链）</li><li>13位核苷酸不能为G（正义链）</li></ol><p><strong>符合条件小于6个的舍弃</strong></p><div class="note danger"><ol><li>如果靶序列开始的两个核苷酸不是AA，选择基因编码区的23个核苷酸来计算G-C的百分含量</li><li>大多数G-C含量为30%-52%的siRNA产生的沉默效应较高，但过高的G-C含量会降低沉默活性</li><li>避免超过3个G/C重复，以及4个A重复，多G/C可能干扰siRNA沉默机制，多A会提前终止转录干扰shRNA合成<br>《小干扰RNA的合理设计》中，为2+个G/C降低RNA内在稳定性，3+个U/A可能终止RNA PolymeraseIII介导的转录</li><li>一定要从启动子第100个核苷酸之后开始搜索</li><li>3’-端可以是合适的靶序列，可特异性防止非必要保守基因的沉默</li></ol></div><h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>选择：</p><ol><li>在所选基因的启动子<code>100个</code>碱基以后开始自5’-端开始</li><li>寻找基因序列中的23个碱基， 最好是5‘- AA（N19）TT -3’ （N是任何碱基）</li><li>如果找不到以上AA（N19）TT，则用 AA（N21）补足。</li><li>如果找不到以上AA（N21）， 则用 NA（N21）补足。</li><li>所选定序列中，G和C的数目的总和在总数（23）的35-55%.</li><li>满足以上1-5项要求的片段数目如果不足四个，将G和C的数目的总和放宽至总数（23）的30-70%</li></ol><p>确定RNA oligo：</p><ol><li>找到正义链和反义链</li><li>将反义链从3‘-5’反转，变成5’-3’</li><li>将除了3‘末端的两个碱基外，所有的T改成U</li><li>使用BLAST确定唯一性</li></ol><div class="note"><p><strong>注意点：</strong></p><ul><li>GC含量为30-50% 的siRNA最有效</li><li>应选2-4个靶点序列</li></ul><p><strong>需排除的siRNA：</strong></p><ul><li>有4个T/A</li><li>基因组数据库比较，去除和其他序列有16-17同源碱基对的靶序列</li></ul></div><h3 id="设置对照"><a href="#设置对照" class="headerlink" title="设置对照"></a>设置对照</h3><p>所有的RNAi试验均应设立阴性对照，siRNA阴性对照序列的合理设计与siRNA序列的设计同样重要。<br>因为有效的对照可以充分证明siRNA只对靶基因产生特异性基因沉默，从而增强实验的可信度。<br>阴性对照siRNA包括碱基错配或混乱序列的siRNA。<br>在实验中最好设计两条siRNA对照序列</p><p>注：<br>多碱基错配比单碱基错配的siRNA阴性对照序列具有更高的实际应用价值</p><p>设置对照：</p><ul><li>阴性对照siRNA：1）打乱原siRNA核苷酸顺序，且和靶mRNA无同源性; 2）碱基错配</li><li>针对相同基因的其他siRNA：确保siRNA数据可靠的最佳方式</li></ul><h3 id="Tuschl法则"><a href="#Tuschl法则" class="headerlink" title="Tuschl法则"></a>Tuschl法则</h3><p>原始法则：</p><ul><li>21bp + 3’两个碱基，最有效</li></ul><p>新法则：</p><ul><li><p>NA -（A/G）-（N17）-（C/U）- NN<br>正义链和反义链（21nt）siRNA应该以嘌呤核苷酸(A)开头，这对于多聚酶Ⅲ启动子的表达是必须的。</p></li><li><p>（N4）- A -（N6）- T -（N2）-（A/T/C）-（N5）-（A）-（N2）</p></li></ul><h2 id="构建shRNA表达载体"><a href="#构建shRNA表达载体" class="headerlink" title="构建shRNA表达载体"></a>构建shRNA表达载体</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>有抗生素标记，可建立稳定的长期基因沉默细胞株，并筛选细胞</li><li>通过病毒插入基因组得到稳定的基因沉默表达细胞株</li></ol><h3 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h3><h4 id="shRNA序列设计"><a href="#shRNA序列设计" class="headerlink" title="shRNA序列设计"></a>shRNA序列设计</h4><p>shRNA 由 siRNA 和环状连接序列组成。<br>就是目标 siRNA 与其反向互补序列之间由特定的连接序列间隔，得到的 RNA 两端反向互补退火，与连接序列形成茎环结构，类似发夹。</p><h4 id="启动子选择"><a href="#启动子选择" class="headerlink" title="启动子选择"></a>启动子选择</h4><p>多数siRNA表达载体依赖三种RNA聚合酶III 启动子(pol III)中的一种，操纵一段小的发夹RNA在哺乳动物细胞中的表达，包括U6和H1。<br>因为它可以在哺乳动物细胞中表达更多小分子RNA</p><ol><li>表达产量取决于启动子强弱</li><li>U6>H1，表达时间长，首选，但shRNA要避免3+个U/A，防提前转录</li><li>RNA 聚合酶 II 类的启动子如CMV 启动子和 U1 启动子也比较常见</li><li>shRNA 序列有连续的 U / T 时应该优先考虑 CMV 启动子载体</li></ol><h4 id="载体类型选择"><a href="#载体类型选择" class="headerlink" title="载体类型选择"></a>载体类型选择</h4><ol><li>质粒载体</li><li>病毒表达载体：感染细胞效率高<br>常用的，哺乳动物细胞,病毒载体包括：<br>&nbsp;&nbsp;&nbsp;&nbsp;逆转录病毒(Retrovirus)，腺病毒(Adenovirus)，腺相关病毒(Adeno-Associated Virus,AAV)，和慢病毒(Lentivirus)。<br>其中逆转录病毒和慢病毒等载体，还可以用于构建，整合到染色体上的,稳定的,长期基因沉默细胞株</li></ol><p>具体见<a href="https://www.zhihu.com/question/23745748" rel="external nofollow noopener noreferrer" target="_blank">病毒的分类</a><br>研究长期基因沉默，选择逆转录病毒，逆转录病毒也是逆转录类型</p><h4 id="抗生素筛选标记"><a href="#抗生素筛选标记" class="headerlink" title="抗生素筛选标记"></a>抗生素筛选标记</h4><p>最好选一个抗性标记</p><ol><li>非必选，但是可以得到稳定表达shRNA的细胞株，且可检测是否转染</li><li>促进shRNA表达，防止表达减弱影响沉默效果</li></ol><h4 id="构建、克隆和测序验证"><a href="#构建、克隆和测序验证" class="headerlink" title="构建、克隆和测序验证"></a>构建、克隆和测序验证</h4><h2 id="结果评测"><a href="#结果评测" class="headerlink" title="结果评测"></a>结果评测</h2><p>通常从两方面检测，首先是检测mRNA的表达，其次是蛋白表达。如果是移植到小鼠或其他载体上，可以再使用生物学方法检测效果。</p><h3 id="mRNA的表达"><a href="#mRNA的表达" class="headerlink" title="mRNA的表达"></a>mRNA的表达</h3><h4 id="RT-PCR"><a href="#RT-PCR" class="headerlink" title="RT-PCR"></a>RT-PCR</h4><p>最常见的是在转染后24-48小时做定量RT-PCR（逆转录PCR）</p><ol><li>纯化细胞</li><li>选取合适的RNA提取试剂盒和银光RT-PCR试剂盒</li><li>提取RNA，进行扩增</li><li>进行RT-PCR检测，按照说明书操作，配置反应体系，于PCR仪扩增实验</li><li>观察结果</li></ol><h4 id="Northern-blot杂交"><a href="#Northern-blot杂交" class="headerlink" title="Northern blot杂交"></a>Northern blot杂交</h4><img src="/Notes/2019-10-01-basic-knowledge-of-RNAi/1.png" title="肿瘤转移抑制基因 KAil 不同转移潜能癌细胞中的表达"><h4 id="原位杂交"><a href="#原位杂交" class="headerlink" title="原位杂交"></a>原位杂交</h4><p>它即可检测 mRNA 的表达，又可观察 mRNA 的定位，是研究细胞内基因表达及有关因素调控的有效工具Northern blot 分析和 RT-PCR 两种方法只用于检测某 特定的 RNA 片段，它们都只能证明细胞或组织中是否存在待测的核酸而不能证明核酸分子在细胞或组织中存在的部位，不具有定位性，也不能反映组织、细胞、器官的差异</p><h3 id="蛋白水平检测"><a href="#蛋白水平检测" class="headerlink" title="蛋白水平检测"></a>蛋白水平检测</h3><h4 id="免疫组化法-immunohistochemistry"><a href="#免疫组化法-immunohistochemistry" class="headerlink" title="免疫组化法(immunohistochemistry)"></a>免疫组化法(immunohistochemistry)</h4><ul><li><strong>原理：</strong>免疫组化，免疫组化，是应用免疫学基本原理——抗原抗体反应，即抗原与抗体特异性结合的原理，通过化学反应使标记抗体的显色剂（荧光素、酶、金属离子、同位素）显色来确定组织细胞内抗原（多肽和蛋白质），对其进行定位、定性及定量的研究，称为免疫组织化学技术(immunohistochemistry)或免疫细胞化学技术(immunocytochemistry)。</li><li><strong>特点：</strong>是融合了免疫学原理（抗原抗体特异性结合）和组织学技术（组织的取材、固定、包埋、切片、脱蜡、水化等），通过化学反应使标记抗体的显色剂(荧光素、酶、金属离子、同位素)显色，来对组织（细胞）内抗原进行定位、定性及定量的研究(主要是定位)。样本是细胞或组织，要在显微镜下观察结果，可能出现膜阳性、质阳性和核阳性。</li></ul><h4 id="蛋白免疫印迹-Western-Blot"><a href="#蛋白免疫印迹-Western-Blot" class="headerlink" title="蛋白免疫印迹( Western Blot)"></a>蛋白免疫印迹( Western Blot)</h4><ul><li><strong>原理：</strong>蛋白质印迹法是将电泳分离后的细胞或组织总蛋白质从凝胶转移到固相支持物NC膜或PVDF膜上，然后用特异性抗体检测某特定抗原的一种蛋白质检测技术。</li><li><strong>特点：</strong>先要进行SDS-PAGE，然后将分离开的蛋白质样品用电转仪转移到固相载体上，而后利用抗原-抗体-标记物显色来检测样品，可以用于定性和半定量。</li></ul><h4 id="ELISA检测"><a href="#ELISA检测" class="headerlink" title="ELISA检测"></a>ELISA检测</h4><ul><li><strong>原理：</strong>酶联免疫吸附剂测定法，简称酶联免疫法，或者ELISA法，它的中心就是让抗体与酶复合物结合，然后通过显色来检测。</li><li><strong>特点：</strong>用到了免疫学原理和化学反应显色，待测的样品多是血清、血浆、尿液、细胞或组织培养上清液，因而没有用到组织包埋、切片等技术，这是与免疫组化的主要区别，操作上 开始需要将抗原或抗体结合到固相载体表面，从而使后来形成的抗原-抗体-酶-底物复合物粘附在载体上，这就是“吸附”的含义。</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>具体的还是参看<a href="https://wenku.baidu.com/view/67f81ad7d4bbfd0a79563c1ec5da50e2524dd102.html" rel="external nofollow noopener noreferrer" target="_blank">蛋白表达不同检测表达方式的比较和分析</a><br><img src="/Notes/2019-10-01-basic-knowledge-of-RNAi/2.png" title="蛋白表达不同检测表达方式的比较和分析"></p><h2 id="miRNA"><a href="#miRNA" class="headerlink" title="miRNA"></a>miRNA</h2><p>RNAi的重要工具</p><p>这种内源性的非编码区小分子 RNA 针对 3’端非编码区，有着极高的保守性，并在组织中广泛表达，可在转录后以及翻译水平上调控基因表达，可能在不影响 mRNA 的水平下调控基因表达</p><p><strong>和siRNA区别：</strong></p><ul><li>内源而非外源序列</li><li>针对非编码区</li><li>物种进化极为高度保守</li><li>组织中广泛表达</li><li>miRNA 可能调控多种关键基因</li><li>可在转录后以及翻译水平上调控基因表达，可能在不影响 mRNA 的水平下调控基因表达</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="《小干扰RNA的合理设计》总结"><a href="#《小干扰RNA的合理设计》总结" class="headerlink" title="《小干扰RNA的合理设计》总结"></a>《小干扰RNA的合理设计》总结</h3><ul><li>RNAi主要是要通过siRNA和靶基因结合并使之降解，所以siRNA要和靶基因高度同源，但是不和其他基因同源。</li><li>搜索siRNA时，靠近基因的3‘端的比较好</li><li>有研究表明，5’UTR是一个高保守区，使之成为siRNA理想的靶点，RNAi作用于5‘UTR或3’UTR序列，也可以引起靶基因沉默</li><li>27nt或者29nt的siRNA效果更好，27nt或29nt的siRNA与21ntsiRNA相比：<blockquote><p>(1)其抑制活性可提高数倍以上；<br>(2)不易于诱导干扰素反应和激活PKR；<br>(3)一些基因对21ntsiRNA不敏感，但是可以被27ntsiRNA有效的抑制；<br>(4)与21ntSiRNA相比，27ntSiRNA对靶基因的最大抑制率可在相对低的浓度下得到</p></blockquote></li><li>每一个靶基因，应该设计4+条siRNA</li><li>只能根据标准设计出理论较高沉默效应的siRNA，最终活性要用实验验证</li><li>关于shRNA的发夹环长度，3-10nt都可以，Brummelkamp研究表明9nt的抑制率高，Siolas表明长度没有明显影响</li><li>每个RNAi实验都要设置阴性对照。具体见上文</li></ul><h3 id="《高效siRNA的设计分析》总结"><a href="#《高效siRNA的设计分析》总结" class="headerlink" title="《高效siRNA的设计分析》总结"></a>《高效siRNA的设计分析》总结</h3><ol><li>RNAi实验一般流程如下：<ul><li>准备材料，包括目标基因，shRNA表达载体，限制性核酸内切酶等</li><li>siRNA的设计和筛选</li><li>重组表达载体的构建</li><li>含靶基因的细胞的分离培养和转染</li><li>RT-PCR的检测和靶基因的表达</li><li>分析结果并总结</li></ul></li><li>一些结论<ul><li>和siRNA结合的<script type="math/tex">AG0_2</script>蛋白主要识别5‘端为A的siRNA，因此5’端为A的siRNA对其进入RISC复合体及对靶mRNA的识别具有关键作用</li><li>正义链5’端具有更多的G/C对siRNA的功能提高非常重要，第19位为G/C也更具有RNAi活力</li><li>反义链的第19位G/C真的对siRNA的高功能性存在相关性有待验证</li><li>高效的siRNA反义链的第13位优先为 A／U，即不为G/C</li><li>反义链第10位为 U 作用强于A，优先考虑</li><li>综合考虑反义链第3,7,14,16,17位还是有必要的</li><li>对zfy基因来说，siRNA靶点在1000bp以内，即第3-6外显子上设计高效siRNA的可能性更大，最好位于150bp-800bp</li></ul></li><li>这个论文主要是记录了一整个siRNA实验以及分析过程，可以作为以后siRNA实验的参考</li></ol><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ol><li><a href="http://dict.bioon.com/" rel="external nofollow noopener noreferrer" target="_blank">生物医药大词典</a></li><li><a href="http://www.labome.cn/method/siRNAs-and-shRNAs-Tools-for-Protein-Knockdown-by-Gene-Silencing.html" rel="external nofollow noopener noreferrer" target="_blank">siRNA和shRNA:通过基因沉默抑制蛋白表达的工具</a></li><li><a href="https://wenku.baidu.com/view/b3571b7c192e45361066f5ca.html" rel="external nofollow noopener noreferrer" target="_blank">Argonaute蛋白结构与功能</a></li><li><a href="http://www.televector.com/9171223659.pdf" rel="external nofollow noopener noreferrer" target="_blank">张美红，周克元.小干扰RNA的合理设计[J].肿瘤防治研究，2006， 33（11）：837-839</a></li><li><a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2017&amp;filename=HLJX201701028" rel="external nofollow noopener noreferrer" target="_blank">秦炳燕，张永生，纪俊明等.高效siRNA的设计分析[B].黑龙江畜牧兽医，2017（1）：109-113，294</a></li><li><a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2017&amp;filename=1017152231.nh" rel="external nofollow noopener noreferrer" target="_blank">韩烨.基于机器学习的siRNA沉默效率预测方法研究[D].吉林省：吉林大学，2019</a></li><li><a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CAPJ&amp;dbname=CAPJLAST&amp;filename=SDYB20190926000" rel="external nofollow noopener noreferrer" target="_blank">薛婷，王黎明，焦今文等.siRNA介导RRM2基因沉默治疗人卵巢癌裸鼠移植瘤[J].山东大学学报，2019，57（10）</a></li><li><a href="http://kns.cnki.net/KCMS/detail/detail.aspx?dbname=cjfd2000&amp;filename=hnyk200002007" rel="external nofollow noopener noreferrer" target="_blank">李珊珊,任秀花,闫爱华,方伟岗.3种mRNA检测方法比较[J].河南医科大学学报，2000，35（2）：113-114</a></li><li><a href="https://wenku.baidu.com/view/67f81ad7d4bbfd0a79563c1ec5da50e2524dd102.html" rel="external nofollow noopener noreferrer" target="_blank">蛋白表达不同检测表达方式的比较和分析</a></li><li><a href="http://kns.cnki.net//KXReader/Detail?TIMESTAMP=637062394829091250&amp;DBCODE=CJFD&amp;TABLEName=CJFD9899&amp;FileName=ZHYX199909026&amp;RESULT=1&amp;SIGN=kvPorAe14Lw3IYsBq017HIfdCF4%3d" rel="external nofollow noopener noreferrer" target="_blank">李珊珊，方伟岗，钟销销，等 肿瘤转移抑制基因 KAil 不同转移潜能癌细胞中的表达．中华医学杂志，1999,(9): 708</a></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;刚接触siRNA搜索、设计和评测这方面的研究，记录一下基本的概念和一些基础知识，还有自己的理解总结。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://hanielxx.com/categories/Notes/"/>
    
    
      <category term="RNAi" scheme="https://hanielxx.com/tags/RNAi/"/>
    
      <category term="siRNA" scheme="https://hanielxx.com/tags/siRNA/"/>
    
      <category term="Note" scheme="https://hanielxx.com/tags/Note/"/>
    
      <category term="Basic" scheme="https://hanielxx.com/tags/Basic/"/>
    
      <category term="Summary" scheme="https://hanielxx.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>NowCoder-谁是你的潜在朋友</title>
    <link href="https://hanielxx.com/NowCoder/2019-09-22-who-is-your-friend.html"/>
    <id>https://hanielxx.com/NowCoder/2019-09-22-who-is-your-friend.html</id>
    <published>2019-09-22T06:03:58.000Z</published>
    <updated>2020-07-15T02:01:02.059Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://www.nowcoder.com/practice/0177394fb25b42b48657bc2b1c6f9fcc?tpId=40&amp;tqId=21360&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>“臭味相投”——这是我们描述朋友时喜欢用的词汇。两个人是朋友通常意味着他们存在着许多共同的兴趣。然而作为一个宅男，你发现自己与他人相互了解的机会并不太多。幸运的是，你意外得到了一份北大图书馆的图书借阅记录，于是你挑灯熬夜地编程，想从中发现潜在的朋友。</p><p>首先你对借阅记录进行了一番整理，把N个读者依次编号为1,2,…,N，把M本书依次编号为1,2,…,M。同时，按照“臭味相投”的原则，和你喜欢读同一本书的人，就是你的潜在朋友。你现在的任务是从这份借阅记录中计算出每个人有几个潜在朋友。</p><p>每个案例第一行两个整数N,M，2 &lt;= N ，M&lt;= 200。接下来有N行，第i(i = 1,2,…,N)行每一行有一个数，表示读者i-1最喜欢的图书的编号P(1&lt;=P&lt;=M)</p><p>每个案例包括N行，每行一个数，第i行的数表示读者i有几个潜在朋友。如果i和任何人都没有共同喜欢的书，则输出“BeiJu”（即悲剧，^ ^）</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>4 5<br>2<br>3<br>2<br>1</p></blockquote><p><strong>Output:</strong></p><blockquote><p>1<br>BeiJu<br>1<br>BeiJu</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>用二维数组表示对应关系，遍历每本书的喜欢的人，就是潜在朋友</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N,M;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; mp(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; friends(N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;p;</span><br><span class="line">      mp[i][p]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        <span class="keyword">if</span>(mp[j][i]==<span class="number">1</span>) </span><br><span class="line">          tmp.push_back(j);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tmp.size();k++) friends[tmp[k]]=tmp.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(friends[i]==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"BeiJu"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;friends[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/0177394fb25b42b48657bc2b1c6f9fcc?tpId=40&amp;amp;tqId=21360&amp;amp;tPage=2&amp;amp;rp=1&amp;amp;ru=%2Fta%2Fkaoyan&amp;amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;“臭味相投”——这是我们描述朋友时喜欢用的词汇。两个人是朋友通常意味着他们存在着许多共同的兴趣。然而作为一个宅男，你发现自己与他人相互了解的机会并不太多。幸运的是，你意外得到了一份北大图书馆的图书借阅记录，于是你挑灯熬夜地编程，想从中发现潜在的朋友。&lt;/p&gt;&lt;p&gt;首先你对借阅记录进行了一番整理，把N个读者依次编号为1,2,…,N，把M本书依次编号为1,2,…,M。同时，按照“臭味相投”的原则，和你喜欢读同一本书的人，就是你的潜在朋友。你现在的任务是从这份借阅记录中计算出每个人有几个潜在朋友。&lt;/p&gt;&lt;p&gt;每个案例第一行两个整数N,M，2 &amp;lt;= N ，M&amp;lt;= 200。接下来有N行，第i(i = 1,2,…,N)行每一行有一个数，表示读者i-1最喜欢的图书的编号P(1&amp;lt;=P&amp;lt;=M)&lt;/p&gt;&lt;p&gt;每个案例包括N行，每行一个数，第i行的数表示读者i有几个潜在朋友。如果i和任何人都没有共同喜欢的书，则输出“BeiJu”（即悲剧，^ ^）&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;4 5&lt;br&gt;2&lt;br&gt;3&lt;br&gt;2&lt;br&gt;1&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;1&lt;br&gt;BeiJu&lt;br&gt;1&lt;br&gt;BeiJu&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="NowCoder" scheme="https://hanielxx.com/categories/NowCoder/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
      <category term="Array" scheme="https://hanielxx.com/tags/Array/"/>
    
      <category term="NowCoder" scheme="https://hanielxx.com/tags/NowCoder/"/>
    
  </entry>
  
  <entry>
    <title>NowCoder-IWannaGoHome</title>
    <link href="https://hanielxx.com/NowCoder/2019-09-22-I-Wanna-Go-Home.html"/>
    <id>https://hanielxx.com/NowCoder/2019-09-22-I-Wanna-Go-Home.html</id>
    <published>2019-09-22T05:19:10.000Z</published>
    <updated>2020-07-15T02:01:02.059Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://www.nowcoder.com/practice/0160bab3ce5d4ae0bb99dc605601e971?tpId=40&amp;tqId=21359&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>补之前的</p><p>The country is facing a terrible civil war——cities in the country are divided into two parts supporting different leaders. As a merchant, Mr. M does not pay attention to politics but he actually knows the severe situation, and your task is to help him reach home as soon as possible. “For the sake of safety,”, said Mr.M, “your route should contain at most 1 road which connects two cities of different camp.” Would you please tell Mr. M at least how long will it take to reach his sweet home?</p><p>The input contains multiple test cases.</p><p>The first line of each case is an integer N (2&lt;=N&lt;=600), representing the number of cities in the country.<br>The second line contains one integer M (0&lt;=M&lt;=10000), which is the number of roads.</p><p>The following M lines are the information of the roads. Each line contains three integers A, B and T, which means the road between city A and city B will cost time T. T is in the range of [1,500].</p><p>Next part contains N integers, which are either 1 or 2. The i-th integer shows the supporting leader of city i.</p><p>To simplify the problem, we assume that Mr. M starts from city 1 and his target is city 2. City 1 always supports leader 1 while city 2 is at the same side of leader 2.</p><p>Note that all roads are bidirectional and there is at most 1 road between two cities.</p><p>Input is ended with a case of N=0.</p><p>For each test case, output one integer representing the minimum time to reach home.</p><p>If it is impossible to reach home according to Mr. M’s demands, output -1 instead.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>2<br>1<br>1 2 100<br>1 2<br>3<br>3<br>1 2 100<br>1 3 40<br>2 3 50<br>1 2 1<br>5<br>5<br>3 1 200<br>5 3 150<br>2 5 160<br>4 3 170<br>4 2 170<br>1 2 2 2 1<br>0</p></blockquote><p><strong>Output:</strong></p><blockquote><p>100<br>90<br>540</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>单源最短路径问题，计算两次最短路，分别是计算阵营1里各点最短路径，和阵营2里各点最短路径，然后再遍历边界线上联通两个阵营的边，看哪个最短</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 601</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> G[N][N];    <span class="comment">//城市间的距离，用时间表示</span></span><br><span class="line"><span class="keyword">int</span> camp[N];    <span class="comment">//各个城市的阵营</span></span><br><span class="line"><span class="keyword">int</span> n[<span class="number">3</span>];       <span class="comment">//n[0]: 城市数量; n[1]、n[2]: 两个阵营各自的城市数量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//两个数相加</span></span><br><span class="line">    <span class="keyword">if</span>(a==INT_MAX||b==INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//三个数相加</span></span><br><span class="line">    <span class="keyword">if</span>(a==INT_MAX||b==INT_MAX||c==INT_MAX)  <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> d1[N], d2[N];       <span class="comment">//分别存储1、2到同阵营各点最小距离</span></span><br><span class="line"><span class="keyword">bool</span> mark[N];           <span class="comment">//标记点是否在集合里面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> d[N], <span class="keyword">int</span> from)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//dijkstra算法求某点到同阵营各点的最小距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n[<span class="number">0</span>]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不是同阵营的先塞进集合里面</span></span><br><span class="line">        <span class="keyword">if</span>(camp[i]==from) mark[i]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> mark[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把起点塞进集合</span></span><br><span class="line">    mark[from]=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//初始化d[N]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n[<span class="number">0</span>]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(camp[i]==from) d[i]=G[from][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把同阵营的点全都塞进集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n[camp[from]]<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> isFirst=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> near;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//挑一个d[?]最小的，下标为near</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n[<span class="number">0</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mark[i]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isFirst)</span><br><span class="line">                &#123;</span><br><span class="line">                    near=i;</span><br><span class="line">                    isFirst=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(d[i]&lt;d[near]) near=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mark[near]=<span class="literal">true</span>;        </span><br><span class="line">        <span class="comment">//更新同阵营的点的d[i]信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n[<span class="number">0</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(camp[i]==from&amp;&amp;mark[i]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum=Add(d[near], G[near][i]);</span><br><span class="line">                <span class="keyword">if</span>(sum&lt;d[i]) d[i]=sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n[<span class="number">0</span>])!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n[<span class="number">0</span>]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n[<span class="number">0</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=n[<span class="number">0</span>]; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) G[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> G[i][j]=INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取边</span></span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, t;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;t);</span><br><span class="line">            <span class="keyword">if</span>(t&lt;G[a][b]) G[a][b]=G[b][a]=t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n[<span class="number">1</span>]=n[<span class="number">2</span>]=<span class="number">0</span>;                <span class="comment">//两个阵营暂时都没城市</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n[<span class="number">0</span>]; i++)  <span class="comment">//读取阵营信息</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;camp[i]);</span><br><span class="line">            n[camp[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Dijkstra(d1, <span class="number">1</span>);            <span class="comment">//求出1到同阵营各点的最小距离</span></span><br><span class="line">        Dijkstra(d2, <span class="number">2</span>);            <span class="comment">//求出2到同阵营各点的最小距离</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans=INT_MAX;            <span class="comment">//先假设最小距离是无穷大</span></span><br><span class="line">        <span class="comment">//开始找穿越边境的路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n[<span class="number">0</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n[<span class="number">0</span>]; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//i是1阵营j是2阵营的话</span></span><br><span class="line">                <span class="keyword">if</span>(camp[i]==<span class="number">1</span>&amp;&amp;camp[j]==<span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//看看从这条路过境是否更划算</span></span><br><span class="line">                    <span class="keyword">int</span> sum=Add3(d1[i], d2[j], G[i][j]);</span><br><span class="line">                    <span class="keyword">if</span>(sum&lt;ans) ans=sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(camp[i]==<span class="number">2</span>&amp;&amp;camp[j]==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=Add3(d2[i], d1[j], G[i][j]);</span><br><span class="line">                    <span class="keyword">if</span>(sum&lt;ans) ans=sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        <span class="comment">//最短总耗时是无穷，说明无路可走</span></span><br><span class="line">        <span class="keyword">if</span>(ans!=INT_MAX) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>不是模板题，需要注意下两个阵营不能一起使用dijkstra，而是应该分阵营计算好，然后加上边界的值，得到最短路劲</li><li>dijkstra主要是两个for循环，最短路径，每次找距离源点最近的点加进去，维护的dis数组也是距离源点的数组</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/0160bab3ce5d4ae0bb99dc605601e971?tpId=40&amp;amp;tqId=21359&amp;amp;tPage=2&amp;amp;rp=1&amp;amp;ru=%2Fta%2Fkaoyan&amp;amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;补之前的&lt;/p&gt;&lt;p&gt;The country is facing a terrible civil war——cities in the country are divided into two parts supporting different leaders. As a merchant, Mr. M does not pay attention to politics but he actually knows the severe situation, and your task is to help him reach home as soon as possible. “For the sake of safety,”, said Mr.M, “your route should contain at most 1 road which connects two cities of different camp.” Would you please tell Mr. M at least how long will it take to reach his sweet home?&lt;/p&gt;&lt;p&gt;The input contains multiple test cases.&lt;/p&gt;&lt;p&gt;The first line of each case is an integer N (2&amp;lt;=N&amp;lt;=600), representing the number of cities in the country.&lt;br&gt;The second line contains one integer M (0&amp;lt;=M&amp;lt;=10000), which is the number of roads.&lt;/p&gt;&lt;p&gt;The following M lines are the information of the roads. Each line contains three integers A, B and T, which means the road between city A and city B will cost time T. T is in the range of [1,500].&lt;/p&gt;&lt;p&gt;Next part contains N integers, which are either 1 or 2. The i-th integer shows the supporting leader of city i.&lt;/p&gt;&lt;p&gt;To simplify the problem, we assume that Mr. M starts from city 1 and his target is city 2. City 1 always supports leader 1 while city 2 is at the same side of leader 2.&lt;/p&gt;&lt;p&gt;Note that all roads are bidirectional and there is at most 1 road between two cities.&lt;/p&gt;&lt;p&gt;Input is ended with a case of N=0.&lt;/p&gt;&lt;p&gt;For each test case, output one integer representing the minimum time to reach home.&lt;/p&gt;&lt;p&gt;If it is impossible to reach home according to Mr. M’s demands, output -1 instead.&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;2&lt;br&gt;1&lt;br&gt;1 2 100&lt;br&gt;1 2&lt;br&gt;3&lt;br&gt;3&lt;br&gt;1 2 100&lt;br&gt;1 3 40&lt;br&gt;2 3 50&lt;br&gt;1 2 1&lt;br&gt;5&lt;br&gt;5&lt;br&gt;3 1 200&lt;br&gt;5 3 150&lt;br&gt;2 5 160&lt;br&gt;4 3 170&lt;br&gt;4 2 170&lt;br&gt;1 2 2 2 1&lt;br&gt;0&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;100&lt;br&gt;90&lt;br&gt;540&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="NowCoder" scheme="https://hanielxx.com/categories/NowCoder/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="Hard" scheme="https://hanielxx.com/tags/Hard/"/>
    
      <category term="NowCoder" scheme="https://hanielxx.com/tags/NowCoder/"/>
    
      <category term="Graph" scheme="https://hanielxx.com/tags/Graph/"/>
    
      <category term="Dijkstra" scheme="https://hanielxx.com/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>NowCoder-查找学生信息</title>
    <link href="https://hanielxx.com/NowCoder/2019-09-22-find-information-of-stu.html"/>
    <id>https://hanielxx.com/NowCoder/2019-09-22-find-information-of-stu.html</id>
    <published>2019-09-22T05:16:09.000Z</published>
    <updated>2020-07-15T02:01:02.059Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://www.nowcoder.com/practice/fe8bff0750c8448081759f3ee0d86bb4?tpId=40&amp;tqId=21358&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>补之前的</p><p>输入N个学生的信息，然后进行查询。</p><p>输入描述:<br>输入的第一行为N，即学生的个数(N&lt;=1000)<br>接下来的N行包括N个学生的信息，信息格式如下：<br>01 李江 男 21<br>02 刘唐 男 23<br>03 张军 男 19<br>04 王娜 女 19<br>然后输入一个M(M&lt;=10000),接下来会有M行，代表M次查询，每行输入一个学号，格式如下：<br>02<br>03<br>01<br>04</p><p>输出M行，每行包括一个对应于查询的学生的信息。<br>如果没有对应的学生信息，则输出“No Answer!”</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>4<br>01 李江 男 21<br>02 刘唐 男 23<br>03 张军 男 19<br>04 王娜 女 19<br>5<br>02<br>03<br>01<br>04<br>03</p></blockquote><p><strong>Output:</strong></p><blockquote><p>02 刘唐 男 23<br>03 张军 男 19<br>01 李江 男 21<br>04 王娜 女 19<br>03 张军 男 19</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>使用结构体保存每个学生信息，然后找学号，找到就输出，找不到就No Answer</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st</span>&#123;</span></span><br><span class="line">    st(<span class="built_in">string</span> sid=<span class="string">"0"</span>, <span class="built_in">string</span> sname=<span class="string">""</span>, <span class="built_in">string</span> ssex=<span class="string">"男"</span>, <span class="keyword">int</span> sage=<span class="number">0</span>):id(sid), name(sname),sex(ssex),age(sage) &#123;&#125;;</span><br><span class="line">    <span class="built_in">string</span> id;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;st&gt; stu(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;stu[i].id&gt;&gt;stu[i].name&gt;&gt;stu[i].sex&gt;&gt;stu[i].age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;M;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> target;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;target;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stu[j].id==target)&#123;</span><br><span class="line">                    pos=j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos!=<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;stu[pos].id&lt;&lt;<span class="string">" "</span>&lt;&lt;stu[pos].name&lt;&lt;<span class="string">" "</span>&lt;&lt;stu[pos].sex&lt;&lt;<span class="string">" "</span>&lt;&lt;stu[pos].age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No Answer!\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/fe8bff0750c8448081759f3ee0d86bb4?tpId=40&amp;amp;tqId=21358&amp;amp;tPage=2&amp;amp;rp=1&amp;amp;ru=%2Fta%2Fkaoyan&amp;amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;补之前的&lt;/p&gt;&lt;p&gt;输入N个学生的信息，然后进行查询。&lt;/p&gt;&lt;p&gt;输入描述:&lt;br&gt;输入的第一行为N，即学生的个数(N&amp;lt;=1000)&lt;br&gt;接下来的N行包括N个学生的信息，信息格式如下：&lt;br&gt;01 李江 男 21&lt;br&gt;02 刘唐 男 23&lt;br&gt;03 张军 男 19&lt;br&gt;04 王娜 女 19&lt;br&gt;然后输入一个M(M&amp;lt;=10000),接下来会有M行，代表M次查询，每行输入一个学号，格式如下：&lt;br&gt;02&lt;br&gt;03&lt;br&gt;01&lt;br&gt;04&lt;/p&gt;&lt;p&gt;输出M行，每行包括一个对应于查询的学生的信息。&lt;br&gt;如果没有对应的学生信息，则输出“No Answer!”&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;4&lt;br&gt;01 李江 男 21&lt;br&gt;02 刘唐 男 23&lt;br&gt;03 张军 男 19&lt;br&gt;04 王娜 女 19&lt;br&gt;5&lt;br&gt;02&lt;br&gt;03&lt;br&gt;01&lt;br&gt;04&lt;br&gt;03&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;02 刘唐 男 23&lt;br&gt;03 张军 男 19&lt;br&gt;01 李江 男 21&lt;br&gt;04 王娜 女 19&lt;br&gt;03 张军 男 19&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="NowCoder" scheme="https://hanielxx.com/categories/NowCoder/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
      <category term="Search" scheme="https://hanielxx.com/tags/Search/"/>
    
      <category term="NowCoder" scheme="https://hanielxx.com/tags/NowCoder/"/>
    
      <category term="Struct" scheme="https://hanielxx.com/tags/Struct/"/>
    
  </entry>
  
  <entry>
    <title>NowCoder-10进制和2进制</title>
    <link href="https://hanielxx.com/NowCoder/2019-09-22-dec-vs-bin.html"/>
    <id>https://hanielxx.com/NowCoder/2019-09-22-dec-vs-bin.html</id>
    <published>2019-09-22T04:05:17.000Z</published>
    <updated>2020-07-15T02:01:02.059Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://www.nowcoder.com/practice/fd972d5d5cf04dd4bb4e5f027d4fc11e?tpId=40&amp;tqId=21357&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>补之前的</p><p>对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们乘B为A的二进制逆序数。 例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。</p><p>输入一个1000位(即10^999)以内的十进制数。<br>输出十进制的二进制逆序数</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>173</p></blockquote><p><strong>Output:</strong></p><blockquote><p>181</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>顺序很清楚，先转换成二进制，然后逆序，然后转换成十进制</li><li>可以写一个通用的进制转换函数</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 进制转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//进制转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">char</span>* original, <span class="keyword">int</span> n, <span class="keyword">char</span>* conversion)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(original),i,j,carry,k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//i是最高位，从最高位开始将每一位除以2，将余数传递给下一位</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len;)&#123;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这一块，数字和字符的处理没搞清楚,其中carry是参与运算的，应该作为数字。</span></span><br><span class="line">        <span class="comment">//而original[j]则是保存当前的运算结果，应该是字符型的</span></span><br><span class="line">        <span class="comment">//本质是模拟除法运算,类比手写的进制转换</span></span><br><span class="line">        <span class="keyword">for</span>(j = i; j &lt; len; j++)&#123; </span><br><span class="line">            original[j] = original[j] - <span class="string">'0'</span> + carry*m;</span><br><span class="line">            carry = (original[j]) % n ;</span><br><span class="line">            original[j] = (original[j]) / n + <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后的余数</span></span><br><span class="line">        conversion[k++] =(<span class="keyword">char</span>) (carry + <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//精髓，在大进制转小进制时，</span></span><br><span class="line">        <span class="comment">//当前的最高位orignal[i]可能无法循环一次就变成0</span></span><br><span class="line">        <span class="comment">//小进制转大进制最高位可能一次循环就</span></span><br><span class="line">        <span class="comment">//使得高几级位变成0</span></span><br><span class="line">        <span class="keyword">while</span>(original[i] == <span class="string">'0'</span>)i++; </span><br><span class="line">    &#125;</span><br><span class="line">    conversion[k] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> dec[<span class="number">1001</span>],bin[<span class="number">4000</span>];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,dec) != EOF)&#123;</span><br><span class="line">        convert(<span class="number">10</span>,dec,<span class="number">2</span>,bin);</span><br><span class="line">        convert(<span class="number">2</span>,bin,<span class="number">10</span>,dec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串反序</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="built_in">strlen</span>(dec)<span class="number">-1</span>,i=<span class="number">0</span>;i&lt;j;)&#123;</span><br><span class="line">                temp = dec[i];</span><br><span class="line">                dec[i++] = dec[j];</span><br><span class="line">                dec[j--] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,dec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>进制转换的方法大概都是模拟手写进制转换，只是写法可能有不同</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/fd972d5d5cf04dd4bb4e5f027d4fc11e?tpId=40&amp;amp;tqId=21357&amp;amp;tPage=2&amp;amp;rp=1&amp;amp;ru=%2Fta%2Fkaoyan&amp;amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;补之前的&lt;/p&gt;&lt;p&gt;对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们乘B为A的二进制逆序数。 例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。&lt;/p&gt;&lt;p&gt;输入一个1000位(即10^999)以内的十进制数。&lt;br&gt;输出十进制的二进制逆序数&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;173&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;181&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="NowCoder" scheme="https://hanielxx.com/categories/NowCoder/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="Medium" scheme="https://hanielxx.com/tags/Medium/"/>
    
      <category term="NowCoder" scheme="https://hanielxx.com/tags/NowCoder/"/>
    
      <category term="Scale" scheme="https://hanielxx.com/tags/Scale/"/>
    
      <category term="Binary" scheme="https://hanielxx.com/tags/Binary/"/>
    
  </entry>
  
  <entry>
    <title>NowCoder-剩下的树</title>
    <link href="https://hanielxx.com/NowCoder/2019-09-22-remaining-tree.html"/>
    <id>https://hanielxx.com/NowCoder/2019-09-22-remaining-tree.html</id>
    <published>2019-09-22T03:07:15.000Z</published>
    <updated>2020-07-15T02:01:02.059Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://www.nowcoder.com/practice/f5787c69f5cf41499ba4706bc93700a2?tpId=40&amp;tqId=21356&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>补之前的</p><p>有一个长度为整数L(1&lt;=L&lt;=10000)的马路，可以想象成数轴上长度为L的一个线段，起点是坐标原点，在每个整数坐标点有一棵树，即在0,1,2，…，L共L+1个位置上有L+1棵树。 现在要移走一些树，移走的树的区间用一对数字表示，如 100 200表示移走从100到200之间（包括端点）所有的树。 可能有M(1&lt;=M&lt;=100)个区间，区间之间可能有重叠。现在要求移走所有区间的树之后剩下的树的个数。</p><p>输入L和M，和M组数字</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>500 3<br>100 200<br>150 300<br>470 471</p></blockquote><p><strong>Output:</strong></p><blockquote><p>298</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>简单的开一个大数组，对每个位置标记就可以了</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> road[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, M;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;M)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=L;i++)&#123;</span><br><span class="line">            road[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> from, to;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;from&gt;&gt;to;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=from;j&lt;=to;j++)&#123;</span><br><span class="line">                road[j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=L;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(road[i]) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/f5787c69f5cf41499ba4706bc93700a2?tpId=40&amp;amp;tqId=21356&amp;amp;tPage=2&amp;amp;rp=1&amp;amp;ru=%2Fta%2Fkaoyan&amp;amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;补之前的&lt;/p&gt;&lt;p&gt;有一个长度为整数L(1&amp;lt;=L&amp;lt;=10000)的马路，可以想象成数轴上长度为L的一个线段，起点是坐标原点，在每个整数坐标点有一棵树，即在0,1,2，…，L共L+1个位置上有L+1棵树。 现在要移走一些树，移走的树的区间用一对数字表示，如 100 200表示移走从100到200之间（包括端点）所有的树。 可能有M(1&amp;lt;=M&amp;lt;=100)个区间，区间之间可能有重叠。现在要求移走所有区间的树之后剩下的树的个数。&lt;/p&gt;&lt;p&gt;输入L和M，和M组数字&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;500 3&lt;br&gt;100 200&lt;br&gt;150 300&lt;br&gt;470 471&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;298&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="NowCoder" scheme="https://hanielxx.com/categories/NowCoder/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="Easy" scheme="https://hanielxx.com/tags/Easy/"/>
    
      <category term="Array" scheme="https://hanielxx.com/tags/Array/"/>
    
      <category term="Map" scheme="https://hanielxx.com/tags/Map/"/>
    
      <category term="NowCoder" scheme="https://hanielxx.com/tags/NowCoder/"/>
    
  </entry>
  
  <entry>
    <title>NowCoder-大数阶乘</title>
    <link href="https://hanielxx.com/NowCoder/2019-09-21-factorial-of-bignumber.html"/>
    <id>https://hanielxx.com/NowCoder/2019-09-21-factorial-of-bignumber.html</id>
    <published>2019-09-21T15:47:25.000Z</published>
    <updated>2020-07-15T02:01:02.059Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --><meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://www.nowcoder.com/practice/f54d8e6de61e4efb8cce3eebfd0e0daa?tpId=40&amp;tqId=21355&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking" rel="external nofollow noopener noreferrer" target="_blank">Problem</a></h2><p>补之前的</p><p>输入一个正整数N，输出N的阶乘。0\&lt;=N\&lt;=1000</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong></p><blockquote><p>4<br>15</p></blockquote><p><strong>Output:</strong></p><blockquote><p>24<br>1307674368000</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>因为数字太大可能超出long long表示范围，所以用大正数乘法做</li><li>乘的过程有点不太一样，看代码</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> width 3000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//i,j: 循环变量</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k: 上一次进位,t: 最高位下标</span></span><br><span class="line">    <span class="keyword">int</span> k,t;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放结果，从d[0]是个位，从低位开始存</span></span><br><span class="line">    <span class="keyword">int</span> d[width];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//a*b，N是a，b是已经乘好的结果</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        t=<span class="number">0</span>;                    <span class="comment">//t是位数-1</span></span><br><span class="line">        <span class="comment">//给数组初始化为零</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;width;i++)    </span><br><span class="line">            d[i]=<span class="number">0</span>;</span><br><span class="line">        d[<span class="number">0</span>]=<span class="number">1</span>;                 <span class="comment">//个位初始化为1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=N;i++)       <span class="comment">//从1到N进行阶乘</span></span><br><span class="line">        &#123;</span><br><span class="line">            k=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//这里直接用b的每位数和整个a相乘，而不是b的每位数和a相乘后再加</span></span><br><span class="line">            <span class="comment">//从个位开始往高位运算</span></span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=t;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = d[j]*i+k;     <span class="comment">//第j位乘以i加上后一位运算得到的k作为tmp</span></span><br><span class="line">                k=tmp/<span class="number">10</span>;               <span class="comment">//tmp除以10得到k</span></span><br><span class="line">                d[j]=tmp%<span class="number">10</span>;            <span class="comment">//tmp取余得到运算后第j位的值</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由于是直接和a相乘，所以k可能比较大，不止一位</span></span><br><span class="line">            <span class="comment">//k!=0说明要向高位进位</span></span><br><span class="line">            <span class="keyword">while</span>(k!=<span class="number">0</span>)&#123;</span><br><span class="line">                d[++t]=k%<span class="number">10</span>;</span><br><span class="line">                k=k/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从个位开始输出各位数字</span></span><br><span class="line">        <span class="keyword">for</span>(i=t;i&gt;=<span class="number">0</span>;i--)   </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,d[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Jul 15 2020 16:05:17 GMT+0800 (China Standard Time) --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/f54d8e6de61e4efb8cce3eebfd0e0daa?tpId=40&amp;amp;tqId=21355&amp;amp;tPage=2&amp;amp;rp=1&amp;amp;ru=%2Fta%2Fkaoyan&amp;amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Problem&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;补之前的&lt;/p&gt;&lt;p&gt;输入一个正整数N，输出N的阶乘。0\&amp;lt;=N\&amp;lt;=1000&lt;/p&gt;&lt;h3 id=&quot;Examples&quot;&gt;&lt;a href=&quot;#Examples&quot; class=&quot;headerlink&quot; title=&quot;Examples:&quot;&gt;&lt;/a&gt;Examples:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;4&lt;br&gt;15&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;24&lt;br&gt;1307674368000&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="NowCoder" scheme="https://hanielxx.com/categories/NowCoder/"/>
    
    
      <category term="Algorithm" scheme="https://hanielxx.com/tags/Algorithm/"/>
    
      <category term="BigNumber" scheme="https://hanielxx.com/tags/BigNumber/"/>
    
      <category term="Hard" scheme="https://hanielxx.com/tags/Hard/"/>
    
      <category term="NowCoder" scheme="https://hanielxx.com/tags/NowCoder/"/>
    
      <category term="Factorial" scheme="https://hanielxx.com/tags/Factorial/"/>
    
  </entry>
  
</feed>
