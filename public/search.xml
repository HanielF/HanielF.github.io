<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>机器学习概念整理</title>
      <link href="/2018/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"/>
      <url>/2018/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>　　记录一些学习过程中遇到的基础概念，来源《机器学习导论》，《机器学习》——周志华，《白话大数据和机器学习》，《统计学习方法》——李航等，不是很全，等以后学习的深入待补充。<a id="more"></a></p><h1 id="数据和信息"><a href="#数据和信息" class="headerlink" title="数据和信息"></a>数据和信息</h1><ul><li>信息: 香农指出是”信息是用来消除随机不定性的东西”,就是那些把我们不清楚的描述,”信息是被消除的不确定性”。</li><li>算法: 简单理解为计算的方法和技巧，也可以是解决问题的办法</li><li>信息量: 一种信息数量化度量的规则，I=log_2m(m中情况产生概率均等)</li><li>先验概率: 事件按照常理，一般性规律发生的概率</li><li>香农公式: <script type="math/tex">C = B * log_2(1+S/N)</script>,B=2H,H为信道带宽,S为信号功率,N为噪声功率</li><li>信息熵: 信息的杂乱程度的量化描述,H(x)=-sum_1^np(x_i)log_2P(x_i),i=1,2…</li><li>熵: 混乱程度的描述，越有序，熵越低，反之越高 </li></ul><h1 id="回归和聚类"><a href="#回归和聚类" class="headerlink" title="回归和聚类"></a>回归和聚类</h1><ul><li>回归: 从大量的函数结果和自变量反推回函数表达式的过程就是回归 </li><li>过拟合: 一般是拟合过程中模型描述的太复杂，一般参数繁多，计算逻辑多</li><li>欠拟合: 一般是操作不当产生的误差e分布太散或者太大的情况</li></ul><h1 id="无分类的概念"><a href="#无分类的概念" class="headerlink" title="无分类的概念"></a>无分类的概念</h1>]]></content>
      
      <categories>
          
          <category> MachineLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ACM-ICPC World Finals 2017 F.Posterize DP</title>
      <link href="/2018/09/27/ACM-ICPC-World-Finals-2017-F-Posterize-DP/"/>
      <url>/2018/09/27/ACM-ICPC-World-Finals-2017-F-Posterize-DP/</url>
      <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="ACM-ICPC-World-Finals-2017-F-Posterize-DP"><a href="#ACM-ICPC-World-Finals-2017-F-Posterize-DP" class="headerlink" title="ACM-ICPC World Finals 2017 F.Posterize DP"></a>ACM-ICPC World Finals 2017 F.Posterize DP</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题<a id="more"></a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>　　Pixels in a digital picture can be represented with three integers in the range 00 to 255255 that indicate the intensity of the red, green, and blue colors. To compress an image or to create an artistic effect, many photo-editing tools include a “posterize” operation which works as follows. Each color channel is examined separately; this problem focuses only on the red channel. Rather than allow all integers from 00 to 255255 for the red channel, a posterized image allows at most kk integers from this range. Each pixel’s original red intensity is replaced with the nearest of the allowed integers. The photo-editing tool selects a set of kk integers that minimizes the sum of the squared errors introduced across all pixels in the original image. If there are nn pixels that have original red values r1,…,rnr1,…,rn, and kk allowed integers v1,…,vkv1,…,vk, the sum of squared errors is defined as</p><p>　　∑i=1nmin1≤j≤k(ri−vj)2.∑i=1nmin1≤j≤k(ri−vj)2.</p><p>　　Your task is to compute the minimum achievable sum of squared errors, given parameter kk and a description of the red intensities of an image’s pixels.</p><div class="note info"><p>数字图像的像素可以用三个在0到255之间的整数表示,它们分别表示红色、绿色和蓝色的强度。为了压缩图片或是<br>为了生艺术效果,许多图像编辑工具收录了如下所述的”色调分离”操作。每个颜色通道会分别考虑,本题只考虑红<br>色通道的情况。不同于在红色通道使用0到255之间全部的整数,一张色调分离后的图片只会使用这些数字里至多 k<br>种整数。每个像素原来的红色强度会被替换成最相近的可用强度。图像编辑工具会选择k个整数来最小化替换过程<br>引起的平方误差之和。假设原图有n个像素,它们的红色取值是r1,···,rn,而 k 种可用整数为v1,···,vk ,那么平方误差之和被定义为</p><p>　　∑i=1nmin1≤j≤k(ri−vj)2.∑i=1nmin1≤j≤k(ri−vj)2.</p><p>你的任务是计算可以实现的最小平方误差之和,参数k和图片的红色强度会给出。</p></div><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains two integers dd (1≤d≤2561≤d≤256), the number of distinct red values that occur in the original image, and kk (1≤k≤d1≤k≤d), the number of distinct red values allowed in the posterized image. The remaining dd lines indicate the number of pixels of the image having various red values. Each such line contains two integers rr (0≤r≤2550≤r≤255) and pp (1≤p≤2261≤p≤226), where rr is a red intensity value and pp is the number of pixels having red intensity rr. Those dd lines are given in increasing order of red value.</p><div class="note info"><p>第一行包含两个整数d(1≤d≤256)和k(1≤k≤d)<br>分别表示原图中不同的红色强度有多少种,色调分离后可以使用的红色强度有多少种。<br>接下来d行描述了每种红色强度在原图中占据的像素点数量。<br>每行包含两个整数r(0≤r≤255)和p(1≤p≤226)<br>这里r是一种红色强度的取值,而p是这种取值对应的像素点数量。这d行信息按照红色强度取值升序给出。</p></div><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Display the sum of the squared errors for an optimally chosen set of kk allowed integer values.</p><div class="note info"><p>输出最优的 k 种可选取值对应的平方误差之和。</p></div><div class="table-container"><table><thead><tr><th>Sample Input 1</th><th>Sample Output 1</th></tr></thead><tbody><tr><td>2 1</td><td></td></tr><tr><td>50 20000</td><td></td></tr><tr><td>150 10000</td><td>66670000</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Sample Input 2</th><th>Sample Output 2</th></tr></thead><tbody><tr><td>2 2</td><td></td></tr><tr><td>50 20000</td><td></td></tr><tr><td>150 10000</td><td>0</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Sample Input 3</th><th>Sample Output 3</th></tr></thead><tbody><tr><td>4 2</td><td></td></tr><tr><td>0 30000</td><td></td></tr><tr><td>25 30000</td><td></td></tr><tr><td>50 30000</td><td></td></tr><tr><td>255 30000</td><td>37500000</td></tr></tbody></table></div><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>　　主要是dp,记忆化搜索＋剪枝,看后面的代码注释和题解</p><h2 id="题目转化"><a href="#题目转化" class="headerlink" title="题目转化"></a>题目转化</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有256个位置，有d个位置上有人（每个位置上可能不止一个人），你可以在k个位置上插旗（每个位置上至多一面旗子），每个人都会走到离自己最近的旗子，求所有人走的距离的平方和的最小值。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>要解决这个问题，我们可以建立一个二维数组<em>f[i][j]</em>，（j&lt;=i），表示前i个位置，放了j个旗子，其中第i个位置一定放了旗子，前i个位置上的所有人走到旗子上的最小距离平方和。如果我们假设第i个位置上的旗子是k个旗子中的最后一个（即第i个位置后面没有旗子），那么第i个位置后面的人只能全部走到第i个位置上，所以把_f[i][j]_加上i位置后面的人走到i位置的距离平方和就可以得到所有人走的距离平方和。因此我们可以枚举最后一个旗子插的位置i，将_f[i][j_]加上i后面的人走到i位置的距离平方和，取最小值，即为答案。<em>f[i][j]</em>数组的建立我们可以用下面的公式来计算：<em>f[i][j]=min{f[m][j-1]+w[m][i]},（j-1&lt;=m&lt; i)</em>，其中<em>w[m][i]</em>表示m~i这一段只有m和i位置放了旗子，这一段上的人走的距离平方和。</p><p>由于第i个位置上固定了一面旗子，我们可以考虑另外j-1面旗子的位置。若j-1面旗子在前m个位置（可以假设第m个位置上一定放旗子），那么<em>f[i][j]</em>可以分解成两段计算，一段是1~m位置，放了j-1个旗子，其中第m个位置一定放了旗子，这就递归成了<em>f[m][j-1]</em>；另一段是m+1~i位置，只有m和i位置放了旗子，这一段上的人只能走到m和i，即<em>w[m][i]</em>。所以我们只要枚举m的值，取<em>f[m][j-1]+w[m][i]</em>的最小值，就可以得出<em>f[i][j]</em>的值。</p><p>下面给出一个f[i][j]的实例：考虑f[8][3]，前8个位置，放了3个旗子，其中第3个位置一定放了旗子。剩余的2面旗子可能在前2/3/4/5/6/7个位置上，由此枚举出所有情况：</p><p>剩余的2面旗子在：</p><blockquote><p>　　前2个位置：f[2][2]+w[2][8]<br>　　前3个位置：f[3][2]+w[3][8]<br>　　前4个位置：f[4][2]+w[4][8]<br>　　前5个位置：f[5][2]+w[5][8]<br>　　前6个位置：f[6][2]+w[6][8]<br>　　前7个位置：f[7][2]+w[7][8]</p></blockquote><p>取出这些值中的最小值，即得到f[8][3]的值。</p><p>至于w[m][i]的建立较为简单，由于只有m和i位置放了旗子，m+1~i位置上的人只能就近走到m或i位置上，我们可以求出m和i的中值，前一半的人走到m，后一半的人走到i，求出距离平方和即可。</p><h3 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 260</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据,返回一个整数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否有符号</span></span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按位读取组成整数</span></span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一共n个位置，kk个旗子,a[N]表示每个位置的人数</span></span><br><span class="line"><span class="keyword">int</span> n,kk,a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//f[i][j]表示前i个位置，放了j个旗子，其中第i个位置一定放了旗子的最小平方误差</span></span><br><span class="line">ll w[N][N],f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">min</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("a.in","r",stdin);</span></span><br><span class="line">    n=read();</span><br><span class="line">    kk=read(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//旗子数不可以比位置数多</span></span><br><span class="line">    <span class="keyword">if</span>(kk&gt;=n)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取每个位置的人数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read();a[x+<span class="number">1</span>]=read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立w[i][j],i是第一个旗子位置,j是第二个旗子的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">256</span>;++i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i~j这一段只在i和j位置放旗子的平方误差</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;=<span class="number">256</span>;++j)&#123;</span><br><span class="line">          <span class="keyword">int</span> mid=i+j&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算i到j之间所有的位置平方和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=i+<span class="number">1</span>;q&lt;=j<span class="number">-1</span>;++q)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q&gt;mid) </span><br><span class="line">                  w[i][j]+=(ll)(j-q)*(j-q)*a[q];</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                  w[i][j]+=(ll)(q-i)*(q-i)*a[q];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只放一个旗子的情况,旗子在i处，遍历i之前所有的位置,累加</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">256</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j)</span><br><span class="line">            f[i][<span class="number">1</span>]+=(ll)(i-j)*(i-j)*a[j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立f[i][j],j是旗子的数量，从２开始到kk</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=kk;++j)</span><br><span class="line">        <span class="comment">//i是一共多少个位置，从j到256</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=j;i&lt;=<span class="number">256</span>;++i)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//前j-1个旗子放在[1,m]这里，并且m处有旗子,i处也有旗子,转化成求f[m][j-1]+w[m][i]的最小值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=j<span class="number">-1</span>;m&lt;i<span class="number">-1</span>;++m)</span><br><span class="line">                f[i][j]=min(f[i][j],f[m][j<span class="number">-1</span>]+w[m][i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ll ans=f[<span class="number">256</span>][kk];</span><br><span class="line">    <span class="comment">//统计答案，如果最后一个旗子不在最后一个位置，就还需要加上最后一个旗子后面的位置的平方和，枚举最后一个旗子插的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//i是最后一个旗子的位置,j是最后一个旗子到最后一个位置的每个位置,tmp是最后这部分的平方和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">255</span>;i&gt;=kk;--i)&#123;</span><br><span class="line">        ll tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">256</span>;j&gt;i;--j)</span><br><span class="line">          tmp+=(ll)(j-i)*(j-i)*a[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较不同位置的平方和，取最小值</span></span><br><span class="line">        ans=min(ans,f[i][kk]+tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> ACM-ICPC </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>numpy.dot()函数</title>
      <link href="/2018/09/11/numpy-dot-%E5%87%BD%E6%95%B0/"/>
      <url>/2018/09/11/numpy-dot-%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p>　　numpy(Numerical Python extensions)是一个第三方的Python包，用于科学计算。本文主要讲学习Numpy过程中遇到的一个问题，关于numpy.dot()是怎运算的。<a id="more"></a></p><h2 id="Numpy中多维数组的轴"><a href="#Numpy中多维数组的轴" class="headerlink" title="Numpy中多维数组的轴"></a>Numpy中多维数组的轴</h2><p>　　多维数组可以用numpy包生成，关于多维数组的运算以及定义等自行百度,主要讲多维数组的轴,这也是我学习时不懂的地方。</p><div class="note default"><p>　　多维数组的轴(axis)和该数组的size(或者)shape元素对应 。轴数从0开始，如果是二维，０轴是竖行，１轴是横行。具体看代码</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.randint(<span class="number">0</span>,<span class="number">5</span>,[<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">print(x)</span><br><span class="line">Out:</span><br><span class="line">  [[[<span class="number">5</span> <span class="number">2</span>]</span><br><span class="line">    [<span class="number">4</span> <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">   [[<span class="number">1</span> <span class="number">3</span>]</span><br><span class="line">    [<span class="number">2</span> <span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">   [[<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">    [<span class="number">0</span> <span class="number">1</span>]]]</span><br><span class="line"></span><br><span class="line">x.sum(axis=<span class="number">0</span>)</span><br><span class="line">Out:</span><br><span class="line">  array([[<span class="number">7</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">6</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">x.sum(axis=<span class="number">1</span>)</span><br><span class="line">Out:</span><br><span class="line">  array([[<span class="number">9</span>, <span class="number">4</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">6</span>],</span><br><span class="line">         [<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line">x.sum(axis=<span class="number">2</span>)</span><br><span class="line">Out:</span><br><span class="line">  array([[<span class="number">7</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><div class="note info"><p>　　如果将三维数组的每一个二维看做一个平面（plane，X[0, :, :], X[1, :, :], X[2, :, :]），三维数组即是这些二维平面层叠（stacked）出来的结果。则（axis=0）表示全部平面上的对应位置，（axis=1），每一个平面的每一列，（axis=2），每一个平面的每一行。</p></div><h1 id="numpy-dot"><a href="#numpy-dot" class="headerlink" title="numpy.dot()"></a>numpy.dot()</h1><p>　　<em>numpy.dot(a,b,out=None)</em></p><ul><li>如果a和b都是一维数组，则进行内积运算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.dot(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">Out:</span><br><span class="line">  <span class="number">12</span></span><br><span class="line"></span><br><span class="line">np.dot([<span class="number">2j</span>, <span class="number">3</span>+<span class="number">3j</span>], [<span class="number">2j</span>, <span class="number">3j</span>])</span><br><span class="line">Out:</span><br><span class="line">  (<span class="number">-13</span>+<span class="number">9j</span>)</span><br></pre></td></tr></table></figure><ul><li>如果都是二维数组，就进行矩阵乘法，推荐<code>a@b</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">b = [[<span class="number">4</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">np.dot(a, b)</span><br><span class="line">Out:</span><br><span class="line">  array([[<span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><ul><li>如果其中一个矩阵０秩，即标量，就进行<code>a*b</code>的运算，相乘</li><li>如果a是N-D矩阵且b是1-D矩阵,就进行a的最后一个轴上的数据和b相乘并求和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = array([[[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">     [ <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>],</span><br><span class="line">     [ <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>, <span class="number">12.</span>]],</span><br><span class="line"></span><br><span class="line">    [[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">     [ <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>],</span><br><span class="line">     [ <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>, <span class="number">12.</span>]]])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">np.dot(a, b)</span><br><span class="line">Out:</span><br><span class="line">  array([[ <span class="number">30.</span>,  <span class="number">70.</span>, <span class="number">110.</span>],</span><br><span class="line">       [ <span class="number">30.</span>,  <span class="number">70.</span>, <span class="number">110.</span>]])</span><br></pre></td></tr></table></figure><ul><li>如果都是多维矩阵，则_a的最后一个轴和b的倒数第二个轴上的数据乘积累加_,类似第四种情况<br><code>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">3</span>*<span class="number">4</span>*<span class="number">5</span>*<span class="number">6</span>).reshape((<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">b = np.arange(<span class="number">3</span>*<span class="number">4</span>*<span class="number">5</span>*<span class="number">6</span>)[::<span class="number">-1</span>].reshape((<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>))</span><br><span class="line">np.dot(a, b)[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Out:</span><br><span class="line">  <span class="number">499128</span></span><br><span class="line">sum(a[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,:] * b[<span class="number">1</span>,<span class="number">2</span>,:,<span class="number">2</span>])</span><br><span class="line">Out:</span><br><span class="line">  <span class="number">499128</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;</p>]]></content>
      
      <categories>
          
          <category> MachineLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聚类和K-Means算法</title>
      <link href="/2018/09/10/%E8%81%9A%E7%B1%BB%E5%92%8CK-Means%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/10/%E8%81%9A%E7%B1%BB%E5%92%8CK-Means%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><h2 id="聚类定义"><a href="#聚类定义" class="headerlink" title="聚类定义"></a>聚类定义</h2><p>　　聚类(Clustering)，指的是一种学习方式（操作方式），即把物理或者抽象对象的集合分组为由彼此的对象组成的多个类的分析过程。<a id="more"></a> </p><div class="note info"><p> 聚类属于无监督机器学习，简言之就是把特征形态相同的或者近似的划分在一个概念下，聚集为一组。</p><p>聚类在实际的应用中中亦是非常广泛的，如：市场细分（Market segmentation）、社交圈分析（social network analysis）、集群计算（organize computing clusters）、天体数据分析（astronomical data analysis）等</p></div><h2 id="聚类算法分类"><a href="#聚类算法分类" class="headerlink" title="聚类算法分类"></a>聚类算法分类</h2><p>　　主要的聚类主要的聚类算法可以划分为如下几类：划分方法、层次方法、基于密度的方法、基于网格的方法以及基于模型的方法。</p><p>　　每一类中都存在着得到广泛应用的算法，例如：划分方法中的k-means聚类算法、层次方法中的凝聚型层次聚类算法、基于模型方法中的神经网络聚类算法等</p><p>　　但是上述的都是硬聚类，即每一个数据只能被归为一类，还有一种是模糊聚类。模糊聚类通过隶属函数来确定每个数据隶属于各个簇的程度，而不是将一个数据对象硬性地归类到某一簇中。</p><h1 id="常用距离算法"><a href="#常用距离算法" class="headerlink" title="常用距离算法"></a>常用距离算法</h1><h2 id="欧氏距离"><a href="#欧氏距离" class="headerlink" title="欧氏距离"></a>欧氏距离</h2><p>　　欧氏距离是最直观的距离度量方法，通常就是学过的两点间距离，可以用在多维。</p><ul><li>二维平面上点a(x1,y1)与b(x2,y2)间的欧氏距离:  <script type="math/tex; mode=display">d_{12} = \sqrt{(x_1-x_2)^2+(y_1-y_2)^2}</script></li><li>三维空间点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离:<script type="math/tex; mode=display">d{12} = \sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}</script></li><li>更高维的计算类似二维三维</li></ul><h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2><p>　　不再是两点间连线的那种，是类似九宫格的走法，只能直线和直角拐弯。又叫做“城市街区距离”。</p><ul><li>二维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离：<script type="math/tex; mode=display">d_12 = |x_1-x_2|+|y_1-y_2|</script></li><li>三维和其他维类似</li></ul><div class="note info"><p>　　除了这两种还有余弦距离和切比雪夫距离等，这里不展开说。采用不同的距离度量方法对结果有很大的影响。</p></div><h1 id="k-means算法"><a href="#k-means算法" class="headerlink" title="k-means算法"></a>k-means算法</h1><p>  思想大致是:</p><ul><li>1.　先随机选k个质心</li><li>2.　对每个点计算其到各个质心的距离</li><li>3.　选距离最近的，把这个点归为这个质心的一类，形成k个簇</li><li>4.　然后对于每个簇，计算其中每个点到质心的平均距离</li><li>5.　然后把这个作为这个簇的新的质心,进行第二步</li><li>6.　直到簇不怎么发生变化或者达到了预设的最大迭代次数，停止</li></ul><p>　主要函数如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//k-means聚类</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Cluster&gt; k_means(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;trans,<span class="keyword">int</span> k,<span class="keyword">int</span> counts)&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Cluster&gt; clusters(k);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> row = trans.size();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> col = trans[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//随机初始化聚类中心</span></span><br><span class="line">  srand((<span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> center = rand()%trans.size();</span><br><span class="line">    clusters[i].center=trans[center]; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//迭代counts次</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">0</span>;cnt&lt;counts;cnt++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空样本空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">      clusters[i].samples.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算样本属于的簇</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">      <span class="keyword">int</span> tmp_center = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> minal = cal_distance(trans[i],clusters[tmp_center].center);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k;j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> distance = cal_distance(trans[i],clusters[j].center);</span><br><span class="line">        <span class="keyword">if</span>(distance&lt;minal)&#123;</span><br><span class="line">          tmp_center = j;</span><br><span class="line">          minal = distance;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      clusters[tmp_center].samples.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新计算簇中心</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;trans[<span class="number">0</span>].size();m++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;clusters[i].samples.size();j++)&#123;</span><br><span class="line">          <span class="comment">//cout&lt;&lt;"sum+=: "&lt;&lt;trans[clusters[i].samples[j]][m];</span></span><br><span class="line">          sum+=trans[clusters[i].samples[j]][m];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clusters[i].center[m]=sum/clusters[i].samples.size();</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> clusters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　用了C++作为实现的代码，python的代码可以参考网上的，有很多。计算距离用的是欧式距离。数据可以自己构造尝试。</p><hr>]]></content>
      
      <categories>
          
          <category> MachineLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> MachineLearning </tag>
            
            <tag> Clustering </tag>
            
            <tag> K-Means </tag>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS-Fedora搭建LNMP环境</title>
      <link href="/2017/08/12/CentOS-Fedora%E6%90%AD%E5%BB%BALNMP%E7%8E%AF%E5%A2%83/"/>
      <url>/2017/08/12/CentOS-Fedora%E6%90%AD%E5%BB%BALNMP%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原本在服务器上一直用的debian系,后来转到本机Fedora搭建环境就蒙了,之前也因为这个花了不少时间,为了把踩过得坑记下来,还是写篇文章。</p><a id="more"></a><p>其实所谓LNMP其实就是指Linux+Nginx+Mysql+PHP,因为Nginx发音问题,有时候也说是LEMP。</p><p><strong>下面就是<em>Centos/Fedora</em> 搭建LNMP环境的教程.</strong>  </p><h1 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h1><p>OS: Fedora 25<br>Nginx Version: 1.6.2<br>Mysql Version: MariaDB 10.2<br>PHP Version: PHP7.17</p><h1 id="安装Nginx-PHP7-1-7和PHP-FPM"><a href="#安装Nginx-PHP7-1-7和PHP-FPM" class="headerlink" title="安装Nginx,PHP7.1.7和PHP-FPM"></a>安装Nginx,PHP7.1.7和PHP-FPM</h1><h2 id="Fedora-25"><a href="#Fedora-25" class="headerlink" title="Fedora 25"></a>Fedora 25</h2><h3 id="切换到root用户"><a href="#切换到root用户" class="headerlink" title="切换到root用户"></a>切换到root用户</h3><pre><code>sudo -i ## OR ##su -  </code></pre><h3 id="添加repositories"><a href="#添加repositories" class="headerlink" title="添加repositories"></a>添加repositories</h3><pre><code>## Remi Dependency on Fedora ##rpm -Uvh http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-stable.noarch.rpm rpm -Uvh http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm## The version 25 can be replaced by 26/24 ##rpm -Uvh http://rpms.famillecollet.com/fedora/remi-release-25.rpm  </code></pre><h3 id="安装Nginx-PHP-7-1-7-and-PHP-FPM"><a href="#安装Nginx-PHP-7-1-7-and-PHP-FPM" class="headerlink" title="安装Nginx,PHP 7.1.7 and PHP-FPM"></a>安装Nginx,PHP 7.1.7 and PHP-FPM</h3><pre><code>dnf --enablerepo=remi --enablerepo=remi-php71 install nginx php-fpm php-common  </code></pre><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><pre><code>dnf --enablerepo=remi --enablerepo=remi-php71 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xml  </code></pre><p>关于这些模块的介绍可以自己百度,根据自己需要来安装,嫌麻烦的话～直接copy吧～</p><h3 id="关闭httpd-Apache-并打开Nginx-PHP-FPM"><a href="#关闭httpd-Apache-并打开Nginx-PHP-FPM" class="headerlink" title="关闭httpd(Apache)并打开Nginx,PHP-FPM"></a>关闭httpd(Apache)并打开Nginx,PHP-FPM</h3><p> <strong>关闭Apache</strong>  </p><pre><code>systemctl stop httpd.service  </code></pre><p><strong>打开Nginx</strong>  </p><pre><code>systemctl start nginx.service  </code></pre><p><strong>打开PHP-FPM</strong>  </p><pre><code>systemctl start php-fpm.service  </code></pre><h3 id="设置开机自启Nginx-PHP-FPM"><a href="#设置开机自启Nginx-PHP-FPM" class="headerlink" title="设置开机自启Nginx PHP-FPM"></a>设置开机自启Nginx PHP-FPM</h3><p> <strong>关闭httpd(Apache)的开机自启</strong>  </p><pre><code>systemctl disable httpd.service  </code></pre><p><strong>设置Nginx和PHP-FPM开机自启</strong>  </p><pre><code>systemctl enable nginx.servicesystemctl enable php-fpm.service  </code></pre><h3 id="配置Nginx-和PHP-FPM"><a href="#配置Nginx-和PHP-FPM" class="headerlink" title="配置Nginx 和PHP-FPM"></a>配置Nginx 和PHP-FPM</h3><p> <strong>先做好默认配置的备份</strong>  </p><pre><code>cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bakcp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf  </code></pre><p><strong>修改PHP-FPM配置</strong>  </p><pre><code>vim /etc/php-fpm.d/www.conf## 注释掉新添加一行 ##;listen = /run/php-fpm/www.socklisten = 127.0.0.1:9000  </code></pre><p><strong>为你的站点创建相关文件夹</strong>  </p><pre><code>## 将testsite.local换成你自己的　##mkdir -p /srv/www/testsite.local/public_htmlmkdir /srv/www/testsite.local/logschown -R apache:apache /srv/www/testsite.localmkdir /etc/nginx/sites-availablemkdir /etc/nginx/sites-enabled  </code></pre><p>这里使用apache user group是因为PHP-FPM默认运行apache,并且apache能够进入一些类似httpd这样的目录</p><p><strong>在/etc/nginx/nginx.conf文件\”include /etc/nginx/conf.d/*.conf\”这行后面添加一行</strong>  </p><pre><code>include /etc/nginx/sites-enabled/*;  </code></pre><p><strong>创建testsite.local 文件并配置</strong>  </p><pre><code>## 这是最基本的配置 ##server {    server_name testsite.local;    access_log /srv/www/testsite.local/logs/access.log;    error_log /srv/www/testsite.local/logs/error.log;    root /srv/www/testsite.local/public_html;    location / {        index index.html index.htm index.php;    }    location ~ \.php$ {        include /etc/nginx/fastcgi_params;        fastcgi_pass  127.0.0.1:9000;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    }}  </code></pre><p><strong>创建软链接到sites-enabled目录</strong>  </p><pre><code>cd /etc/nginx/sites-enabled/ln -s /etc/nginx/sites-available/testsite.localsystemctl restart nginx.service  </code></pre><p><strong>将testsite.local添加到/etc/hosts中</strong>  </p><pre><code>127.0.0.1               localhost.localdomain localhost testsite.local  </code></pre><p><a href="http://www.if-not-true-then-false.com/2011/nginx-and-php-fpm-configuration-and-optimizing-tips-and-tricks/" target="_blank" rel="noopener">更多的Nginx 和PHP-FPM配置点这里～</a></p><h3 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h3><p><strong>创建/srv/www/testsite.local/public_html/index.php并添加以下内容:</strong>  </p><p><strong>然后访问域名或者服务器ip看是否出现phpinfo的页面。</strong></p><h3 id="出现403-forbidden"><a href="#出现403-forbidden" class="headerlink" title="出现403 forbidden"></a>出现403 forbidden</h3><p><strong>可能是SELinux有问题</strong>  </p><pre><code>chcon -R -t httpd_sys_content_t /srv/www/testsite.local/public_html  </code></pre><h3 id="远程链接到服务器"><a href="#远程链接到服务器" class="headerlink" title="远程链接到服务器"></a>远程链接到服务器</h3><p><strong>打开防火墙的80端口</strong>  </p><pre><code>firewall-cmd --get-active-zonesfirewall-cmd --permanent --zone=public --add-service=http## OR ##firewall-cmd --permanent --zone=public --add-port=80/tcpsystemctl restart firewalld.service  </code></pre><p><strong>访问域名或者ip试试~</strong></p><h2 id="Centos-7"><a href="#Centos-7" class="headerlink" title="Centos 7"></a>Centos 7</h2><h3 id="切换到root用户-1"><a href="#切换到root用户-1" class="headerlink" title="切换到root用户"></a>切换到root用户</h3><pre><code>sudo -i ## OR ##su -  </code></pre><h3 id="添加repositories-1"><a href="#添加repositories-1" class="headerlink" title="添加repositories"></a>添加repositories</h3><pre><code>## Centos 7 Remi repo ##rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm  ## Centos 7 Nginx repo ##vim /etc/yum.repos.d/nginx.repo## 添加 ##[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1  </code></pre><h3 id="安装Nginx-PHP-7-1-7-and-PHP-FPM-1"><a href="#安装Nginx-PHP-7-1-7-and-PHP-FPM-1" class="headerlink" title="安装Nginx,PHP 7.1.7 and PHP-FPM"></a>安装Nginx,PHP 7.1.7 and PHP-FPM</h3><pre><code> yum --enablerepo=remi,remi-php71 install nginx php-fpm php-common  </code></pre><h3 id="安装模块-1"><a href="#安装模块-1" class="headerlink" title="安装模块"></a>安装模块</h3><pre><code>yum --enablerepo=remi,remi-php71 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xml  </code></pre><h3 id="关闭httpd-Apache-并打开Nginx-PHP-FPM-1"><a href="#关闭httpd-Apache-并打开Nginx-PHP-FPM-1" class="headerlink" title="关闭httpd(Apache)并打开Nginx,PHP-FPM"></a>关闭httpd(Apache)并打开Nginx,PHP-FPM</h3><p> <strong>关闭Apache</strong>  </p><pre><code>/etc/init.d/httpd stop## OR ## service httpd stop  </code></pre><p><strong>打开Nginx和PHP-FPM</strong>  </p><pre><code>systemctl start nginx.servicesystemctl start php-fpm.service  </code></pre><h3 id="设置开机自启Nginx-PHP-FPM-1"><a href="#设置开机自启Nginx-PHP-FPM-1" class="headerlink" title="设置开机自启Nginx PHP-FPM"></a>设置开机自启Nginx PHP-FPM</h3><p> <strong>关闭httpd(Apache)的开机自启,并设置nginx和php-fpm开机自启</strong>  </p><pre><code>systemctl disable httpd.servicesystemctl enable nginx.servicesystemctl enable php-fpm.service  </code></pre><h3 id="配置Nginx-和PHP-FPM及其他"><a href="#配置Nginx-和PHP-FPM及其他" class="headerlink" title="配置Nginx 和PHP-FPM及其他"></a>配置Nginx 和PHP-FPM及其他</h3><p>这一段的配置和fedora是一样的,可以不看了~</p><p><strong>先做好默认配置的备份</strong>  </p><pre><code>cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bakcp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf  </code></pre><p><strong>修改PHP-FPM配置</strong>  </p><pre><code>vim /etc/php-fpm.d/www.conf## 注释掉新添加一行 ##;listen = /run/php-fpm/www.socklisten = 127.0.0.1:9000  </code></pre><p><strong>为你的站点创建相关文件夹</strong>  </p><pre><code>## 将testsite.local换成你自己的　##mkdir -p /srv/www/testsite.local/public_htmlmkdir /srv/www/testsite.local/logschown -R apache:apache /srv/www/testsite.localmkdir /etc/nginx/sites-availablemkdir /etc/nginx/sites-enabled  </code></pre><p><strong>在/etc/nginx/nginx.conf文件”include /etc/nginx/conf.d/*.conf”这行后面添加一行</strong>  </p><pre><code>include /etc/nginx/sites-enabled/*;  </code></pre><p><strong>创建testsite.local 文件并配置</strong>  </p><pre><code>## 这是最基本的配置 ##server {    server_name testsite.local;    access_log /srv/www/testsite.local/logs/access.log;    error_log /srv/www/testsite.local/logs/error.log;    root /srv/www/testsite.local/public_html;    location / {        index index.html index.htm index.php;    }    location ~ \.php$ {        include /etc/nginx/fastcgi_params;        fastcgi_pass  127.0.0.1:9000;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    }}  </code></pre><p><strong>创建软链接到sites-enabled目录</strong>  </p><pre><code>cd /etc/nginx/sites-enabled/ln -s /etc/nginx/sites-available/testsite.localsystemctl restart nginx.service  </code></pre><p><strong>将testsite.local添加到/etc/hosts中</strong>  </p><pre><code>127.0.0.1               localhost.localdomain localhost testsite.local  </code></pre><p><a href="http://www.if-not-true-then-false.com/2011/nginx-and-php-fpm-configuration-and-optimizing-tips-and-tricks/" target="_blank" rel="noopener">更多的Nginx 和PHP-FPM配置点这里～</a></p><p><strong>测试是否成功</strong><br>创建/srv/www/testsite.local/public_html/index.php并添加以下内容:  </p><p>然后访问域名或者服务器ip看是否出现phpinfo的页面。</p><p><strong>出现403 forbidden</strong><br>有可能是SELinux有问题  </p><pre><code>chcon -R -t httpd_sys_content_t /srv/www/testsite.local/public_html  </code></pre><p><strong>远程链接到服务器</strong><br>打开防火墙的80端口  </p><pre><code>firewall-cmd --get-active-zonesfirewall-cmd --permanent --zone=public --add-service=http## OR ##firewall-cmd --permanent --zone=public --add-port=80/tcpsystemctl restart firewalld.service  </code></pre><h1 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h1><p>这里安装的是MariaDB,而不是Mysql,有如下几个原因</p><ul><li>MariaDB本来就是一个Mysql的开源版本</li><li>MariaDB和Mysql类似并兼容Mysql</li><li>Fedora和Centos系列的发行版已经转用MariaDB了</li></ul><p><strong>我这里选择安装MariaDB 10.2.7 [stable],具体安装过程如下~</strong></p><ul><li>如果之前安装了Mysql,记得备份你的数据库和配置文件!</li><li>如果是从低版本升级的,记得执行<code>mysql_upgrade</code>~</li></ul><h2 id="切换root用户"><a href="#切换root用户" class="headerlink" title="切换root用户"></a>切换root用户</h2><pre><code>su -## OR ##sudo -i  </code></pre><h2 id="添加MariaDB-repo"><a href="#添加MariaDB-repo" class="headerlink" title="添加MariaDB repo"></a>添加MariaDB repo</h2><p>现在Fedora 24/25/26 用户都可以直接安装MariaDB 10.1 而不用添加其他的repo来安装~</p><p><a href="http://downloads.mariadb.org/mariadb/repositories/" target="_blank" rel="noopener">MariaDB repository configuration<br>tool</a>,这里面有repo,自己选择repo文件安装,上面也有教程~</p><h2 id="更新并安装"><a href="#更新并安装" class="headerlink" title="更新并安装"></a>更新并安装</h2><h3 id="Fedora-24-25-26"><a href="#Fedora-24-25-26" class="headerlink" title="Fedora 24/25/26"></a>Fedora 24/25/26</h3><pre><code>dnf install mariadb mariadb-server  </code></pre><h3 id="Centos-7-1"><a href="#Centos-7-1" class="headerlink" title="Centos 7"></a>Centos 7</h3><pre><code>yum install MariaDB MariaDB-server  </code></pre><h2 id="打开MariaDB并配置自启"><a href="#打开MariaDB并配置自启" class="headerlink" title="打开MariaDB并配置自启"></a>打开MariaDB并配置自启</h2><h3 id="Fedora"><a href="#Fedora" class="headerlink" title="Fedora"></a>Fedora</h3><pre><code>systemctl start mariadb.service ## use restart after updatesystemctl enable mariadb.service  </code></pre><h3 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h3><pre><code>service mysql start ## use restart after update## OR ##/etc/init.d/mysql start ## use restart after updatechkconfig --levels 235 mysql on  </code></pre><h2 id="进行secure-installation"><a href="#进行secure-installation" class="headerlink" title="进行secure installation"></a>进行secure installation</h2><pre><code>/usr/bin/mysql_secure_installation  </code></pre><p>自己看提示来~第一个没设置密码呢,直接回车,下面的大多数都选Y</p><p>如果不想进行secure installation 的话,emmmmm….最好还是做下吧~  </p><p>到这里其实已经结束了…233333</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><pre><code>mysql -u root -p  </code></pre><h2 id="创建数据库和user"><a href="#创建数据库和user" class="headerlink" title="创建数据库和user"></a>创建数据库和user</h2><pre><code>## CREATE DATABASE ##MariaDB [(none)]&gt; CREATE DATABASE webdb;## CREATE USER ##MariaDB [(none)]&gt; CREATE USER &#39;webdb_user&#39;@&#39;10.0.15.25&#39; IDENTIFIED BY &#39;password123&#39;;## GRANT PERMISSIONS ##MariaDB [(none)]&gt; GRANT ALL ON webdb.* TO &#39;webdb_user&#39;@&#39;10.0.15.25&#39;;##  FLUSH PRIVILEGES, Tell the server to reload the grant tables  ##MariaDB [(none)]&gt; FLUSH PRIVILEGES;  </code></pre><h2 id="确保数据库能远程连接"><a href="#确保数据库能远程连接" class="headerlink" title="确保数据库能远程连接"></a>确保数据库能远程连接</h2><h3 id="Centos-1"><a href="#Centos-1" class="headerlink" title="Centos"></a>Centos</h3><pre><code>vim /etc/sysconfig/iptables-config## 添加 ##-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT## 重启 ##service iptables restart## OR ##/etc/init.d/iptables restart  </code></pre><h3 id="Fedora-1"><a href="#Fedora-1" class="headerlink" title="Fedora"></a>Fedora</h3><pre><code>firewall-cmd --get-active-zones## 应该会输出如下 ##- public-    interfaces: wlp1s0firewall-cmd --permanent --zone=public --add-service=mysqlsystemctl restart firewalld.servicemysql -h 10.0.15.25 -u myusername -p  </code></pre><h2 id="—————————"><a href="#—————————" class="headerlink" title="—————————- "></a>—————————- </h2><p>emmmm…没想到要写这么多….</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LNMP,Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown学习笔记</title>
      <link href="/2017/08/02/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/08/02/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本来博客初建，理应写点文章总结心得，说点自己的想法。<br>但正好这时候又学了<a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>，不如就先写个学习笔记，供自己以后写文参考。</p><p>关于博客的搭建和以后的想法,就留着下次吧～<br><a id="more"></a></p><h1 id="关于Markdown"><a href="#关于Markdown" class="headerlink" title="关于Markdown"></a>关于Markdown</h1><h2 id="宗旨和兼容性"><a href="#宗旨和兼容性" class="headerlink" title="宗旨和兼容性"></a>宗旨和兼容性</h2><p><a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>目标是实现易读易写，使用其编写的文件可以直接以纯文本发布。<br><a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>兼容<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>，语法目标是成为一种适用于网络的书写语言。  </p><p>相比HTML，Markdown是一种书写的格式，而HTML更多是一种发布的格式。<br>在Markdown文件内可以直接用HTML书写，不用额外标注。</p><p><a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>兼容<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>，但是在<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>等区块元素，比如<code>&lt;div&gt;</code>,<code>&lt;table&gt;</code>,<code>&lt;pre&gt;</code>,<code>&lt;p&gt;</code>,等标签，必须在前后加上空行和其他内容隔开，还要求他们的开始和结尾标签，不能用制表符或者空格来缩进。</p><p>在<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>区块标签内的<a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>格式语法不会被处理<br>但是在<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>区段标签内，<a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>语法是有效的。比如<code>&lt;span&gt;</code>,<code>&lt;cite&gt;</code>,<code>&lt;del&gt;</code></p><h2 id="特殊字符转换"><a href="#特殊字符转换" class="headerlink" title="特殊字符转换"></a>特殊字符转换</h2><p>在<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>中，&lt; 和 &amp; 想要显示字符原型需要用实体的形式，<code>&amp;lt</code> 和<br><code>&amp;amp</code><br>而在<a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>中，则可以自由书写字符。</p><p><strong>注</strong> :在code范围内，&lt; 和 &amp; 都会一定被转换成HTML实体，因此可以更方便的写出HTML code</p><h1 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h1><h2 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h2><p>段落由连续文本行组成，且允许段落内用换行符强迫换行。</p><p>如果想插入<code>&lt;br /&gt;</code>，需要在插入处按入两个以上空格然后回车。<br>段落的前后要有一个以上空行，且普通段落不可以用空格或者制表符缩进。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>支持两种标题的语法，类Setext和atx形式</p><h3 id="类Setext"><a href="#类Setext" class="headerlink" title="类Setext"></a>类Setext</h3><p>类Setext用底线的形式，利用任意数量=（最高阶）和－（第二阶）</p><p><strong>栗子</strong> :  </p><pre><code>This is an H1============This is an H2-------------  </code></pre><h3 id="Atx"><a href="#Atx" class="headerlink" title="Atx"></a>Atx</h3><p>Atx形式则是在行首插入一到六个#,对应标题一到六阶<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># H1</span><br><span class="line"></span><br><span class="line">##  H2</span><br><span class="line"></span><br><span class="line">##### H5</span><br></pre></td></tr></table></figure></p><p>可以选择闭合#，且结尾的#和开头不用一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># H1 #</span><br><span class="line"></span><br><span class="line">## H2 ##</span><br><span class="line"></span><br><span class="line">### H3  ###</span><br></pre></td></tr></table></figure></p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>在每行前面加上&gt;,(可以偷个懒在整个段落的第一行加上&gt;),并且区块引用可以嵌套，只要根据层次加上不同数量的&gt;</p><p><strong>栗子</strong> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; This is the fiest level of quoting </span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt; This is nested blokquote</span><br><span class="line">&gt;</span><br><span class="line">&gt; back to first level</span><br></pre></td></tr></table></figure></p><p>显示为:</p><blockquote><p>This is the fiest level of quoting </p><blockquote><p>This is nested blokquote</p></blockquote><p>back to first level  </p></blockquote><p>在引用区块内也可以使用其他<a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>语法， <strong>栗如</strong><br>标题、列表、代码区块  </p><pre><code>&gt; ## 这是一个标题。&gt;&gt; 1.   这是第一行列表项。&gt; 2.   这是第二行列表项。&gt;&gt; 给出一些例子代码：&gt;&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);  </code></pre><p>显示为:</p><blockquote><h2 id="这是一个标题。"><a href="#这是一个标题。" class="headerlink" title="这是一个标题。"></a>这是一个标题。</h2><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);  </code></pre></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>支持有序列表和无序列表两种</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用 + - 作为列表标记，个人偏向－，因为不用按shift</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表则使用数字接着一个英文句点:  </p><pre><code>1.  First one2.  Second one  </code></pre><p>显示为:</p><ol><li><p>First one</p></li><li><p>Second one  </p></li></ol><p>使用不同的数字不会有问题，但是看着不舒服，不推荐，还是顺序下来。<br>或者也可以只用一个数字。</p><p><strong>栗如</strong>  </p><pre><code>1.  First one1.  Second one1.  THird one  </code></pre><p>列表通常在最左边，但是也可以缩进，最多三个空格，标记后面一定要接上至少一个空格或者制表符<br>如果列表间由空行，<a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>会用\标签将内容裹起来</p><p><strong>栗子</strong> ：  </p><pre><code>*   Bird*   Magic  </code></pre><p>会被转换成：  </p><pre><code>&gt;    &lt;ul&gt;&gt;    &lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&gt;    &lt;/ul&gt;  </code></pre><p>显示为:</p><ul><li><p>Bird</p></li><li><p>Magic  </p></li></ul><p>列表可以包含多个段落，但是记得每个段落都要缩进哦</p><p>如果放引用，&gt;也要缩进<br>如果放代码区块，这个区块就要缩进两次<br>如果要在行首输入2017. 这种数字+句点+空白，可以在句点前面加反斜杠，即2017.</p><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>终于到这啦，代码区块最简单了，只要简单的缩进4个空格或者一个tab,或者,```这个标识,</p><p><strong>栗子</strong> ：  </p><ul><li>____printf(“hello world”)</li><li><tab>printf(“hello world”) </tab></li><li>```<br>printf(“hello world”)<br>```   </li></ul><p>显示为:   </p><pre><code>printf(&quot;hello world&quot;)</code></pre><p>markdown 会自动在代码区块外面加上\，而且代码区块里面&amp; &lt; &gt;会自动转成<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>实体，所以可以想怎么写code就怎么写</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格对齐方式  </p><pre><code>1.  居左: :----2.  居中: :----: 或者　-----3.  居右: ----:  </code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>可以在一行中用三个以上的<em>，-，_ 来建立一个分割线。行内不可以用其他东西，可以在</em> -中间插入空格。  </p><pre><code>* * *****---___  </code></pre><p>显示为:</p><hr><hr><hr><hr><h1 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>支持行内式和参考式两种，但都是用[]标记链接文字</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>在方括号后面接一个()在里面写上网址就行，如果要加title,在后面用单引号、双引号或是括弧把title文字包起来就行</p><p><strong>栗子</strong> ：  </p><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute.  </code></pre><p>如果想要链接到同主机资源，用相对路径  </p><pre><code>See my [About](/about/) page for details.  </code></pre><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>参考式是在后面加上另一个[],在里面写上标记  </p><pre><code>This is [an example][id] reference-style link.  </code></pre><p>可以在方括号中间加空格。。。<br>最后在文件的任意处，可以是段尾，可以是文件尾，把标记的链接定义出来  </p><pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;  </code></pre><p>要注意的是[]后面有一个:,还有一个以上的空格，id这个标记是不区分大小写的！链接网址可以用&lt;&gt;包起来。</p><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>隐式链接标记功能可以让你省略号指定的链接标记，这种情况标记会被视为等同于链接文字。<br>隐式链接只要在链接文字后面加上一个空的[]</p><p><strong>栗子</strong> ：  </p><pre><code>[Google][][Google]: http://google.com/  </code></pre><p>参考式链接的优点是比较好读，可以将一些标记的元数据移到段落之外，可以是段尾文件尾，这样就可以不让文章的阅读感被打断</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>如果你的<em> 和_ 两边都有空白，就只会被当成普通的</em> _</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果要标记一小段行内代码，可以用反引号｀把它包起来  </p><pre><code>Use the `printf()` function.  </code></pre><p>显示为:</p><p>Use the <code>printf()</code> function.  </p><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：  </p><pre><code>``There is a literal backtick (`) here.``  </code></pre><p>显示为:</p><p><code>There is a literal backtick (`) here.</code>  </p><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，酱紫就可以在区段开始就加入一个反引号  </p><pre><code>A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` ``  </code></pre><p>显示为:</p><p>A single backtick in a code span: <code>` </code></p><p>A backtick-delimited string in a code span: <code>`foo` </code>  </p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>使用行内式和参考式</p><h3 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h3><pre><code>![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;)  </code></pre><h3 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h3><pre><code>![Alt text][id][id]: url/to/image  &quot;Optional title attribute&quot;  </code></pre><p>这部分和链接是差不多的,但如果想要指定图片的宽高，可以使用普通的<code>&lt;img&gt;</code>标签.</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>用&lt;&gt;包起来的，都会被自动转成链接  </p><pre><code>&lt;http://example.com/&gt;  </code></pre><p>会被转成  </p><pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;  </code></pre><h2 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h2><p>可以用\插入一些在语法中有含义的符号  </p><pre><code>\   反斜线      `   反引号`*   星号       _   底线`{}  花括号      []  方括号()  括弧        #   井字号\+   加号       \-   减号.   英文句点    !   惊叹号  </code></pre><p>上面就是我学[Markdown][]的一些笔记，可能会有缺少的，有看到的可以指正～。</p>]]></content>
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning Markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/08/01/hello-world/"/>
      <url>/2017/08/01/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
