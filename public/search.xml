<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode-012-Integer to Roman</title>
      <link href="/2019/04/30/LeetCode-012-Integer-to-Roman/"/>
      <url>/2019/04/30/LeetCode-012-Integer-to-Roman/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/integer-to-roman/" target="_blank" rel="noopener">Problem</a></h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><blockquote><p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p></blockquote><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9. </li><li>X can be placed before L (50) and C (100) to make 40 and 90. </li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul><p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong> 3<br><strong>Output:</strong> “III”<br><strong>Input:</strong> 4<br><strong>Output:</strong> “IV”<br><strong>Input:</strong> 58<br><strong>Output:</strong> “LVIII”<br><strong>Input:</strong> 1994<br><strong>Output:</strong> “MCMXCIV”</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>这题，题目比较长，可能容易晕，但是很好理解，就是把一个整数转成罗马数字，给出了每个字符表示的大小</li><li>简单的办法就是从最大值开始，整除得到这个字母的个数，求模得到剩余的数字，然后再次对较小的整除、求模一直到“I”，就是1为止，过程中把字符加到结果字符串上</li><li>这里由于有对应关系，所以C++中用两个数组表示对应关系，也可以用map<string,int>表示，Python直接用字典就可以</string,int></li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> values[]=&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> chr[]=&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">13</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num/values[i];j++)</span><br><span class="line">                res += chr[i];</span><br><span class="line">            num %= values[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        values = &#123;<span class="string">"M"</span>:<span class="number">1000</span>,<span class="string">"CM"</span>:<span class="number">900</span>,<span class="string">"D"</span>:<span class="number">500</span>,<span class="string">"CD"</span>:<span class="number">400</span>,<span class="string">"C"</span>:<span class="number">100</span>,<span class="string">"XC"</span>:<span class="number">90</span>,<span class="string">"L"</span>:<span class="number">50</span>,<span class="string">"XL"</span>:<span class="number">40</span>,<span class="string">"X"</span>:<span class="number">10</span>,<span class="string">"IX"</span>:<span class="number">9</span>,<span class="string">"V"</span>:<span class="number">5</span>,<span class="string">"IV"</span>:<span class="number">4</span>,<span class="string">"I"</span>:<span class="number">1</span>&#125;</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> values.items():</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(num//value):</span><br><span class="line">                res += key</span><br><span class="line">            num %= value                </span><br><span class="line">        <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>有对应关系的时候，没必要写很多重复代码，用map或者两个列表对应起来，遍历一遍就可以 </li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> String </tag>
            
            <tag> Map </tag>
            
            <tag> Integer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-011-Container With Most Water</title>
      <link href="/2019/04/30/LeetCode-011-Container-With-Most-Water/"/>
      <url>/2019/04/30/LeetCode-011-Container-With-Most-Water/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">Problem</a></h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p><strong>Note</strong>: You may not slant the container and n is at least 2.<br><img src="/2019/04/30/LeetCode-011-Container-With-Most-Water/011.png"></p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong> [1,8,6,2,5,4,8,3,7]<br><strong>Output:</strong> 49</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>第一种方法就是暴力法，遍历每种情况，是<script type="math/tex">O(n^2)</script>复杂度，找到这里面的最大容量的情况，尝试了会超时，所以只能尽量优化到<script type="math/tex">O(n)</script>，于是有了下一种方法</li><li>第二种方法是用两个指针，初始情况是一个指向最开头，一个指向结尾，此时的宽度是最大的，然后比较当前两个指针所在位置的高度，低的一方向里面移动，移动会导致宽度减小，所以只能高度低的一边向内移，可能会有更高的。时间复杂度是<script type="math/tex">O(n)</script></li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.size() - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            res = max(res, min(height[i], height[j]) * (j - i));</span><br><span class="line">            height[i] &lt; height[j] ? i++ : j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(height) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        i = res = <span class="number">0</span></span><br><span class="line">        j = len(height) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            res = max(res, min(height[i], height[j]) * (j - i))</span><br><span class="line">            <span class="keyword">if</span> height[i]&lt;height[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>这道题思维上很简单，就是找到最大面积的两个值，但是如果简单的暴力法，中等难度的题目很明显没这么无脑，所以直接就超时了</li><li>之前做过的题目里也用到过两个指针遍历的方法，这样的<script type="math/tex">O(n)</script>复杂度还是很快的</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Math </tag>
            
            <tag> Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-010-Regular Expression Matching</title>
      <link href="/2019/04/27/LeetCode-010-Regular-Expression-Matching/"/>
      <url>/2019/04/27/LeetCode-010-Regular-Expression-Matching/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">Problem</a></h2><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*‘.</p><blockquote><p>‘.’ Matches any single character.<br>‘*‘ Matches zero or more of the preceding element.</p></blockquote><p>The matching should cover the entire input string (not partial).</p><p><strong>Note</strong>:</p><blockquote><p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.</p></blockquote><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong> s=”aa” p=”a”<br><strong>Output:</strong> false<br><strong>Input:</strong> s=”aa” p=”a*“<br><strong>Output:</strong> true<br><strong>Input:</strong> s=”ab” p=”.*“<br><strong>Output:</strong> true<br><strong>Input:</strong> s=”aab” p=”c*a*b”<br><strong>Output:</strong> true<br><strong>Input:</strong> s=”mississippi” p=”mis*is*p*.”<br><strong>Output:</strong> false</p><p>佛了，一道题搞了两个多小时，还是有bug…貌似方法错了，题解说了递归和DP，我用到了递归，可还是不行，DP就直接没想到，先码着回头改</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>递归，首字母匹配，并且后面的子串也匹配</li><li>DP动态规划，自上而下和自下而上两种，自下而上的不用递归，时间复杂度上会好点</li><li>自下而上的方法，在判断前一个字符的时候，因为后面的部分已经判断过了，所以可以直接从dp表里面取数据</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p><strong>递归方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.empty())<span class="keyword">return</span> s.empty();</span><br><span class="line">        <span class="comment">//第一个字符匹配或者是.匹配符</span></span><br><span class="line">        <span class="keyword">bool</span> first_match = (!s.empty() &amp;&amp;</span><br><span class="line">                            (p[<span class="number">0</span>]==s[<span class="number">0</span>]||p[<span class="number">0</span>]==<span class="string">'.'</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是字符加*</span></span><br><span class="line">        <span class="keyword">if</span>(p.length()&gt;=<span class="number">2</span> &amp;&amp; p[<span class="number">1</span>]==<span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (isMatch(s, p.substr(<span class="number">2</span>)) ||</span><br><span class="line">                (first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p)));</span><br><span class="line">        <span class="comment">//如果没有*或者少于两个字符</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp;</span><br><span class="line">                isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Java-Codes"><a href="#Java-Codes" class="headerlink" title="Java Codes"></a>Java Codes</h2><p><strong>自上而下的DP</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Result &#123;</span><br><span class="line">    TRUE, FALSE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Result[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> Result[text.length() + <span class="number">1</span>][pattern.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>, text, pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j] == Result.TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (j == pattern.length())&#123;</span><br><span class="line">            ans = i == text.length();</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> first_match = (i &lt; text.length() &amp;&amp;</span><br><span class="line">                                   (pattern.charAt(j) == text.charAt(i) ||</span><br><span class="line">                                    pattern.charAt(j) == <span class="string">'.'</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                ans = (dp(i, j+<span class="number">2</span>, text, pattern) ||</span><br><span class="line">                       first_match &amp;&amp; dp(i+<span class="number">1</span>, j, text, pattern));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = first_match &amp;&amp; dp(i+<span class="number">1</span>, j+<span class="number">1</span>, text, pattern);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i][j] = ans ? Result.TRUE : Result.FALSE;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自下而上的DP</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[text.length() + <span class="number">1</span>][pattern.length() + <span class="number">1</span>];</span><br><span class="line">        dp[text.length()][pattern.length()] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = text.length(); i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = pattern.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> first_match = (i &lt; text.length() &amp;&amp;</span><br><span class="line">                                       (pattern.charAt(j) == text.charAt(i) ||</span><br><span class="line">                                        pattern.charAt(j) == <span class="string">'.'</span>));</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || first_match &amp;&amp; dp[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = first_match &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Codes-1"><a href="#C-Codes-1" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>暂时码着自己代码，还有bug，在s遍历完了，p没遍历完时会出错…代码太丑陋了，只会暴力吗，僵硬…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> si=<span class="number">0</span>,pi=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sn=s.length(), pn=p.length();</span><br><span class="line">        <span class="keyword">for</span>(pi;pi&lt;pn,si&lt;sn;pi++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;s.substr(si)&lt;&lt;<span class="string">"\t"</span>&lt;&lt;p.substr(pi)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">switch</span>(p[pi])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'.'</span>:        <span class="comment">//任意单个字符</span></span><br><span class="line">                    si++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:        <span class="comment">//零个或者多个前面的元素</span></span><br><span class="line">                    <span class="keyword">if</span>(p[pi<span class="number">-1</span>]==<span class="string">'.'</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(pi==pn<span class="number">-1</span>)re后面还要改turn <span class="literal">true</span>;    <span class="comment">//如果.*是最后两个字符，直接返回true</span></span><br><span class="line">                        <span class="keyword">while</span>((p[pi+<span class="number">1</span>]==<span class="string">'.'</span>||p[pi+<span class="number">1</span>]==<span class="string">'*'</span>)&amp;&amp;pi&lt;pn)&#123; <span class="comment">//如果后面持续特殊字符</span></span><br><span class="line">                            pi++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(pi==pn)<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//如果到最后全是特殊字符</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//p[pi+1]是普通字符,让si++,找s[si]==p[pi+1]</span></span><br><span class="line">                        <span class="keyword">while</span>(s[si]!=p[pi+<span class="number">1</span>] &amp;&amp; si&lt;sn) si++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(p[pi<span class="number">-1</span>]!=s[si])<span class="comment">//零个</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//一个或者多个,后面部分的需要也匹配</span></span><br><span class="line">                    <span class="keyword">if</span>(p[pi<span class="number">-1</span>]==s[si])si++;</span><br><span class="line">                    <span class="keyword">if</span>(si==sn &amp;&amp; pi==pn<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(si==sn)si--;</span><br><span class="line">                    <span class="keyword">while</span>(p[pi<span class="number">-1</span>]==s[si] &amp;&amp;(si&lt;sn &amp;&amp; pi+<span class="number">1</span>&lt;pn &amp;&amp; isMatch(s.substr(si),p.substr(pi+<span class="number">1</span>))==<span class="literal">false</span>))&#123;</span><br><span class="line">                        si++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">if</span>(p[pi]==s[si] &amp;&amp; si&lt;sn)&#123;           <span class="comment">//相等就继续遍历</span></span><br><span class="line">                        si++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="comment">//不等，则判断后面是否有*，如果有，这个字符可以跳过,注意这里si并没有自增</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(p[pi]!=s[si] &amp;&amp; pi+<span class="number">1</span>&lt;pn &amp;&amp; p[pi+<span class="number">1</span>]==<span class="string">'*'</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pi==pn &amp;&amp; si==sn)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>评论区有人一行Java正则就搞定了，我觉得，python一行也够了…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>正则匹配这里，其实应该先想到递归和DP的，但是思维太局限，训练的少，虽然会递归和DP，但是想不起来用..仿佛读了假书..</li><li>算法题需要训练，不光是会算法，不然都不知道题目应该用什么算法…</li><li>这道题来说，递归还是挺容易写的，首字母匹配，后面的也匹配就可以，再考虑下*字符的情况</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode, DP, String, Match </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-009-Palindrome Number</title>
      <link href="/2019/04/19/LeetCode-009-Palindrome-Number/"/>
      <url>/2019/04/19/LeetCode-009-Palindrome-Number/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">Problem</a></h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>121<br><strong>Output:</strong>true<br><strong>Input:</strong>-121<br><strong>Output:</strong>true</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>首先想到的肯定是转成字符串，然后前后每个数判断是否相等，遇到不等的就return，这种方法会创建一个字符串，可能会慢一点</li><li>另一种方法也很容易想，就是把数字翻转过来嘛，再比较，相等的就是回文数了，但是可能会出现翻转后的数字溢出的问题，所以，可以只把后半部分的数字翻转，和前半部分的数字比较，如果是奇数位，可以把多一位的那部分除以10再比较。</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>转成字符串的方法，36ms，8.2MB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(int x) &#123;</span><br><span class="line">        string xstr = to_string(x);</span><br><span class="line">        int n = xstr.length();</span><br><span class="line">        for(int i=0;i&lt;n/2;i++)&#123;</span><br><span class="line">            if(xstr[i]!=xstr[n-i-1]) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>Python的代码和这个几乎一样，就不写了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>因为是简单题，所以没啥思维难度，很容易想到方法，要注意的还是细节上面小心点 </li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> String </tag>
            
            <tag> Palindrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MNIST入门-手写数字识别问题集锦</title>
      <link href="/2019/04/18/MNIST%E5%85%A5%E9%97%A8-%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
      <url>/2019/04/18/MNIST%E5%85%A5%E9%97%A8-%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>记录一下手写数字识别这个项目过程中遇到的问题，以及解决方法，还有一些图像处理方面的文章推荐</p></div><a id="more"></a><h2 id="canvas画笔位置有偏移"><a href="#canvas画笔位置有偏移" class="headerlink" title="canvas画笔位置有偏移"></a>canvas画笔位置有偏移</h2><ul><li>使用<code>window.innerHeight || document.documentElement.clientHeight</code>语句获取视窗高度，同理获得宽度</li><li>移动端获得视窗的高度和宽度后，根据高视窗的大小设置canvas大小，以及下方按钮文字等大小</li><li>PC端通过canvas的<code>mousedown、mousemove、mouseup</code>这三个事件绘图，画笔的起始点和新点用<code>event.clientX - canvas.offsetLeft</code>获取x，同理获取y,</li><li>移动端用<code>touchstart、touchmove、touchend</code>这三个事件，画笔的起始点和终点都用<code>event.targetTouches[0].clientX - canvas.offsetLeft</code>获取x，<code>event.targetTouches[0].clientY - canvas.offsetTop</code>获取y</li></ul><h2 id="canvas用二次贝塞尔曲线绘图"><a href="#canvas用二次贝塞尔曲线绘图" class="headerlink" title="canvas用二次贝塞尔曲线绘图"></a>canvas用二次贝塞尔曲线绘图</h2><p><strong>PC端mousemove事件代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PC端鼠标移动</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (onoff == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//获取新点和中点</span></span><br><span class="line">    <span class="keyword">var</span> newx = event.clientX - canvas.offsetLeft;</span><br><span class="line">    <span class="keyword">var</span> newy = event.clientY - canvas.offsetTop;</span><br><span class="line">    midx = <span class="number">0.5</span>*(newx+oldx);</span><br><span class="line">    midy = <span class="number">0.5</span>*(newy+oldy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置粗细和颜色</span></span><br><span class="line">    ctx.lineWidth = linew;</span><br><span class="line">    ctx.strokeStyle = linecolor;</span><br><span class="line">    ctx.lineCap = <span class="string">'round'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制二次贝塞尔</span></span><br><span class="line">    ctx.moveTo(oldx,oldy);</span><br><span class="line">    ctx.quadraticCurveTo( midx , midy , newx , newy );</span><br><span class="line">    ctx.stroke();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转移新旧坐标</span></span><br><span class="line">    oldx = newx;</span><br><span class="line">    oldy = newy;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mobile端mousemove事件代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动端手指移动</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tMove</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//获取新点和中点</span></span><br><span class="line">  <span class="keyword">var</span> touche = event.targetTouches[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> newx = touche.clientX - canvas.offsetLeft;</span><br><span class="line">  <span class="keyword">var</span> newy = touche.clientY - canvas.offsetTop;</span><br><span class="line">  midx = <span class="number">0.5</span>*(newx+oldx);</span><br><span class="line">  midy = <span class="number">0.5</span>*(newy+oldy);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置粗细和颜色</span></span><br><span class="line">  ctx.lineWidth = linew;</span><br><span class="line">  ctx.strokeStyle = linecolor;</span><br><span class="line">  ctx.lineCap = <span class="string">'round'</span></span><br><span class="line"></span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(oldx,oldy);</span><br><span class="line">  ctx.quadraticCurveTo(midx,midy,newx,newy);</span><br><span class="line">  ctx.stroke();</span><br><span class="line"></span><br><span class="line">  oldx = newx;</span><br><span class="line">  oldy = newy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="canvas的imageData像素级缩放"><a href="#canvas的imageData像素级缩放" class="headerlink" title="canvas的imageData像素级缩放"></a>canvas的imageData像素级缩放</h2><p>想要获得canvas上的图像并且缩放到28*28，使用scale方法是不行的，必须获取所有的像素RGBA值，然后横向隔一段取一个点，竖向隔几行取一行，一共横向每行取28个像素点，竖向取28行</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩放imageData,scale:倍数,返回:imageData</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scaleImageData</span>(<span class="params">imageData, scale</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scaled =</span><br><span class="line">      ctx.createImageData(imageData.width * scale, imageData.height * scale);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> row = <span class="number">0</span>; row &lt; imageData.height; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> col = <span class="number">0</span>; col &lt; imageData.width; col++) &#123;</span><br><span class="line">      <span class="keyword">var</span> sourcePixel = [</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">0</span>],</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">1</span>],</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">2</span>],</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">3</span>]</span><br><span class="line">      ];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; scale; y++) &#123;</span><br><span class="line">        <span class="keyword">var</span> destRow = <span class="built_in">Math</span>.floor(row * scale) + y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; scale; x++) &#123;</span><br><span class="line">          <span class="keyword">var</span> destCol = <span class="built_in">Math</span>.floor(col * scale) + x;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            scaled.data[(destRow * scaled.width + destCol) * <span class="number">4</span> + i] = sourcePixel[i];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  alert(scaled.data.length);</span></span><br><span class="line">  <span class="keyword">return</span> scaled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取服务器的ip"><a href="#获取服务器的ip" class="headerlink" title="获取服务器的ip"></a>获取服务器的ip</h2><p>这里取巧了，直接从浏览器显示部分获取<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取服务器ip，运行时urlPath为https://192.168.137.1:8000/</span></span><br><span class="line"><span class="function">function <span class="title">getRemoteIp</span><span class="params">()</span></span>&#123;</span><br><span class="line">  var urlPath = window.document.location.href;  <span class="comment">//浏览器显示地址 http://10.15.5.83:5555/ISV/demo.aspx?a=1&amp;b=2</span></span><br><span class="line">  <span class="comment">// var docPath = window.document.location.pathname; //文件在服务器相对地址 /ISV/demo.aspx</span></span><br><span class="line">  <span class="comment">// var index = urlPath.indexOf(docPath);</span></span><br><span class="line">  var serverPath = urlPath.substring(<span class="number">7</span>, urlPath.length-<span class="number">1</span>);<span class="comment">//服务器ip 192.168.137.1</span></span><br><span class="line">  <span class="keyword">return</span> serverPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UA检测"><a href="#UA检测" class="headerlink" title="UA检测"></a>UA检测</h2><p>因为要适配移动端和PC端，所以简单的UA检测还是必要的，这里没有做的很复杂<br>主要就是通过检测<code>navigator.platfowm</code>中的关键词来判断</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var ua = navigator.userAgent; </span><br><span class="line">var system = &#123;</span><br><span class="line">  win : <span class="keyword">false</span>,</span><br><span class="line">  mac : <span class="keyword">false</span>,</span><br><span class="line">  linux : <span class="keyword">false</span>,</span><br><span class="line">  <span class="comment">// mobile</span></span><br><span class="line">  iphone : <span class="keyword">false</span>,</span><br><span class="line">  android : <span class="keyword">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p = navigator.platform;</span><br><span class="line">system.win = p.indexOf(<span class="string">'Win'</span>) == <span class="number">0</span>;</span><br><span class="line">system.mac = p.indexOf(<span class="string">'Mac'</span>) == <span class="number">0</span>;</span><br><span class="line">system.linux = p.indexOf(<span class="string">'Linux'</span>) == <span class="number">0</span>;</span><br><span class="line">system.iphone = ua.indexOf(<span class="string">'iPhone'</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">system.android = ua.indexOf(<span class="string">'Android'</span>) &gt; -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(system.win||system.mac)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(system.android||system.iphone)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="python根据数组生成图片"><a href="#python根据数组生成图片" class="headerlink" title="python根据数组生成图片"></a>python根据数组生成图片</h2><p>dtype一定要写的，不写生成错误<br>imgData就是图片的RGBA数据数组，要转成np数组才可以用PIL的Image.fromarray()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = np.asarray(imgData, dtype=np.uint8)</span><br><span class="line">image = Image.fromarray(array, <span class="string">'RGBA'</span>) </span><br><span class="line">image.save(outputImgPath + imgName +<span class="string">'.png'</span>)</span><br></pre></td></tr></table></figure><h2 id="将RGBA转换为RGB格式数组"><a href="#将RGBA转换为RGB格式数组" class="headerlink" title="将RGBA转换为RGB格式数组"></a>将RGBA转换为RGB格式数组</h2><p>网上看了很多，有用PIL的，还有直接写算法转换的，用opencv的…很多<br>这里发现PIL的不好用，读出来还是RGBA的格式，而且没办法用函数在数组上转换</p><p>最后解决办法是:</p><ul><li>从前端传过来的数据是字典类型，先获取values()</li><li>将dict.vlues这个数组转换为ndarray数组</li><li>转换完了,再把这个RGBA数组用 PIL 转换为图片</li><li>用save()方法保存为临时图片</li><li>用opencv读取临时图片的RGB通道的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 将图片数据转换为ndarray类型</span><br><span class="line">npData = np.array(imageData,dtype=np.uint8).reshape(<span class="number">28</span>,<span class="number">28</span>,<span class="number">4</span>)</span><br><span class="line"># 将RGBA格式数组转换为图片</span><br><span class="line">image = Image.fromarray(npData, <span class="string">'RGBA'</span>) </span><br><span class="line"># 保存临时图片</span><br><span class="line">image.save(<span class="string">'static/images/npimg.png'</span>)</span><br><span class="line"></span><br><span class="line"># 用opencv读取图片的RGB数据</span><br><span class="line">rgbImage = cv2.imread(<span class="string">'static/images/npimg.png'</span>, cv2.IMREAD_COLOR)</span><br></pre></td></tr></table></figure><h2 id="cv2-imread-path-flags"><a href="#cv2-imread-path-flags" class="headerlink" title="cv2.imread(path[, flags])"></a>cv2.imread(path[, flags])</h2><p>cv2的imread函数的第二个参数这里说明下:</p><blockquote><p>如果不设置，读进来的是BGR格式的数据，值在0-255,flag一共有3个取值<br>cv2.IMREAD_COLOR : 读入彩色图片,任何与透明度相关通道的会被忽视,默认以这种方式读入.<br>cv2.IMREAD_GRAYSCALE : 以灰度图的形式读入图片<br>cv2.IMREAD_UNCHANGED : 保留读取图片原有的颜色通道.</p></blockquote><p>可以简单的用<strong>-1,0,1</strong>来分别表示这3个flag</p><h2 id="Python图像处理"><a href="#Python图像处理" class="headerlink" title="Python图像处理"></a>Python图像处理</h2><h3 id="图片的读写方式总结"><a href="#图片的读写方式总结" class="headerlink" title="图片的读写方式总结"></a>图片的读写方式总结</h3><p>找到一个很全的博客，推荐一下：<a href="https://www.jb51.net/article/135307.htm" target="_blank" rel="noopener">Python各类图像库的图片读写方式总结</a></p><h3 id="opencv的基本操作"><a href="#opencv的基本操作" class="headerlink" title="opencv的基本操作"></a>opencv的基本操作</h3><p>推荐看看这篇文章：<a href="https://www.jianshu.com/p/ed00179ede34" target="_blank" rel="noopener">点击跳转</a></p><h3 id="tensorflow简单的图像处理"><a href="#tensorflow简单的图像处理" class="headerlink" title="tensorflow简单的图像处理"></a>tensorflow简单的图像处理</h3><p>推荐链接：<a href="https://blog.csdn.net/jia20003/article/details/79118769" target="_blank" rel="noopener">使用TensorFlow进行简单的图像处理</a></p><h3 id="PIL格式转换"><a href="#PIL格式转换" class="headerlink" title="PIL格式转换"></a>PIL格式转换</h3><p>推荐链接：<a href="https://blog.csdn.net/icamera0/article/details/50843172" target="_blank" rel="noopener">Python图像处理库PIL中图像格式转换（一）</a></p><h2 id="对图片灰度化"><a href="#对图片灰度化" class="headerlink" title="对图片灰度化"></a>对图片灰度化</h2><p>如果只是灰度的话可以用PIL的convert函数，很方便，但是这里要用tensorflow，所以得用<code>tf.image_to_grayscale(imageData)</code>这个函数。注意事先要先将数据格式转换为<code>tf.float32</code>类型的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将rgb图片转换为float32格式</span></span><br><span class="line">rgbImage = tf.image.convert_image_dtype(rgbImage, tf.float32)</span><br><span class="line"><span class="comment"># 将图片灰度化得到(28,28,1)格式的tensor</span></span><br><span class="line">rgbImage = tf.image.rgb_to_grayscale(rgbImage</span><br></pre></td></tr></table></figure><h2 id="后端改变图片的背景和画笔颜色数据"><a href="#后端改变图片的背景和画笔颜色数据" class="headerlink" title="后端改变图片的背景和画笔颜色数据"></a>后端改变图片的背景和画笔颜色数据</h2><p>出于美观，前端并不是黑底白字，但是模型训练的是黑底白字的，虽然后面测试用了灰度数据，还是会不准确，所以在数据处理前，对imageData中的部分像素进行修改，将橙色变为黑色，黑色画笔变为白色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将橙色的背景转换为黑色,将画笔的黑色转为白色</span></span><br><span class="line"><span class="comment"># input: RGBA格式图片数据</span></span><br><span class="line"><span class="comment"># output: 修改过的RGBA格式图片数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reveBlack</span><span class="params">(imageData)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(imageData),<span class="number">4</span>):</span><br><span class="line">        <span class="comment"># 如果画笔为白色</span></span><br><span class="line">        <span class="keyword">if</span> imageData[i]==<span class="number">0</span> <span class="keyword">and</span> imageData[i+<span class="number">1</span>]==<span class="number">0</span> <span class="keyword">and</span> imageData[i+<span class="number">2</span>]==<span class="number">0</span>:</span><br><span class="line">            imageData[i]=imageData[i+<span class="number">1</span>]=imageData[i+<span class="number">2</span>]=<span class="number">255</span></span><br><span class="line">        <span class="comment"># 如果背景为橙色</span></span><br><span class="line">        <span class="keyword">if</span> imageData[i]==<span class="number">255</span> <span class="keyword">and</span> imageData[i+<span class="number">1</span>]==<span class="number">165</span> <span class="keyword">and</span> imageData[i+<span class="number">2</span>]==<span class="number">0</span>:</span><br><span class="line">            imageData[i]=imageData[i+<span class="number">1</span>]=imageData[i+<span class="number">2</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> imageDat</span><br></pre></td></tr></table></figure><h2 id="tensor和numpy数组转换"><a href="#tensor和numpy数组转换" class="headerlink" title="tensor和numpy数组转换"></a>tensor和numpy数组转换</h2><h3 id="tensor转ndarray"><a href="#tensor转ndarray" class="headerlink" title="tensor转ndarray"></a>tensor转ndarray</h3><p>由于项目里面是模型恢复，所以没有初始化这步<br>有两种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 将tensor转换为ndarray</span></span><br><span class="line">init = tf.initialize_all_variables()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="comment"># 第一种</span></span><br><span class="line">    ndName = tensorName1.eval(session=sess)</span><br><span class="line">    <span class="comment">#第二种</span></span><br><span class="line">    ndName = sess.run(tensorName2)</span><br></pre></td></tr></table></figure><h2 id="ndarray转tensor"><a href="#ndarray转tensor" class="headerlink" title="ndarray转tensor"></a>ndarray转tensor</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将ndarray转换为tensor</span></span><br><span class="line">tensorName =  tf.convert_to_tensor(ndName, dtype = tf.float32)</span><br></pre></td></tr></table></figure><h2 id="使用训练好的模型"><a href="#使用训练好的模型" class="headerlink" title="使用训练好的模型"></a>使用训练好的模型</h2><p><strong>参考链接：</strong><a href="https://blog.csdn.net/yanchujian88/article/details/80559936" target="_blank" rel="noopener">言初见的CSDN博客</a></p><p>训练用的算法是Lenet-5，下面的代码是部分调用模型代码，因为只有一张图片的数据，并不是用整个测试集，所以有些地方会有点不一样</p><p>主要还是通过恢复模型，传入图片数据来获得预测结果</p><p>注意点：</p><ol><li>x占位符的shape，要注意个train的一致，第一个shape要是1，因为只有一个图片</li><li>使用tf.argmax(y,1)函数获得最大预测的下标,这里就是结果了，因为是0-9正好对应了下标</li><li>输入的feed_dict测试数据必须是ndarray，不可以是tensor，因此要转换以下</li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义输入格式(1,28,28,1)</span></span><br><span class="line">x = tf.placeholder(tf.float32, [<span class="number">1</span>, </span><br><span class="line">                                mnist_inference.IMAGE_SIZE, </span><br><span class="line">                                mnist_inference.IMAGE_SIZE, </span><br><span class="line">                                mnist_inference.NUM_CHANNEL], </span><br><span class="line">                                name=<span class="string">'x-input'</span>)</span><br><span class="line"><span class="comment">#直接通过调用封装好的函数来计算前向传播的结果 </span></span><br><span class="line">y = mnist_inference.interence(x,<span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用tf.argmax(y, 1)就可以得到输入样例的预测类别 </span></span><br><span class="line">prediction = tf.argmax(y, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过变量重命名的方式来加载模型</span></span><br><span class="line"><span class="comment"># 所有滑动平均的值组成的字典,处在/ExponentialMovingAverage下的值  </span></span><br><span class="line"><span class="comment"># 为了方便加载时重命名滑动平均量，tf.train.ExponentialMovingAverage类  </span></span><br><span class="line"><span class="comment"># 提供了variables_to_store函数来生成tf.train.Saver类所需要的变量  </span></span><br><span class="line"><span class="comment"># 这些值要从模型中提取</span></span><br><span class="line">variable_averages = tf.train.ExponentialMovingAverage(mnist_train.MOVING_AVERAGE_DECAY)</span><br><span class="line">variable_to_restore = variable_averages.variables_to_restore()</span><br><span class="line">saver = tf.train.Saver(variable_to_restore)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用数据测试模型</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess: </span><br><span class="line">    <span class="comment"># get_checkoutpoint_state()会通过checkoutpoint文件自动找到目录中最新模型的文件名</span></span><br><span class="line">    ckpt = tf.train.get_checkpoint_state(mnist_train.MODEL_PATH)</span><br><span class="line">    <span class="keyword">if</span> ckpt <span class="keyword">and</span> ckpt.model_checkpoint_path:</span><br><span class="line">        <span class="comment"># 加载模型</span></span><br><span class="line">        saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将tensor转换为np数组,这里也可以用np的reshape方法</span></span><br><span class="line">        rgbNpData = tf.reshape(rgbImage,[<span class="number">1</span>,</span><br><span class="line">                                            mnist_inference.IMAGE_SIZE, </span><br><span class="line">                                            mnist_inference.IMAGE_SIZE, </span><br><span class="line">                                            mnist_inference.NUM_CHANNEL])</span><br><span class="line">        <span class="comment"># 将tensor转换为ndarray</span></span><br><span class="line">        reshaped_data = rgbNpData.eval()</span><br><span class="line">        <span class="comment"># 将输入的测试数据格式调整为一个四维矩阵</span></span><br><span class="line">        validate_feed = &#123;x: reshaped_data&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获得预测的结果数组</span></span><br><span class="line">        predictionNum = sess.run(prediction, feed_dict = validate_feed)</span><br><span class="line">        print(<span class="string">"Number is %d"</span> %(predictionNum[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">tf.reset_default_graph()</span><br></pre></td></tr></table></figure><h2 id="报错：Error-the-tensor’s-graph-is-different-from-the-session’s-graph"><a href="#报错：Error-the-tensor’s-graph-is-different-from-the-session’s-graph" class="headerlink" title="报错：Error: the tensor’s graph is different from the session’s graph"></a>报错：Error: the tensor’s graph is different from the session’s graph</h2><p>这是因为session里面的图和使用的图不一样导致的，刚开始不清楚，把参考的博客上面的那句： with tf.Graph().as_default() as g:写上去了，导致默认图被设置成了g，但是用的又是恢复的图，所以不一样了</p><p>解决办法炒鸡简单…但是debug的过程里就一直没意识到就是了…就是把那句话去掉就行了哇</p><h2 id="报错：List-of-Tensors-when-single-Tensor-expected"><a href="#报错：List-of-Tensors-when-single-Tensor-expected" class="headerlink" title="报错：List of Tensors when single Tensor expected"></a>报错：List of Tensors when single Tensor expected</h2><p>使用tf.constant()函数的时候可能会报这个错误</p><p>看看这个函数的定义：</p><blockquote><p>def constant(value, dtype=None, shape=None, name=”Const”, verify_shape=False)<br>value: A constant value (or list) of output type dtype.<br>Returns: A Constant Tensor.</p></blockquote><p>问题也应该清楚了，constant要求输入的是list，用的时候如果传入了tensor类型的，当然就不可以了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遇到的问题还是很多的，好几个bug都折磨了我几个小时，找不到bug在哪太艰难了，深深的感受到要学了点基础再来做项目，就说这个tensorflow，没有大致的学一遍，遇到问题完全就是无头苍蝇，不好排错</p><p>一个项目学到的东西还是挺多的，实战真的很重要啊</p>]]></content>
      
      
      <categories>
          
          <category> MachineLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Daily </tag>
            
            <tag> ML </tag>
            
            <tag> MNIST </tag>
            
            <tag> Tensorflow </tag>
            
            <tag> LeNet-5 </tag>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-008-String to Integer (atoi)</title>
      <link href="/2019/04/16/LeetCode-008-String-to-Integer-atoi/"/>
      <url>/2019/04/16/LeetCode-008-String-to-Integer-atoi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">Problem</a></h2><p>实现C++的atoi()函数<br>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p></div><a id="more"></a><div class="note info"><p><strong>Note:</strong>  </p><blockquote><p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: <script type="math/tex">[−2^{31},  2^{31} − 1]</script>. If the numerical value is out of the range of representable values, INT_MAX <script type="math/tex">2^{31}-1</script> or INT_MIN <script type="math/tex">-2^{31}</script> is returned.</p></blockquote></div><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>“42”<br><strong>Output:</strong>42<br><strong>Input:</strong>“    -42”<br><strong>Output:</strong>-42<br><strong>Input:</strong>“words and 987”<br><strong>Output:</strong>987</p><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>没啥思维量，就是简单的遍历每个字符，然后设置两个flag，一个用于判断有没有到数字部分，第二个判断是不是负数，如果没到数字部分，就要分情况讨论，如果到了数字部分，判断到没到非数字，到了就退出，没到就每个数字加到结果上</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>每个字符遍历过去的方法，12ms，8.4MB<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">//是否到数字部分</span></span><br><span class="line">        <span class="keyword">int</span> flag2 = <span class="number">1</span>;<span class="comment">//负数标志，有就变为-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//已经开始数字部分的情况，即flag = true</span></span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;INT_MAX)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag &amp;&amp; (str[i]&lt;<span class="string">'0'</span> || str[i]&gt;<span class="string">'9'</span>)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag) tmp = tmp*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//还没到数字的情况，前面那部分，分为空格、非数字非符号、数字或正负号</span></span><br><span class="line">            <span class="keyword">if</span>(!flag &amp;&amp; str[i]==<span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!flag &amp;&amp; str[i]!=<span class="string">'+'</span> &amp;&amp; str[i]!=<span class="string">'-'</span> &amp;&amp; (str[i]&lt;<span class="string">'0'</span> || str[i]&gt;<span class="string">'9'</span>) )</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!flag &amp;&amp; (str[i]==<span class="string">'+'</span> || str[i]==<span class="string">'-'</span>|| (str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)))&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(str[i]==<span class="string">'-'</span>)flag2 = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(str[i]==<span class="string">'+'</span>||str[i]==<span class="string">'-'</span>)<span class="keyword">continue</span>;</span><br><span class="line">                tmp = tmp*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp*=flag2;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(tmp&lt;INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>借用了<a href="http://chengfeng96.com/blog/2017/03/07/LeetCode-No-8-String-to-Integer-atoi/" target="_blank" rel="noopener">HazzaCheng的代码</a>,这道题用python解简直作弊..<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        ls = list(s.strip())</span><br><span class="line">        <span class="keyword">if</span> len(ls) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        sign = <span class="number">-1</span> <span class="keyword">if</span> ls[<span class="number">0</span>] == <span class="string">'-'</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> ls[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">'-'</span>, <span class="string">'+'</span>]:</span><br><span class="line">            <span class="keyword">del</span> ls[<span class="number">0</span>]</span><br><span class="line">        res, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(ls) <span class="keyword">and</span> ls[i].isdigit():</span><br><span class="line">            res = res * <span class="number">10</span> + ord(ls[i]) - ord(<span class="string">'0'</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">-2</span> ** <span class="number">31</span>, min(sign * res, <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>要注意各种情况的判断</li><li>就算用了long long作为中转，在循环中也要判断是否已经超过int表示范围，提前break，可能出现longlong都无法表示的测试</li><li>注意空串</li><li>注意前面的符号</li><li>不应该进行的操作及时continue掉</li><li>还是会出现’+’号的</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-007-Reverse Integer</title>
      <link href="/2019/04/16/LeetCode-007-Reverse-Integer/"/>
      <url>/2019/04/16/LeetCode-007-Reverse-Integer/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">Problem</a></h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong>123<br><strong>Output:</strong>321<br><strong>Input:</strong>-123<br><strong>Output:</strong>-321</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>用字符串的方法，先将输入转换成字符串，然后判断第一个字符是不是‘-’，是就加到结果字符串上，最后逆序添加字符到结果字符串上，再将字符串转换成长整数，return之前判断是否有溢出</li><li>题解的办法是用取模的方法获取每一位之后再加到结果上，遍历一遍，但是这种方法在计算结果时容易溢出，要事先检查</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>我的字符串方法，4ms，8.3MB<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(x);</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'-'</span>)&#123;</span><br><span class="line">            str = str.substr(<span class="number">1</span>,str.length());</span><br><span class="line">            res+=<span class="string">'-'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            res+=str[str.length()<span class="number">-1</span>-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> tmp =  atol(res.c_str());</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span> || tmp&lt;<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)*(<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>题解的数学方法，8ms，8.3MB<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>Python的和第一种方法一样做，差别不大</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>C++中int型最大最小可以用<limits.h>中的INT_MAX和INT_MIN表示，分别是<script type="math/tex">2^31=2147483647</script>和<script type="math/tex">-2^31-1=-2147483648</script></limits.h></li><li>C++中有atoi(),atol(),c_str(),to_string()这几种方法，分别是字符串转int，字符串转long，字符串转C串，整形转字符串</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> String </tag>
            
            <tag> Reverse </tag>
            
            <tag> Big Number </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-006-ZigZag Conversion</title>
      <link href="/2019/04/15/LeetCode-006-ZigZag-Conversion/"/>
      <url>/2019/04/15/LeetCode-006-ZigZag-Conversion/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/zigzag-conversion/submissions/" target="_blank" rel="noopener">Problem</a></h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><blockquote><p>P   A   H   N<br>A P L S I I G<br>Y   I   R  </p></blockquote><p>And then read line by line: <strong>“PAHNAPLSIIGYIR”</strong><br>Write the code that will take a string and make this conversion given a number of rows:   </p><blockquote><p>string convert(string s, int numRows);</p></blockquote></div><a id="more"></a><div class="note info"><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p><strong>Input:</strong> s = “PAYPALISHIRING”, numRows = 3<br><strong>Output:</strong> “PAHNAPLSIIGYIR”</p><p><strong>Input:</strong> s = “PAYPALISHIRING”, numRows = 4<br><strong>Output:</strong> “PINALSIGYAHRPI”<br><strong>Explanation:</strong></p><blockquote><p>P     I    N<br>A   L S  I G<br>Y A   H R<br>P     I</p></blockquote></div><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>想到的是用数学方法，遍历每一行，然后计算每一行字符的位置，逐个添加进去，是题解的第二种方法。每行的字符位置都满足一个数列，所以可以很简单的计算出来。时间复杂度是<script type="math/tex">O(n)</script>.</li><li>题解还给了一种方法是按行排序，每一行建一个字符串，从左向右迭代源字符串，判断每个字符是属于哪一行，然后加到那一行的字符串上，最后对每行字符串拼接，原理感觉和上一种方法差不多。时间复杂度也是<script type="math/tex">O(n)</script>  </li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>自己想到的解法，用时12ms，内存10.2MB，超过99.51%感觉还是挺快的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">ceil</span>(len*<span class="number">1.0</span>/numRows);</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">2</span>*numRows<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;   <span class="comment">//遍历行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=num;j++)&#123;    <span class="comment">//遍历每个Z</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; (j<span class="number">-1</span>)*d&lt;len)&#123;  <span class="comment">//第一行</span></span><br><span class="line">                    res+=s[(j<span class="number">-1</span>)*d];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i==(numRows<span class="number">-1</span>) &amp;&amp; ((j<span class="number">-1</span>)*d+numRows<span class="number">-1</span>)&lt;len)&#123; <span class="comment">//最后一行</span></span><br><span class="line">                    res+=s[(j<span class="number">-1</span>)*d+numRows<span class="number">-1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123; <span class="comment">//其余行</span></span><br><span class="line">                        <span class="keyword">if</span>((j<span class="number">-1</span>)*d+i&lt;len)</span><br><span class="line">                            res+=s[(j<span class="number">-1</span>)*d+i];</span><br><span class="line">                        <span class="keyword">if</span>(j*d-i&lt;len)</span><br><span class="line">                            res+=s[j*d-i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>第二种遍历每个字符的解法:测试是20ms，12.6MB<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; rows(min(numRows, <span class="keyword">int</span>(s.size())));</span><br><span class="line">        <span class="keyword">int</span> curRow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> goingDown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            rows[curRow] += c;</span><br><span class="line">            <span class="keyword">if</span> (curRow == <span class="number">0</span> || curRow == numRows - <span class="number">1</span>) goingDown = !goingDown;</span><br><span class="line">            curRow += goingDown ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> row : rows) ret += row;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        slen = len(s)</span><br><span class="line">        num = math.ceil(slen/numRows);</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        d = <span class="number">2</span>*numRows<span class="number">-2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> numRows==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,num+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">and</span> (j<span class="number">-1</span>)*d&lt;slen:</span><br><span class="line">                    res = res + s[(j<span class="number">-1</span>)*d]</span><br><span class="line">                <span class="keyword">elif</span> i==numRows<span class="number">-1</span> <span class="keyword">and</span> (j<span class="number">-1</span>)*d+numRows<span class="number">-1</span>&lt;slen:</span><br><span class="line">                    res = res + s[(j<span class="number">-1</span>)*d+numRows<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    <span class="keyword">if</span> (j<span class="number">-1</span>)*d+i&lt;slen:</span><br><span class="line">                        res = res + s[(j<span class="number">-1</span>)*d+i]</span><br><span class="line">                    <span class="keyword">if</span>(j*d-i&lt;slen):</span><br><span class="line">                        res = res + s[j*d-i]</span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>很多题目可以直接从数学角度着手，会很方便</li><li>暴力法在很多时候都有用啊，时间复杂度不够再优化下说不定就过了</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Math </tag>
            
            <tag> String </tag>
            
            <tag> Split </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-005-Longest Palindromic Substring</title>
      <link href="/2019/04/14/LeetCode-005-Longest-Palindromic-Substring/"/>
      <url>/2019/04/14/LeetCode-005-Longest-Palindromic-Substring/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/longest-palindromic-substring/solution/" target="_blank" rel="noopener">Problem</a></h2><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><blockquote><p>“babad” —-&gt; “bab”<br>“cbbd” —-&gt; “bb”</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li><strong>暴力法</strong>：首先想到的当然是暴力法…暴力大法好/斜眼笑</li><li><strong>遍历中心点暴力:</strong>感觉直接暴力子串太幼稚，想了想可以遍历所有字串的中心点，于是产生了下面第一种解法，遍历每个下标，然后对子串是奇数个字符和偶数个字符分别查找最长子串，记录最长子串起始下标和长度，最后返回。时间复杂度是<script type="math/tex">O(n^2)</script></li><li><strong>动态规划: </strong>看了题解，里面讲到了动态规划的解法，首先是有一个二维数组P[i, j]，用于保存i-j位置这段子串是不是回文，是就是true，不是就是false，初始化P中长度为1和2的子串，P[i-1, j+1]=True相当于：<strong>P[i, j]==true &amp;&amp; S[i-1]==S[j+1]</strong></li><li><strong>翻转字符串和原字符串比较：</strong>:把字符串翻转，然后和原来的比较，找到最长的公共子串就是要的结果，这种方法有缺陷就是可能存在非回文子串的反向副本，改进的办法也很简单，就是比较找到的公共子串的索引是否和反向子串的原索引相同，不相同就可以排除了</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>遍历中心点法：用了32ms，8.8MB</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//判断子串为奇数个字符时</span></span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i-tmp&gt;=<span class="number">0</span> &amp;&amp; i+tmp&lt;n &amp;&amp; s[i-tmp]==s[i+tmp])&#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="number">2</span>*tmp+<span class="number">1</span>)&gt;maxLen)&#123;</span><br><span class="line">                    maxLen = <span class="number">2</span>*tmp+<span class="number">1</span>;</span><br><span class="line">                    pos = i-tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//断子串为偶数个字符时</span></span><br><span class="line">            tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i-tmp+<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; i+tmp&lt;n &amp;&amp; s[i-tmp+<span class="number">1</span>]==s[i+tmp] )&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>*tmp&gt;maxLen)&#123;</span><br><span class="line">                    maxLen = <span class="number">2</span>*tmp;</span><br><span class="line">                    pos = i-tmp+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substr(pos,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>动态规划版本：用了140ms，13.1MB</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> p[n][n]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化数组边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            p[i][i]=<span class="number">1</span>;</span><br><span class="line">            p[i][i+<span class="number">1</span>]=s[i]==s[i+<span class="number">1</span>]?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(p[i][i+<span class="number">1</span>])&#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                maxLen = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p[n<span class="number">-1</span>][n<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//动规循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;   <span class="comment">//长度-1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;n;j++)&#123;   <span class="comment">//起始下标</span></span><br><span class="line">                <span class="keyword">if</span>( p[j+<span class="number">1</span>][j+i<span class="number">-1</span>]==<span class="number">1</span> &amp;&amp; s[j]==s[j+i])&#123;</span><br><span class="line">                    p[j][j+i]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i+<span class="number">1</span>)&gt;maxLen)&#123;</span><br><span class="line">                        maxLen = i+<span class="number">1</span>;</span><br><span class="line">                        pos = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(pos,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>算法题要注意边界问题，遍历的时候别下标越界</li><li>C++中数组要注意初始化，不会像java那样有默认值</li><li>动态规划注意初始化边界</li><li>暴力的时候注意子串长度还可以是偶数</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Math </tag>
            
            <tag> String </tag>
            
            <tag> Palindromic </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-004-Median of Two Sorted Arrays</title>
      <link href="/2019/04/14/LeetCode-004-Median-of-Two-Sorted-Arrays/"/>
      <url>/2019/04/14/LeetCode-004-Median-of-Two-Sorted-Arrays/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">Problem</a></h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.<br>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br>You may assume nums1 and nums2 cannot be both empty</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><blockquote><p>a = [1, 3], b = [2] —-&gt; 2.0<br>a = [1, 2], b = [3, 4] —-&gt; 2.5</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>刚开始是一点思路都么得…如果没有O(log (m+n))的限制，还能用遍历的方法找到，但是加了log，应该是要用二叉的</li><li>题解里面给出了将两个数组，以i，j为分界，分为两部分:[0,i-1], [i,m-1], [0, j-1], [j,n-1]，使得左边的[0,i-1], [0,j-1] 全都小于右边的[i,m-1], [j,n-1]，利用中位数的意义</li><li>前提要<strong>确保m&lt;=n</strong>，这很重要！刚开始就弄反了导致一直找不到bug..</li><li>同时配合二叉搜索，这时搜索的条件就变成了：如果左边的有大于右边的数，就缩小，如果右边的有小于左边的数，就扩大</li><li>这里需要判断几个边界条件：i=0, j=0, i=m, j=n这四种</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>用时是36ms, 内存9.6MB</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n=nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)&#123;    <span class="comment">//确保m&lt;=n,不然会造成j可能是负数</span></span><br><span class="line">            nums1.swap(nums2);</span><br><span class="line">            <span class="keyword">int</span> tmp=m; m=n; n=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> imin=<span class="number">0</span>,imax=m,half=(m+n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(imin&lt;=imax)&#123;</span><br><span class="line">            <span class="keyword">int</span> i=(imin+imax)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j=half - i;</span><br><span class="line">            <span class="keyword">int</span> maxLeft = <span class="number">0</span>, minRight=<span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i&lt;imax &amp;&amp; nums2[j<span class="number">-1</span>]&gt;nums1[i])&#123;  <span class="comment">//i太小</span></span><br><span class="line">                imin = i+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;imin &amp;&amp; nums1[i<span class="number">-1</span>]&gt;nums2[j])&#123;   <span class="comment">//i太大</span></span><br><span class="line">                imax=i<span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//maxleft = max(nums1[i-1],nums2[j-1]), i, j可能是0, i-1就可能为-1</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123; maxLeft=nums2[j<span class="number">-1</span>];&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123; maxLeft = nums1[i<span class="number">-1</span>];&#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; maxLeft = nums1[i<span class="number">-1</span>]&gt;nums2[j<span class="number">-1</span>]?nums1[i<span class="number">-1</span>]:nums2[j<span class="number">-1</span>];&#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果是奇数个</span></span><br><span class="line">                <span class="keyword">if</span>((m+n)%<span class="number">2</span>)&#123; <span class="keyword">return</span> maxLeft;&#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//maxRight = max(nums1[i], nums2[j]), i, j可能是m和n，nums1[i]就会越界</span></span><br><span class="line">                <span class="keyword">if</span>(i==m)&#123; minRight=nums2[j];&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==n)&#123; minRight = nums1[i];&#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; minRight=nums1[i]&lt;nums2[j]?nums1[i]:nums2[j];&#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> (minRight+maxLeft)/<span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n):</span><br><span class="line">            nums1,nums2,m,n = nums2,nums1,n,m</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 整除</span></span><br><span class="line">        imin, imax, half = <span class="number">0</span>, m, (m+n+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> imin&lt;=imax:</span><br><span class="line">            i = (imin+imax)//<span class="number">2</span>;</span><br><span class="line">            j = half - i;</span><br><span class="line">            maxLeft = <span class="number">0</span></span><br><span class="line">            minRight = <span class="number">0</span></span><br><span class="line">            print(i,j)</span><br><span class="line">            <span class="keyword">if</span> i&lt;m <span class="keyword">and</span> nums2[j<span class="number">-1</span>]&gt;nums1[i]:</span><br><span class="line">                imin = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums1[i<span class="number">-1</span>]&gt;nums2[j]:</span><br><span class="line">                imax = i<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span>: maxLeft = nums2[j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j==<span class="number">0</span>: maxLeft = nums1[i<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    maxLeft = max(nums2[j<span class="number">-1</span>],nums1[i<span class="number">-1</span>])</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (m+n)%<span class="number">2</span>==<span class="number">1</span>: <span class="keyword">return</span> maxLeft</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> i==m: minRight = nums2[j]</span><br><span class="line">                <span class="keyword">elif</span> j==n: minRight = nums1[i]</span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    minRight = min(nums1[i],nums2[j])</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">return</span> (minRight+maxLeft)/<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对用到中位数的题目可以想想中位数的意义，搜索那个分界点，可以直接遍历分界点也可以二叉找，看时间复杂度。</li><li>要注意前提是m&lt;=n，不然会出错</li><li>注意搜索时候变化条件，还有几个边界情况注意判断</li><li>while循环的条件这里是imin&lt;=imax，等于的时候就是到叶子节点了</li><li>python这里居然只能用双斜线整除</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Math </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-003-Longest Substring Without Repeating Characters</title>
      <link href="/2019/04/13/LeetCode-003-Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2019/04/13/LeetCode-003-Longest-Substring-Without-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Problem</a></h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><blockquote><p>“abcabcbb” —-&gt; 3<br>“bbbbb” —-&gt; 1<br>“pwwkew” —-&gt; 3</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>第一反应下想到的也是暴力遍历，写一个判断有没有重复字符串的函数，然后遍历每个子串，时间复杂度是<script type="math/tex">O(n^3)</script>，太高了，导致第一次提交没过，后面优化了下暴力法，过了。</li><li>除了暴力，题解上给出了<strong>滑动窗口</strong>的解法，利用前后两个指针i,j 不断移动来遍历字符串以及子串，i,j中间的就是没有重复字符的,如果遇到重复字符，就把i自增，一直到没有重复字符为止（就是相当于找到和j处的相同字符的为止），时间复杂度是<script type="math/tex">O(n)</script></li><li>最后是优化的滑动窗口，先记录每个字符第一次出现的位置pos，然后第二次出现的时候，将第一个指针i直接变成pos+1</li><li>对上面的优化还有一个技巧是利用整数数组代替Map，也可以用bitmap每一位表示一个字符数量</li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><p>这是我优化过的暴力法，勉强过了，判断函数那边用了太大的数组，可以用bitmap降低空间复杂度</p><p>用了72ms,20.1MB…僵硬</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//i是最大长度，j是每次遍历的起始位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="comment">//这里让i直接从max开始，可以少一点没用的遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=max;i+j&lt;=s.length();i++)&#123;</span><br><span class="line">                <span class="comment">//如果有重复字符直接退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(!judgeSubstring(s.substr(j,i))) <span class="keyword">break</span>;</span><br><span class="line">                max=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeSubstring</span><span class="params">(<span class="built_in">string</span> substr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;substr.length();i++)&#123;</span><br><span class="line">            <span class="comment">//如果不是0就肯定有重复字符</span></span><br><span class="line">            <span class="keyword">if</span>(tmp[<span class="keyword">int</span>(substr[i])])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            tmp[<span class="keyword">int</span>(substr[i])]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好了，这是第三种方法对应的代码，这次只用了12ms,9.1MB，话说感觉这种滑动窗口有点像快排…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="comment">//用来保存每个字符的下一个位置，用于出现重复字符的时候直接赋值给i</span></span><br><span class="line">        <span class="keyword">int</span> cNum[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;      </span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i是第一个指针，j是第二个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,i=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">//如果不为0就是出现了和s[j]一样的字符，让i等于那个字符的后一个位置</span></span><br><span class="line">            <span class="keyword">if</span>(cNum[s[j]])&#123;</span><br><span class="line">                i = cNum[s[j]]&gt;i?cNum[s[j]]:i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不管有没有重复字符都要更新max和cNum[s[j]]</span></span><br><span class="line">            <span class="comment">//很明显，如果有，i已经被更新，相当于已经变成了没有重复字符的情形，位置也要更新</span></span><br><span class="line">            max=(j-i+<span class="number">1</span>)&gt;max?(j-i+<span class="number">1</span>):max;</span><br><span class="line">            cNum[s[j]]=j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>用时52ms，12.7MB</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cNum=dict()</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> cNum:</span><br><span class="line">                start=max(start,cNum[s[i]])</span><br><span class="line">            res=max(res,i-start+<span class="number">1</span>)</span><br><span class="line">            cNum[s[i]]=i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总感觉自己想的太简单，优化还是有点难度的，这道题关键的就是一次遍历，用两个指针表示字符串，并且没有单独拿出字符串判断，而是用set或者map、dict这种方式记录当前子串的内容，用于判断是否有没有出现重复字符，优化的时候减少无用的遍历</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Math </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas中像素级别ImageData缩放</title>
      <link href="/2019/04/10/Canvas%E4%B8%AD%E5%83%8F%E7%B4%A0%E7%BA%A7%E5%88%ABImageData%E7%BC%A9%E6%94%BE/"/>
      <url>/2019/04/10/Canvas%E4%B8%AD%E5%83%8F%E7%B4%A0%E7%BA%A7%E5%88%ABImageData%E7%BC%A9%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>弄Web端手写数字识别的时候要把Canvas缩成32*32大小的，刚开始想的是用canvas的画布缩放，弄了好久发现行不通，然后无意中发现可以获得每个像素的RGBA的值，然后又自己尝试每个像素缩放，语法不熟悉，各种尝试…<br>好了不多说了，代码在下面</p></div><a id="more"></a><h2 id="Canvas中对ImageData数据缩放"><a href="#Canvas中对ImageData数据缩放" class="headerlink" title="Canvas中对ImageData数据缩放"></a>Canvas中对ImageData数据缩放</h2><ul><li>ctx: 原始canvas的context</li><li>outCtx: 输出canvas的context</li><li>scale: 缩放倍数</li><li>scaled: 缩放后的ImageData</li><li>imageData.data: 图像的RGBA数组，是一个一维数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genImg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgData = ctx.getImageData(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">  outCtx.putImageData(scaleImageData(imgData,<span class="number">0.5</span>),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scaleImageData</span>(<span class="params">imageData, scale</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scaled =</span><br><span class="line">      outCtx.createImageData(imageData.width * scale, imageData.height * scale);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> row = <span class="number">0</span>; row &lt; imageData.height; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> col = <span class="number">0</span>; col &lt; imageData.width; col++) &#123;</span><br><span class="line">      <span class="keyword">var</span> sourcePixel = [</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">0</span>],</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">1</span>],</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">2</span>],</span><br><span class="line">        imageData.data[(row * imageData.width + col) * <span class="number">4</span> + <span class="number">3</span>]</span><br><span class="line">      ];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; scale; y++) &#123;</span><br><span class="line">        <span class="keyword">var</span> destRow = <span class="built_in">Math</span>.floor(row * scale) + y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; scale; x++) &#123;</span><br><span class="line">          <span class="keyword">var</span> destCol = <span class="built_in">Math</span>.floor(col * scale) + x;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            scaled.data[(destRow * scaled.width + destCol) * <span class="number">4</span> + i] = sourcePixel[i];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> scaled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note "><p>主要就是scaleImageData这个函数，原型是stackoverflow上的，不过有bug，自己修改了下。<br>遇到问题果然还是要看源码…</p></div>]]></content>
      
      
      <categories>
          
          <category> Daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Canvas </tag>
            
            <tag> Web </tag>
            
            <tag> Daily </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-002-Add Two Numbers</title>
      <link href="/2019/04/09/LeetCode-002-Add-Two-Numbers/"/>
      <url>/2019/04/09/LeetCode-002-Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">Problem</a></h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers.<br>The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit.<br>Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p></blockquote></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><p>因为以前做过差不多的题目，而且感觉也不难，设置一个进位标志，然后一个个往后加。</p><p>犯了三个小错误</p><ul><li>算当前node的值时居然没把carry一起加起来算</li><li>算下次的carry时没有把上次的carry加上</li><li>忘了最后一次还可能有进位，要新建一个node</li></ul><p>还纠结好久要不要头结点，刚开始以为题目不可以用头结点，毕竟Example上没有，写到后面还是出错了，看了题解换了有头结点的版本就好了。</p><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *tmp = res;</span><br><span class="line">        ListNode *p = l1;</span><br><span class="line">        ListNode *q = l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tmp-&gt;next = <span class="keyword">new</span> ListNode((p-&gt;val + q-&gt;val+carry)%<span class="number">10</span>);<span class="comment">//把+carry放在了%10的后面</span></span><br><span class="line">            carry = (p-&gt;val + q-&gt;val+carry)/<span class="number">10</span>;<span class="comment">//居然漏了+carry</span></span><br><span class="line"></span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line"></span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tmp-&gt;next = <span class="keyword">new</span> ListNode((p-&gt;val + carry)%<span class="number">10</span>);</span><br><span class="line">            carry = (p-&gt;val + carry)/<span class="number">10</span>;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tmp-&gt;next = <span class="keyword">new</span> ListNode((q-&gt;val + carry)%<span class="number">10</span>);</span><br><span class="line">            carry = (q-&gt;val + carry)/<span class="number">10</span>;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>) tmp-&gt;next = <span class="keyword">new</span> ListNode(carry);<span class="comment">//漏了最后的进位</span></span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note default"><p>我这里在最后用了两个while来判断是否结束，题解上面是在第一个while里面对p和q进行了处理：<br>　　只要到了NULL，就让它的值为0，时间复杂度上来说是一样的，都是<script type="math/tex">\max{l1的节点数，l2的节点数}</script>，简单理解为<script type="math/tex">O(n)</script></p></div><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><p>一共两种，不是自己写的，不是很熟悉Python的链表，多看看学习下。</p><p>第一中的sum写法不是很懂…绝望，第二种比较好理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        res = ListNode(0)</span><br><span class="line">        tmp = res</span><br><span class="line">        left = 0</span><br><span class="line"></span><br><span class="line">        while l1 or l2 or left:</span><br><span class="line">            left, right = divmod(sum(l and l.val or 0 for l in (l1, l2)) + left, 10)</span><br><span class="line">            tmp.next = ListNode(right)</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">            l1 = l1 and l1.next</span><br><span class="line">            l2 = l2 and l2.next</span><br><span class="line"></span><br><span class="line">        return res.next</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        head = ListNode(0)</span><br><span class="line">        curr = head</span><br><span class="line">        carry, total = 0, 0</span><br><span class="line"></span><br><span class="line">        while(l1 or l2):</span><br><span class="line">            a = l1.val if l1 else 0</span><br><span class="line">            b = l2.val if l2 else 0</span><br><span class="line">            total = a + b + carry</span><br><span class="line">            carry = total // 10</span><br><span class="line"></span><br><span class="line">            if l1 or l2:</span><br><span class="line">                curr.next = ListNode(total % 10)</span><br><span class="line"></span><br><span class="line">            if l1:</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            if l2:</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            curr = curr.next</span><br><span class="line"></span><br><span class="line">        if carry&gt;0:</span><br><span class="line">            curr.next = ListNode(carry)</span><br><span class="line"></span><br><span class="line">        return head.next</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉自己解题速度有点慢，而且粗心犯小错误。</p><p>感觉是练得太少，以后加油！</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Math </tag>
            
            <tag> Linked List </tag>
            
            <tag> Large Number </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基石--Feasibility of Learning</title>
      <link href="/2019/04/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3-Feasibility-of-Learning/"/>
      <url>/2019/04/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3-Feasibility-of-Learning/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>《机器学习基石》第四讲<strong>Feasibility of Learning</strong>的课程笔记。主要介绍了机器学习的可行性。</p></div><a id="more"></a><p>机器学习很多时候，如果不加限制，常常会因为标准的不同，而有很多的不一样的结果。</p><p>并且，在训练集内得到的结果拟合的很好，但是在测试集甚至所有的可能来看，可能就是错误的，可能就是不确定的</p><h1 id="Learning-is-impossiable"><a href="#Learning-is-impossiable" class="headerlink" title="Learning is impossiable"></a>Learning is impossiable</h1><h2 id="No-Free-Lunch"><a href="#No-Free-Lunch" class="headerlink" title="No Free Lunch"></a>No Free Lunch</h2><blockquote><p>即: 天下没有免费的午餐<br>用于比较两种优化算法之间的关系，即如何确定一种算法比另外一种算法好</p></blockquote><p>NFL定理的前提是，所有问题出现的机会相等、或所有问题都是同等重要。</p><p>而实际情形往往并不是这样。一般我们只需要关注自己正要解决的问题即可。而对于我们的解决方案在另一个问题上的表现是否同等出色，我们并不关心。</p><blockquote><p>因此，脱离具体问题而空谈“什么算法最好”之类的讨论毫无意义.<br> 因为若考虑所有潜在的问题，那么所有的模型、算法都一样好——这也是我们通过NFL定理得出的。<br>要比较模型的相对优劣，则必须建立在与之对应的学习问题之上。</p></blockquote><h1 id="Probability-to-the-Rescue"><a href="#Probability-to-the-Rescue" class="headerlink" title="Probability to the Rescue"></a>Probability to the Rescue</h1><h2 id="Hoeffding’s-Inequality"><a href="#Hoeffding’s-Inequality" class="headerlink" title="Hoeffding’s Inequality"></a>Hoeffding’s Inequality</h2><blockquote><p>Hoeffding 不等式</p></blockquote><p>大概意思就是不知道很大的样本中的概率，但是我们可以通过很多次的抽样，得到的概率来推测真正的概率。</p><p>想到以前数学家证明硬币一面朝上的概率，通过很多很多很多次的抛硬币来统计每面朝上的概率，最后证明就是1/2，并且抛的次数越多，概率越接近。</p><img src="/2019/04/08/机器学习基石-Feasibility-of-Learning/fol1.png" title="Hoeffding Inequality 1/2"><img src="/2019/04/08/机器学习基石-Feasibility-of-Learning/fol2.png" title="Hoeffding Inequality 2/2"><h1 id="Connection-to-Learning"><a href="#Connection-to-Learning" class="headerlink" title="Connection to Learning"></a>Connection to Learning</h1><script type="math/tex; mode=display">E_in(h) $$代表我们抽的样本中的不一致概率$$ E_out(h) $$代表总的样本中的不一致的概率可以推断说N足够大时，$$ E_in(h) \sim E_out(h)</script><p>如果<script type="math/tex">E_in(h) \sim E_out(h)</script>，并且<script type="math/tex">E_in(h)</script>很小，我们就可以推断，<script type="math/tex">E_out(h)</script>很小，并且，<script type="math/tex">h \sim f with respect to P</script></p><img src="/2019/04/08/机器学习基石-Feasibility-of-Learning/fol3.png" title="Added Componentss"><img src="/2019/04/08/机器学习基石-Feasibility-of-Learning/fol4.png" title="The Formal Guarantee"><div class="note danger"><p><strong>real learning</strong> is: <script type="math/tex">A</script> shall <strong>make choices <script type="math/tex">\in H</script></strong> (like PLA)<br>rather than <em>being forced to pick one h</em></p></div><div class="note info"><p>可以使用历史数据(data)来验证一个假设的表现到底好不好, 可以理解为验证集</p></div><h1 id="Connection-to-Real-Learning"><a href="#Connection-to-Real-Learning" class="headerlink" title="Connection to Real Learning"></a>Connection to Real Learning</h1><p>提出了问题：如果我们在一堆假设中看到了一个假设，在我们选出的样本上全对，我们要不要选择这个假设？举例子就是每个人都抛硬币，抛五次，可能有一个人会五次全都朝上，我们要不要说这个硬币会有点特殊？</p><p>Hoeffding说的是取样的和真实的大部分情况下是符合的，只有小部分是不好的</p><p>事实上当你有选择的时候，比如这里抛五次硬币实验150次的时候,150次试验里出现一次五个硬币同时朝上的概率就是<script type="math/tex">1 - {(31 \over 32)^150} > 99%</script></p><p>因此不好的样本，在有选择的时候，出现的概率会恶化。<br><strong>不好的Data</strong> == <script type="math/tex">A</script>不可以自由做选择，可能会踩雷 == 存在<script type="math/tex">h</script>使<script type="math/tex">E_out(h)</script>和<script type="math/tex">E_in(h)</script><br>差得很大</p><p>Hoeffding说的是在一个Data里面，抽一堆和大部分符合</p><p>这里说的其实是一堆Data里，出现不好的Data的概率是：<br><img src="/2019/04/08/机器学习基石-Feasibility-of-Learning/fol5.png" title="Bound of BAD Data"></p><p>所以如果假设数量有限，即M有限，并且每个Data样本N足够大，那么不管<script type="math/tex">A</script>怎么选，<script type="math/tex">E_out(g) \sim E_in(g)</script>，即可以放心选，这样就说明了有限数量的h情况下，机器学习是可行的</p>]]></content>
      
      
      <categories>
          
          <category> MachineLearning </category>
          
          <category> 机器学习基石 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
            <tag> 机器学习基石 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-001-Two Sum</title>
      <link href="/2019/04/07/LeetCode-001-Two-Sum/"/>
      <url>/2019/04/07/LeetCode-001-Two-Sum/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Problem</a></h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. UPDATE (2016/2/13): The return format had been changed to zero-based indices. Please read the above updated description carefully.</p></div><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ul><li>刚开始第一反应就是暴力遍历，但是时间复杂度是<script type="math/tex">O(n^2)</script></li><li>题解用了hash map，时间复杂度为<script type="math/tex">O(n)</script><ul><li>第一种方式是两遍hash，第一遍将元素添加进去，第二遍遍历元素</li><li>第二种方式一遍hash，一边添加元素一边判断结果是否在已添加的元素中</li></ul></li></ul><h2 id="C-Codes"><a href="#C-Codes" class="headerlink" title="C++ Codes"></a>C++ Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; numMap;          <span class="comment">//创建map</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt;::iterator it;   <span class="comment">//创建迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            it=numMap.find(target-nums[i]);       <span class="comment">//find函数查找key</span></span><br><span class="line">            <span class="keyword">if</span>(it!=numMap.end())&#123;                 <span class="comment">//如果到了end就说明没找到</span></span><br><span class="line">                res.push_back(i);</span><br><span class="line">                res.push_back(numMap[target-nums[i]]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            numMap.insert(make_pair(nums[i],i));  <span class="comment">//插入pair</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info"><h2 id="C-中vector用法回忆："><a href="#C-中vector用法回忆：" class="headerlink" title="C++中vector用法回忆："></a>C++中vector用法回忆：</h2><ul><li>创建：vector<int> vec;</int></li><li>访问：int i=vec[0];</li><li>插入：vec.push_back(1);vec.insert(index,val)，在第i个元素后面插入</li><li>删除：<ul><li>vec.pop_back(),删除最后一个</li><li>vec.erase(index)，删除index位置处元素</li><li>vec.erase(1,3)，删除[1,3)区间的元素</li></ul></li><li>大小：vec.size();</li><li>清空：vec.clear();</li><li>翻转：reverse(vec.begin(),vec.end());将元素翻转在vecotr，要#include<algorithm></algorithm></li><li>排序：<ul><li>sort(vec.begin(),vec.end());默认按照升序排列</li><li>sort(vec.begin(),vec.end(),cmp);定义排序比较函数将序排列<blockquote><p>bool cmp(const int&amp;a,const int&amp;b){<br>  return a&gt;b;<br>}</p></blockquote></li></ul></li><li>迭代器访问<blockquote><p>vector<int>::iterator it;<br>for(it=vec.begin();it!=vec.end();it++)<br>  cout&lt;&lt;*it&lt;&lt;endl;</int></p></blockquote></li></ul></div><div class="note info"><h2 id="C-中map的用法"><a href="#C-中map的用法" class="headerlink" title="C++中map的用法"></a>C++中map的用法</h2><ul><li>创建：map\<string, int\="">mapString; key类型为string，val类型为int</string,></li><li>添加：<ul><li>mapString[“hello”]=1; 最常用的最简单的插入方式,<strong>会覆盖之前的数据</strong></li><li>mapString.insert(make_pair(“hello”,1));  次常用,<strong> insert()不会覆盖之前的数据</strong></li><li>mapString.insert(pair<string,int>(“hello”,1));</string,int></li><li>mapString.insert(map<string,int>::value_type(“hello”,1));</string,int></li></ul></li><li><p>迭代：</p><blockquote><p>map<string,int>::iterator it;<br>for ( it = mapString.begin( ); it != mapString.end( ); it++ )<br>  cout &lt;&lt; “ “ &lt;&lt; it -&gt; second;</string,int></p></blockquote></li><li><p>查找：</p><ul><li><strong>不建议!</strong> mapString[“hello”];返回”hello”对应的值，如果不存在，则添加一个元素，key为”hello”,val为类型默认值,并返回这个默认值</li><li>mapString.count(“hello”); map::count()方法返回被查找元素的个数,只有0或1</li><li>map::find()方法,返回的是被查找元素的位置，没有则返回map.end()<blockquote><p>map<string,int>::iterator it;<br>it = mapString.find(“hello”);<br>if(it==test.end()){<br>  cout&lt;&lt;”hello not found”&lt;&lt;endl;<br>}</string,int></p></blockquote></li></ul></li><li><p>删除:</p><ul><li>mapString.erase(“hello”);</li><li>用迭代器删除,注意在迭代期间是不能被删除的<blockquote><p>map<string,int>::iterator it;<br>it = mapString.find(“hello”);</string,int></p><p>if(it==mapString.end())  cout&lt;&lt;”hello not found”&lt;&lt;endl;<br>else  mapString.erase(it);</p></blockquote></li></ul></li><li><p>排序：map中元素自动按照key升序排序，不可以用sort函数</p></li><li>大小：mapString.size();</li><li>清除：mapString.clear();</li></ul></div><h2 id="Python-Codes"><a href="#Python-Codes" class="headerlink" title="Python Codes"></a>Python Codes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> map:</span><br><span class="line">                <span class="keyword">return</span> [map[target - num], i]</span><br><span class="line">            map[num] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><div class="note info"><p>list中遍历的三种方式：</p><ol><li>for items in list:  根据元素遍历</li><li>for index in range(len(list)):  根据索引遍历</li><li>enumerate(seq, [start=0])  创建枚举对象，同时列出数据下标和数据<ul><li>seq: 一个序列、迭代器或其他支持迭代对象, 如列表、元组或字符串</li><li>start: 下标起始位置</li><li>返回：一个列表 [(下标，数据)…], 例如[(1, ‘a’), (2, ‘b’), (3, ‘c’)]</li></ul></li><li>iterList = iter(list)  创建迭代器遍历<ul><li>用法：for item in iterList: print(item)</li></ul></li></ol></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然第一题很简单，但是深入了看还是能学了不少东西的，在遍历这方面，时间复杂度优化可以用map，C++时间复杂度可以从<script type="math/tex">O(n)</script>降到<script type="math/tex">O(logn)</script>，python和java可以直接降到<script type="math/tex">O(1)</script>.</p><p>而且打完代码复习了C++中vector的用法，还有pythonlist的enumerate遍历。C++ STL中的map是现学现卖了.</p><p>打算每天一题，感觉有点晚了，亡羊补牢把。</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Hash Map </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基石--Types of Learning</title>
      <link href="/2019/04/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3-Types-of-Learning/"/>
      <url>/2019/04/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3-Types-of-Learning/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>《机器学习基石》第三讲<strong>Types of Learning</strong>的笔记。主要介绍了机器学习的集中分类标准和具体分类。</p></div><a id="more"></a><h1 id="不同的输出空间"><a href="#不同的输出空间" class="headerlink" title="不同的输出空间"></a>不同的输出空间</h1><h2 id="二元分类-binary-classification"><a href="#二元分类-binary-classification" class="headerlink" title="二元分类: binary classification"></a>二元分类: binary classification</h2><p>很基本的分类问题，输出只有两种. 通俗的理解就是简单的是非题，要么是，要么不是。</p><h2 id="多元分类-multiclass-classification"><a href="#多元分类-multiclass-classification" class="headerlink" title="多元分类: multiclass classification"></a>多元分类: multiclass classification</h2><p>很简单的例子就是对硬币的分类，课程中使用了美元的分类，1c, 5c, 10c, 25c 这样。</p><p>输出可以不只两种，上述硬币的分类输出为四，输出可以是K种。</p><p>二元分类是特殊的多元分类，即K=2的情况。</p><p><strong>应用场景</strong>:主要是视觉或听觉的辨识</p><ul><li>数字识别</li><li>图片内容分类</li><li>邮件的分类</li></ul><h2 id="回归问题-Regression"><a href="#回归问题-Regression" class="headerlink" title="回归问题: Regression"></a>回归问题: Regression</h2><p>$ y=R $ or $y = [lower, upper] \setminus R (bounded regression)$</p><p><strong>特点是</strong>输出是一个实数</p><p><strong>应用</strong></p><ul><li>股票价格</li><li>温度预测</li></ul><h2 id="结构化学习-Structed-Learning"><a href="#结构化学习-Structed-Learning" class="headerlink" title="结构化学习: Structed Learning"></a>结构化学习: Structed Learning</h2><p>理解起来就是多元分类的扩展，有很多很多的类别，但是类别和类别之间有着某种潜在结构，我们要输出的就是这种结构。</p><p>比如一个句子，可以是主谓宾、主谓等等，但是不可能是谓语谓语谓语这样。我们如果对一个句子进行语法判断，输出空间就是这些结构，而不是一个个的类别。</p><p><strong>应用</strong>:输出空间有着某种结构</p><ul><li>蛋白质的结构</li><li>自然语言处理中语言的parse tree</li></ul><p>总的可以看下图：<br><img src="/2019/04/07/机器学习基石-Types-of-Learning/tol1.png" title="Learning with Different Output Space"></p><h1 id="不同程度标记的样本"><a href="#不同程度标记的样本" class="headerlink" title="不同程度标记的样本"></a>不同程度标记的样本</h1><h2 id="监督学习-Supervised-Learning"><a href="#监督学习-Supervised-Learning" class="headerlink" title="监督学习: Supervised Learning"></a>监督学习: Supervised Learning</h2><p>给了一堆样本，然后还对每个样本进行了标记是什么，即每个<script type="math/tex">x_n</script>对应一个<script type="math/tex">y_n</script></p><h2 id="非监督学习-Unsupervised-Learning"><a href="#非监督学习-Unsupervised-Learning" class="headerlink" title="非监督学习: Unsupervised Learning"></a>非监督学习: Unsupervised Learning</h2><p>给了一对样本，但是不给样本的正确标记(without yn), 让机器自己去把样本分成几类。</p><p><strong>聚类</strong>就相当于是<strong>非监督的多分类问题</strong></p><ul><li>把一些文章按照不同的topic分类</li><li>按照消费者的资料把消费者分类,针对不同的人群进行促销。</li></ul><p><strong>密度预测</strong>相当于是<strong>Unsupervised bounded regression</strong></p><ul><li>交通车流量分析,按照位置分</li></ul><p><strong>异常监测</strong>相当于是<strong>Unsupervised binary classification</strong></p><ul><li>网络流量分析</li></ul><div class="note info"><p>聚类通常比较有用，但是评定聚类的好坏通常比较困难。</p></div><h2 id="半监督式学习-Semi-supervised-Learning"><a href="#半监督式学习-Semi-supervised-Learning" class="headerlink" title="半监督式学习: Semi-supervised Learning"></a>半监督式学习: Semi-supervised Learning</h2><p>比如硬币识别，但是只给了一部分<script type="math/tex">y_n</script>，和其他没有标记的样本混在一起</p><p><strong>应用</strong></p><ul><li>人脸识别，只有少量标记的面部照片</li><li>药物效果预测，只有少量的药物有标签</li></ul><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>一种非常不同的，但是很自然的学习方式。不直接告诉它你要做什么，但是可以通过一定的行为反应，惩罚错误的结果，奖励正确的结果。</p><p>比如训练狗狗，做得对就奖励，做的错就惩罚，没办法直接说给他听。</p><p><strong>应用</strong></p><ul><li>广告系统输入的是顾客资料，顾客点击或者不点击，推荐</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2019/04/07/机器学习基石-Types-of-Learning/tol2.png" title="Learning with Different Data Label yn"><h1 id="不同的训练方式"><a href="#不同的训练方式" class="headerlink" title="不同的训练方式"></a>不同的训练方式</h1><h2 id="batch-Supervised-multiclass-classification"><a href="#batch-Supervised-multiclass-classification" class="headerlink" title="batch Supervised multiclass classification"></a>batch Supervised multiclass classification</h2><p>成批的将数据喂给机器学习的算法，算法从所有已知的data中学习，得到假设<script type="math/tex">g</script><br><strong>应用</strong></p><ul><li>数据是email，得到邮件分类器</li><li>数据是cancer资料，得到cancer分类器</li></ul><div class="note info"><p>根据数据是否一次送入模型中训练分为batch learning和online learning.</p><p>batch learning像是填鸭式，online learning像是教书，一条一条教.</p></div><h2 id="online-learning"><a href="#online-learning" class="headerlink" title="online learning"></a>online learning</h2><p>指每次有新样本的时候就用来训练更新 hypothesis，每一轮<script type="math/tex">g</script>会更好, 常见的比如说有垃圾邮件分类系统.</p><p>增强学习和PLA常常比较接近online learning</p><h2 id="active-learning"><a href="#active-learning" class="headerlink" title="active learning"></a>active learning</h2><p>希望是机器能够主动的问选择的<script type="math/tex">x_n</script>对应的<script type="math/tex">y_n</script>，可以通过这种方式用很少的labels来提高<script type="math/tex">g</script></p><h1 id="不同的输入空间"><a href="#不同的输入空间" class="headerlink" title="不同的输入空间"></a>不同的输入空间</h1><p>根据输入的样本的特征来分也可以分为下面三类（虽然这种分类方法并不常见）：concrete features，raw features 和 abstract features。</p><h2 id="concrete-features"><a href="#concrete-features" class="headerlink" title="concrete features"></a>concrete features</h2><p>指输入的样本已经标注好了各种特征，如信用卡例子中顾客的各种资料</p><h2 id="raw-features"><a href="#raw-features" class="headerlink" title="raw features"></a>raw features</h2><p>一般指图像或音频中的图像或声波，这些信息是原始的信号，需要进行一些转换才能使用。</p><p>比如手写数字识别，16x16的像素格，可以将16x16=256个像素变成一个256维的向量输入。</p><h2 id="abstract-features"><a href="#abstract-features" class="headerlink" title="abstract features"></a>abstract features</h2><p>课程中用了KDDCup的例子，给出每个用户和他们喜欢听的音乐，要预测这个用户对一个新歌曲的评分是多少。<br>输入的是，用户id，歌曲的id，输出是评分数字</p><p>但是输入的特征并不是很直接，需要一方面人来提示，还有是机器自己从每个人喜欢听的歌里面得到特征，从每首歌的曲风等特征里面总结出特征，然后再用这些特征训练，得到结果。</p><p>这种按照输入样本的 features 进行分类的方法在实际中并不常用，因为输入的样本往往是各种 features交杂在一起的，不同问题需要与其相应的 features 才能得到好的效果，features 对结果的影响比较大。因此机器学习中也产生了 feature engineering 一说。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><img src="/2019/04/07/机器学习基石-Types-of-Learning/tol3.png" title="Learning with Different input Space">]]></content>
      
      
      <categories>
          
          <category> MachineLearning </category>
          
          <category> 机器学习基石 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
            <tag> 机器学习基石 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基石--PLA算法</title>
      <link href="/2019/04/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3-PLA%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3-PLA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p>《机器学习基石》第二讲 <strong>Learning to Answer Yes/NO</strong> 课程笔记。这一讲主要介绍了机器学习基本概念和感知机，以及其训练算法PLA。</p></div><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><script type="math/tex">\mathcal f</script>: 未知的目标函数</li><li><script type="math/tex">\mathcal D</script>: 训练样本，数据集</li><li><script type="math/tex">\mathcal A</script>: 学习算法</li><li><script type="math/tex">\mathcal H</script>: 假设集</li><li><script type="math/tex">\mathcal g</script>: 最终的假设，是\mathcalf的一个近似函数</li></ul><p>课件上很清楚的描绘了机器学习的一个过程<br><img src="/2019/04/07/机器学习基石-PLA算法/pla1.png" title="基本过程"></p><h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><p>感知机是神经网络的基础，与线性回归（Linear Regression），逻辑回归（Logistics Regression）等模型也非常类似，是一种非常典型的线性模型。</p><p>原始的感知机算法用于解决二分类问题，其思想如下：假设样本有 d 个特征，但是每个特征的重要性不一样，因此各个特征的权重也不一样，对其进行加权后得到的总和假如大于某个阈值则认为归为其中一类，反之归为另一类。如在信用卡的例子中，通过感知机有如下的结果<br><img src="/2019/04/07/机器学习基石-PLA算法/pla2.png" title="推导过程"></p><p>然后可以将threshold化为常数项作为<script type="math/tex">w_0</script>,简化为下图：<br><img src="/2019/04/07/机器学习基石-PLA算法/pla3.png" title="简化过程"><br>上面的<script type="math/tex">w</script>和<script type="math/tex">x</script>均为一个列向量，即<script type="math/tex">w</script>转置后成为行向量</p><h2 id="PLA"><a href="#PLA" class="headerlink" title="PLA"></a>PLA</h2><p>感知机要通过学习才能对样本进行正确的分类，这个学习的过程就是PLA(Perceptron Learning Algorithm).</p><p><strong>过程如下</strong>：</p><ol><li>随机初始化参数<script type="math/tex">w</script></li><li>利用参数<script type="math/tex">w</script>预测每个样本点的值并与其实际的值比较，对于分类错误的样本点(xn,yn),利用公式<script type="math/tex">w=w+ynxn</script>更新参数<script type="math/tex">w</script>的值</li><li>重复上面的过程直到所有的样本点都能够被参数<script type="math/tex">w</script>正确预测。</li></ol><p>对于某个被预测错误的样本点，参数<script type="math/tex">w</script>更新过程如下：<br><img src="/2019/04/07/机器学习基石-PLA算法/pla4.png" title="w的更新"></p><p>注意上面的算法的前提是所有的样本点都必须线性可分，假如样本点线性不可分，那么PLA按照上面的规则会陷入死循环中。如下是线性可分与线性不可分的例子)<br><img src="/2019/04/07/机器学习基石-PLA算法/pla5.png" title="线性不可分的例子"></p><h2 id="收敛性证明"><a href="#收敛性证明" class="headerlink" title="收敛性证明"></a>收敛性证明</h2><p>上面提到只有当所有的样本均为线性可分时，PLA才能将所有的样本点正确分类后再停下了，但是这仅仅是定性的说明而已，并没有严格的数学正面来支撑其收敛性，下面要讲的便是通过数学证明来说明 PLA 算法的收敛性。</p><p>课程中用两次递进的证明来说明收敛性<br><img src="/2019/04/07/机器学习基石-PLA算法/pla6.png" title="简单证明"></p><p>上面讲的是随着参数<script type="math/tex">w</script>的更新,<script type="math/tex">w^T_fw_t+1</script>的值越来越大，也就是两者越来越相似<br>衡量两个向量相似性的一种方法就是考虑他们的内积，值越大，代表两者约接近，但是这里还没对向量归一化，所以证明并不严格，但是已经说明了两者具有这个趋势，下面是更严格的过程<br><img src="/2019/04/07/机器学习基石-PLA算法/pla7.png" title="严格证明"></p><p>上面似乎只是说明了经过 T 次的纠错，wt 的值会限制在一个范围内，但是并没有给出最终结论</p><script type="math/tex; mode=display">{w_f \over ||w_f||}{w_T \over ||w_T||} \ge \sqrt{T} * constant</script><p>的证明过程，因此在这里进行推导过程的描述<br>(注：这里的<script type="math/tex">w_f</script>是不变的，因此<script type="math/tex">w_f</script>与<script type="math/tex">w^T_f</script>是一样的)</p><p>假设经过了 T 次纠错，那由第一张PPT可知</p><script type="math/tex; mode=display">w^T_fw_T \ge w_f^Tw_{T-1} + \min_{n}y_nw_f^Tx_n</script><p>而由第二章张ppt可知</p><script type="math/tex; mode=display">||w_T||^2 \le ||w_{T-1}||^2 + \max_n||x_n||^2 \le T\max_n||x_n||^2</script><p>即：<script type="math/tex">||w_T|| \le \sqrt{T}\max_n||x_n||</script></p><p>综合上面两个式子有</p><script type="math/tex; mode=display">{w_f^T \over ||w_f^T||}{w_T \over ||w_T||} \ge {T\min_ny_n^Tw^T_fx_n \over ||w_f^T||\sqrt{T}\max_n||x_n||} = \sqrt{T}{\min_ny_n{w_f^T \over ||w_f^T||}x_n \over \max_n||x_n||} = \sqrt{T} * constant</script><p>因此上面的命题得证。至此，已经可知道犯错误的次数 T 是受到某个上限的约束的。下面会给出这个具体的上限是多少。</p><p>又因为</p><script type="math/tex; mode=display">1 \ge {w_f^T \over ||w_f^T||}{w_T\over||w_T||} \ge \sqrt{T} * constant</script><script type="math/tex; mode=display">{1\over constant^2 } \ge T</script><p>即犯错的次数上限是${1 \over constant^2}$,假设令</p><script type="math/tex; mode=display">\max_n||x||^2 = R^2, \rho = \min_ny_n{w_f^T \over ||w_f^T||}x_n</script><p>则有</p><script type="math/tex; mode=display">T \le {R^2 \over \rho^2}</script><p>这也说明了PLA会在有限步内收敛，这个证明也是后面的练习答案</p><h2 id="优缺点和优化"><a href="#优缺点和优化" class="headerlink" title="优缺点和优化"></a>优缺点和优化</h2><p>PLA 的优点和缺点都非常明显，其中优点是简单，易于实现</p><p>缺点是假设了数据是线性可分的，然而事先并无法知道数据是否线性可分的。正如上面提到的一样，假如将PLA 用在线性不可分的数据中时，会导致PLA永远都无法对样本进行正确分类从而陷入到死循环中。</p><p>为了避免上面的情况，将 PLA 的条件放宽一点，不再要求所有的样本都能正确地分开，而是要求犯错的的样本尽可能的少，即将问题变为了</p><script type="math/tex; mode=display">arg\min_w\sum_{n=0}^N1\{y_n \neq sign(w^Tx_n)\}</script><p>这个最优化问题是个 NP-hard 问题，无法求得其最优解，因此只能求尽可能接近其最优解的近似解。讲义中提出的一种求解其近似解的算法<code>Pocket Algorithm</code>。  </p><p>其思想就是每次保留当前最好的<script type="math/tex">w</script>, 当遇到错误的样本点对<script type="math/tex">w</script>进行修正后，比较修正后的<script type="math/tex">w</script>与原来最好的<script type="math/tex">w</script>在整个样本点上的总体效果再决定保留哪一个，重复迭代足够多的次数后返回当前得到的最好的<script type="math/tex">w</script>。</p>]]></content>
      
      
      <categories>
          
          <category> MachineLearning </category>
          
          <category> 机器学习基石 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
            <tag> 机器学习基石 </tag>
            
            <tag> PLA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MNIST入门-手写数字识别</title>
      <link href="/2019/04/02/MNIST%E5%85%A5%E9%97%A8-%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
      <url>/2019/04/02/MNIST%E5%85%A5%E9%97%A8-%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><div class="note info"><p><strong>Target</strong><br>将训练一个机器学习模型用于预测图片里面的数字.  </p><p>理解TensorFlow工作流程和机器学习的基本概念</p><p>和官网不同的是只记录关键点</p></div><a id="more"></a><p><strong>关键词</strong></p><p><a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST</a><br><a href="http://www.tensorfly.cn/tfdoc/tutorials/mnist_beginners.html" target="_blank" rel="noopener">TensorFlow</a><br><a href="https://blog.csdn.net/google19890102/article/details/41594889" target="_blank" rel="noopener">Softmax Regression</a></p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><ul><li>数据集被分成两部分：60000行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）</li><li>把这些图片设为“xs”，把这些标签设为“ys”<ul><li>训练数据集的图片是 mnist.train.images ，训练数据集的标签是 mnist.train.labels</li></ul></li><li>mnist.train.images 是一个形状为 [60000, 784] 的张量，第一个维度数字索引图片，第二个维度数字索引每张图片中的像素点<ul><li>向量值表某个像素的强度值，值介于0和1之间</li></ul></li><li>mnist.train.labels 是一个 [60000, 10] 的数字矩阵<ul><li>标签数据是”one-hot vectors”</li><li>10维，只有一个维度非0</li><li>标签0将表示成([1,0,0,0,0,0,0,0,0,0,0])</li></ul></li></ul><h2 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h2><p>softmax模型可以用来给不同的对象分配概率。即使在之后，我们训练更加精细的模型时，最后一步也需要用softmax来分配概率。</p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><ul><li>对数据进行加权求和，在手写数字识别的例子里就是丢每个像素值加权求和</li><li>在每个像素值求和的后面加上一个偏置量<script type="math/tex">b_i</script>，这是由于输入会有一些干扰量</li></ul><p>可以得到输入图片 x ，[784]的向量，它代表的是数字 i 的证据可以表示:</p><script type="math/tex; mode=display">evidence_i = \sum_jW_{i,j}x_j+b_i</script><p>其中<script type="math/tex">W_i</script>维度是[784,10]，代表权重，<script type="math/tex">b_i</script>维度是[10]代表是数字i类的偏置量，j代表图片x的像素索引用于求和</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>再使用softmax函数将evidence转换成概率y</p><script type="math/tex; mode=display">y=softmax(evidence)</script><p>softmax函数可以看成是激励函数(activation)，把线性函数输出转换成想要的格式:关于10个数字的概率分布。</p><script type="math/tex; mode=display">softmax(x) = normalize(exp(x))</script><script type="math/tex; mode=display">softmax(x)_i = {exp(x_i) \over \sum_jexp(x_j)}</script><div class="note "><p>即：把输入值当成幂指数求值，再正则化这些结果值</p></div><p>结合上面的evidence可以知道，evidence越大，正则化后的结果更大，就是权重更大。<br><img src="/2019/04/02/MNIST入门-手写数字识别/sof1.png"><br>进一步写成:</p><script type="math/tex; mode=display">y = softmax(W_x + b)</script><h2 id="实现模型"><a href="#实现模型" class="headerlink" title="实现模型"></a>实现模型</h2>]]></content>
      
      
      <categories>
          
          <category> MachineLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> ML </tag>
            
            <tag> MNIST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fedora 26 编译内核</title>
      <link href="/2019/04/01/Fedora26%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/"/>
      <url>/2019/04/01/Fedora26%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"><br>被迫很不情愿的编译内核…以前服务器上编译过，贼麻烦，现在又要编译，为了不让我的Arch出什么幺蛾子，新弄了个虚拟机练手了。<br>还是Fedora26的，现在都出29了，时间过得真快。</p><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="查看自己内核版本"><a href="#查看自己内核版本" class="headerlink" title="查看自己内核版本"></a>查看自己内核版本</h2><pre><code>uname -aLinux localhost.localdomain 4.11.8-300.fc26.x86_64 #1 SMP Thu Jun 29 20:09:48 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</code></pre><h2 id="下载内核并解压到-usr-src目录下"><a href="#下载内核并解压到-usr-src目录下" class="headerlink" title="下载内核并解压到/usr/src目录下"></a>下载内核并解压到/usr/src目录下</h2><p>推荐一下<a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/" target="_blank" rel="noopener">上海交大的网站</a>，速度挺快的。<br>下载好后<code>tar xf linux-5.0.1.tar.gz -C /usr/src</code>解压到/usr/src下</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><div class="note danger"><p>make编译内核起码预留10个G，编译完之后，不然存储会不够，又要重新弄。<br>boot分区发现200M会不够用，改成500M可以，扩容还是挺麻烦的<br>/ 根目录（具体来说是 /lib，没挂载/lib的话就默认是使用/目录） 要有至少4G的空余空间</p></div><h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><h2 id="make-makemenuconfig"><a href="#make-makemenuconfig" class="headerlink" title="make makemenuconfig"></a>make makemenuconfig</h2><p>这是带有图形化界面的配置命令，在这里面可以定制很多功能。<br>常见的是定制内核版本，或者开启ntfs的功能。</p><p>内核版本在general setup里面，找到local version -append to kernel release</p><p>ntfs在file-systems下面，很下面的位置，找到DOS/FAT/NT Filesystems，进入后用M键启用NTFS，用模块的方式，并在下面的NTFS write support 那里用y键启用  </p><p>然后 保存退出</p><p>如果想用默认配置，可以直接方向键选择<strong>save</strong>，然后<strong>exit</strong>。</p><p>刚开始使用这个命令可能会一直报错，解决的基本原则是提示缺少什么包</p><p>就在这个包的名字后面加上-devel，然后用dnf安装（其他版本也一样，只要换一下包管理器名）</p><h3 id="缺少ncurses-devel包"><a href="#缺少ncurses-devel包" class="headerlink" title="缺少ncurses-devel包"></a>缺少ncurses-devel包</h3><pre><code>dnf install ncurses-devel</code></pre><h3 id="缺少flex包"><a href="#缺少flex包" class="headerlink" title="缺少flex包"></a>缺少flex包</h3><pre><code>dnf install flex</code></pre><h3 id="缺少bison包"><a href="#缺少bison包" class="headerlink" title="缺少bison包"></a>缺少bison包</h3><pre><code>dnf install bison</code></pre><h3 id="报错：You-are-building-kernel-with-non-retpoline-compiler"><a href="#报错：You-are-building-kernel-with-non-retpoline-compiler" class="headerlink" title="报错：You are building kernel with non-retpoline compiler."></a>报错：You are building kernel with non-retpoline compiler.</h3><p>应该升级GCC了，刚开始一直卡在这，网上也没发现non-retpoline是什么鬼，后来才发现是gcc版本太低，可能我刚装的虚拟机，没升级…      </p><pre><code>dnf update gcc</code></pre><h3 id="缺少libelf-dev-libelf-devel-or-elfutils-libelf-devel"><a href="#缺少libelf-dev-libelf-devel-or-elfutils-libelf-devel" class="headerlink" title="缺少libelf-dev, libelf-devel or elfutils-libelf-devel"></a>缺少libelf-dev, libelf-devel or elfutils-libelf-devel</h3><p>报错：error: Cannot generate ORC metadata for CONFIG_UNWINDER_ORC=y, please install libelf-dev, libelf-devel or elfutils-libelf-devel</p><p>这个直接安装会发现源里面没有，可以选择rpm包安装,也可以：</p><pre><code>dnf install binutils gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms</code></pre><p>这也是百度到的办法…当时都惊了，源里面居然都没有…</p><p>这里在装dkms,kernel-devel,patch的时候，安装了elfutils-libelf-devel和zlib-devel依赖</p><h3 id="缺少openssl"><a href="#缺少openssl" class="headerlink" title="缺少openssl"></a>缺少openssl</h3><p>报错:scripts/sign-file.c:25:10: fatal error: openssl/opensslv.h: No such file or directory</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <openssl opensslv.h=""></openssl></h1><p> 这里<code>dnf install openssl</code>发现已经安装了，很奇怪，后来发现libssl-devel在redhat系这里叫<strong>openssl-devel</strong></p><p>所以<code>dnf install openssl-devel</code></p><p> 如果是<strong>debian</strong>系的，应该是安装<strong>openss</strong>和<strong>libssl-devel</strong></p><h2 id="make-mrproper"><a href="#make-mrproper" class="headerlink" title="make mrproper"></a>make mrproper</h2><p>清除编译过程中产生的所有中间文件   </p><p>假如你之前也编译过内核，而你没有用此命令去清除之前编译产生的.o文件，那么，在make的时候，可能就会产生干扰。  </p><p>清除之后要重新make menuconfig 生成.config文件</p><h2 id="make-j8"><a href="#make-j8" class="headerlink" title="make -j8"></a>make -j8</h2><p><strong>-j</strong>是代表编译时用几个线程，这里开了8个线程来编译，不然太慢了。</p><h2 id="make-modules-install"><a href="#make-modules-install" class="headerlink" title="make modules_install"></a>make modules_install</h2><p>安装内核模块，这里比较快，一会会就好了，安装完后可以看到/lib/modules目录下就会出现新的内核。</p><h2 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h2><p>安装bzImage为/boot/vmlinuz-VERSION-RELEASE，并生成initramfs文件<br>使用ls /boot就可以查看新生成的文件，注意以安装的版本结尾的文件就好</p><p>查看grub.cfg, <code>ls /boot/grub2</code>, 应该就有grub.cfg引导文件了</p><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p>这时候应该就可以在启动项发现新的内核了</p><h2 id="删除旧内核"><a href="#删除旧内核" class="headerlink" title="删除旧内核"></a>删除旧内核</h2><ul><li><p>删除/lib/modules/目录下不需要的内核库文件</p></li><li><p>删除/usr/src/linux/目录下不需要的内核源码</p></li><li><p>删除/boot目录下启动的内核和内核映像文件</p></li><li><p>更改grub的配置文件，删除不需要的内核启动列表</p></li></ul><hr><p>这时候内核编译就结束了，还是挺耗时间的，特别是编译的时候。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cannot start gnome-tweaks</title>
      <link href="/2019/03/20/cannot-start-gnome-tweaks/"/>
      <url>/2019/03/20/cannot-start-gnome-tweaks/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>今天在用Gnome-tweaks的时候发现打不开了???很莫名其妙,怀疑是滚动更新滚炸了。bing了一下在stackoverflow上找到了解决办法。<br><a id="more"></a></p><h1 id="无法打开gnome-tweaks"><a href="#无法打开gnome-tweaks" class="headerlink" title="无法打开gnome-tweaks"></a>无法打开gnome-tweaks</h1><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[sudo] password for root: </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/bin/gnome-tweaks&quot;, line 13, in &lt;module&gt;</span><br><span class="line">    import gi</span><br><span class="line">ModuleNotFoundError: No module named &apos;gi&apos;</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>参照了<a href="https://stackoverflow.com/questions/32640083/gnome-terminal-not-starting-due-to-error-in-python-script-related-to-gi" target="_blank" rel="noopener">stackoverflow</a></p><p><strong>步骤如下</strong></p><ul><li>在命令行进入python2、python3测试import gi，看有没有gi这个包</li><li>发现只有python3.7下面有这个包</li><li>$ sudo vim /usr/bin/gnome-tweaks</li><li>编辑第一行，把<code>#!/usr/bin/env python</code>改成<code>#!/usr/bin/python</code></li><li>我这里<code>python-&gt;python3.7</code>,如果不是的话要写成<code>!/usr/bin/python3.7</code></li><li>重新运行gnome-tweaks</li><li>注意不要带sudo,我这里sudo出现了如下报错<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No protocol specified</span><br><span class="line">Unable to init server: Could not connect: Connection refused</span><br></pre></td></tr></table></figure></li></ul><hr><p>OK，问题解决</p>]]></content>
      
      
      <categories>
          
          <category> Daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Daily </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpaceVim中自定义Markdown相关快捷键</title>
      <link href="/2019/03/18/SpaceVim%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89Markdown%E7%9B%B8%E5%85%B3%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/03/18/SpaceVim%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89Markdown%E7%9B%B8%E5%85%B3%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>  SpaceVim对Markdown的注释居然是html版本的，预览的时候还是可以显示，百度了才知道用[[//]]:#()的方法，就想着弄了快捷键，又是挖坑踩坑…<br>  <a id="more"></a></p><h1 id="Markdown注释方法"><a href="#Markdown注释方法" class="headerlink" title="Markdown注释方法"></a>Markdown注释方法</h1><h2 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h2><p>注意：需要在前面空一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&apos;display: none&apos;&gt;</span><br><span class="line">哈哈我是注释，不会在浏览器中显示。</span><br><span class="line">我也是注释。</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h2 id="html注释"><a href="#html注释" class="headerlink" title="html注释"></a>html注释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--哈哈我是注释，不会在浏览器中显示。--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">哈哈我是多段</span><br><span class="line">注释，</span><br><span class="line">不会在浏览器中显示。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><h2 id="利用Markdown原理"><a href="#利用Markdown原理" class="headerlink" title="利用Markdown原理"></a>利用Markdown原理</h2><p>利用markdown的解析原理来实现注释的。一般有的markdown解析器不支持上面的注释方法，这个时候就可以用此方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[//]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span><br><span class="line">[//]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure><p>其中，这种方法最稳定，适用性最强：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[//]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure></p><p>还看到这种最可爱，超级无敌萌的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^_^]: # (哈哈我是注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure></p><h1 id="SpaceVim中自定义快捷键"><a href="#SpaceVim中自定义快捷键" class="headerlink" title="SpaceVim中自定义快捷键"></a>SpaceVim中自定义快捷键</h1><p><strong>下面是<a href="https://spacevim.org/cn" target="_blank" rel="noopener">SpaceVim官网</a>的说明</strong></p><blockquote><p>启动函数<br>由于 toml 配置的局限性，SpaceVim 提供了两种启动函数 bootstrap_before 和 bootstrap_after，在该函数内可以使用 Vim script。<br>可通过 ~/.SpaceVim.d/init.toml 的 [options] 片段中的这两个选项 bootstrap_before 和 bootstrap_after 来指定函数名称，例如：</p><p>[options]<br>　　bootstrap_before = “myspacevim#before”<br> 　　bootstrap_after  = “myspacevim#after”<br>启动函数文件应放置在 Vim &amp;runtimepath 的 autoload 文件夹内。例如：</p><p>文件名：~/.SpaceVim.d/autoload/myspacevim.vim</p><p>function! myspacevim#before() abort<br>　　let g:neomake_enabled_c_makers = [‘clang’]<br>　　nnoremap jk <esc><br>endfunction</esc></p><p>function! myspacevim#after() abort<br>　　iunmap jk<br>endfunction<br>函数 bootstrap_before 将在读取用户配置后执行，而函数 bootstrap_after 将在 VimEnter autocmd 之后执行。</p><p>如果你需要添加自定义以 SPC 为前缀的快捷键，你需要使用 bootstrap function，在其中加入：</p><p>function! myspacevim#before() abort<br>　　call SpaceVim#custom#SPCGroupName([‘G’], ‘+TestGroup’)<br>　　call SpaceVim#custom#SPC(‘nore’, [‘G’, ‘t’], ‘echom 1’, ‘echomessage 1’, 1)<br>endfunction</p></blockquote><h1 id="vim中定义快捷键相关说明"><a href="#vim中定义快捷键相关说明" class="headerlink" title="vim中定义快捷键相关说明"></a>vim中定义快捷键相关说明</h1><h2 id="autocmd"><a href="#autocmd" class="headerlink" title="autocmd"></a>autocmd</h2><ul><li>autocmd是一个十分强大的命令，在.vimrc中配置以后在用vim创建文件的时候就会自动执行一些命令</li></ul><h2 id="键盘映射"><a href="#键盘映射" class="headerlink" title="键盘映射"></a>键盘映射</h2><p>具体参照<a href="https://www.cnblogs.com/softwaretesting/archive/2011/09/28/2194515.html" target="_blank" rel="noopener">Vim中的键映射</a></p><p>使用map命令，可以将键盘上的某个按键与Vim的命令绑定起来。例如使用以下命令，可以通过F5键将单词用花括号括起来：   </p><p>　　:map <f5> i{e<esc>a}<esc>  </esc></esc></f5></p><p>其中：i{将插入字符{，然后使用Esc退回到命令状态；接着用e移到单词结尾，a}增加字符}，最后退至命令状态。</p><p>在执行以上命令之后，光标定位在一个单词上（例如amount），按下F5键，这时字符就会变成{amount}的形式。   </p><h2 id="不同模式下的键盘映射"><a href="#不同模式下的键盘映射" class="headerlink" title="不同模式下的键盘映射"></a>不同模式下的键盘映射</h2><p>使用下表中不同形式的map命令，可以针对特定的模式设置键盘映射：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Command</th><th style="text-align:center">Normal</th><th style="text-align:center">Visual</th><th style="text-align:center">Operator Pending</th><th style="text-align:center">插入模式</th><th style="text-align:center">命令行模式</th></tr></thead><tbody><tr><td style="text-align:center">命令</td><td style="text-align:center">常规模式</td><td style="text-align:center">可视化模式</td><td style="text-align:center">运算符模式</td><td style="text-align:center">Insert Only</td><td style="text-align:center">Command Line</td></tr><tr><td style="text-align:center">:map</td><td style="text-align:center">y</td><td style="text-align:center">y</td><td style="text-align:center">y</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:nmap</td><td style="text-align:center">y</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:vmap</td><td style="text-align:center"></td><td style="text-align:center">y</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:omap</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">y</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:map!</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">y</td><td style="text-align:center">y</td></tr><tr><td style="text-align:center">:imap</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">y</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">:cmap</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">y</td></tr></tbody></table></div><h1 id="SpaceVim中进行自定义SPC开头的键映射"><a href="#SpaceVim中进行自定义SPC开头的键映射" class="headerlink" title="SpaceVim中进行自定义SPC开头的键映射"></a>SpaceVim中进行自定义SPC开头的键映射</h1><p>下面是将SPC-v-c定义为Markdown文本中行注释，SPC-v-u对Markdown进行行取消注释，SPC-v-p进行Markdown文件样式预览.</p><p><strong>~/.SpaceVim.d/autoload/myspacevim.vim</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function! myspacevim#before() abort</span><br><span class="line">　　set wrap</span><br><span class="line"></span><br><span class="line">    &quot;v开头为自定义快捷键</span><br><span class="line">　　call SpaceVim#custom#SPCGroupName([&apos;v&apos;], &apos;+Personal Key Bindings&apos;)</span><br><span class="line"></span><br><span class="line">    &quot;使用v-p进行markdown网页预览</span><br><span class="line">　　autocmd BufRead,BufNewFile *.&#123;md,mdown,mkd,mkdn,markdown,mdwn&#125; call SpaceVim#custom#SPC(&apos;nore&apos;, [&apos;v&apos;, &apos;p&apos;], &apos;:!google-chrome-stable &quot;%:p&quot;&apos;, &apos;Markdown-Previews&apos;,1)</span><br><span class="line"></span><br><span class="line">    &quot;对markdown进行行注释，在行首插入[//]:#(,在行尾插入右括号),命令是&apos;I[//]:#(&lt;Esc&gt;A)&lt;Esc&gt;&apos;,注意这里的&lt;Esc&gt;要用Ctrl-Esc来完成 </span><br><span class="line">　　call SpaceVim#custom#SPC(&apos;nore&apos;, [&apos;v&apos;, &apos;c&apos;], &apos;I[//]:#(&lt;Esc&gt;A)&lt;Esc&gt;&apos;, &apos;Markdown-comment one line&apos;, 0)</span><br><span class="line"></span><br><span class="line">    &quot;对markdown取消行注释,在行首删除[//]:#(,在行尾删除右括号)</span><br><span class="line">　　call SpaceVim#custom#SPC(&apos;nore&apos;, [&apos;v&apos;, &apos;u&apos;], &apos;07x$x&apos;, &apos;Markdown-uncomment one line&apos;, 0)</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><h2 id="———————"><a href="#———————" class="headerlink" title="———————-"></a>———————-</h2><p>其实…我就想弄两个快捷键…</p>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpaceVim </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tornado中的异步</title>
      <link href="/2019/03/17/Tornado%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5/"/>
      <url>/2019/03/17/Tornado%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Tornado中的异步"><a href="#Tornado中的异步" class="headerlink" title="Tornado中的异步"></a>Tornado中的异步</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>因为epoll主要用来解决网络IO的并发问题，所以Tornado中的异步也主要体现在网络的IO异步上，即异步web<br><a id="more"></a></p><h2 id="tornado-httpclient-AsyncHttpClinet"><a href="#tornado-httpclient-AsyncHttpClinet" class="headerlink" title="tornado.httpclient.AsyncHttpClinet"></a>tornado.httpclient.AsyncHttpClinet</h2><ul><li>是Tornado提供的异步web请求客户端，用来进行异步web请求</li><li>from tornado.httpclient import AsyncHttpClinet</li></ul><h2 id="fetch-request-callback-None"><a href="#fetch-request-callback-None" class="headerlink" title="fetch(request, callback = None)"></a>fetch(request, callback = None)</h2><ul><li>此函数用于执行一个Web请求，并异步响应返回一个tornado.httpclient.HttpResponse</li><li>request可以是一个URL，也可以是一个Tornado.httpclient.HttpResponse对象,如果插入的是url，会自动生成一个request对象</li></ul><h2 id="HTTPRequest"><a href="#HTTPRequest" class="headerlink" title="HTTPRequest"></a>HTTPRequest</h2><ul><li>HTTP请求类，该类的构造函数可以接收参数    </li><li>参数:<ul><li>url: 字符串类型，要访问的网址，必传</li><li>method：字符串类型，http请求方式</li><li>headers：字典或者HTTPHeaders，附加的协议头</li><li>body: HTTP请求体</li></ul></li></ul><h2 id="HTTPResponse"><a href="#HTTPResponse" class="headerlink" title="HTTPResponse"></a>HTTPResponse</h2><ul><li>HTTP响应类</li><li>属性<ul><li>code: 状态码</li><li>reason： 状态码的描述</li><li>body： 相应的数据</li><li>error： 是否有异常</li></ul></li></ul><h2 id="tornado-web-asynchronous装饰器"><a href="#tornado-web-asynchronous装饰器" class="headerlink" title="@tornado.web.asynchronous装饰器"></a>@tornado.web.asynchronous装饰器</h2><ul><li>不关闭通信的通道</li><li><strong>实际操作发现无法使用这个装饰器</strong></li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="回调函数实现的异步"><a href="#回调函数实现的异步" class="headerlink" title="回调函数实现的异步"></a>回调函数实现的异步</h3><p><strong>Handler代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class StudentsHandler(RequestHandler):</span><br><span class="line">    def on_response(self, response):</span><br><span class="line">        if response.error:</span><br><span class="line">            self.send_error(500)</span><br><span class="line">        else:</span><br><span class="line">            data = json.loads(response.body)</span><br><span class="line">            # 这里本身无法write,要打开通道，用asynchronous装饰器</span><br><span class="line">            self.write(data)</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line">    # 不关闭通信的通道</span><br><span class="line">    #  @tornado.web.asynchronous</span><br><span class="line">    # 实操发现用不了这个装饰器</span><br><span class="line">    def get(self, *args, **kwargs):</span><br><span class="line">        url = &quot;http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&amp;t=&amp;market=360zhushou&amp;client=android&amp;appname=budejie&amp;device=&amp;jdk=1&amp;ver=8.0.1&amp;udid=&amp;from=android&quot;</span><br><span class="line">        # 创建客户端</span><br><span class="line">        client = AsyncHTTPClient()</span><br><span class="line">        # on_response是回调函数,如果请求成功，就进行on_response回调函数</span><br><span class="line">        client.fetch(url, self.on_response)</span><br><span class="line">        #  self.write(&quot;OK&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="协程实现的异步"><a href="#协程实现的异步" class="headerlink" title="协程实现的异步"></a>协程实现的异步</h3><p><strong>Handler代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Students2Handler(RequestHandler):</span><br><span class="line">    @tornado.gen.coroutine</span><br><span class="line">    def get(self, *args, **kwargs):</span><br><span class="line">        url = &quot;http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&amp;t=&amp;market=360zhushou&amp;client=android&amp;appname=budejie&amp;device=&amp;jdk=1&amp;ver=8.0.1&amp;udid=&amp;from=android&quot;</span><br><span class="line">        client = AsyncHTTPClient()</span><br><span class="line">        # 耗时操作挂起</span><br><span class="line">        res = yield client.fetch(url)</span><br><span class="line">        if res.error:</span><br><span class="line">            self.send_error(500)</span><br><span class="line">        else:</span><br><span class="line">            data = json.loads(res.body)</span><br><span class="line">            self.write(data)</span><br></pre></td></tr></table></figure></p><h3 id="协程异步并将异步web请求单独出来"><a href="#协程异步并将异步web请求单独出来" class="headerlink" title="协程异步并将异步web请求单独出来"></a>协程异步并将异步web请求单独出来</h3><p><strong>Handler代码</strong></p><pre><code>class Students3Handler(RequestHandler):    # 简化get函数    @tornado.gen.coroutine    def get(self, *args, **kwargs):        res = yield self.getData()        self.write(res)    # 这里也要加装饰器，这里也是耗时操作    @tornado.gen.coroutine    def getData(self):        url = &quot;http://s.budejie.com/v2/topic/list/10/0-0/budejie-android-8.0.1/0-25.json?uid=&amp;t=&amp;market=360zhushou&amp;client=android&amp;appname=budejie&amp;device=&amp;jdk=1&amp;ver=8.0.1&amp;udid=&amp;from=android&quot;        client = AsyncHTTPClient()        # 耗时操作        res = yield client.fetch(url)        if res.error:            #  表示没有结果            ret = {&quot;ret&quot;: 0}        else:            ret = json.loads(res.body)        #  相当于gen.send()函数        raise tornado.gen.Return(ret)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Tornado </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的异步</title>
      <link href="/2019/03/17/Python%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5/"/>
      <url>/2019/03/17/Python%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>学Tornado的异步之前学了下Python的同步和异步机制，下面是三种实现Python中同步的方法。主要是用yield和装饰器以及threading模块实现。</p><a id="more"></a><h1 id="python中异步的理解"><a href="#python中异步的理解" class="headerlink" title="python中异步的理解"></a>python中异步的理解</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><blockquote><p>按部就班的依次执行<br>如果在请求中添加一个耗时操作，则必须等耗时操作结束才继续下去<br>一般不会用同步</p></blockquote><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于耗时的操作，一般会交给另一个线程处理，我们继续向下执行，当别人结束耗时操作后再将结果返回给我们</p><h3 id="回调函数实现异步"><a href="#回调函数实现异步" class="headerlink" title="回调函数实现异步"></a>回调函数实现异步</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tornado中不用我们写这个函数</span></span><br><span class="line"><span class="comment"># handler获取数据（数据库、其他服务器、循环耗时）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longIo</span><span class="params">(callback)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(cb)</span>:</span></span><br><span class="line">    print(<span class="string">"开始耗时操作"</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"结束耗时操作"</span>)</span><br><span class="line">    <span class="comment">#耗时操作结束执行回调函数</span></span><br><span class="line">    cb(<span class="string">" 我是返回的数据"</span>)</span><br><span class="line">  <span class="comment">#创建一个线程，处理耗时操作threading传参args=()</span></span><br><span class="line">  threading.Thread(target=run,args=(callback,)).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数（回调函数）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(data)</span>:</span></span><br><span class="line">  print(<span class="string">"开始处理回调函数"</span>)</span><br><span class="line">  print(<span class="string">"接收到longIo的相应数据:"</span>,data)</span><br><span class="line">  print(<span class="string">"结束处理回调函数"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个客户的请求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reqA</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"开始处理reqA"</span>)</span><br><span class="line">  longIo(finish)</span><br><span class="line">  print(<span class="string">"结束处理reqA"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reqB</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"开始处理reqB"</span>)</span><br><span class="line">  longIo(finish)</span><br><span class="line">  print(<span class="string">"结束处理reqB"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Tornado服务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  reqA()</span><br><span class="line">  reqB()</span><br><span class="line">  <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><h3 id="协程实现异步"><a href="#协程实现异步" class="headerlink" title="协程实现异步"></a>协程实现异步</h3><h4 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量生成器</span></span><br><span class="line">gen = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longIo</span><span class="params">(callback)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(cb)</span>:</span></span><br><span class="line">    print(<span class="string">"开始耗时操作"</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      引进全局变量并且用生成器回发数据</span><br><span class="line">      <span class="keyword">global</span> gen</span><br><span class="line">      gen.send(<span class="string">"我是返回的数据"</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"结束耗时操作"</span>)</span><br><span class="line">  <span class="comment">#创建一个线程，处理耗时操作,不会影响A和B</span></span><br><span class="line">  threading.Thread(target=run).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个客户的请求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reqA</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"开始处理reqA"</span>)</span><br><span class="line">  <span class="comment"># 接受返回结果</span></span><br><span class="line">  <span class="comment"># 此处相当于挂起,执行longIo,不影响执行reqB</span></span><br><span class="line">  res = <span class="keyword">yield</span> longIo()</span><br><span class="line">  print(<span class="string">"接收longIo的相应数据:"</span>,res)</span><br><span class="line">  print(<span class="string">"结束处理reqA"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reqB</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"开始处理reqB"</span>)</span><br><span class="line">  time.sleep(<span class="number">2</span>)</span><br><span class="line">  print(<span class="string">"结束处理reqB"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Tornado服务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="comment"># 创建一个reqA的生成器</span></span><br><span class="line">  <span class="keyword">global</span> gen</span><br><span class="line">  gen = reqA()</span><br><span class="line">  <span class="comment"># 在这里真正执行reqA</span></span><br><span class="line">  next(gen)</span><br><span class="line"></span><br><span class="line">  reqB()</span><br><span class="line">  <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><h4 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h4><p><strong>问题</strong>    </p><blockquote><p>版本1中调用reqA的时候不能将其视为一个简单的函数，而是要作为生成器来对待<br>很明显要在主函数中要用三行调用reqA，只要用一行调用reqB。</p></blockquote><p><strong>解决办法</strong></p><blockquote><p>给reqA添加一个装饰器</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量生成器</span></span><br><span class="line">gen</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longIo</span><span class="params">(callback)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(cb)</span>:</span></span><br><span class="line">    print(<span class="string">"开始耗时操作"</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      引进全局变量并且用生成器回发数据</span><br><span class="line">      <span class="keyword">global</span> gen</span><br><span class="line">      gen.send(<span class="string">"我是返回的数据"</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"结束耗时操作"</span>)</span><br><span class="line">  <span class="comment">#创建一个线程，处理耗时操作,不会影响A和B</span></span><br><span class="line">  threading.Thread(target=run).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genCoroutine</span><span class="params">(func)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> gen</span><br><span class="line">    gen = func(*args, **kwargs)</span><br><span class="line">    next(gen)</span><br><span class="line">  <span class="comment"># 返回内部函数的时候不可以加括号，这里不可以加括号</span></span><br><span class="line">  <span class="keyword">return</span> wrapper</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个客户的请求</span></span><br><span class="line"><span class="meta">@genCoroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reqA</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"开始处理reqA"</span>)</span><br><span class="line">  <span class="comment"># 接受返回结果</span></span><br><span class="line">  <span class="comment"># 此处相当于挂起,执行longIo,不影响执行reqB</span></span><br><span class="line">  res = <span class="keyword">yield</span> longIo()</span><br><span class="line">  print(<span class="string">"接收longIo的相应数据:"</span>,res)</span><br><span class="line">  print(<span class="string">"结束处理reqA"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reqB</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"开始处理reqB"</span>)</span><br><span class="line">  time.sleep(<span class="number">2</span>)</span><br><span class="line">  print(<span class="string">"结束处理reqB"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Tornado服务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  reqA()</span><br><span class="line">  reqB()</span><br><span class="line">  <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><h4 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h4><p><strong>问题</strong></p><blockquote><p>版本2中存在一个全局变量gen，需要消除<br><strong>解决办法</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genCoroutine</span><span class="params">(func)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment">#reqA的生成器</span></span><br><span class="line">    gen1 = func()</span><br><span class="line">    <span class="comment">#longIo的生成器</span></span><br><span class="line">    gen2 = next(gen1)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(g)</span>:</span></span><br><span class="line">      <span class="comment">#gen2,即longIo的返回数据</span></span><br><span class="line">      res = next(g) </span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">        gen1.send(res)<span class="comment">#返回给reqA数据</span></span><br><span class="line">      <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    threading.Thread(target=run,args=(gen2,)).start()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 返回内部函数的时候不可以加括号，这里不可以加括号</span></span><br><span class="line">  <span class="keyword">return</span> wrapper</span><br><span class="line">  </span><br><span class="line"><span class="comment">#这次在这里不管线程了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longIo</span><span class="params">(callback)</span>:</span></span><br><span class="line">    print(<span class="string">"开始耗时操作"</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"结束耗时操作"</span>)</span><br><span class="line">    <span class="comment">#要返回数据，挂起</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"我是返回的数据"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个客户的请求</span></span><br><span class="line"><span class="meta">@genCoroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reqA</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"开始处理reqA"</span>)</span><br><span class="line">  <span class="comment"># 接受返回结果</span></span><br><span class="line">  <span class="comment"># 此处相当于挂起,执行longIo,不影响执行reqB</span></span><br><span class="line">  res = <span class="keyword">yield</span> longIo()</span><br><span class="line">  print(<span class="string">"接收longIo的相应数据:"</span>,res)</span><br><span class="line">  print(<span class="string">"结束处理reqA"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reqB</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"开始处理reqB"</span>)</span><br><span class="line">  time.sleep(<span class="number">2</span>)</span><br><span class="line">  print(<span class="string">"结束处理reqB"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Tornado服务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  reqA()</span><br><span class="line">  reqB()</span><br><span class="line">  <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习概念整理</title>
      <link href="/2018/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"/>
      <url>/2018/10/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>　　记录一些学习过程中遇到的基础概念，来源《机器学习导论》，《机器学习》——周志华，《白话大数据和机器学习》，《统计学习方法》——李航等，不是很全，等以后学习的深入待补充。<a id="more"></a></p><h1 id="数据和信息"><a href="#数据和信息" class="headerlink" title="数据和信息"></a>数据和信息</h1><ul><li>信息: 香农指出是”信息是用来消除随机不定性的东西”,就是那些把我们不清楚的描述,”信息是被消除的不确定性”。</li><li>算法: 简单理解为计算的方法和技巧，也可以是解决问题的办法</li><li>信息量: 一种信息数量化度量的规则，I=log_2m(m中情况产生概率均等)</li><li>先验概率: 事件按照常理，一般性规律发生的概率</li><li>香农公式: <script type="math/tex">C = B * log_2(1+S/N)</script>,B=2H,H为信道带宽,S为信号功率,N为噪声功率</li><li>信息熵: 信息的杂乱程度的量化描述,H(x)=-sum_1^np(x_i)log_2P(x_i),i=1,2…</li><li>熵: 混乱程度的描述，越有序，熵越低，反之越高 </li></ul><h1 id="回归和聚类"><a href="#回归和聚类" class="headerlink" title="回归和聚类"></a>回归和聚类</h1><ul><li>回归: 从大量的函数结果和自变量反推回函数表达式的过程就是回归 </li><li>过拟合: 一般是拟合过程中模型描述的太复杂，一般参数繁多，计算逻辑多</li><li>欠拟合: 一般是操作不当产生的误差e分布太散或者太大的情况</li></ul><h1 id="无分类的概念"><a href="#无分类的概念" class="headerlink" title="无分类的概念"></a>无分类的概念</h1>]]></content>
      
      
      <categories>
          
          <category> MachineLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM-2017WF-F-Posterize</title>
      <link href="/2018/09/27/ACM-2017WF-F-Posterize/"/>
      <url>/2018/09/27/ACM-2017WF-F-Posterize/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"><br>  算法课居然直接安排了一个ACM-WF的题目…弄了半天弄懂了，记笔记记笔记!<br><a id="more"></a></p><h1 id="ACM-ICPC-World-Finals-2017-F-Posterize-DP"><a href="#ACM-ICPC-World-Finals-2017-F-Posterize-DP" class="headerlink" title="ACM-ICPC World Finals 2017 F.Posterize DP"></a>ACM-ICPC World Finals 2017 F.Posterize DP</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>　　Pixels in a digital picture can be represented with three integers in the range 00 to 255255 that indicate the intensity of the red, green, and blue colors.</p><p>  To compress an image or to create an artistic effect, many photo-editing tools include a “posterize” operation which works as follows.</p><p>  Each color channel is examined separately; this problem focuses only on the red channel.</p><p>  Rather than allow all integers from 00 to 255255 for the red channel, a posterized image allows at most kk integers from this range.</p><p>  Each pixel’s original red intensity is replaced with the nearest of the allowed integers.</p><p>  The photo-editing tool selects a set of kk integers that minimizes the sum of the squared errors introduced across all pixels in the original image.</p><p>  If there are nn pixels that have original red values r1,…,rnr1,…,rn, and kk allowed integers v1,…,vkv1,…,vk, the sum of squared errors is defined as</p><p>　　∑i=1nmin1≤j≤k(ri−vj)2.∑i=1nmin1≤j≤k(ri−vj)2.</p><p>　　Your task is to compute the minimum achievable sum of squared errors, given parameter kk and a description of the red intensities of an image’s pixels.</p><div class="note info"><p>数字图像的像素可以用三个在0到255之间的整数表示,它们分别表示红色、绿色和蓝色的强度。</p><p>为了压缩图片或是为了生艺术效果,许多图像编辑工具收录了如下所述的”色调分离”操作。</p><p>每个颜色通道会分别考虑,本题只考虑红<br>色通道的情况。</p><p>不同于在红色通道使用0到255之间全部的整数,一张色调分离后的图片只会使用这些数字里至多 k<br>种整数。</p><p>每个像素原来的红色强度会被替换成最相近的可用强度。</p><p>图像编辑工具会选择k个整数来最小化替换过程<br>引起的平方误差之和。</p><p>假设原图有n个像素,它们的红色取值是r1,···,rn,而 k 种可用整数为v1,···,vk ,那么平方误差之和被定义为</p><p>　　∑i=1nmin1≤j≤k(ri−vj)2.∑i=1nmin1≤j≤k(ri−vj)2.</p><p>你的任务是计算可以实现的最小平方误差之和,参数k和图片的红色强度会给出。</p></div><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains two integers dd (1≤d≤2561≤d≤256), the number of distinct red values that occur in the original image, and kk (1≤k≤d1≤k≤d), the number of distinct red values allowed in the posterized image. The remaining dd lines indicate the number of pixels of the image having various red values. Each such line contains two integers rr (0≤r≤2550≤r≤255) and pp (1≤p≤2261≤p≤226), where rr is a red intensity value and pp is the number of pixels having red intensity rr. Those dd lines are given in increasing order of red value.</p><div class="note info"><p>第一行包含两个整数d(1≤d≤256)和k(1≤k≤d)<br>分别表示原图中不同的红色强度有多少种,<br>色调分离后可以使用的红色强度有多少种。<br>接下来d行描述了每种红色强度在原图中占据的像素点数量。<br>每行包含两个整数r(0≤r≤255)和p(1≤p≤226)<br>这里r是一种红色强度的取值<br>而p是这种取值对应的像素点数量。这d行信息按照红色强度取值升序给出。  </p></div><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Display the sum of the squared errors for an optimally chosen set of kk allowed integer values.</p><div class="note info"><p>输出最优的 k 种可选取值对应的平方误差之和。</p></div><div class="table-container"><table><thead><tr><th>Sample Input 1</th><th>Sample Output 1</th></tr></thead><tbody><tr><td>2 1</td><td></td></tr><tr><td>50 20000</td><td></td></tr><tr><td>150 10000</td><td>66670000</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Sample Input 2</th><th>Sample Output 2</th></tr></thead><tbody><tr><td>2 2</td><td></td></tr><tr><td>50 20000</td><td></td></tr><tr><td>150 10000</td><td>0</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Sample Input 3</th><th>Sample Output 3</th></tr></thead><tbody><tr><td>4 2</td><td></td></tr><tr><td>0 30000</td><td></td></tr><tr><td>25 30000</td><td></td></tr><tr><td>50 30000</td><td></td></tr><tr><td>255 30000</td><td>37500000</td></tr></tbody></table></div><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>　　主要是dp,记忆化搜索＋剪枝,看后面的代码注释和题解</p><h2 id="题目转化"><a href="#题目转化" class="headerlink" title="题目转化"></a>题目转化</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有256个位置，有d个位置上有人（每个位置上可能不止一个人），你可以在k个位置上插旗（每个位置上至多一面旗子），</p><p>每个人都会走到离自己最近的旗子，求所有人走的距离的平方和的最小值。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>要解决这个问题，我们可以建立一个二维数组<em>f[i][j]</em>，（j&lt;=i），表示前i个位置，放了j个旗子，其中第i个位置一定放了旗子，前i个位置上的所有人走到旗子上的最小距离平方和。</p><p>如果我们假设第i个位置上的旗子是k个旗子中的最后一个（即第i个位置后面没有旗子），那么第i个位置后面的人只能全部走到第i个位置上，所以把_f[i][j]_加上i位置后面的人走到i位置的距离平方和就可以得到所有人走的距离平方和。</p><p>因此我们可以枚举最后一个旗子插的位置i，将_f[i][j_]加上i后面的人走到i位置的距离平方和，取最小值，即为答案。</p><p><em>f[i][j]</em>数组的建立我们可以用下面的公式来计算：<em>f[i][j]=min{f[m][j-1]+w[m][i]},（j-1&lt;=m&lt; i)</em>，其中<em>w[m][i]</em></p><p>表示m~i这一段只有m和i位置放了旗子，这一段上的人走的距离平方和。</p><p>由于第i个位置上固定了一面旗子，我们可以考虑另外j-1面旗子的位置。</p><p>若j-1面旗子在前m个位置（可以假设第m个位置上一定放旗子），那么<em>f[i][j]</em>可以分解成两段计算，</p><p>一段是1~m位置，放了j-1个旗子，其中第m个位置一定放了旗子，这就递归成了<em>f[m][j-1]</em>；</p><p>另一段是m+1~i位置，只有m和i位置放了旗子，这一段上的人只能走到m和i，即<em>w[m][i]</em>。</p><p>所以我们只要枚举m的值，取<em>f[m][j-1]+w[m][i]</em>的最小值，就可以得出<em>f[i][j]</em>的值。</p><p>下面给出一个f[i][j]的实例：考虑f[8][3]，前8个位置，放了3个旗子，其中第3个位置一定放了旗子。</p><p>剩余的2面旗子可能在前2/3/4/5/6/7个位置上，由此枚举出所有情况：</p><p>剩余的2面旗子在：</p><blockquote><p>　　前2个位置：f[2][2]+w[2][8]<br>　　前3个位置：f[3][2]+w[3][8]<br>　　前4个位置：f[4][2]+w[4][8]<br>　　前5个位置：f[5][2]+w[5][8]<br>　　前6个位置：f[6][2]+w[6][8]<br>　　前7个位置：f[7][2]+w[7][8]</p></blockquote><p>取出这些值中的最小值，即得到f[8][3]的值。</p><p>至于w[m][i]的建立较为简单，由于只有m和i位置放了旗子，m+1~i位置上的人只能就近走到m或i位置上，</p><p>我们可以求出m和i的中值，前一半的人走到m，后一半的人走到i，求出距离平方和即可。</p><h3 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 260</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据,返回一个整数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否有符号</span></span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按位读取组成整数</span></span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一共n个位置，kk个旗子,a[N]表示每个位置的人数</span></span><br><span class="line"><span class="keyword">int</span> n,kk,a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//f[i][j]表示前i个位置，放了j个旗子，其中第i个位置一定放了旗子的最小平方误差</span></span><br><span class="line">ll w[N][N],f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">min</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("a.in","r",stdin);</span></span><br><span class="line">    n=read();</span><br><span class="line">    kk=read(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//旗子数不可以比位置数多</span></span><br><span class="line">    <span class="keyword">if</span>(kk&gt;=n)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取每个位置的人数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read();a[x+<span class="number">1</span>]=read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立w[i][j],i是第一个旗子位置,j是第二个旗子的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">256</span>;++i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i~j这一段只在i和j位置放旗子的平方误差</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;=<span class="number">256</span>;++j)&#123;</span><br><span class="line">          <span class="keyword">int</span> mid=i+j&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算i到j之间所有的位置平方和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=i+<span class="number">1</span>;q&lt;=j<span class="number">-1</span>;++q)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q&gt;mid) </span><br><span class="line">                  w[i][j]+=(ll)(j-q)*(j-q)*a[q];</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                  w[i][j]+=(ll)(q-i)*(q-i)*a[q];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只放一个旗子的情况,旗子在i处，遍历i之前所有的位置,累加</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">256</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j)</span><br><span class="line">            f[i][<span class="number">1</span>]+=(ll)(i-j)*(i-j)*a[j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立f[i][j],j是旗子的数量，从２开始到kk</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=kk;++j)</span><br><span class="line">        <span class="comment">//i是一共多少个位置，从j到256</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=j;i&lt;=<span class="number">256</span>;++i)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//前j-1个旗子放在[1,m]这里，并且m处有旗子,i处也有旗子,转化成求f[m][j-1]+w[m][i]的最小值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=j<span class="number">-1</span>;m&lt;i<span class="number">-1</span>;++m)</span><br><span class="line">                f[i][j]=min(f[i][j],f[m][j<span class="number">-1</span>]+w[m][i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ll ans=f[<span class="number">256</span>][kk];</span><br><span class="line">    <span class="comment">//统计答案，如果最后一个旗子不在最后一个位置，就还需要加上最后一个旗子后面的位置的平方和，枚举最后一个旗子插的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//i是最后一个旗子的位置,j是最后一个旗子到最后一个位置的每个位置,tmp是最后这部分的平方和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">255</span>;i&gt;=kk;--i)&#123;</span><br><span class="line">        ll tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">256</span>;j&gt;i;--j)</span><br><span class="line">          tmp+=(ll)(j-i)*(j-i)*a[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较不同位置的平方和，取最小值</span></span><br><span class="line">        ans=min(ans,f[i][kk]+tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> DP </tag>
            
            <tag> ACM-ICPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy.dot()函数</title>
      <link href="/2018/09/11/numpy-dot-%E5%87%BD%E6%95%B0/"/>
      <url>/2018/09/11/numpy-dot-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p>　　numpy(Numerical Python extensions)是一个第三方的Python包，用于科学计算。本文主要讲学习Numpy过程中遇到的一个问题，关于numpy.dot()是怎运算的。<a id="more"></a></p><h2 id="Numpy中多维数组的轴"><a href="#Numpy中多维数组的轴" class="headerlink" title="Numpy中多维数组的轴"></a>Numpy中多维数组的轴</h2><p>　　多维数组可以用numpy包生成，关于多维数组的运算以及定义等自行百度,主要讲多维数组的轴,这也是我学习时不懂的地方。</p><div class="note default"><p>　　多维数组的轴(axis)和该数组的size(或者)shape元素对应 。轴数从0开始，如果是二维，０轴是竖行，１轴是横行。具体看代码</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.randint(<span class="number">0</span>,<span class="number">5</span>,[<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">print(x)</span><br><span class="line">Out:</span><br><span class="line">  [[[<span class="number">5</span> <span class="number">2</span>]</span><br><span class="line">    [<span class="number">4</span> <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">   [[<span class="number">1</span> <span class="number">3</span>]</span><br><span class="line">    [<span class="number">2</span> <span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">   [[<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">    [<span class="number">0</span> <span class="number">1</span>]]]</span><br><span class="line"></span><br><span class="line">x.sum(axis=<span class="number">0</span>)</span><br><span class="line">Out:</span><br><span class="line">  array([[<span class="number">7</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">6</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">x.sum(axis=<span class="number">1</span>)</span><br><span class="line">Out:</span><br><span class="line">  array([[<span class="number">9</span>, <span class="number">4</span>],</span><br><span class="line">         [<span class="number">3</span>, <span class="number">6</span>],</span><br><span class="line">         [<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line">x.sum(axis=<span class="number">2</span>)</span><br><span class="line">Out:</span><br><span class="line">  array([[<span class="number">7</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><div class="note info"><p>　　如果将三维数组的每一个二维看做一个平面（plane，X[0, :, :], X[1, :, :], X[2, :, :]），三维数组即是这些二维平面层叠（stacked）出来的结果。则（axis=0）表示全部平面上的对应位置，（axis=1），每一个平面的每一列，（axis=2），每一个平面的每一行。</p></div><h1 id="numpy-dot"><a href="#numpy-dot" class="headerlink" title="numpy.dot()"></a>numpy.dot()</h1><p>　　<em>numpy.dot(a,b,out=None)</em></p><ul><li>如果a和b都是一维数组，则进行内积运算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.dot(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">Out:</span><br><span class="line">  <span class="number">12</span></span><br><span class="line"></span><br><span class="line">np.dot([<span class="number">2j</span>, <span class="number">3</span>+<span class="number">3j</span>], [<span class="number">2j</span>, <span class="number">3j</span>])</span><br><span class="line">Out:</span><br><span class="line">  (<span class="number">-13</span>+<span class="number">9j</span>)</span><br></pre></td></tr></table></figure><ul><li>如果都是二维数组，就进行矩阵乘法，推荐<code>a@b</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">b = [[<span class="number">4</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">np.dot(a, b)</span><br><span class="line">Out:</span><br><span class="line">  array([[<span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">2</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><ul><li>如果其中一个矩阵０秩，即标量，就进行<code>a*b</code>的运算，相乘</li><li>如果a是N-D矩阵且b是1-D矩阵,就进行a的最后一个轴上的数据和b相乘并求和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = array([[[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">     [ <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>],</span><br><span class="line">     [ <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>, <span class="number">12.</span>]],</span><br><span class="line"></span><br><span class="line">    [[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">     [ <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>],</span><br><span class="line">     [ <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>, <span class="number">12.</span>]]])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">np.dot(a, b)</span><br><span class="line">Out:</span><br><span class="line">  array([[ <span class="number">30.</span>,  <span class="number">70.</span>, <span class="number">110.</span>],</span><br><span class="line">       [ <span class="number">30.</span>,  <span class="number">70.</span>, <span class="number">110.</span>]])</span><br></pre></td></tr></table></figure><ul><li>如果都是多维矩阵，则_a的最后一个轴和b的倒数第二个轴上的数据乘积累加_,类似第四种情况<br><code>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">3</span>*<span class="number">4</span>*<span class="number">5</span>*<span class="number">6</span>).reshape((<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">b = np.arange(<span class="number">3</span>*<span class="number">4</span>*<span class="number">5</span>*<span class="number">6</span>)[::<span class="number">-1</span>].reshape((<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>))</span><br><span class="line">np.dot(a, b)[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Out:</span><br><span class="line">  <span class="number">499128</span></span><br><span class="line">sum(a[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,:] * b[<span class="number">1</span>,<span class="number">2</span>,:,<span class="number">2</span>])</span><br><span class="line">Out:</span><br><span class="line">  <span class="number">499128</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> MachineLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚类和K-Means算法</title>
      <link href="/2018/09/10/%E8%81%9A%E7%B1%BB%E5%92%8CK-Means%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/10/%E8%81%9A%E7%B1%BB%E5%92%8CK-Means%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><h2 id="聚类定义"><a href="#聚类定义" class="headerlink" title="聚类定义"></a>聚类定义</h2><p>　　聚类(Clustering)，指的是一种学习方式（操作方式），即把物理或者抽象对象的集合分组为由彼此的对象组成的多个类的分析过程。<a id="more"></a> </p><div class="note info"><p> 聚类属于无监督机器学习，简言之就是把特征形态相同的或者近似的划分在一个概念下，聚集为一组。</p><p>聚类在实际的应用中中亦是非常广泛的，如：市场细分（Market segmentation）、社交圈分析（social network analysis）、集群计算（organize computing clusters）、天体数据分析（astronomical data analysis）等</p></div><h2 id="聚类算法分类"><a href="#聚类算法分类" class="headerlink" title="聚类算法分类"></a>聚类算法分类</h2><p>　　主要的聚类主要的聚类算法可以划分为如下几类：划分方法、层次方法、基于密度的方法、基于网格的方法以及基于模型的方法。</p><p>　　每一类中都存在着得到广泛应用的算法，例如：划分方法中的k-means聚类算法、层次方法中的凝聚型层次聚类算法、基于模型方法中的神经网络聚类算法等</p><p>　　但是上述的都是硬聚类，即每一个数据只能被归为一类，还有一种是模糊聚类。<br>   　　模糊聚类通过隶属函数来确定每个数据隶属于各个簇的程度，而不是将一个数据对象硬性地归类到某一簇中。</p><h1 id="常用距离算法"><a href="#常用距离算法" class="headerlink" title="常用距离算法"></a>常用距离算法</h1><h2 id="欧氏距离"><a href="#欧氏距离" class="headerlink" title="欧氏距离"></a>欧氏距离</h2><p>　　欧氏距离是最直观的距离度量方法，通常就是学过的两点间距离，可以用在多维。</p><ul><li>二维平面上点a(x1,y1)与b(x2,y2)间的欧氏距离:  <script type="math/tex; mode=display">d_{12} = \sqrt{(x_1-x_2)^2+(y_1-y_2)^2}</script></li><li>三维空间点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离:<script type="math/tex; mode=display">d{12} = \sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}</script></li><li>更高维的计算类似二维三维</li></ul><h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2><p>　　不再是两点间连线的那种，是类似九宫格的走法，只能直线和直角拐弯。又叫做“城市街区距离”。</p><ul><li>二维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离：<script type="math/tex; mode=display">d_12 = |x_1-x_2|+|y_1-y_2|</script></li><li>三维和其他维类似</li></ul><div class="note info"><p>　　除了这两种还有余弦距离和切比雪夫距离等，这里不展开说。采用不同的距离度量方法对结果有很大的影响。</p></div><h1 id="k-means算法"><a href="#k-means算法" class="headerlink" title="k-means算法"></a>k-means算法</h1><p>  思想大致是:</p><ul><li>1.　先随机选k个质心</li><li>2.　对每个点计算其到各个质心的距离</li><li>3.　选距离最近的，把这个点归为这个质心的一类，形成k个簇</li><li>4.　然后对于每个簇，计算其中每个点到质心的平均距离</li><li>5.　然后把这个作为这个簇的新的质心,进行第二步</li><li>6.　直到簇不怎么发生变化或者达到了预设的最大迭代次数，停止</li></ul><p>　主要函数如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//k-means聚类</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Cluster&gt; k_means(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;trans,<span class="keyword">int</span> k,<span class="keyword">int</span> counts)&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Cluster&gt; clusters(k);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> row = trans.size();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> col = trans[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//随机初始化聚类中心</span></span><br><span class="line">  srand((<span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> center = rand()%trans.size();</span><br><span class="line">    clusters[i].center=trans[center]; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//迭代counts次</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">0</span>;cnt&lt;counts;cnt++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空样本空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">      clusters[i].samples.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算样本属于的簇</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">      <span class="keyword">int</span> tmp_center = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> minal = cal_distance(trans[i],clusters[tmp_center].center);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k;j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> distance = cal_distance(trans[i],clusters[j].center);</span><br><span class="line">        <span class="keyword">if</span>(distance&lt;minal)&#123;</span><br><span class="line">          tmp_center = j;</span><br><span class="line">          minal = distance;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      clusters[tmp_center].samples.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新计算簇中心</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;trans[<span class="number">0</span>].size();m++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;clusters[i].samples.size();j++)&#123;</span><br><span class="line">          <span class="comment">//cout&lt;&lt;"sum+=: "&lt;&lt;trans[clusters[i].samples[j]][m];</span></span><br><span class="line">          sum+=trans[clusters[i].samples[j]][m];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clusters[i].center[m]=sum/clusters[i].samples.size();</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> clusters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　用了C++作为实现的代码，python的代码可以参考网上的，有很多。计算距离用的是欧式距离。数据可以自己构造尝试。</p><hr>]]></content>
      
      
      <categories>
          
          <category> MachineLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> Python </tag>
            
            <tag> MachineLearning </tag>
            
            <tag> Clustering </tag>
            
            <tag> K-Means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fedora搭建LNMP环境</title>
      <link href="/2017/08/13/Fedora%E6%90%AD%E5%BB%BALNMP%E7%8E%AF%E5%A2%83/"/>
      <url>/2017/08/13/Fedora%E6%90%AD%E5%BB%BALNMP%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>woc!因为Algolia文章长度限制…不得不把原本的<centos-fedora搭建lnmp环境>改成两篇文章…佛了<br><a id="more"></a></centos-fedora搭建lnmp环境></p><p>原本在服务器上一直用的debian系,后来转到本机Fedora搭建环境就蒙了,之前也因为这个花了不少时间,为了把踩过得坑记下来,还是写篇文章。</p><p>其实所谓LNMP其实就是指Linux+Nginx+Mysql+PHP,因为Nginx发音问题,有时候也说是LEMP。</p><p><strong>下面就是<em>Centos/Fedora</em> 搭建LNMP环境的教程.</strong>  </p><h1 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h1><p>OS: Fedora 25<br>Nginx Version: 1.6.2<br>Mysql Version: MariaDB 10.2<br>PHP Version: PHP7.17</p><h1 id="安装Nginx-PHP7-1-7和PHP-FPM"><a href="#安装Nginx-PHP7-1-7和PHP-FPM" class="headerlink" title="安装Nginx,PHP7.1.7和PHP-FPM"></a>安装Nginx,PHP7.1.7和PHP-FPM</h1><h2 id="切换到root用户"><a href="#切换到root用户" class="headerlink" title="切换到root用户"></a>切换到root用户</h2><pre><code>sudo -i ## OR ##su -  </code></pre><h2 id="添加repositories"><a href="#添加repositories" class="headerlink" title="添加repositories"></a>添加repositories</h2><pre><code>## Remi Dependency on Fedora ##rpm -Uvh http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-stable.noarch.rpm rpm -Uvh http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm## The version 25 can be replaced by 26/24 ##rpm -Uvh http://rpms.famillecollet.com/fedora/remi-release-25.rpm  </code></pre><h2 id="安装Nginx-PHP-7-1-7-and-PHP-FPM"><a href="#安装Nginx-PHP-7-1-7-and-PHP-FPM" class="headerlink" title="安装Nginx,PHP 7.1.7 and PHP-FPM"></a>安装Nginx,PHP 7.1.7 and PHP-FPM</h2><pre><code>dnf --enablerepo=remi --enablerepo=remi-php71 install nginx php-fpm php-common  </code></pre><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><pre><code>dnf --enablerepo=remi --enablerepo=remi-php71 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xml  </code></pre><p>关于这些模块的介绍可以自己百度,根据自己需要来安装,嫌麻烦的话～直接copy吧～</p><h2 id="关闭httpd-Apache-并打开Nginx-PHP-FPM"><a href="#关闭httpd-Apache-并打开Nginx-PHP-FPM" class="headerlink" title="关闭httpd(Apache)并打开Nginx,PHP-FPM"></a>关闭httpd(Apache)并打开Nginx,PHP-FPM</h2><p> <strong>关闭Apache</strong>  </p><pre><code>systemctl stop httpd.service  </code></pre><p><strong>打开Nginx</strong>  </p><pre><code>systemctl start nginx.service  </code></pre><p><strong>打开PHP-FPM</strong>  </p><pre><code>systemctl start php-fpm.service  </code></pre><h2 id="设置开机自启Nginx-PHP-FPM"><a href="#设置开机自启Nginx-PHP-FPM" class="headerlink" title="设置开机自启Nginx PHP-FPM"></a>设置开机自启Nginx PHP-FPM</h2><p> <strong>关闭httpd(Apache)的开机自启</strong>  </p><pre><code>systemctl disable httpd.service  </code></pre><p><strong>设置Nginx和PHP-FPM开机自启</strong>  </p><pre><code>systemctl enable nginx.servicesystemctl enable php-fpm.service  </code></pre><h2 id="配置Nginx-和PHP-FPM"><a href="#配置Nginx-和PHP-FPM" class="headerlink" title="配置Nginx 和PHP-FPM"></a>配置Nginx 和PHP-FPM</h2><p> <strong>先做好默认配置的备份</strong>  </p><pre><code>cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bakcp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf  </code></pre><p><strong>修改PHP-FPM配置</strong>  </p><pre><code>vim /etc/php-fpm.d/www.conf## 注释掉新添加一行 ##;listen = /run/php-fpm/www.socklisten = 127.0.0.1:9000  </code></pre><p><strong>为你的站点创建相关文件夹</strong>  </p><pre><code>## 将testsite.local换成你自己的　##mkdir -p /srv/www/testsite.local/public_htmlmkdir /srv/www/testsite.local/logschown -R apache:apache /srv/www/testsite.localmkdir /etc/nginx/sites-availablemkdir /etc/nginx/sites-enabled  </code></pre><p>这里使用apache user group是因为PHP-FPM默认运行apache,并且apache能够进入一些类似httpd这样的目录</p><p><strong>在/etc/nginx/nginx.conf文件\”include /etc/nginx/conf.d/*.conf\”这行后面添加一行</strong>  </p><pre><code>include /etc/nginx/sites-enabled/*;  </code></pre><p><strong>创建testsite.local 文件并配置</strong>  </p><pre><code>## 这是最基本的配置 ##server {    server_name testsite.local;    access_log /srv/www/testsite.local/logs/access.log;    error_log /srv/www/testsite.local/logs/error.log;    root /srv/www/testsite.local/public_html;    location / {        index index.html index.htm index.php;    }    location ~ \.php$ {        include /etc/nginx/fastcgi_params;        fastcgi_pass  127.0.0.1:9000;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    }}  </code></pre><p><strong>创建软链接到sites-enabled目录</strong>  </p><pre><code>cd /etc/nginx/sites-enabled/ln -s /etc/nginx/sites-available/testsite.localsystemctl restart nginx.service  </code></pre><p><strong>将testsite.local添加到/etc/hosts中</strong>  </p><pre><code>127.0.0.1               localhost.localdomain localhost testsite.local  </code></pre><p><a href="http://www.if-not-true-then-false.com/2011/nginx-and-php-fpm-configuration-and-optimizing-tips-and-tricks/" target="_blank" rel="noopener">更多的Nginx 和PHP-FPM配置点这里～</a></p><h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><p><strong>创建/srv/www/testsite.local/public_html/index.php并添加以下内容:</strong>  </p><p><strong>然后访问域名或者服务器ip看是否出现phpinfo的页面。</strong></p><h2 id="出现403-forbidden"><a href="#出现403-forbidden" class="headerlink" title="出现403 forbidden"></a>出现403 forbidden</h2><p><strong>可能是SELinux有问题</strong>  </p><pre><code>chcon -R -t httpd_sys_content_t /srv/www/testsite.local/public_html  </code></pre><h2 id="远程链接到服务器"><a href="#远程链接到服务器" class="headerlink" title="远程链接到服务器"></a>远程链接到服务器</h2><p><strong>打开防火墙的80端口</strong>  </p><pre><code>firewall-cmd --get-active-zonesfirewall-cmd --permanent --zone=public --add-service=http## OR ##firewall-cmd --permanent --zone=public --add-port=80/tcpsystemctl restart firewalld.service  </code></pre><p><strong>访问域名或者ip试试~</strong></p><h1 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h1><p>这里安装的是MariaDB,而不是Mysql,有如下几个原因</p><ul><li>MariaDB本来就是一个Mysql的开源版本</li><li>MariaDB和Mysql类似并兼容Mysql</li><li>Fedora和Centos系列的发行版已经转用MariaDB了</li></ul><p><strong>我这里选择安装MariaDB 10.2.7 [stable],具体安装过程如下~</strong></p><ul><li>如果之前安装了Mysql,记得备份你的数据库和配置文件!</li><li>如果是从低版本升级的,记得执行<code>mysql_upgrade</code>~</li></ul><h2 id="切换root用户"><a href="#切换root用户" class="headerlink" title="切换root用户"></a>切换root用户</h2><pre><code>su -## OR ##sudo -i  </code></pre><h2 id="添加MariaDB-repo"><a href="#添加MariaDB-repo" class="headerlink" title="添加MariaDB repo"></a>添加MariaDB repo</h2><p>现在Fedora 24/25/26 用户都可以直接安装MariaDB 10.1 而不用添加其他的repo来安装~</p><p><a href="http://downloads.mariadb.org/mariadb/repositories/" target="_blank" rel="noopener">MariaDB repository configuration<br>tool</a>,这里面有repo,自己选择repo文件安装,上面也有教程~</p><h2 id="更新并安装"><a href="#更新并安装" class="headerlink" title="更新并安装"></a>更新并安装</h2><pre><code>dnf install mariadb mariadb-server  </code></pre><h2 id="打开MariaDB并配置自启"><a href="#打开MariaDB并配置自启" class="headerlink" title="打开MariaDB并配置自启"></a>打开MariaDB并配置自启</h2><pre><code>systemctl start mariadb.service ## use restart after updatesystemctl enable mariadb.service  </code></pre><h2 id="进行secure-installation"><a href="#进行secure-installation" class="headerlink" title="进行secure installation"></a>进行secure installation</h2><pre><code>/usr/bin/mysql_secure_installation  </code></pre><p>自己看提示来~第一个没设置密码呢,直接回车,下面的大多数都选Y</p><p>如果不想进行secure installation 的话,emmmmm….最好还是做下吧~  </p><p>到这里其实已经结束了…233333</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><pre><code>mysql -u root -p  </code></pre><h2 id="创建数据库和user"><a href="#创建数据库和user" class="headerlink" title="创建数据库和user"></a>创建数据库和user</h2><pre><code>## CREATE DATABASE ##MariaDB [(none)]&gt; CREATE DATABASE webdb;## CREATE USER ##MariaDB [(none)]&gt; CREATE USER &#39;webdb_user&#39;@&#39;10.0.15.25&#39; IDENTIFIED BY &#39;password123&#39;;## GRANT PERMISSIONS ##MariaDB [(none)]&gt; GRANT ALL ON webdb.* TO &#39;webdb_user&#39;@&#39;10.0.15.25&#39;;##  FLUSH PRIVILEGES, Tell the server to reload the grant tables  ##MariaDB [(none)]&gt; FLUSH PRIVILEGES;  </code></pre><h2 id="确保数据库能远程连接"><a href="#确保数据库能远程连接" class="headerlink" title="确保数据库能远程连接"></a>确保数据库能远程连接</h2><pre><code>firewall-cmd --get-active-zones## 应该会输出如下 ##- public-    interfaces: wlp1s0firewall-cmd --permanent --zone=public --add-service=mysqlsystemctl restart firewalld.servicemysql -h 10.0.15.25 -u myusername -p  </code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LNMP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS搭建LNMP环境</title>
      <link href="/2017/08/12/CentOS%E6%90%AD%E5%BB%BALNMP%E7%8E%AF%E5%A2%83/"/>
      <url>/2017/08/12/CentOS%E6%90%AD%E5%BB%BALNMP%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>woc!因为Algolia文章长度限制…不得不把原本的<centos-fedora搭建lnmp环境>改成两篇文章…佛了<br><a id="more"></a></centos-fedora搭建lnmp环境></p><p>原本在服务器上一直用的debian系,后来转到本机Fedora搭建环境就蒙了,之前也因为这个花了不少时间,为了把踩过得坑记下来,还是写篇文章。</p><p>其实所谓LNMP其实就是指Linux+Nginx+Mysql+PHP,因为Nginx发音问题,有时候也说是LEMP。</p><p><strong>下面就是<em>Centos/Fedora</em> 搭建LNMP环境的教程.</strong>  </p><h1 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h1><p>OS: Fedora 25<br>Nginx Version: 1.6.2<br>Mysql Version: MariaDB 10.2<br>PHP Version: PHP7.17</p><h1 id="安装Nginx-PHP7-1-7和PHP-FPM"><a href="#安装Nginx-PHP7-1-7和PHP-FPM" class="headerlink" title="安装Nginx,PHP7.1.7和PHP-FPM"></a>安装Nginx,PHP7.1.7和PHP-FPM</h1><h2 id="切换到root用户"><a href="#切换到root用户" class="headerlink" title="切换到root用户"></a>切换到root用户</h2><pre><code>sudo -i ## OR ##su -  </code></pre><h2 id="添加repositories"><a href="#添加repositories" class="headerlink" title="添加repositories"></a>添加repositories</h2><pre><code>## Centos 7 Remi repo ##rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm  ## Centos 7 Nginx repo ##vim /etc/yum.repos.d/nginx.repo## 添加 ##[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1  </code></pre><h2 id="安装Nginx-PHP-7-1-7-and-PHP-FPM"><a href="#安装Nginx-PHP-7-1-7-and-PHP-FPM" class="headerlink" title="安装Nginx,PHP 7.1.7 and PHP-FPM"></a>安装Nginx,PHP 7.1.7 and PHP-FPM</h2><pre><code> yum --enablerepo=remi,remi-php71 install nginx php-fpm php-common  </code></pre><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><pre><code>yum --enablerepo=remi,remi-php71 install php-opcache php-pecl-apcu php-cli php-pear php-pdo php-mysqlnd php-pgsql php-pecl-mongodb php-pecl-redis php-pecl-memcache php-pecl-memcached php-gd php-mbstring php-mcrypt php-xml  </code></pre><h2 id="关闭httpd-Apache-并打开Nginx-PHP-FPM"><a href="#关闭httpd-Apache-并打开Nginx-PHP-FPM" class="headerlink" title="关闭httpd(Apache)并打开Nginx,PHP-FPM"></a>关闭httpd(Apache)并打开Nginx,PHP-FPM</h2><p> <strong>关闭Apache</strong>  </p><pre><code>/etc/init.d/httpd stop## OR ## service httpd stop  </code></pre><p><strong>打开Nginx和PHP-FPM</strong>  </p><pre><code>systemctl start nginx.servicesystemctl start php-fpm.service  </code></pre><h2 id="设置开机自启Nginx-PHP-FPM"><a href="#设置开机自启Nginx-PHP-FPM" class="headerlink" title="设置开机自启Nginx PHP-FPM"></a>设置开机自启Nginx PHP-FPM</h2><p> <strong>关闭httpd(Apache)的开机自启,并设置nginx和php-fpm开机自启</strong>  </p><pre><code>systemctl disable httpd.servicesystemctl enable nginx.servicesystemctl enable php-fpm.service  </code></pre><h2 id="配置Nginx-和PHP-FPM及其他"><a href="#配置Nginx-和PHP-FPM及其他" class="headerlink" title="配置Nginx 和PHP-FPM及其他"></a>配置Nginx 和PHP-FPM及其他</h2><p>这一段的配置和fedora是一样的,可以不看了~</p><p><strong>先做好默认配置的备份</strong>  </p><pre><code>cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bakcp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf  </code></pre><p><strong>修改PHP-FPM配置</strong>  </p><pre><code>vim /etc/php-fpm.d/www.conf## 注释掉新添加一行 ##;listen = /run/php-fpm/www.socklisten = 127.0.0.1:9000  </code></pre><p><strong>为你的站点创建相关文件夹</strong>  </p><pre><code>## 将testsite.local换成你自己的　##mkdir -p /srv/www/testsite.local/public_htmlmkdir /srv/www/testsite.local/logschown -R apache:apache /srv/www/testsite.localmkdir /etc/nginx/sites-availablemkdir /etc/nginx/sites-enabled  </code></pre><p><strong>在/etc/nginx/nginx.conf文件”include /etc/nginx/conf.d/*.conf”这行后面添加一行</strong>  </p><pre><code>include /etc/nginx/sites-enabled/*;  </code></pre><p><strong>创建testsite.local 文件并配置</strong>  </p><pre><code>## 这是最基本的配置 ##server {    server_name testsite.local;    access_log /srv/www/testsite.local/logs/access.log;    error_log /srv/www/testsite.local/logs/error.log;    root /srv/www/testsite.local/public_html;    location / {        index index.html index.htm index.php;    }    location ~ \.php$ {        include /etc/nginx/fastcgi_params;        fastcgi_pass  127.0.0.1:9000;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    }}  </code></pre><p><strong>创建软链接到sites-enabled目录</strong>  </p><pre><code>cd /etc/nginx/sites-enabled/ln -s /etc/nginx/sites-available/testsite.localsystemctl restart nginx.service  </code></pre><p><strong>将testsite.local添加到/etc/hosts中</strong>  </p><pre><code>127.0.0.1               localhost.localdomain localhost testsite.local  </code></pre><p><a href="http://www.if-not-true-then-false.com/2011/nginx-and-php-fpm-configuration-and-optimizing-tips-and-tricks/" target="_blank" rel="noopener">更多的Nginx 和PHP-FPM配置点这里～</a></p><p><strong>测试是否成功</strong><br>创建/srv/www/testsite.local/public_html/index.php并添加以下内容:  </p><p>然后访问域名或者服务器ip看是否出现phpinfo的页面。</p><p><strong>出现403 forbidden</strong><br>有可能是SELinux有问题  </p><pre><code>chcon -R -t httpd_sys_content_t /srv/www/testsite.local/public_html  </code></pre><p><strong>远程链接到服务器</strong><br>打开防火墙的80端口  </p><pre><code>firewall-cmd --get-active-zonesfirewall-cmd --permanent --zone=public --add-service=http## OR ##firewall-cmd --permanent --zone=public --add-port=80/tcpsystemctl restart firewalld.service  </code></pre><h1 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h1><p>这里安装的是MariaDB,而不是Mysql,有如下几个原因</p><ul><li>MariaDB本来就是一个Mysql的开源版本</li><li>MariaDB和Mysql类似并兼容Mysql</li><li>Fedora和Centos系列的发行版已经转用MariaDB了</li></ul><p><strong>我这里选择安装MariaDB 10.2.7 [stable],具体安装过程如下~</strong></p><ul><li>如果之前安装了Mysql,记得备份你的数据库和配置文件!</li><li>如果是从低版本升级的,记得执行<code>mysql_upgrade</code>~</li></ul><h2 id="切换root用户"><a href="#切换root用户" class="headerlink" title="切换root用户"></a>切换root用户</h2><pre><code>su -## OR ##sudo -i  </code></pre><h2 id="添加MariaDB-repo"><a href="#添加MariaDB-repo" class="headerlink" title="添加MariaDB repo"></a>添加MariaDB repo</h2><p>现在Fedora 24/25/26 用户都可以直接安装MariaDB 10.1 而不用添加其他的repo来安装~</p><p><a href="http://downloads.mariadb.org/mariadb/repositories/" target="_blank" rel="noopener">MariaDB repository configuration<br>tool</a>,这里面有repo,自己选择repo文件安装,上面也有教程~</p><pre><code>yum install MariaDB MariaDB-server  </code></pre><h2 id="打开MariaDB并配置自启"><a href="#打开MariaDB并配置自启" class="headerlink" title="打开MariaDB并配置自启"></a>打开MariaDB并配置自启</h2><pre><code>service mysql start ## use restart after update## OR ##/etc/init.d/mysql start ## use restart after updatechkconfig --levels 235 mysql on  </code></pre><h2 id="进行secure-installation"><a href="#进行secure-installation" class="headerlink" title="进行secure installation"></a>进行secure installation</h2><pre><code>/usr/bin/mysql_secure_installation  </code></pre><p>自己看提示来~第一个没设置密码呢,直接回车,下面的大多数都选Y</p><p>如果不想进行secure installation 的话,emmmmm….最好还是做下吧~  </p><p>到这里其实已经结束了…233333</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><pre><code>mysql -u root -p  </code></pre><h2 id="创建数据库和user"><a href="#创建数据库和user" class="headerlink" title="创建数据库和user"></a>创建数据库和user</h2><pre><code>## CREATE DATABASE ##MariaDB [(none)]&gt; CREATE DATABASE webdb;## CREATE USER ##MariaDB [(none)]&gt; CREATE USER &#39;webdb_user&#39;@&#39;10.0.15.25&#39; IDENTIFIED BY &#39;password123&#39;;## GRANT PERMISSIONS ##MariaDB [(none)]&gt; GRANT ALL ON webdb.* TO &#39;webdb_user&#39;@&#39;10.0.15.25&#39;;##  FLUSH PRIVILEGES, Tell the server to reload the grant tables  ##MariaDB [(none)]&gt; FLUSH PRIVILEGES;  </code></pre><h2 id="确保数据库能远程连接"><a href="#确保数据库能远程连接" class="headerlink" title="确保数据库能远程连接"></a>确保数据库能远程连接</h2><pre><code>vim /etc/sysconfig/iptables-config## 添加 ##-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT## 重启 ##service iptables restart## OR ##/etc/init.d/iptables restart  </code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LNMP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown学习笔记</title>
      <link href="/2017/08/02/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/08/02/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本来博客初建，理应写点文章总结心得，说点自己的想法。<br>但正好这时候又学了<a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>，不如就先写个学习笔记，供自己以后写文参考。</p><p>关于博客的搭建和以后的想法,就留着下次吧～<br><a id="more"></a></p><h1 id="关于Markdown"><a href="#关于Markdown" class="headerlink" title="关于Markdown"></a>关于Markdown</h1><h2 id="宗旨和兼容性"><a href="#宗旨和兼容性" class="headerlink" title="宗旨和兼容性"></a>宗旨和兼容性</h2><p><a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>目标是实现易读易写，使用其编写的文件可以直接以纯文本发布。<br><a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>兼容<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>，语法目标是成为一种适用于网络的书写语言。  </p><p>相比HTML，Markdown是一种书写的格式，而HTML更多是一种发布的格式。<br>在Markdown文件内可以直接用HTML书写，不用额外标注。</p><p><a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>兼容<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>，但是在<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>等区块元素，比如<code>&lt;div&gt;</code>,<code>&lt;table&gt;</code>,<code>&lt;pre&gt;</code>,<code>&lt;p&gt;</code>,等标签，必须在前后加上空行和其他内容隔开，还要求他们的开始和结尾标签，不能用制表符或者空格来缩进。</p><p>在<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>区块标签内的<a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>格式语法不会被处理<br>但是在<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>区段标签内，<a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>语法是有效的。比如<code>&lt;span&gt;</code>,<code>&lt;cite&gt;</code>,<code>&lt;del&gt;</code></p><h2 id="特殊字符转换"><a href="#特殊字符转换" class="headerlink" title="特殊字符转换"></a>特殊字符转换</h2><p>在<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>中，&lt; 和 &amp; 想要显示字符原型需要用实体的形式，<code>&amp;lt</code> 和<br><code>&amp;amp</code><br>而在<a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>中，则可以自由书写字符。</p><p><strong>注</strong> :在code范围内，&lt; 和 &amp; 都会一定被转换成HTML实体，因此可以更方便的写出HTML code</p><h1 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h1><h2 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h2><p>段落由连续文本行组成，且允许段落内用换行符强迫换行。</p><p>如果想插入<code>&lt;br /&gt;</code>，需要在插入处按入两个以上空格然后回车。<br>段落的前后要有一个以上空行，且普通段落不可以用空格或者制表符缩进。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>支持两种标题的语法，类Setext和atx形式</p><h3 id="类Setext"><a href="#类Setext" class="headerlink" title="类Setext"></a>类Setext</h3><p>类Setext用底线的形式，利用任意数量=（最高阶）和－（第二阶）</p><p><strong>栗子</strong> :  </p><pre><code>This is an H1============This is an H2-------------  </code></pre><h3 id="Atx"><a href="#Atx" class="headerlink" title="Atx"></a>Atx</h3><p>Atx形式则是在行首插入一到六个#,对应标题一到六阶<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># H1</span><br><span class="line"></span><br><span class="line">##  H2</span><br><span class="line"></span><br><span class="line">##### H5</span><br></pre></td></tr></table></figure></p><p>可以选择闭合#，且结尾的#和开头不用一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># H1 #</span><br><span class="line"></span><br><span class="line">## H2 ##</span><br><span class="line"></span><br><span class="line">### H3  ###</span><br></pre></td></tr></table></figure></p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>在每行前面加上&gt;,(可以偷个懒在整个段落的第一行加上&gt;),并且区块引用可以嵌套，只要根据层次加上不同数量的&gt;</p><p><strong>栗子</strong> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; This is the fiest level of quoting </span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt; This is nested blokquote</span><br><span class="line">&gt;</span><br><span class="line">&gt; back to first level</span><br></pre></td></tr></table></figure></p><p>显示为:</p><blockquote><p>This is the fiest level of quoting </p><blockquote><p>This is nested blokquote</p></blockquote><p>back to first level  </p></blockquote><p>在引用区块内也可以使用其他<a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>语法， <strong>栗如</strong><br>标题、列表、代码区块  </p><pre><code>&gt; ## 这是一个标题。&gt;&gt; 1.   这是第一行列表项。&gt; 2.   这是第二行列表项。&gt;&gt; 给出一些例子代码：&gt;&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);  </code></pre><p>显示为:</p><blockquote><h2 id="这是一个标题。"><a href="#这是一个标题。" class="headerlink" title="这是一个标题。"></a>这是一个标题。</h2><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);  </code></pre></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>支持有序列表和无序列表两种</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用 + - 作为列表标记，个人偏向－，因为不用按shift</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表则使用数字接着一个英文句点:  </p><pre><code>1.  First one2.  Second one  </code></pre><p>显示为:</p><ol><li><p>First one</p></li><li><p>Second one  </p></li></ol><p>使用不同的数字不会有问题，但是看着不舒服，不推荐，还是顺序下来。<br>或者也可以只用一个数字。</p><p><strong>栗如</strong>  </p><pre><code>1.  First one1.  Second one1.  THird one  </code></pre><p>列表通常在最左边，但是也可以缩进，最多三个空格，标记后面一定要接上至少一个空格或者制表符<br>如果列表间由空行，<a href="https://en.wikipedia.org/wiki/Markdowna" target="_blank" rel="noopener">Markdown</a>会用\标签将内容裹起来</p><p><strong>栗子</strong> ：  </p><pre><code>*   Bird*   Magic  </code></pre><p>会被转换成：  </p><pre><code>&gt;    &lt;ul&gt;&gt;    &lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&gt;    &lt;/ul&gt;  </code></pre><p>显示为:</p><ul><li><p>Bird</p></li><li><p>Magic  </p></li></ul><p>列表可以包含多个段落，但是记得每个段落都要缩进哦</p><p>如果放引用，&gt;也要缩进<br>如果放代码区块，这个区块就要缩进两次<br>如果要在行首输入2017. 这种数字+句点+空白，可以在句点前面加反斜杠，即2017.</p><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>终于到这啦，代码区块最简单了，只要简单的缩进4个空格或者一个tab,或者,```这个标识,</p><p><strong>栗子</strong> ：  </p><ul><li>____printf(“hello world”)</li><li><tab>printf(“hello world”) </tab></li><li>```<br>printf(“hello world”)<br>```   </li></ul><p>显示为:   </p><pre><code>printf(&quot;hello world&quot;)</code></pre><p>markdown 会自动在代码区块外面加上\，而且代码区块里面&amp; &lt; &gt;会自动转成<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>实体，所以可以想怎么写code就怎么写</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格对齐方式  </p><pre><code>1.  居左: :----2.  居中: :----: 或者　-----3.  居右: ----:  </code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>可以在一行中用三个以上的<em>，-，_ 来建立一个分割线。行内不可以用其他东西，可以在</em> -中间插入空格。  </p><pre><code>* * *****---___  </code></pre><p>显示为:</p><hr><hr><hr><hr><h1 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>支持行内式和参考式两种，但都是用[]标记链接文字</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>在方括号后面接一个()在里面写上网址就行，如果要加title,在后面用单引号、双引号或是括弧把title文字包起来就行</p><p><strong>栗子</strong> ：  </p><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute.  </code></pre><p>如果想要链接到同主机资源，用相对路径  </p><pre><code>See my [About](/about/) page for details.  </code></pre><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>参考式是在后面加上另一个[],在里面写上标记  </p><pre><code>This is [an example][id] reference-style link.  </code></pre><p>可以在方括号中间加空格。。。<br>最后在文件的任意处，可以是段尾，可以是文件尾，把标记的链接定义出来  </p><pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;  </code></pre><p>要注意的是[]后面有一个:,还有一个以上的空格，id这个标记是不区分大小写的！链接网址可以用&lt;&gt;包起来。</p><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>隐式链接标记功能可以让你省略号指定的链接标记，这种情况标记会被视为等同于链接文字。<br>隐式链接只要在链接文字后面加上一个空的[]</p><p><strong>栗子</strong> ：  </p><pre><code>[Google][][Google]: http://google.com/  </code></pre><p>参考式链接的优点是比较好读，可以将一些标记的元数据移到段落之外，可以是段尾文件尾，这样就可以不让文章的阅读感被打断</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>如果你的<em> 和_ 两边都有空白，就只会被当成普通的</em> _</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果要标记一小段行内代码，可以用反引号｀把它包起来  </p><pre><code>Use the `printf()` function.  </code></pre><p>显示为:</p><p>Use the <code>printf()</code> function.  </p><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：  </p><pre><code>``There is a literal backtick (`) here.``  </code></pre><p>显示为:</p><p><code>There is a literal backtick (`) here.</code>  </p><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，酱紫就可以在区段开始就加入一个反引号  </p><pre><code>A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` ``  </code></pre><p>显示为:</p><p>A single backtick in a code span: <code>` </code></p><p>A backtick-delimited string in a code span: <code>`foo` </code>  </p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>使用行内式和参考式</p><h3 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h3><pre><code>![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;)  </code></pre><h3 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h3><pre><code>![Alt text][id][id]: url/to/image  &quot;Optional title attribute&quot;  </code></pre><p>这部分和链接是差不多的,但如果想要指定图片的宽高，可以使用普通的<code>&lt;img&gt;</code>标签.</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>用&lt;&gt;包起来的，都会被自动转成链接  </p><pre><code>&lt;http://example.com/&gt;  </code></pre><p>会被转成  </p><pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;  </code></pre><h2 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h2><p>可以用\插入一些在语法中有含义的符号  </p><pre><code>\   反斜线      `   反引号`*   星号       _   底线`{}  花括号      []  方括号()  括弧        #   井字号\+   加号       \-   减号.   英文句点    !   惊叹号  </code></pre><p>上面就是我学[Markdown][]的一些笔记，可能会有缺少的，有看到的可以指正～。</p>]]></content>
      
      
      <categories>
          
          <category> Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/08/01/hello-world/"/>
      <url>/2017/08/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
